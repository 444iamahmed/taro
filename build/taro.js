const REVISION = '124dev', MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = '100', GLSL3 = '300 es'; function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, { addEventListener: function ( e, t ) {

	void 0 === this._listeners && ( this._listeners = {} ); const n = this._listeners; void 0 === n[ e ] && ( n[ e ] = [] ), - 1 === n[ e ].indexOf( t ) && n[ e ].push( t );

}, hasEventListener: function ( e, t ) {

	if ( void 0 === this._listeners ) return ! 1; const n = this._listeners; return void 0 !== n[ e ] && - 1 !== n[ e ].indexOf( t );

}, removeEventListener: function ( e, t ) {

	if ( void 0 === this._listeners ) return; const n = this._listeners[ e ]; if ( void 0 !== n ) {

		const e = n.indexOf( t ); - 1 !== e && n.splice( e, 1 );

	}

}, dispatchEvent: function ( e ) {

	if ( void 0 === this._listeners ) return; const t = this._listeners[ e.type ]; if ( void 0 !== t ) {

		e.target = this; const n = t.slice( 0 ); for ( let t = 0, r = n.length; t < r; t ++ )n[ t ].call( this, e );

	}

} } ); const _lut = []; for ( let e = 0; e < 256; e ++ )_lut[ e ] = ( e < 16 ? '0' : '' ) + e.toString( 16 ); let _seed = 1234567; const MathUtils = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {

	const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return ( _lut[ 255 & e ] + _lut[ e >> 8 & 255 ] + _lut[ e >> 16 & 255 ] + _lut[ e >> 24 & 255 ] + '-' + _lut[ 255 & t ] + _lut[ t >> 8 & 255 ] + '-' + _lut[ t >> 16 & 15 | 64 ] + _lut[ t >> 24 & 255 ] + '-' + _lut[ 63 & n | 128 ] + _lut[ n >> 8 & 255 ] + '-' + _lut[ n >> 16 & 255 ] + _lut[ n >> 24 & 255 ] + _lut[ 255 & r ] + _lut[ r >> 8 & 255 ] + _lut[ r >> 16 & 255 ] + _lut[ r >> 24 & 255 ] ).toUpperCase();

}, clamp: function ( e, t, n ) {

	return Math.max( t, Math.min( n, e ) );

}, euclideanModulo: function ( e, t ) {

	return ( e % t + t ) % t;

}, mapLinear: function ( e, t, n, r, i ) {

	return r + ( e - t ) * ( i - r ) / ( n - t );

}, lerp: function ( e, t, n ) {

	return ( 1 - n ) * e + n * t;

}, smoothstep: function ( e, t, n ) {

	return e <= t ? 0 : e >= n ? 1 : ( e = ( e - t ) / ( n - t ) ) * e * ( 3 - 2 * e );

}, smootherstep: function ( e, t, n ) {

	return e <= t ? 0 : e >= n ? 1 : ( e = ( e - t ) / ( n - t ) ) * e * e * ( e * ( 6 * e - 15 ) + 10 );

}, randInt: function ( e, t ) {

	return e + Math.floor( Math.random() * ( t - e + 1 ) );

}, randFloat: function ( e, t ) {

	return e + Math.random() * ( t - e );

}, randFloatSpread: function ( e ) {

	return e * ( .5 - Math.random() );

}, seededRandom: function ( e ) {

	return void 0 !== e && ( _seed = e % 2147483647 ), ( ( _seed = 16807 * _seed % 2147483647 ) - 1 ) / 2147483646;

}, degToRad: function ( e ) {

	return e * MathUtils.DEG2RAD;

}, radToDeg: function ( e ) {

	return e * MathUtils.RAD2DEG;

}, isPowerOfTwo: function ( e ) {

	return 0 == ( e & e - 1 ) && 0 !== e;

}, ceilPowerOfTwo: function ( e ) {

	return Math.pow( 2, Math.ceil( Math.log( e ) / Math.LN2 ) );

}, floorPowerOfTwo: function ( e ) {

	return Math.pow( 2, Math.floor( Math.log( e ) / Math.LN2 ) );

}, setQuaternionFromProperEuler: function ( e, t, n, r, i ) {

	const o = Math.cos, a = Math.sin, s = o( n / 2 ), c = a( n / 2 ), l = o( ( t + r ) / 2 ), h = a( ( t + r ) / 2 ), u = o( ( t - r ) / 2 ), d = a( ( t - r ) / 2 ), p = o( ( r - t ) / 2 ), m = a( ( r - t ) / 2 ); switch ( i ) {

		case 'XYX':e.set( s * h, c * u, c * d, s * l ); break; case 'YZY':e.set( c * d, s * h, c * u, s * l ); break; case 'ZXZ':e.set( c * u, c * d, s * h, s * l ); break; case 'XZX':e.set( s * h, c * m, c * p, s * l ); break; case 'YXY':e.set( c * p, s * h, c * m, s * l ); break; case 'ZYZ':e.set( c * m, c * p, s * h, s * l ); break; default:console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + i );

	}

} }; class Vector2 {

	constructor( e = 0, t = 0 ) {

		Object.defineProperty( this, 'isVector2', { value: ! 0 } ), this.x = e, this.y = t;

	} get width() {

		return this.x;

	} set width( e ) {

		this.x = e;

	} get height() {

		return this.y;

	} set height( e ) {

		this.y = e;

	}set( e, t ) {

		return this.x = e, this.y = t, this;

	}setScalar( e ) {

		return this.x = e, this.y = e, this;

	}setX( e ) {

		return this.x = e, this;

	}setY( e ) {

		return this.y = e, this;

	}setComponent( e, t ) {

		switch ( e ) {

			case 0:this.x = t; break; case 1:this.y = t; break; default:throw new Error( 'index is out of range: ' + e );

		}

		return this;

	}getComponent( e ) {

		switch ( e ) {

			case 0:return this.x; case 1:return this.y; default:throw new Error( 'index is out of range: ' + e );

		}

	}clone() {

		return new this.constructor( this.x, this.y );

	}copy( e ) {

		return this.x = e.x, this.y = e.y, this;

	}add( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ), this.addVectors( e, t ) ) : ( this.x += e.x, this.y += e.y, this );

	}addScalar( e ) {

		return this.x += e, this.y += e, this;

	}addVectors( e, t ) {

		return this.x = e.x + t.x, this.y = e.y + t.y, this;

	}addScaledVector( e, t ) {

		return this.x += e.x * t, this.y += e.y * t, this;

	}sub( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ), this.subVectors( e, t ) ) : ( this.x -= e.x, this.y -= e.y, this );

	}subScalar( e ) {

		return this.x -= e, this.y -= e, this;

	}subVectors( e, t ) {

		return this.x = e.x - t.x, this.y = e.y - t.y, this;

	}multiply( e ) {

		return this.x *= e.x, this.y *= e.y, this;

	}multiplyScalar( e ) {

		return this.x *= e, this.y *= e, this;

	}divide( e ) {

		return this.x /= e.x, this.y /= e.y, this;

	}divideScalar( e ) {

		return this.multiplyScalar( 1 / e );

	}applyMatrix3( e ) {

		const t = this.x, n = this.y, r = e.elements; return this.x = r[ 0 ] * t + r[ 3 ] * n + r[ 6 ], this.y = r[ 1 ] * t + r[ 4 ] * n + r[ 7 ], this;

	}min( e ) {

		return this.x = Math.min( this.x, e.x ), this.y = Math.min( this.y, e.y ), this;

	}max( e ) {

		return this.x = Math.max( this.x, e.x ), this.y = Math.max( this.y, e.y ), this;

	}clamp( e, t ) {

		return this.x = Math.max( e.x, Math.min( t.x, this.x ) ), this.y = Math.max( e.y, Math.min( t.y, this.y ) ), this;

	}clampScalar( e, t ) {

		return this.x = Math.max( e, Math.min( t, this.x ) ), this.y = Math.max( e, Math.min( t, this.y ) ), this;

	}clampLength( e, t ) {

		const n = this.length(); return this.divideScalar( n || 1 ).multiplyScalar( Math.max( e, Math.min( t, n ) ) );

	}floor() {

		return this.x = Math.floor( this.x ), this.y = Math.floor( this.y ), this;

	}ceil() {

		return this.x = Math.ceil( this.x ), this.y = Math.ceil( this.y ), this;

	}round() {

		return this.x = Math.round( this.x ), this.y = Math.round( this.y ), this;

	}roundToZero() {

		return this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x ), this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y ), this;

	}negate() {

		return this.x = - this.x, this.y = - this.y, this;

	}dot( e ) {

		return this.x * e.x + this.y * e.y;

	}cross( e ) {

		return this.x * e.y - this.y * e.x;

	}lengthSq() {

		return this.x * this.x + this.y * this.y;

	}length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}normalize() {

		return this.divideScalar( this.length() || 1 );

	}angle() {

		return Math.atan2( - this.y, - this.x ) + Math.PI;

	}distanceTo( e ) {

		return Math.sqrt( this.distanceToSquared( e ) );

	}distanceToSquared( e ) {

		const t = this.x - e.x, n = this.y - e.y; return t * t + n * n;

	}manhattanDistanceTo( e ) {

		return Math.abs( this.x - e.x ) + Math.abs( this.y - e.y );

	}setLength( e ) {

		return this.normalize().multiplyScalar( e );

	}lerp( e, t ) {

		return this.x += ( e.x - this.x ) * t, this.y += ( e.y - this.y ) * t, this;

	}lerpVectors( e, t, n ) {

		return this.x = e.x + ( t.x - e.x ) * n, this.y = e.y + ( t.y - e.y ) * n, this;

	}equals( e ) {

		return e.x === this.x && e.y === this.y;

	}fromArray( e, t = 0 ) {

		return this.x = e[ t ], this.y = e[ t + 1 ], this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this.x, e[ t + 1 ] = this.y, e;

	}fromBufferAttribute( e, t, n ) {

		return void 0 !== n && console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' ), this.x = e.getX( t ), this.y = e.getY( t ), this;

	}rotateAround( e, t ) {

		const n = Math.cos( t ), r = Math.sin( t ), i = this.x - e.x, o = this.y - e.y; return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this;

	}random() {

		return this.x = Math.random(), this.y = Math.random(), this;

	}

} class Matrix3 {

	constructor() {

		Object.defineProperty( this, 'isMatrix3', { value: ! 0 } ), this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], arguments.length > 0 && console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}set( e, t, n, r, i, o, a, s, c ) {

		const l = this.elements; return l[ 0 ] = e, l[ 1 ] = r, l[ 2 ] = a, l[ 3 ] = t, l[ 4 ] = i, l[ 5 ] = s, l[ 6 ] = n, l[ 7 ] = o, l[ 8 ] = c, this;

	}identity() {

		return this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), this;

	}clone() {

		return ( new this.constructor() ).fromArray( this.elements );

	}copy( e ) {

		const t = this.elements, n = e.elements; return t[ 0 ] = n[ 0 ], t[ 1 ] = n[ 1 ], t[ 2 ] = n[ 2 ], t[ 3 ] = n[ 3 ], t[ 4 ] = n[ 4 ], t[ 5 ] = n[ 5 ], t[ 6 ] = n[ 6 ], t[ 7 ] = n[ 7 ], t[ 8 ] = n[ 8 ], this;

	}extractBasis( e, t, n ) {

		return e.setFromMatrix3Column( this, 0 ), t.setFromMatrix3Column( this, 1 ), n.setFromMatrix3Column( this, 2 ), this;

	}setFromMatrix4( e ) {

		const t = e.elements; return this.set( t[ 0 ], t[ 4 ], t[ 8 ], t[ 1 ], t[ 5 ], t[ 9 ], t[ 2 ], t[ 6 ], t[ 10 ] ), this;

	}multiply( e ) {

		return this.multiplyMatrices( this, e );

	}premultiply( e ) {

		return this.multiplyMatrices( e, this );

	}multiplyMatrices( e, t ) {

		const n = e.elements, r = t.elements, i = this.elements, o = n[ 0 ], a = n[ 3 ], s = n[ 6 ], c = n[ 1 ], l = n[ 4 ], h = n[ 7 ], u = n[ 2 ], d = n[ 5 ], p = n[ 8 ], m = r[ 0 ], f = r[ 3 ], g = r[ 6 ], v = r[ 1 ], y = r[ 4 ], _ = r[ 7 ], x = r[ 2 ], b = r[ 5 ], M = r[ 8 ]; return i[ 0 ] = o * m + a * v + s * x, i[ 3 ] = o * f + a * y + s * b, i[ 6 ] = o * g + a * _ + s * M, i[ 1 ] = c * m + l * v + h * x, i[ 4 ] = c * f + l * y + h * b, i[ 7 ] = c * g + l * _ + h * M, i[ 2 ] = u * m + d * v + p * x, i[ 5 ] = u * f + d * y + p * b, i[ 8 ] = u * g + d * _ + p * M, this;

	}multiplyScalar( e ) {

		const t = this.elements; return t[ 0 ] *= e, t[ 3 ] *= e, t[ 6 ] *= e, t[ 1 ] *= e, t[ 4 ] *= e, t[ 7 ] *= e, t[ 2 ] *= e, t[ 5 ] *= e, t[ 8 ] *= e, this;

	}determinant() {

		const e = this.elements, t = e[ 0 ], n = e[ 1 ], r = e[ 2 ], i = e[ 3 ], o = e[ 4 ], a = e[ 5 ], s = e[ 6 ], c = e[ 7 ], l = e[ 8 ]; return t * o * l - t * a * c - n * i * l + n * a * s + r * i * c - r * o * s;

	}invert() {

		const e = this.elements, t = e[ 0 ], n = e[ 1 ], r = e[ 2 ], i = e[ 3 ], o = e[ 4 ], a = e[ 5 ], s = e[ 6 ], c = e[ 7 ], l = e[ 8 ], h = l * o - a * c, u = a * s - l * i, d = c * i - o * s, p = t * h + n * u + r * d; if ( 0 === p ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); const m = 1 / p; return e[ 0 ] = h * m, e[ 1 ] = ( r * c - l * n ) * m, e[ 2 ] = ( a * n - r * o ) * m, e[ 3 ] = u * m, e[ 4 ] = ( l * t - r * s ) * m, e[ 5 ] = ( r * i - a * t ) * m, e[ 6 ] = d * m, e[ 7 ] = ( n * s - c * t ) * m, e[ 8 ] = ( o * t - n * i ) * m, this;

	}transpose() {

		let e; const t = this.elements; return e = t[ 1 ], t[ 1 ] = t[ 3 ], t[ 3 ] = e, e = t[ 2 ], t[ 2 ] = t[ 6 ], t[ 6 ] = e, e = t[ 5 ], t[ 5 ] = t[ 7 ], t[ 7 ] = e, this;

	}getNormalMatrix( e ) {

		return this.setFromMatrix4( e ).copy( this ).invert().transpose();

	}transposeIntoArray( e ) {

		const t = this.elements; return e[ 0 ] = t[ 0 ], e[ 1 ] = t[ 3 ], e[ 2 ] = t[ 6 ], e[ 3 ] = t[ 1 ], e[ 4 ] = t[ 4 ], e[ 5 ] = t[ 7 ], e[ 6 ] = t[ 2 ], e[ 7 ] = t[ 5 ], e[ 8 ] = t[ 8 ], this;

	}setUvTransform( e, t, n, r, i, o, a ) {

		const s = Math.cos( i ), c = Math.sin( i ); return this.set( n * s, n * c, - n * ( s * o + c * a ) + o + e, - r * c, r * s, - r * ( - c * o + s * a ) + a + t, 0, 0, 1 ), this;

	}scale( e, t ) {

		const n = this.elements; return n[ 0 ] *= e, n[ 3 ] *= e, n[ 6 ] *= e, n[ 1 ] *= t, n[ 4 ] *= t, n[ 7 ] *= t, this;

	}rotate( e ) {

		const t = Math.cos( e ), n = Math.sin( e ), r = this.elements, i = r[ 0 ], o = r[ 3 ], a = r[ 6 ], s = r[ 1 ], c = r[ 4 ], l = r[ 7 ]; return r[ 0 ] = t * i + n * s, r[ 3 ] = t * o + n * c, r[ 6 ] = t * a + n * l, r[ 1 ] = - n * i + t * s, r[ 4 ] = - n * o + t * c, r[ 7 ] = - n * a + t * l, this;

	}translate( e, t ) {

		const n = this.elements; return n[ 0 ] += e * n[ 2 ], n[ 3 ] += e * n[ 5 ], n[ 6 ] += e * n[ 8 ], n[ 1 ] += t * n[ 2 ], n[ 4 ] += t * n[ 5 ], n[ 7 ] += t * n[ 8 ], this;

	}equals( e ) {

		const t = this.elements, n = e.elements; for ( let e = 0; e < 9; e ++ ) if ( t[ e ] !== n[ e ] ) return ! 1; return ! 0;

	}fromArray( e, t = 0 ) {

		for ( let n = 0; n < 9; n ++ ) this.elements[ n ] = e[ n + t ]; return this;

	}toArray( e = [], t = 0 ) {

		const n = this.elements; return e[ t ] = n[ 0 ], e[ t + 1 ] = n[ 1 ], e[ t + 2 ] = n[ 2 ], e[ t + 3 ] = n[ 3 ], e[ t + 4 ] = n[ 4 ], e[ t + 5 ] = n[ 5 ], e[ t + 6 ] = n[ 6 ], e[ t + 7 ] = n[ 7 ], e[ t + 8 ] = n[ 8 ], e;

	}

} let _canvas; const ImageUtils = { getDataURL: function ( e ) {

	if ( /^data:/i.test( e.src ) ) return e.src; if ( 'undefined' == typeof HTMLCanvasElement ) return e.src; let t; if ( e instanceof HTMLCanvasElement )t = e; else {

		void 0 === _canvas && ( _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) ), _canvas.width = e.width, _canvas.height = e.height; const n = _canvas.getContext( '2d' ); e instanceof ImageData ? n.putImageData( e, 0, 0 ) : n.drawImage( e, 0, 0, e.width, e.height ), t = _canvas;

	}

	return t.width > 2048 || t.height > 2048 ? t.toDataURL( 'image/jpeg', .6 ) : t.toDataURL( 'image/png' );

} }; let textureId = 0; function Texture( e = Texture.DEFAULT_IMAGE, t = Texture.DEFAULT_MAPPING, n = ClampToEdgeWrapping, r = ClampToEdgeWrapping, i = LinearFilter, o = LinearMipmapLinearFilter, a = RGBAFormat, s = UnsignedByteType, c = 1, l = LinearEncoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } ), this.uuid = MathUtils.generateUUID(), this.name = '', this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = s, this.offset = new Vector2( 0, 0 ), this.repeat = new Vector2( 1, 1 ), this.center = new Vector2( 0, 0 ), this.rotation = 0, this.matrixAutoUpdate = ! 0, this.matrix = new Matrix3(), this.generateMipmaps = ! 0, this.premultiplyAlpha = ! 1, this.flipY = ! 0, this.unpackAlignment = 4, this.encoding = l, this.version = 0, this.onUpdate = null;

}

function serializeImage( e ) {

	return 'undefined' != typeof HTMLImageElement && e instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && e instanceof ImageBitmap ? ImageUtils.getDataURL( e ) : e.data ? { data: Array.prototype.slice.call( e.data ), width: e.width, height: e.height, type: e.data.constructor.name } : ( console.warn( 'THREE.Texture: Unable to serialize Texture.' ), {} );

}

Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = 300, Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Texture, isTexture: ! 0, updateMatrix: function () {

	this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, copy: function ( e ) {

	return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice( 0 ), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy( e.offset ), this.repeat.copy( e.repeat ), this.center.copy( e.center ), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy( e.matrix ), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;

}, toJSON: function ( e ) {

	const t = void 0 === e || 'string' == typeof e; if ( ! t && void 0 !== e.textures[ this.uuid ] ) return e.textures[ this.uuid ]; const n = { metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( void 0 !== this.image ) {

		const r = this.image; if ( void 0 === r.uuid && ( r.uuid = MathUtils.generateUUID() ), ! t && void 0 === e.images[ r.uuid ] ) {

			let t; if ( Array.isArray( r ) ) {

				t = []; for ( let e = 0, n = r.length; e < n; e ++ )r[ e ].isDataTexture ? t.push( serializeImage( r[ e ].image ) ) : t.push( serializeImage( r[ e ] ) );

			} else t = serializeImage( r ); e.images[ r.uuid ] = { uuid: r.uuid, url: t };

		}

		n.image = r.uuid;

	}

	return t || ( e.textures[ this.uuid ] = n ), n;

}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

}, transformUv: function ( e ) {

	if ( 300 !== this.mapping ) return e; if ( e.applyMatrix3( this.matrix ), e.x < 0 || e.x > 1 ) switch ( this.wrapS ) {

		case RepeatWrapping:e.x = e.x - Math.floor( e.x ); break; case ClampToEdgeWrapping:e.x = e.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping:1 === Math.abs( Math.floor( e.x ) % 2 ) ? e.x = Math.ceil( e.x ) - e.x : e.x = e.x - Math.floor( e.x );

	}

	if ( e.y < 0 || e.y > 1 ) switch ( this.wrapT ) {

		case RepeatWrapping:e.y = e.y - Math.floor( e.y ); break; case ClampToEdgeWrapping:e.y = e.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping:1 === Math.abs( Math.floor( e.y ) % 2 ) ? e.y = Math.ceil( e.y ) - e.y : e.y = e.y - Math.floor( e.y );

	}

	return this.flipY && ( e.y = 1 - e.y ), e;

} } ), Object.defineProperty( Texture.prototype, 'needsUpdate', { set: function ( e ) {

	! 0 === e && this.version ++;

} } ); class Vector4 {

	constructor( e = 0, t = 0, n = 0, r = 1 ) {

		Object.defineProperty( this, 'isVector4', { value: ! 0 } ), this.x = e, this.y = t, this.z = n, this.w = r;

	} get width() {

		return this.z;

	} set width( e ) {

		this.z = e;

	} get height() {

		return this.w;

	} set height( e ) {

		this.w = e;

	}set( e, t, n, r ) {

		return this.x = e, this.y = t, this.z = n, this.w = r, this;

	}setScalar( e ) {

		return this.x = e, this.y = e, this.z = e, this.w = e, this;

	}setX( e ) {

		return this.x = e, this;

	}setY( e ) {

		return this.y = e, this;

	}setZ( e ) {

		return this.z = e, this;

	}setW( e ) {

		return this.w = e, this;

	}setComponent( e, t ) {

		switch ( e ) {

			case 0:this.x = t; break; case 1:this.y = t; break; case 2:this.z = t; break; case 3:this.w = t; break; default:throw new Error( 'index is out of range: ' + e );

		}

		return this;

	}getComponent( e ) {

		switch ( e ) {

			case 0:return this.x; case 1:return this.y; case 2:return this.z; case 3:return this.w; default:throw new Error( 'index is out of range: ' + e );

		}

	}clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}copy( e ) {

		return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this;

	}add( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ), this.addVectors( e, t ) ) : ( this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this );

	}addScalar( e ) {

		return this.x += e, this.y += e, this.z += e, this.w += e, this;

	}addVectors( e, t ) {

		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;

	}addScaledVector( e, t ) {

		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;

	}sub( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ), this.subVectors( e, t ) ) : ( this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this );

	}subScalar( e ) {

		return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;

	}subVectors( e, t ) {

		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;

	}multiplyScalar( e ) {

		return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;

	}applyMatrix4( e ) {

		const t = this.x, n = this.y, r = this.z, i = this.w, o = e.elements; return this.x = o[ 0 ] * t + o[ 4 ] * n + o[ 8 ] * r + o[ 12 ] * i, this.y = o[ 1 ] * t + o[ 5 ] * n + o[ 9 ] * r + o[ 13 ] * i, this.z = o[ 2 ] * t + o[ 6 ] * n + o[ 10 ] * r + o[ 14 ] * i, this.w = o[ 3 ] * t + o[ 7 ] * n + o[ 11 ] * r + o[ 15 ] * i, this;

	}divideScalar( e ) {

		return this.multiplyScalar( 1 / e );

	}setAxisAngleFromQuaternion( e ) {

		this.w = 2 * Math.acos( e.w ); const t = Math.sqrt( 1 - e.w * e.w ); return t < 1e-4 ? ( this.x = 1, this.y = 0, this.z = 0 ) : ( this.x = e.x / t, this.y = e.y / t, this.z = e.z / t ), this;

	}setAxisAngleFromRotationMatrix( e ) {

		let t, n, r, i; const o = e.elements, a = o[ 0 ], s = o[ 4 ], c = o[ 8 ], l = o[ 1 ], h = o[ 5 ], u = o[ 9 ], d = o[ 2 ], p = o[ 6 ], m = o[ 10 ]; if ( Math.abs( s - l ) < .01 && Math.abs( c - d ) < .01 && Math.abs( u - p ) < .01 ) {

			if ( Math.abs( s + l ) < .1 && Math.abs( c + d ) < .1 && Math.abs( u + p ) < .1 && Math.abs( a + h + m - 3 ) < .1 ) return this.set( 1, 0, 0, 0 ), this; t = Math.PI; const e = ( a + 1 ) / 2, o = ( h + 1 ) / 2, f = ( m + 1 ) / 2, g = ( s + l ) / 4, v = ( c + d ) / 4, y = ( u + p ) / 4; return e > o && e > f ? e < .01 ? ( n = 0, r = .707106781, i = .707106781 ) : ( r = g / ( n = Math.sqrt( e ) ), i = v / n ) : o > f ? o < .01 ? ( n = .707106781, r = 0, i = .707106781 ) : ( n = g / ( r = Math.sqrt( o ) ), i = y / r ) : f < .01 ? ( n = .707106781, r = .707106781, i = 0 ) : ( n = v / ( i = Math.sqrt( f ) ), r = y / i ), this.set( n, r, i, t ), this;

		}

		let f = Math.sqrt( ( p - u ) * ( p - u ) + ( c - d ) * ( c - d ) + ( l - s ) * ( l - s ) ); return Math.abs( f ) < .001 && ( f = 1 ), this.x = ( p - u ) / f, this.y = ( c - d ) / f, this.z = ( l - s ) / f, this.w = Math.acos( ( a + h + m - 1 ) / 2 ), this;

	}min( e ) {

		return this.x = Math.min( this.x, e.x ), this.y = Math.min( this.y, e.y ), this.z = Math.min( this.z, e.z ), this.w = Math.min( this.w, e.w ), this;

	}max( e ) {

		return this.x = Math.max( this.x, e.x ), this.y = Math.max( this.y, e.y ), this.z = Math.max( this.z, e.z ), this.w = Math.max( this.w, e.w ), this;

	}clamp( e, t ) {

		return this.x = Math.max( e.x, Math.min( t.x, this.x ) ), this.y = Math.max( e.y, Math.min( t.y, this.y ) ), this.z = Math.max( e.z, Math.min( t.z, this.z ) ), this.w = Math.max( e.w, Math.min( t.w, this.w ) ), this;

	}clampScalar( e, t ) {

		return this.x = Math.max( e, Math.min( t, this.x ) ), this.y = Math.max( e, Math.min( t, this.y ) ), this.z = Math.max( e, Math.min( t, this.z ) ), this.w = Math.max( e, Math.min( t, this.w ) ), this;

	}clampLength( e, t ) {

		const n = this.length(); return this.divideScalar( n || 1 ).multiplyScalar( Math.max( e, Math.min( t, n ) ) );

	}floor() {

		return this.x = Math.floor( this.x ), this.y = Math.floor( this.y ), this.z = Math.floor( this.z ), this.w = Math.floor( this.w ), this;

	}ceil() {

		return this.x = Math.ceil( this.x ), this.y = Math.ceil( this.y ), this.z = Math.ceil( this.z ), this.w = Math.ceil( this.w ), this;

	}round() {

		return this.x = Math.round( this.x ), this.y = Math.round( this.y ), this.z = Math.round( this.z ), this.w = Math.round( this.w ), this;

	}roundToZero() {

		return this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x ), this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y ), this.z = this.z < 0 ? Math.ceil( this.z ) : Math.floor( this.z ), this.w = this.w < 0 ? Math.ceil( this.w ) : Math.floor( this.w ), this;

	}negate() {

		return this.x = - this.x, this.y = - this.y, this.z = - this.z, this.w = - this.w, this;

	}dot( e ) {

		return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;

	}lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}normalize() {

		return this.divideScalar( this.length() || 1 );

	}setLength( e ) {

		return this.normalize().multiplyScalar( e );

	}lerp( e, t ) {

		return this.x += ( e.x - this.x ) * t, this.y += ( e.y - this.y ) * t, this.z += ( e.z - this.z ) * t, this.w += ( e.w - this.w ) * t, this;

	}lerpVectors( e, t, n ) {

		return this.x = e.x + ( t.x - e.x ) * n, this.y = e.y + ( t.y - e.y ) * n, this.z = e.z + ( t.z - e.z ) * n, this.w = e.w + ( t.w - e.w ) * n, this;

	}equals( e ) {

		return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;

	}fromArray( e, t = 0 ) {

		return this.x = e[ t ], this.y = e[ t + 1 ], this.z = e[ t + 2 ], this.w = e[ t + 3 ], this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this.x, e[ t + 1 ] = this.y, e[ t + 2 ] = this.z, e[ t + 3 ] = this.w, e;

	}fromBufferAttribute( e, t, n ) {

		return void 0 !== n && console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' ), this.x = e.getX( t ), this.y = e.getY( t ), this.z = e.getZ( t ), this.w = e.getW( t ), this;

	}random() {

		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;

	}

} function WebGLRenderTarget( e, t, n ) {

	this.width = e, this.height = t, this.scissor = new Vector4( 0, 0, e, t ), this.scissorTest = ! 1, this.viewport = new Vector4( 0, 0, e, t ), n = n || {}, this.texture = new Texture( void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding ), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : LinearFilter, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null;

}

function WebGLMultisampleRenderTarget( e, t, n ) {

	WebGLRenderTarget.call( this, e, t, n ), this.samples = 4;

}

WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: WebGLRenderTarget, isWebGLRenderTarget: ! 0, setSize: function ( e, t ) {

	this.width === e && this.height === t || ( this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose() ), this.viewport.set( 0, 0, e, t ), this.scissor.set( 0, 0, e, t );

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, copy: function ( e ) {

	return this.width = e.width, this.height = e.height, this.viewport.copy( e.viewport ), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;

}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

} } ), WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), { constructor: WebGLMultisampleRenderTarget, isWebGLMultisampleRenderTarget: ! 0, copy: function ( e ) {

	return WebGLRenderTarget.prototype.copy.call( this, e ), this.samples = e.samples, this;

} } ); class Quaternion {

	constructor( e = 0, t = 0, n = 0, r = 1 ) {

		Object.defineProperty( this, 'isQuaternion', { value: ! 0 } ), this._x = e, this._y = t, this._z = n, this._w = r;

	} static slerp( e, t, n, r ) {

		return n.copy( e ).slerp( t, r );

	} static slerpFlat( e, t, n, r, i, o, a ) {

		let s = n[ r + 0 ], c = n[ r + 1 ], l = n[ r + 2 ], h = n[ r + 3 ]; const u = i[ o + 0 ], d = i[ o + 1 ], p = i[ o + 2 ], m = i[ o + 3 ]; if ( h !== m || s !== u || c !== d || l !== p ) {

			let e = 1 - a; const t = s * u + c * d + l * p + h * m, n = t >= 0 ? 1 : - 1, r = 1 - t * t; if ( r > Number.EPSILON ) {

				const i = Math.sqrt( r ), o = Math.atan2( i, t * n ); e = Math.sin( e * o ) / i, a = Math.sin( a * o ) / i;

			}

			const i = a * n; if ( s = s * e + u * i, c = c * e + d * i, l = l * e + p * i, h = h * e + m * i, e === 1 - a ) {

				const e = 1 / Math.sqrt( s * s + c * c + l * l + h * h ); s *= e, c *= e, l *= e, h *= e;

			}

		}

		e[ t ] = s, e[ t + 1 ] = c, e[ t + 2 ] = l, e[ t + 3 ] = h;

	} static multiplyQuaternionsFlat( e, t, n, r, i, o ) {

		const a = n[ r ], s = n[ r + 1 ], c = n[ r + 2 ], l = n[ r + 3 ], h = i[ o ], u = i[ o + 1 ], d = i[ o + 2 ], p = i[ o + 3 ]; return e[ t ] = a * p + l * h + s * d - c * u, e[ t + 1 ] = s * p + l * u + c * h - a * d, e[ t + 2 ] = c * p + l * d + a * u - s * h, e[ t + 3 ] = l * p - a * h - s * u - c * d, e;

	} get x() {

		return this._x;

	} set x( e ) {

		this._x = e, this._onChangeCallback();

	} get y() {

		return this._y;

	} set y( e ) {

		this._y = e, this._onChangeCallback();

	} get z() {

		return this._z;

	} set z( e ) {

		this._z = e, this._onChangeCallback();

	} get w() {

		return this._w;

	} set w( e ) {

		this._w = e, this._onChangeCallback();

	}set( e, t, n, r ) {

		return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;

	}clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}copy( e ) {

		return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;

	}setFromEuler( e, t ) {

		if ( ! e || ! e.isEuler ) throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' ); const n = e._x, r = e._y, i = e._z, o = e._order, a = Math.cos, s = Math.sin, c = a( n / 2 ), l = a( r / 2 ), h = a( i / 2 ), u = s( n / 2 ), d = s( r / 2 ), p = s( i / 2 ); switch ( o ) {

			case 'XYZ':this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p; break; case 'YXZ':this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p; break; case 'ZXY':this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p; break; case 'ZYX':this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p; break; case 'YZX':this._x = u * l * h + c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h - u * d * p; break; case 'XZY':this._x = u * l * h - c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h + u * d * p; break; default:console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + o );

		}

		return ! 1 !== t && this._onChangeCallback(), this;

	}setFromAxisAngle( e, t ) {

		const n = t / 2, r = Math.sin( n ); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos( n ), this._onChangeCallback(), this;

	}setFromRotationMatrix( e ) {

		const t = e.elements, n = t[ 0 ], r = t[ 4 ], i = t[ 8 ], o = t[ 1 ], a = t[ 5 ], s = t[ 9 ], c = t[ 2 ], l = t[ 6 ], h = t[ 10 ], u = n + a + h; if ( u > 0 ) {

			const e = .5 / Math.sqrt( u + 1 ); this._w = .25 / e, this._x = ( l - s ) * e, this._y = ( i - c ) * e, this._z = ( o - r ) * e;

		} else if ( n > a && n > h ) {

			const e = 2 * Math.sqrt( 1 + n - a - h ); this._w = ( l - s ) / e, this._x = .25 * e, this._y = ( r + o ) / e, this._z = ( i + c ) / e;

		} else if ( a > h ) {

			const e = 2 * Math.sqrt( 1 + a - n - h ); this._w = ( i - c ) / e, this._x = ( r + o ) / e, this._y = .25 * e, this._z = ( s + l ) / e;

		} else {

			const e = 2 * Math.sqrt( 1 + h - n - a ); this._w = ( o - r ) / e, this._x = ( i + c ) / e, this._y = ( s + l ) / e, this._z = .25 * e;

		}

		return this._onChangeCallback(), this;

	}setFromUnitVectors( e, t ) {

		let n = e.dot( t ) + 1; return n < 1e-6 ? ( n = 0, Math.abs( e.x ) > Math.abs( e.z ) ? ( this._x = - e.y, this._y = e.x, this._z = 0, this._w = n ) : ( this._x = 0, this._y = - e.z, this._z = e.y, this._w = n ) ) : ( this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n ), this.normalize();

	}angleTo( e ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( e ), - 1, 1 ) ) );

	}rotateTowards( e, t ) {

		const n = this.angleTo( e ); if ( 0 === n ) return this; const r = Math.min( 1, t / n ); return this.slerp( e, r ), this;

	}identity() {

		return this.set( 0, 0, 0, 1 );

	}invert() {

		return this.conjugate();

	}conjugate() {

		return this._x *= - 1, this._y *= - 1, this._z *= - 1, this._onChangeCallback(), this;

	}dot( e ) {

		return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;

	}lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}normalize() {

		let e = this.length(); return 0 === e ? ( this._x = 0, this._y = 0, this._z = 0, this._w = 1 ) : ( e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e ), this._onChangeCallback(), this;

	}multiply( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' ), this.multiplyQuaternions( e, t ) ) : this.multiplyQuaternions( this, e );

	}premultiply( e ) {

		return this.multiplyQuaternions( e, this );

	}multiplyQuaternions( e, t ) {

		const n = e._x, r = e._y, i = e._z, o = e._w, a = t._x, s = t._y, c = t._z, l = t._w; return this._x = n * l + o * a + r * c - i * s, this._y = r * l + o * s + i * a - n * c, this._z = i * l + o * c + n * s - r * a, this._w = o * l - n * a - r * s - i * c, this._onChangeCallback(), this;

	}slerp( e, t ) {

		if ( 0 === t ) return this; if ( 1 === t ) return this.copy( e ); const n = this._x, r = this._y, i = this._z, o = this._w; let a = o * e._w + n * e._x + r * e._y + i * e._z; if ( a < 0 ? ( this._w = - e._w, this._x = - e._x, this._y = - e._y, this._z = - e._z, a = - a ) : this.copy( e ), a >= 1 ) return this._w = o, this._x = n, this._y = r, this._z = i, this; const s = 1 - a * a; if ( s <= Number.EPSILON ) {

			const e = 1 - t; return this._w = e * o + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this;

		}

		const c = Math.sqrt( s ), l = Math.atan2( c, a ), h = Math.sin( ( 1 - t ) * l ) / c, u = Math.sin( t * l ) / c; return this._w = o * h + this._w * u, this._x = n * h + this._x * u, this._y = r * h + this._y * u, this._z = i * h + this._z * u, this._onChangeCallback(), this;

	}equals( e ) {

		return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;

	}fromArray( e, t = 0 ) {

		return this._x = e[ t ], this._y = e[ t + 1 ], this._z = e[ t + 2 ], this._w = e[ t + 3 ], this._onChangeCallback(), this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this._x, e[ t + 1 ] = this._y, e[ t + 2 ] = this._z, e[ t + 3 ] = this._w, e;

	}fromBufferAttribute( e, t ) {

		return this._x = e.getX( t ), this._y = e.getY( t ), this._z = e.getZ( t ), this._w = e.getW( t ), this;

	}_onChange( e ) {

		return this._onChangeCallback = e, this;

	}_onChangeCallback() {}

} class Vector3 {

	constructor( e = 0, t = 0, n = 0 ) {

		Object.defineProperty( this, 'isVector3', { value: ! 0 } ), this.x = e, this.y = t, this.z = n;

	}set( e, t, n ) {

		return void 0 === n && ( n = this.z ), this.x = e, this.y = t, this.z = n, this;

	}setScalar( e ) {

		return this.x = e, this.y = e, this.z = e, this;

	}setX( e ) {

		return this.x = e, this;

	}setY( e ) {

		return this.y = e, this;

	}setZ( e ) {

		return this.z = e, this;

	}setComponent( e, t ) {

		switch ( e ) {

			case 0:this.x = t; break; case 1:this.y = t; break; case 2:this.z = t; break; default:throw new Error( 'index is out of range: ' + e );

		}

		return this;

	}getComponent( e ) {

		switch ( e ) {

			case 0:return this.x; case 1:return this.y; case 2:return this.z; default:throw new Error( 'index is out of range: ' + e );

		}

	}clone() {

		return new this.constructor( this.x, this.y, this.z );

	}copy( e ) {

		return this.x = e.x, this.y = e.y, this.z = e.z, this;

	}add( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ), this.addVectors( e, t ) ) : ( this.x += e.x, this.y += e.y, this.z += e.z, this );

	}addScalar( e ) {

		return this.x += e, this.y += e, this.z += e, this;

	}addVectors( e, t ) {

		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;

	}addScaledVector( e, t ) {

		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;

	}sub( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ), this.subVectors( e, t ) ) : ( this.x -= e.x, this.y -= e.y, this.z -= e.z, this );

	}subScalar( e ) {

		return this.x -= e, this.y -= e, this.z -= e, this;

	}subVectors( e, t ) {

		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;

	}multiply( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' ), this.multiplyVectors( e, t ) ) : ( this.x *= e.x, this.y *= e.y, this.z *= e.z, this );

	}multiplyScalar( e ) {

		return this.x *= e, this.y *= e, this.z *= e, this;

	}multiplyVectors( e, t ) {

		return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;

	}applyEuler( e ) {

		return e && e.isEuler || console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' ), this.applyQuaternion( _quaternion.setFromEuler( e ) );

	}applyAxisAngle( e, t ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( e, t ) );

	}applyMatrix3( e ) {

		const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[ 0 ] * t + i[ 3 ] * n + i[ 6 ] * r, this.y = i[ 1 ] * t + i[ 4 ] * n + i[ 7 ] * r, this.z = i[ 2 ] * t + i[ 5 ] * n + i[ 8 ] * r, this;

	}applyNormalMatrix( e ) {

		return this.applyMatrix3( e ).normalize();

	}applyMatrix4( e ) {

		const t = this.x, n = this.y, r = this.z, i = e.elements, o = 1 / ( i[ 3 ] * t + i[ 7 ] * n + i[ 11 ] * r + i[ 15 ] ); return this.x = ( i[ 0 ] * t + i[ 4 ] * n + i[ 8 ] * r + i[ 12 ] ) * o, this.y = ( i[ 1 ] * t + i[ 5 ] * n + i[ 9 ] * r + i[ 13 ] ) * o, this.z = ( i[ 2 ] * t + i[ 6 ] * n + i[ 10 ] * r + i[ 14 ] ) * o, this;

	}applyQuaternion( e ) {

		const t = this.x, n = this.y, r = this.z, i = e.x, o = e.y, a = e.z, s = e.w, c = s * t + o * r - a * n, l = s * n + a * t - i * r, h = s * r + i * n - o * t, u = - i * t - o * n - a * r; return this.x = c * s + u * - i + l * - a - h * - o, this.y = l * s + u * - o + h * - i - c * - a, this.z = h * s + u * - a + c * - o - l * - i, this;

	}project( e ) {

		return this.applyMatrix4( e.matrixWorldInverse ).applyMatrix4( e.projectionMatrix );

	}unproject( e ) {

		return this.applyMatrix4( e.projectionMatrixInverse ).applyMatrix4( e.matrixWorld );

	}transformDirection( e ) {

		const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[ 0 ] * t + i[ 4 ] * n + i[ 8 ] * r, this.y = i[ 1 ] * t + i[ 5 ] * n + i[ 9 ] * r, this.z = i[ 2 ] * t + i[ 6 ] * n + i[ 10 ] * r, this.normalize();

	}divide( e ) {

		return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;

	}divideScalar( e ) {

		return this.multiplyScalar( 1 / e );

	}min( e ) {

		return this.x = Math.min( this.x, e.x ), this.y = Math.min( this.y, e.y ), this.z = Math.min( this.z, e.z ), this;

	}max( e ) {

		return this.x = Math.max( this.x, e.x ), this.y = Math.max( this.y, e.y ), this.z = Math.max( this.z, e.z ), this;

	}clamp( e, t ) {

		return this.x = Math.max( e.x, Math.min( t.x, this.x ) ), this.y = Math.max( e.y, Math.min( t.y, this.y ) ), this.z = Math.max( e.z, Math.min( t.z, this.z ) ), this;

	}clampScalar( e, t ) {

		return this.x = Math.max( e, Math.min( t, this.x ) ), this.y = Math.max( e, Math.min( t, this.y ) ), this.z = Math.max( e, Math.min( t, this.z ) ), this;

	}clampLength( e, t ) {

		const n = this.length(); return this.divideScalar( n || 1 ).multiplyScalar( Math.max( e, Math.min( t, n ) ) );

	}floor() {

		return this.x = Math.floor( this.x ), this.y = Math.floor( this.y ), this.z = Math.floor( this.z ), this;

	}ceil() {

		return this.x = Math.ceil( this.x ), this.y = Math.ceil( this.y ), this.z = Math.ceil( this.z ), this;

	}round() {

		return this.x = Math.round( this.x ), this.y = Math.round( this.y ), this.z = Math.round( this.z ), this;

	}roundToZero() {

		return this.x = this.x < 0 ? Math.ceil( this.x ) : Math.floor( this.x ), this.y = this.y < 0 ? Math.ceil( this.y ) : Math.floor( this.y ), this.z = this.z < 0 ? Math.ceil( this.z ) : Math.floor( this.z ), this;

	}negate() {

		return this.x = - this.x, this.y = - this.y, this.z = - this.z, this;

	}dot( e ) {

		return this.x * e.x + this.y * e.y + this.z * e.z;

	}lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}normalize() {

		return this.divideScalar( this.length() || 1 );

	}setLength( e ) {

		return this.normalize().multiplyScalar( e );

	}lerp( e, t ) {

		return this.x += ( e.x - this.x ) * t, this.y += ( e.y - this.y ) * t, this.z += ( e.z - this.z ) * t, this;

	}lerpVectors( e, t, n ) {

		return this.x = e.x + ( t.x - e.x ) * n, this.y = e.y + ( t.y - e.y ) * n, this.z = e.z + ( t.z - e.z ) * n, this;

	}cross( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' ), this.crossVectors( e, t ) ) : this.crossVectors( this, e );

	}crossVectors( e, t ) {

		const n = e.x, r = e.y, i = e.z, o = t.x, a = t.y, s = t.z; return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this;

	}projectOnVector( e ) {

		const t = e.lengthSq(); if ( 0 === t ) return this.set( 0, 0, 0 ); const n = e.dot( this ) / t; return this.copy( e ).multiplyScalar( n );

	}projectOnPlane( e ) {

		return _vector.copy( this ).projectOnVector( e ), this.sub( _vector );

	}reflect( e ) {

		return this.sub( _vector.copy( e ).multiplyScalar( 2 * this.dot( e ) ) );

	}angleTo( e ) {

		const t = Math.sqrt( this.lengthSq() * e.lengthSq() ); if ( 0 === t ) return Math.PI / 2; const n = this.dot( e ) / t; return Math.acos( MathUtils.clamp( n, - 1, 1 ) );

	}distanceTo( e ) {

		return Math.sqrt( this.distanceToSquared( e ) );

	}distanceToSquared( e ) {

		const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z; return t * t + n * n + r * r;

	}manhattanDistanceTo( e ) {

		return Math.abs( this.x - e.x ) + Math.abs( this.y - e.y ) + Math.abs( this.z - e.z );

	}setFromSpherical( e ) {

		return this.setFromSphericalCoords( e.radius, e.phi, e.theta );

	}setFromSphericalCoords( e, t, n ) {

		const r = Math.sin( t ) * e; return this.x = r * Math.sin( n ), this.y = Math.cos( t ) * e, this.z = r * Math.cos( n ), this;

	}setFromCylindrical( e ) {

		return this.setFromCylindricalCoords( e.radius, e.theta, e.y );

	}setFromCylindricalCoords( e, t, n ) {

		return this.x = e * Math.sin( t ), this.y = n, this.z = e * Math.cos( t ), this;

	}setFromMatrixPosition( e ) {

		const t = e.elements; return this.x = t[ 12 ], this.y = t[ 13 ], this.z = t[ 14 ], this;

	}setFromMatrixScale( e ) {

		const t = this.setFromMatrixColumn( e, 0 ).length(), n = this.setFromMatrixColumn( e, 1 ).length(), r = this.setFromMatrixColumn( e, 2 ).length(); return this.x = t, this.y = n, this.z = r, this;

	}setFromMatrixColumn( e, t ) {

		return this.fromArray( e.elements, 4 * t );

	}setFromMatrix3Column( e, t ) {

		return this.fromArray( e.elements, 3 * t );

	}equals( e ) {

		return e.x === this.x && e.y === this.y && e.z === this.z;

	}fromArray( e, t = 0 ) {

		return this.x = e[ t ], this.y = e[ t + 1 ], this.z = e[ t + 2 ], this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this.x, e[ t + 1 ] = this.y, e[ t + 2 ] = this.z, e;

	}fromBufferAttribute( e, t, n ) {

		return void 0 !== n && console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' ), this.x = e.getX( t ), this.y = e.getY( t ), this.z = e.getZ( t ), this;

	}random() {

		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;

	}

} const _vector = new Vector3(), _quaternion = new Quaternion(); class Box3 {

	constructor( e, t ) {

		Object.defineProperty( this, 'isBox3', { value: ! 0 } ), this.min = void 0 !== e ? e : new Vector3( 1 / 0, 1 / 0, 1 / 0 ), this.max = void 0 !== t ? t : new Vector3( - 1 / 0, - 1 / 0, - 1 / 0 );

	}set( e, t ) {

		return this.min.copy( e ), this.max.copy( t ), this;

	}setFromArray( e ) {

		let t = 1 / 0, n = 1 / 0, r = 1 / 0, i = - 1 / 0, o = - 1 / 0, a = - 1 / 0; for ( let s = 0, c = e.length; s < c; s += 3 ) {

			const c = e[ s ], l = e[ s + 1 ], h = e[ s + 2 ]; c < t && ( t = c ), l < n && ( n = l ), h < r && ( r = h ), c > i && ( i = c ), l > o && ( o = l ), h > a && ( a = h );

		}

		return this.min.set( t, n, r ), this.max.set( i, o, a ), this;

	}setFromBufferAttribute( e ) {

		let t = 1 / 0, n = 1 / 0, r = 1 / 0, i = - 1 / 0, o = - 1 / 0, a = - 1 / 0; for ( let s = 0, c = e.count; s < c; s ++ ) {

			const c = e.getX( s ), l = e.getY( s ), h = e.getZ( s ); c < t && ( t = c ), l < n && ( n = l ), h < r && ( r = h ), c > i && ( i = c ), l > o && ( o = l ), h > a && ( a = h );

		}

		return this.min.set( t, n, r ), this.max.set( i, o, a ), this;

	}setFromPoints( e ) {

		this.makeEmpty(); for ( let t = 0, n = e.length; t < n; t ++ ) this.expandByPoint( e[ t ] ); return this;

	}setFromCenterAndSize( e, t ) {

		const n = _vector$1.copy( t ).multiplyScalar( .5 ); return this.min.copy( e ).sub( n ), this.max.copy( e ).add( n ), this;

	}setFromObject( e ) {

		return this.makeEmpty(), this.expandByObject( e );

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.min.copy( e.min ), this.max.copy( e.max ), this;

	}makeEmpty() {

		return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = - 1 / 0, this;

	}isEmpty() {

		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;

	}getCenter( e ) {

		return void 0 === e && ( console.warn( 'THREE.Box3: .getCenter() target is now required' ), e = new Vector3() ), this.isEmpty() ? e.set( 0, 0, 0 ) : e.addVectors( this.min, this.max ).multiplyScalar( .5 );

	}getSize( e ) {

		return void 0 === e && ( console.warn( 'THREE.Box3: .getSize() target is now required' ), e = new Vector3() ), this.isEmpty() ? e.set( 0, 0, 0 ) : e.subVectors( this.max, this.min );

	}expandByPoint( e ) {

		return this.min.min( e ), this.max.max( e ), this;

	}expandByVector( e ) {

		return this.min.sub( e ), this.max.add( e ), this;

	}expandByScalar( e ) {

		return this.min.addScalar( - e ), this.max.addScalar( e ), this;

	}expandByObject( e ) {

		e.updateWorldMatrix( ! 1, ! 1 ); const t = e.geometry; void 0 !== t && ( null === t.boundingBox && t.computeBoundingBox(), _box.copy( t.boundingBox ), _box.applyMatrix4( e.matrixWorld ), this.union( _box ) ); const n = e.children; for ( let e = 0, t = n.length; e < t; e ++ ) this.expandByObject( n[ e ] ); return this;

	}containsPoint( e ) {

		return ! ( e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z );

	}containsBox( e ) {

		return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;

	}getParameter( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Box3: .getParameter() target is now required' ), t = new Vector3() ), t.set( ( e.x - this.min.x ) / ( this.max.x - this.min.x ), ( e.y - this.min.y ) / ( this.max.y - this.min.y ), ( e.z - this.min.z ) / ( this.max.z - this.min.z ) );

	}intersectsBox( e ) {

		return ! ( e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z );

	}intersectsSphere( e ) {

		return this.clampPoint( e.center, _vector$1 ), _vector$1.distanceToSquared( e.center ) <= e.radius * e.radius;

	}intersectsPlane( e ) {

		let t, n; return e.normal.x > 0 ? ( t = e.normal.x * this.min.x, n = e.normal.x * this.max.x ) : ( t = e.normal.x * this.max.x, n = e.normal.x * this.min.x ), e.normal.y > 0 ? ( t += e.normal.y * this.min.y, n += e.normal.y * this.max.y ) : ( t += e.normal.y * this.max.y, n += e.normal.y * this.min.y ), e.normal.z > 0 ? ( t += e.normal.z * this.min.z, n += e.normal.z * this.max.z ) : ( t += e.normal.z * this.max.z, n += e.normal.z * this.min.z ), t <= - e.constant && n >= - e.constant;

	}intersectsTriangle( e ) {

		if ( this.isEmpty() ) return ! 1; this.getCenter( _center ), _extents.subVectors( this.max, _center ), _v0.subVectors( e.a, _center ), _v1.subVectors( e.b, _center ), _v2.subVectors( e.c, _center ), _f0.subVectors( _v1, _v0 ), _f1.subVectors( _v2, _v1 ), _f2.subVectors( _v0, _v2 ); let t = [ 0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y, _f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x, - _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0 ]; return !! satForAxes( t, _v0, _v1, _v2, _extents ) && ( !! satForAxes( t = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], _v0, _v1, _v2, _extents ) && ( _triangleNormal.crossVectors( _f0, _f1 ), satForAxes( t = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ], _v0, _v1, _v2, _extents ) ) );

	}clampPoint( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Box3: .clampPoint() target is now required' ), t = new Vector3() ), t.copy( e ).clamp( this.min, this.max );

	}distanceToPoint( e ) {

		return _vector$1.copy( e ).clamp( this.min, this.max ).sub( e ).length();

	}getBoundingSphere( e ) {

		return void 0 === e && console.error( 'THREE.Box3: .getBoundingSphere() target is now required' ), this.getCenter( e.center ), e.radius = .5 * this.getSize( _vector$1 ).length(), e;

	}intersect( e ) {

		return this.min.max( e.min ), this.max.min( e.max ), this.isEmpty() && this.makeEmpty(), this;

	}union( e ) {

		return this.min.min( e.min ), this.max.max( e.max ), this;

	}applyMatrix4( e ) {

		return this.isEmpty() ? this : ( _points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( e ), _points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( e ), _points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( e ), _points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( e ), _points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( e ), _points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( e ), _points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( e ), _points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( e ), this.setFromPoints( _points ), this );

	}translate( e ) {

		return this.min.add( e ), this.max.add( e ), this;

	}equals( e ) {

		return e.min.equals( this.min ) && e.max.equals( this.max );

	}

} function satForAxes( e, t, n, r, i ) {

	for ( let o = 0, a = e.length - 3; o <= a; o += 3 ) {

		_testAxis.fromArray( e, o ); const a = i.x * Math.abs( _testAxis.x ) + i.y * Math.abs( _testAxis.y ) + i.z * Math.abs( _testAxis.z ), s = t.dot( _testAxis ), c = n.dot( _testAxis ), l = r.dot( _testAxis ); if ( Math.max( - Math.max( s, c, l ), Math.min( s, c, l ) ) > a ) return ! 1;

	}

	return ! 0;

}

const _points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ], _vector$1 = new Vector3(), _box = new Box3(), _v0 = new Vector3(), _v1 = new Vector3(), _v2 = new Vector3(), _f0 = new Vector3(), _f1 = new Vector3(), _f2 = new Vector3(), _center = new Vector3(), _extents = new Vector3(), _triangleNormal = new Vector3(), _testAxis = new Vector3(), _box$1 = new Box3(); class Sphere {

	constructor( e, t ) {

		this.center = void 0 !== e ? e : new Vector3(), this.radius = void 0 !== t ? t : - 1;

	}set( e, t ) {

		return this.center.copy( e ), this.radius = t, this;

	}setFromPoints( e, t ) {

		const n = this.center; void 0 !== t ? n.copy( t ) : _box$1.setFromPoints( e ).getCenter( n ); let r = 0; for ( let t = 0, i = e.length; t < i; t ++ )r = Math.max( r, n.distanceToSquared( e[ t ] ) ); return this.radius = Math.sqrt( r ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.center.copy( e.center ), this.radius = e.radius, this;

	}isEmpty() {

		return this.radius < 0;

	}makeEmpty() {

		return this.center.set( 0, 0, 0 ), this.radius = - 1, this;

	}containsPoint( e ) {

		return e.distanceToSquared( this.center ) <= this.radius * this.radius;

	}distanceToPoint( e ) {

		return e.distanceTo( this.center ) - this.radius;

	}intersectsSphere( e ) {

		const t = this.radius + e.radius; return e.center.distanceToSquared( this.center ) <= t * t;

	}intersectsBox( e ) {

		return e.intersectsSphere( this );

	}intersectsPlane( e ) {

		return Math.abs( e.distanceToPoint( this.center ) ) <= this.radius;

	}clampPoint( e, t ) {

		const n = this.center.distanceToSquared( e ); return void 0 === t && ( console.warn( 'THREE.Sphere: .clampPoint() target is now required' ), t = new Vector3() ), t.copy( e ), n > this.radius * this.radius && ( t.sub( this.center ).normalize(), t.multiplyScalar( this.radius ).add( this.center ) ), t;

	}getBoundingBox( e ) {

		return void 0 === e && ( console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' ), e = new Box3() ), this.isEmpty() ? ( e.makeEmpty(), e ) : ( e.set( this.center, this.center ), e.expandByScalar( this.radius ), e );

	}applyMatrix4( e ) {

		return this.center.applyMatrix4( e ), this.radius = this.radius * e.getMaxScaleOnAxis(), this;

	}translate( e ) {

		return this.center.add( e ), this;

	}equals( e ) {

		return e.center.equals( this.center ) && e.radius === this.radius;

	}

} const _vector$2 = new Vector3(), _segCenter = new Vector3(), _segDir = new Vector3(), _diff = new Vector3(), _edge1 = new Vector3(), _edge2 = new Vector3(), _normal = new Vector3(); class Ray {

	constructor( e, t ) {

		this.origin = void 0 !== e ? e : new Vector3(), this.direction = void 0 !== t ? t : new Vector3( 0, 0, - 1 );

	}set( e, t ) {

		return this.origin.copy( e ), this.direction.copy( t ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.origin.copy( e.origin ), this.direction.copy( e.direction ), this;

	}at( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Ray: .at() target is now required' ), t = new Vector3() ), t.copy( this.direction ).multiplyScalar( e ).add( this.origin );

	}lookAt( e ) {

		return this.direction.copy( e ).sub( this.origin ).normalize(), this;

	}recast( e ) {

		return this.origin.copy( this.at( e, _vector$2 ) ), this;

	}closestPointToPoint( e, t ) {

		void 0 === t && ( console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' ), t = new Vector3() ), t.subVectors( e, this.origin ); const n = t.dot( this.direction ); return n < 0 ? t.copy( this.origin ) : t.copy( this.direction ).multiplyScalar( n ).add( this.origin );

	}distanceToPoint( e ) {

		return Math.sqrt( this.distanceSqToPoint( e ) );

	}distanceSqToPoint( e ) {

		const t = _vector$2.subVectors( e, this.origin ).dot( this.direction ); return t < 0 ? this.origin.distanceToSquared( e ) : ( _vector$2.copy( this.direction ).multiplyScalar( t ).add( this.origin ), _vector$2.distanceToSquared( e ) );

	}distanceSqToSegment( e, t, n, r ) {

		_segCenter.copy( e ).add( t ).multiplyScalar( .5 ), _segDir.copy( t ).sub( e ).normalize(), _diff.copy( this.origin ).sub( _segCenter ); const i = .5 * e.distanceTo( t ), o = - this.direction.dot( _segDir ), a = _diff.dot( this.direction ), s = - _diff.dot( _segDir ), c = _diff.lengthSq(), l = Math.abs( 1 - o * o ); let h, u, d, p; if ( l > 0 ) if ( u = o * a - s, p = i * l, ( h = o * s - a ) >= 0 ) if ( u >= - p ) if ( u <= p ) {

			const e = 1 / l; d = ( h *= e ) * ( h + o * ( u *= e ) + 2 * a ) + u * ( o * h + u + 2 * s ) + c;

		} else u = i, d = - ( h = Math.max( 0, - ( o * u + a ) ) ) * h + u * ( u + 2 * s ) + c; else u = - i, d = - ( h = Math.max( 0, - ( o * u + a ) ) ) * h + u * ( u + 2 * s ) + c; else u <= - p ? d = - ( h = Math.max( 0, - ( - o * i + a ) ) ) * h + ( u = h > 0 ? - i : Math.min( Math.max( - i, - s ), i ) ) * ( u + 2 * s ) + c : u <= p ? ( h = 0, d = ( u = Math.min( Math.max( - i, - s ), i ) ) * ( u + 2 * s ) + c ) : d = - ( h = Math.max( 0, - ( o * i + a ) ) ) * h + ( u = h > 0 ? i : Math.min( Math.max( - i, - s ), i ) ) * ( u + 2 * s ) + c; else u = o > 0 ? - i : i, d = - ( h = Math.max( 0, - ( o * u + a ) ) ) * h + u * ( u + 2 * s ) + c; return n && n.copy( this.direction ).multiplyScalar( h ).add( this.origin ), r && r.copy( _segDir ).multiplyScalar( u ).add( _segCenter ), d;

	}intersectSphere( e, t ) {

		_vector$2.subVectors( e.center, this.origin ); const n = _vector$2.dot( this.direction ), r = _vector$2.dot( _vector$2 ) - n * n, i = e.radius * e.radius; if ( r > i ) return null; const o = Math.sqrt( i - r ), a = n - o, s = n + o; return a < 0 && s < 0 ? null : a < 0 ? this.at( s, t ) : this.at( a, t );

	}intersectsSphere( e ) {

		return this.distanceSqToPoint( e.center ) <= e.radius * e.radius;

	}distanceToPlane( e ) {

		const t = e.normal.dot( this.direction ); if ( 0 === t ) return 0 === e.distanceToPoint( this.origin ) ? 0 : null; const n = - ( this.origin.dot( e.normal ) + e.constant ) / t; return n >= 0 ? n : null;

	}intersectPlane( e, t ) {

		const n = this.distanceToPlane( e ); return null === n ? null : this.at( n, t );

	}intersectsPlane( e ) {

		const t = e.distanceToPoint( this.origin ); return 0 === t || e.normal.dot( this.direction ) * t < 0;

	}intersectBox( e, t ) {

		let n, r, i, o, a, s; const c = 1 / this.direction.x, l = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return c >= 0 ? ( n = ( e.min.x - u.x ) * c, r = ( e.max.x - u.x ) * c ) : ( n = ( e.max.x - u.x ) * c, r = ( e.min.x - u.x ) * c ), l >= 0 ? ( i = ( e.min.y - u.y ) * l, o = ( e.max.y - u.y ) * l ) : ( i = ( e.max.y - u.y ) * l, o = ( e.min.y - u.y ) * l ), n > o || i > r ? null : ( ( i > n || n != n ) && ( n = i ), ( o < r || r != r ) && ( r = o ), h >= 0 ? ( a = ( e.min.z - u.z ) * h, s = ( e.max.z - u.z ) * h ) : ( a = ( e.max.z - u.z ) * h, s = ( e.min.z - u.z ) * h ), n > s || a > r ? null : ( ( a > n || n != n ) && ( n = a ), ( s < r || r != r ) && ( r = s ), r < 0 ? null : this.at( n >= 0 ? n : r, t ) ) );

	}intersectsBox( e ) {

		return null !== this.intersectBox( e, _vector$2 );

	}intersectTriangle( e, t, n, r, i ) {

		_edge1.subVectors( t, e ), _edge2.subVectors( n, e ), _normal.crossVectors( _edge1, _edge2 ); let o, a = this.direction.dot( _normal ); if ( a > 0 ) {

			if ( r ) return null; o = 1;

		} else {

			if ( ! ( a < 0 ) ) return null; o = - 1, a = - a;

		}

		_diff.subVectors( this.origin, e ); const s = o * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) ); if ( s < 0 ) return null; const c = o * this.direction.dot( _edge1.cross( _diff ) ); if ( c < 0 ) return null; if ( s + c > a ) return null; const l = - o * _diff.dot( _normal ); return l < 0 ? null : this.at( l / a, i );

	}applyMatrix4( e ) {

		return this.origin.applyMatrix4( e ), this.direction.transformDirection( e ), this;

	}equals( e ) {

		return e.origin.equals( this.origin ) && e.direction.equals( this.direction );

	}

} class Matrix4 {

	constructor() {

		Object.defineProperty( this, 'isMatrix4', { value: ! 0 } ), this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], arguments.length > 0 && console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}set( e, t, n, r, i, o, a, s, c, l, h, u, d, p, m, f ) {

		const g = this.elements; return g[ 0 ] = e, g[ 4 ] = t, g[ 8 ] = n, g[ 12 ] = r, g[ 1 ] = i, g[ 5 ] = o, g[ 9 ] = a, g[ 13 ] = s, g[ 2 ] = c, g[ 6 ] = l, g[ 10 ] = h, g[ 14 ] = u, g[ 3 ] = d, g[ 7 ] = p, g[ 11 ] = m, g[ 15 ] = f, this;

	}identity() {

		return this.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ), this;

	}clone() {

		return ( new Matrix4() ).fromArray( this.elements );

	}copy( e ) {

		const t = this.elements, n = e.elements; return t[ 0 ] = n[ 0 ], t[ 1 ] = n[ 1 ], t[ 2 ] = n[ 2 ], t[ 3 ] = n[ 3 ], t[ 4 ] = n[ 4 ], t[ 5 ] = n[ 5 ], t[ 6 ] = n[ 6 ], t[ 7 ] = n[ 7 ], t[ 8 ] = n[ 8 ], t[ 9 ] = n[ 9 ], t[ 10 ] = n[ 10 ], t[ 11 ] = n[ 11 ], t[ 12 ] = n[ 12 ], t[ 13 ] = n[ 13 ], t[ 14 ] = n[ 14 ], t[ 15 ] = n[ 15 ], this;

	}copyPosition( e ) {

		const t = this.elements, n = e.elements; return t[ 12 ] = n[ 12 ], t[ 13 ] = n[ 13 ], t[ 14 ] = n[ 14 ], this;

	}extractBasis( e, t, n ) {

		return e.setFromMatrixColumn( this, 0 ), t.setFromMatrixColumn( this, 1 ), n.setFromMatrixColumn( this, 2 ), this;

	}makeBasis( e, t, n ) {

		return this.set( e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1 ), this;

	}extractRotation( e ) {

		const t = this.elements, n = e.elements, r = 1 / _v1$1.setFromMatrixColumn( e, 0 ).length(), i = 1 / _v1$1.setFromMatrixColumn( e, 1 ).length(), o = 1 / _v1$1.setFromMatrixColumn( e, 2 ).length(); return t[ 0 ] = n[ 0 ] * r, t[ 1 ] = n[ 1 ] * r, t[ 2 ] = n[ 2 ] * r, t[ 3 ] = 0, t[ 4 ] = n[ 4 ] * i, t[ 5 ] = n[ 5 ] * i, t[ 6 ] = n[ 6 ] * i, t[ 7 ] = 0, t[ 8 ] = n[ 8 ] * o, t[ 9 ] = n[ 9 ] * o, t[ 10 ] = n[ 10 ] * o, t[ 11 ] = 0, t[ 12 ] = 0, t[ 13 ] = 0, t[ 14 ] = 0, t[ 15 ] = 1, this;

	}makeRotationFromEuler( e ) {

		e && e.isEuler || console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' ); const t = this.elements, n = e.x, r = e.y, i = e.z, o = Math.cos( n ), a = Math.sin( n ), s = Math.cos( r ), c = Math.sin( r ), l = Math.cos( i ), h = Math.sin( i ); if ( 'XYZ' === e.order ) {

			const e = o * l, n = o * h, r = a * l, i = a * h; t[ 0 ] = s * l, t[ 4 ] = - s * h, t[ 8 ] = c, t[ 1 ] = n + r * c, t[ 5 ] = e - i * c, t[ 9 ] = - a * s, t[ 2 ] = i - e * c, t[ 6 ] = r + n * c, t[ 10 ] = o * s;

		} else if ( 'YXZ' === e.order ) {

			const e = s * l, n = s * h, r = c * l, i = c * h; t[ 0 ] = e + i * a, t[ 4 ] = r * a - n, t[ 8 ] = o * c, t[ 1 ] = o * h, t[ 5 ] = o * l, t[ 9 ] = - a, t[ 2 ] = n * a - r, t[ 6 ] = i + e * a, t[ 10 ] = o * s;

		} else if ( 'ZXY' === e.order ) {

			const e = s * l, n = s * h, r = c * l, i = c * h; t[ 0 ] = e - i * a, t[ 4 ] = - o * h, t[ 8 ] = r + n * a, t[ 1 ] = n + r * a, t[ 5 ] = o * l, t[ 9 ] = i - e * a, t[ 2 ] = - o * c, t[ 6 ] = a, t[ 10 ] = o * s;

		} else if ( 'ZYX' === e.order ) {

			const e = o * l, n = o * h, r = a * l, i = a * h; t[ 0 ] = s * l, t[ 4 ] = r * c - n, t[ 8 ] = e * c + i, t[ 1 ] = s * h, t[ 5 ] = i * c + e, t[ 9 ] = n * c - r, t[ 2 ] = - c, t[ 6 ] = a * s, t[ 10 ] = o * s;

		} else if ( 'YZX' === e.order ) {

			const e = o * s, n = o * c, r = a * s, i = a * c; t[ 0 ] = s * l, t[ 4 ] = i - e * h, t[ 8 ] = r * h + n, t[ 1 ] = h, t[ 5 ] = o * l, t[ 9 ] = - a * l, t[ 2 ] = - c * l, t[ 6 ] = n * h + r, t[ 10 ] = e - i * h;

		} else if ( 'XZY' === e.order ) {

			const e = o * s, n = o * c, r = a * s, i = a * c; t[ 0 ] = s * l, t[ 4 ] = - h, t[ 8 ] = c * l, t[ 1 ] = e * h + i, t[ 5 ] = o * l, t[ 9 ] = n * h - r, t[ 2 ] = r * h - n, t[ 6 ] = a * l, t[ 10 ] = i * h + e;

		}

		return t[ 3 ] = 0, t[ 7 ] = 0, t[ 11 ] = 0, t[ 12 ] = 0, t[ 13 ] = 0, t[ 14 ] = 0, t[ 15 ] = 1, this;

	}makeRotationFromQuaternion( e ) {

		return this.compose( _zero, e, _one );

	}lookAt( e, t, n ) {

		const r = this.elements; return _z.subVectors( e, t ), 0 === _z.lengthSq() && ( _z.z = 1 ), _z.normalize(), _x.crossVectors( n, _z ), 0 === _x.lengthSq() && ( 1 === Math.abs( n.z ) ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors( n, _z ) ), _x.normalize(), _y.crossVectors( _z, _x ), r[ 0 ] = _x.x, r[ 4 ] = _y.x, r[ 8 ] = _z.x, r[ 1 ] = _x.y, r[ 5 ] = _y.y, r[ 9 ] = _z.y, r[ 2 ] = _x.z, r[ 6 ] = _y.z, r[ 10 ] = _z.z, this;

	}multiply( e, t ) {

		return void 0 !== t ? ( console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' ), this.multiplyMatrices( e, t ) ) : this.multiplyMatrices( this, e );

	}premultiply( e ) {

		return this.multiplyMatrices( e, this );

	}multiplyMatrices( e, t ) {

		const n = e.elements, r = t.elements, i = this.elements, o = n[ 0 ], a = n[ 4 ], s = n[ 8 ], c = n[ 12 ], l = n[ 1 ], h = n[ 5 ], u = n[ 9 ], d = n[ 13 ], p = n[ 2 ], m = n[ 6 ], f = n[ 10 ], g = n[ 14 ], v = n[ 3 ], y = n[ 7 ], _ = n[ 11 ], x = n[ 15 ], b = r[ 0 ], M = r[ 4 ], w = r[ 8 ], S = r[ 12 ], T = r[ 1 ], E = r[ 5 ], A = r[ 9 ], L = r[ 13 ], C = r[ 2 ], R = r[ 6 ], P = r[ 10 ], B = r[ 14 ], D = r[ 3 ], G = r[ 7 ], I = r[ 11 ], F = r[ 15 ]; return i[ 0 ] = o * b + a * T + s * C + c * D, i[ 4 ] = o * M + a * E + s * R + c * G, i[ 8 ] = o * w + a * A + s * P + c * I, i[ 12 ] = o * S + a * L + s * B + c * F, i[ 1 ] = l * b + h * T + u * C + d * D, i[ 5 ] = l * M + h * E + u * R + d * G, i[ 9 ] = l * w + h * A + u * P + d * I, i[ 13 ] = l * S + h * L + u * B + d * F, i[ 2 ] = p * b + m * T + f * C + g * D, i[ 6 ] = p * M + m * E + f * R + g * G, i[ 10 ] = p * w + m * A + f * P + g * I, i[ 14 ] = p * S + m * L + f * B + g * F, i[ 3 ] = v * b + y * T + _ * C + x * D, i[ 7 ] = v * M + y * E + _ * R + x * G, i[ 11 ] = v * w + y * A + _ * P + x * I, i[ 15 ] = v * S + y * L + _ * B + x * F, this;

	}multiplyScalar( e ) {

		const t = this.elements; return t[ 0 ] *= e, t[ 4 ] *= e, t[ 8 ] *= e, t[ 12 ] *= e, t[ 1 ] *= e, t[ 5 ] *= e, t[ 9 ] *= e, t[ 13 ] *= e, t[ 2 ] *= e, t[ 6 ] *= e, t[ 10 ] *= e, t[ 14 ] *= e, t[ 3 ] *= e, t[ 7 ] *= e, t[ 11 ] *= e, t[ 15 ] *= e, this;

	}determinant() {

		const e = this.elements, t = e[ 0 ], n = e[ 4 ], r = e[ 8 ], i = e[ 12 ], o = e[ 1 ], a = e[ 5 ], s = e[ 9 ], c = e[ 13 ], l = e[ 2 ], h = e[ 6 ], u = e[ 10 ], d = e[ 14 ]; return e[ 3 ] * ( + i * s * h - r * c * h - i * a * u + n * c * u + r * a * d - n * s * d ) + e[ 7 ] * ( + t * s * d - t * c * u + i * o * u - r * o * d + r * c * l - i * s * l ) + e[ 11 ] * ( + t * c * h - t * a * d - i * o * h + n * o * d + i * a * l - n * c * l ) + e[ 15 ] * ( - r * a * l - t * s * h + t * a * u + r * o * h - n * o * u + n * s * l );

	}transpose() {

		const e = this.elements; let t; return t = e[ 1 ], e[ 1 ] = e[ 4 ], e[ 4 ] = t, t = e[ 2 ], e[ 2 ] = e[ 8 ], e[ 8 ] = t, t = e[ 6 ], e[ 6 ] = e[ 9 ], e[ 9 ] = t, t = e[ 3 ], e[ 3 ] = e[ 12 ], e[ 12 ] = t, t = e[ 7 ], e[ 7 ] = e[ 13 ], e[ 13 ] = t, t = e[ 11 ], e[ 11 ] = e[ 14 ], e[ 14 ] = t, this;

	}setPosition( e, t, n ) {

		const r = this.elements; return e.isVector3 ? ( r[ 12 ] = e.x, r[ 13 ] = e.y, r[ 14 ] = e.z ) : ( r[ 12 ] = e, r[ 13 ] = t, r[ 14 ] = n ), this;

	}invert() {

		const e = this.elements, t = e[ 0 ], n = e[ 1 ], r = e[ 2 ], i = e[ 3 ], o = e[ 4 ], a = e[ 5 ], s = e[ 6 ], c = e[ 7 ], l = e[ 8 ], h = e[ 9 ], u = e[ 10 ], d = e[ 11 ], p = e[ 12 ], m = e[ 13 ], f = e[ 14 ], g = e[ 15 ], v = h * f * c - m * u * c + m * s * d - a * f * d - h * s * g + a * u * g, y = p * u * c - l * f * c - p * s * d + o * f * d + l * s * g - o * u * g, _ = l * m * c - p * h * c + p * a * d - o * m * d - l * a * g + o * h * g, x = p * h * s - l * m * s - p * a * u + o * m * u + l * a * f - o * h * f, b = t * v + n * y + r * _ + i * x; if ( 0 === b ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ); const M = 1 / b; return e[ 0 ] = v * M, e[ 1 ] = ( m * u * i - h * f * i - m * r * d + n * f * d + h * r * g - n * u * g ) * M, e[ 2 ] = ( a * f * i - m * s * i + m * r * c - n * f * c - a * r * g + n * s * g ) * M, e[ 3 ] = ( h * s * i - a * u * i - h * r * c + n * u * c + a * r * d - n * s * d ) * M, e[ 4 ] = y * M, e[ 5 ] = ( l * f * i - p * u * i + p * r * d - t * f * d - l * r * g + t * u * g ) * M, e[ 6 ] = ( p * s * i - o * f * i - p * r * c + t * f * c + o * r * g - t * s * g ) * M, e[ 7 ] = ( o * u * i - l * s * i + l * r * c - t * u * c - o * r * d + t * s * d ) * M, e[ 8 ] = _ * M, e[ 9 ] = ( p * h * i - l * m * i - p * n * d + t * m * d + l * n * g - t * h * g ) * M, e[ 10 ] = ( o * m * i - p * a * i + p * n * c - t * m * c - o * n * g + t * a * g ) * M, e[ 11 ] = ( l * a * i - o * h * i - l * n * c + t * h * c + o * n * d - t * a * d ) * M, e[ 12 ] = x * M, e[ 13 ] = ( l * m * r - p * h * r + p * n * u - t * m * u - l * n * f + t * h * f ) * M, e[ 14 ] = ( p * a * r - o * m * r - p * n * s + t * m * s + o * n * f - t * a * f ) * M, e[ 15 ] = ( o * h * r - l * a * r + l * n * s - t * h * s - o * n * u + t * a * u ) * M, this;

	}scale( e ) {

		const t = this.elements, n = e.x, r = e.y, i = e.z; return t[ 0 ] *= n, t[ 4 ] *= r, t[ 8 ] *= i, t[ 1 ] *= n, t[ 5 ] *= r, t[ 9 ] *= i, t[ 2 ] *= n, t[ 6 ] *= r, t[ 10 ] *= i, t[ 3 ] *= n, t[ 7 ] *= r, t[ 11 ] *= i, this;

	}getMaxScaleOnAxis() {

		const e = this.elements, t = e[ 0 ] * e[ 0 ] + e[ 1 ] * e[ 1 ] + e[ 2 ] * e[ 2 ], n = e[ 4 ] * e[ 4 ] + e[ 5 ] * e[ 5 ] + e[ 6 ] * e[ 6 ], r = e[ 8 ] * e[ 8 ] + e[ 9 ] * e[ 9 ] + e[ 10 ] * e[ 10 ]; return Math.sqrt( Math.max( t, n, r ) );

	}makeTranslation( e, t, n ) {

		return this.set( 1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1 ), this;

	}makeRotationX( e ) {

		const t = Math.cos( e ), n = Math.sin( e ); return this.set( 1, 0, 0, 0, 0, t, - n, 0, 0, n, t, 0, 0, 0, 0, 1 ), this;

	}makeRotationY( e ) {

		const t = Math.cos( e ), n = Math.sin( e ); return this.set( t, 0, n, 0, 0, 1, 0, 0, - n, 0, t, 0, 0, 0, 0, 1 ), this;

	}makeRotationZ( e ) {

		const t = Math.cos( e ), n = Math.sin( e ); return this.set( t, - n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ), this;

	}makeRotationAxis( e, t ) {

		const n = Math.cos( t ), r = Math.sin( t ), i = 1 - n, o = e.x, a = e.y, s = e.z, c = i * o, l = i * a; return this.set( c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, l * a + n, l * s - r * o, 0, c * s - r * a, l * s + r * o, i * s * s + n, 0, 0, 0, 0, 1 ), this;

	}makeScale( e, t, n ) {

		return this.set( e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1 ), this;

	}makeShear( e, t, n ) {

		return this.set( 1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1 ), this;

	}compose( e, t, n ) {

		const r = this.elements, i = t._x, o = t._y, a = t._z, s = t._w, c = i + i, l = o + o, h = a + a, u = i * c, d = i * l, p = i * h, m = o * l, f = o * h, g = a * h, v = s * c, y = s * l, _ = s * h, x = n.x, b = n.y, M = n.z; return r[ 0 ] = ( 1 - ( m + g ) ) * x, r[ 1 ] = ( d + _ ) * x, r[ 2 ] = ( p - y ) * x, r[ 3 ] = 0, r[ 4 ] = ( d - _ ) * b, r[ 5 ] = ( 1 - ( u + g ) ) * b, r[ 6 ] = ( f + v ) * b, r[ 7 ] = 0, r[ 8 ] = ( p + y ) * M, r[ 9 ] = ( f - v ) * M, r[ 10 ] = ( 1 - ( u + m ) ) * M, r[ 11 ] = 0, r[ 12 ] = e.x, r[ 13 ] = e.y, r[ 14 ] = e.z, r[ 15 ] = 1, this;

	}decompose( e, t, n ) {

		const r = this.elements; let i = _v1$1.set( r[ 0 ], r[ 1 ], r[ 2 ] ).length(); const o = _v1$1.set( r[ 4 ], r[ 5 ], r[ 6 ] ).length(), a = _v1$1.set( r[ 8 ], r[ 9 ], r[ 10 ] ).length(); this.determinant() < 0 && ( i = - i ), e.x = r[ 12 ], e.y = r[ 13 ], e.z = r[ 14 ], _m1.copy( this ); const s = 1 / i, c = 1 / o, l = 1 / a; return _m1.elements[ 0 ] *= s, _m1.elements[ 1 ] *= s, _m1.elements[ 2 ] *= s, _m1.elements[ 4 ] *= c, _m1.elements[ 5 ] *= c, _m1.elements[ 6 ] *= c, _m1.elements[ 8 ] *= l, _m1.elements[ 9 ] *= l, _m1.elements[ 10 ] *= l, t.setFromRotationMatrix( _m1 ), n.x = i, n.y = o, n.z = a, this;

	}makePerspective( e, t, n, r, i, o ) {

		void 0 === o && console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' ); const a = this.elements, s = 2 * i / ( t - e ), c = 2 * i / ( n - r ), l = ( t + e ) / ( t - e ), h = ( n + r ) / ( n - r ), u = - ( o + i ) / ( o - i ), d = - 2 * o * i / ( o - i ); return a[ 0 ] = s, a[ 4 ] = 0, a[ 8 ] = l, a[ 12 ] = 0, a[ 1 ] = 0, a[ 5 ] = c, a[ 9 ] = h, a[ 13 ] = 0, a[ 2 ] = 0, a[ 6 ] = 0, a[ 10 ] = u, a[ 14 ] = d, a[ 3 ] = 0, a[ 7 ] = 0, a[ 11 ] = - 1, a[ 15 ] = 0, this;

	}makeOrthographic( e, t, n, r, i, o ) {

		const a = this.elements, s = 1 / ( t - e ), c = 1 / ( n - r ), l = 1 / ( o - i ), h = ( t + e ) * s, u = ( n + r ) * c, d = ( o + i ) * l; return a[ 0 ] = 2 * s, a[ 4 ] = 0, a[ 8 ] = 0, a[ 12 ] = - h, a[ 1 ] = 0, a[ 5 ] = 2 * c, a[ 9 ] = 0, a[ 13 ] = - u, a[ 2 ] = 0, a[ 6 ] = 0, a[ 10 ] = - 2 * l, a[ 14 ] = - d, a[ 3 ] = 0, a[ 7 ] = 0, a[ 11 ] = 0, a[ 15 ] = 1, this;

	}equals( e ) {

		const t = this.elements, n = e.elements; for ( let e = 0; e < 16; e ++ ) if ( t[ e ] !== n[ e ] ) return ! 1; return ! 0;

	}fromArray( e, t = 0 ) {

		for ( let n = 0; n < 16; n ++ ) this.elements[ n ] = e[ n + t ]; return this;

	}toArray( e = [], t = 0 ) {

		const n = this.elements; return e[ t ] = n[ 0 ], e[ t + 1 ] = n[ 1 ], e[ t + 2 ] = n[ 2 ], e[ t + 3 ] = n[ 3 ], e[ t + 4 ] = n[ 4 ], e[ t + 5 ] = n[ 5 ], e[ t + 6 ] = n[ 6 ], e[ t + 7 ] = n[ 7 ], e[ t + 8 ] = n[ 8 ], e[ t + 9 ] = n[ 9 ], e[ t + 10 ] = n[ 10 ], e[ t + 11 ] = n[ 11 ], e[ t + 12 ] = n[ 12 ], e[ t + 13 ] = n[ 13 ], e[ t + 14 ] = n[ 14 ], e[ t + 15 ] = n[ 15 ], e;

	}

} const _v1$1 = new Vector3(), _m1 = new Matrix4(), _zero = new Vector3( 0, 0, 0 ), _one = new Vector3( 1, 1, 1 ), _x = new Vector3(), _y = new Vector3(), _z = new Vector3(); class Euler {

	constructor( e = 0, t = 0, n = 0, r = Euler.DefaultOrder ) {

		Object.defineProperty( this, 'isEuler', { value: ! 0 } ), this._x = e, this._y = t, this._z = n, this._order = r;

	} get x() {

		return this._x;

	} set x( e ) {

		this._x = e, this._onChangeCallback();

	} get y() {

		return this._y;

	} set y( e ) {

		this._y = e, this._onChangeCallback();

	} get z() {

		return this._z;

	} set z( e ) {

		this._z = e, this._onChangeCallback();

	} get order() {

		return this._order;

	} set order( e ) {

		this._order = e, this._onChangeCallback();

	}set( e, t, n, r ) {

		return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this;

	}clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}copy( e ) {

		return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;

	}setFromRotationMatrix( e, t, n ) {

		const r = MathUtils.clamp, i = e.elements, o = i[ 0 ], a = i[ 4 ], s = i[ 8 ], c = i[ 1 ], l = i[ 5 ], h = i[ 9 ], u = i[ 2 ], d = i[ 6 ], p = i[ 10 ]; switch ( t = t || this._order ) {

			case 'XYZ':this._y = Math.asin( r( s, - 1, 1 ) ), Math.abs( s ) < .9999999 ? ( this._x = Math.atan2( - h, p ), this._z = Math.atan2( - a, o ) ) : ( this._x = Math.atan2( d, l ), this._z = 0 ); break; case 'YXZ':this._x = Math.asin( - r( h, - 1, 1 ) ), Math.abs( h ) < .9999999 ? ( this._y = Math.atan2( s, p ), this._z = Math.atan2( c, l ) ) : ( this._y = Math.atan2( - u, o ), this._z = 0 ); break; case 'ZXY':this._x = Math.asin( r( d, - 1, 1 ) ), Math.abs( d ) < .9999999 ? ( this._y = Math.atan2( - u, p ), this._z = Math.atan2( - a, l ) ) : ( this._y = 0, this._z = Math.atan2( c, o ) ); break; case 'ZYX':this._y = Math.asin( - r( u, - 1, 1 ) ), Math.abs( u ) < .9999999 ? ( this._x = Math.atan2( d, p ), this._z = Math.atan2( c, o ) ) : ( this._x = 0, this._z = Math.atan2( - a, l ) ); break; case 'YZX':this._z = Math.asin( r( c, - 1, 1 ) ), Math.abs( c ) < .9999999 ? ( this._x = Math.atan2( - h, l ), this._y = Math.atan2( - u, o ) ) : ( this._x = 0, this._y = Math.atan2( s, p ) ); break; case 'XZY':this._z = Math.asin( - r( a, - 1, 1 ) ), Math.abs( a ) < .9999999 ? ( this._x = Math.atan2( d, l ), this._y = Math.atan2( s, o ) ) : ( this._x = Math.atan2( - h, p ), this._y = 0 ); break; default:console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t );

		}

		return this._order = t, ! 1 !== n && this._onChangeCallback(), this;

	}setFromQuaternion( e, t, n ) {

		return _matrix.makeRotationFromQuaternion( e ), this.setFromRotationMatrix( _matrix, t, n );

	}setFromVector3( e, t ) {

		return this.set( e.x, e.y, e.z, t || this._order );

	}reorder( e ) {

		return _quaternion$1.setFromEuler( this ), this.setFromQuaternion( _quaternion$1, e );

	}equals( e ) {

		return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;

	}fromArray( e ) {

		return this._x = e[ 0 ], this._y = e[ 1 ], this._z = e[ 2 ], void 0 !== e[ 3 ] && ( this._order = e[ 3 ] ), this._onChangeCallback(), this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this._x, e[ t + 1 ] = this._y, e[ t + 2 ] = this._z, e[ t + 3 ] = this._order, e;

	}toVector3( e ) {

		return e ? e.set( this._x, this._y, this._z ) : new Vector3( this._x, this._y, this._z );

	}_onChange( e ) {

		return this._onChangeCallback = e, this;

	}_onChangeCallback() {}

}Euler.DefaultOrder = 'XYZ', Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ]; const _matrix = new Matrix4(), _quaternion$1 = new Quaternion(); class Layers {

	constructor() {

		this.mask = 1;

	}set( e ) {

		this.mask = 1 << e | 0;

	}enable( e ) {

		this.mask |= 1 << e | 0;

	}enableAll() {

		this.mask = - 1;

	}toggle( e ) {

		this.mask ^= 1 << e | 0;

	}disable( e ) {

		this.mask &= ~ ( 1 << e | 0 );

	}disableAll() {

		this.mask = 0;

	}test( e ) {

		return 0 != ( this.mask & e.mask );

	}

} let _object3DId = 0; const _v1$2 = new Vector3(), _q1 = new Quaternion(), _m1$1 = new Matrix4(), _target = new Vector3(), _position = new Vector3(), _scale = new Vector3(), _quaternion$2 = new Quaternion(), _xAxis = new Vector3( 1, 0, 0 ), _yAxis = new Vector3( 0, 1, 0 ), _zAxis = new Vector3( 0, 0, 1 ), _addedEvent = { type: 'added' }, _removedEvent = { type: 'removed' }; function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } ), this.uuid = MathUtils.generateUUID(), this.name = '', this.type = 'Object3D', this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone(); const e = new Vector3(), t = new Euler(), n = new Quaternion(), r = new Vector3( 1, 1, 1 ); t._onChange( function () {

		n.setFromEuler( t, ! 1 );

	} ), n._onChange( function () {

		t.setFromQuaternion( n, void 0, ! 1 );

	} ), Object.defineProperties( this, { position: { configurable: ! 0, enumerable: ! 0, value: e }, rotation: { configurable: ! 0, enumerable: ! 0, value: t }, quaternion: { configurable: ! 0, enumerable: ! 0, value: n }, scale: { configurable: ! 0, enumerable: ! 0, value: r }, modelViewMatrix: { value: new Matrix4() }, normalMatrix: { value: new Matrix3() } } ), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = ! 1, this.layers = new Layers(), this.visible = ! 0, this.castShadow = ! 1, this.receiveShadow = ! 1, this.frustumCulled = ! 0, this.renderOrder = 0, this.animations = [], this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 ), Object3D.DefaultMatrixAutoUpdate = ! 0, Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Object3D, isObject3D: ! 0, onBeforeRender: function () {}, onAfterRender: function () {}, applyMatrix4: function ( e ) {

	this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply( e ), this.matrix.decompose( this.position, this.quaternion, this.scale );

}, applyQuaternion: function ( e ) {

	return this.quaternion.premultiply( e ), this;

}, setRotationFromAxisAngle: function ( e, t ) {

	this.quaternion.setFromAxisAngle( e, t );

}, setRotationFromEuler: function ( e ) {

	this.quaternion.setFromEuler( e, ! 0 );

}, setRotationFromMatrix: function ( e ) {

	this.quaternion.setFromRotationMatrix( e );

}, setRotationFromQuaternion: function ( e ) {

	this.quaternion.copy( e );

}, rotateOnAxis: function ( e, t ) {

	return _q1.setFromAxisAngle( e, t ), this.quaternion.multiply( _q1 ), this;

}, rotateOnWorldAxis: function ( e, t ) {

	return _q1.setFromAxisAngle( e, t ), this.quaternion.premultiply( _q1 ), this;

}, rotateX: function ( e ) {

	return this.rotateOnAxis( _xAxis, e );

}, rotateY: function ( e ) {

	return this.rotateOnAxis( _yAxis, e );

}, rotateZ: function ( e ) {

	return this.rotateOnAxis( _zAxis, e );

}, translateOnAxis: function ( e, t ) {

	return _v1$2.copy( e ).applyQuaternion( this.quaternion ), this.position.add( _v1$2.multiplyScalar( t ) ), this;

}, translateX: function ( e ) {

	return this.translateOnAxis( _xAxis, e );

}, translateY: function ( e ) {

	return this.translateOnAxis( _yAxis, e );

}, translateZ: function ( e ) {

	return this.translateOnAxis( _zAxis, e );

}, localToWorld: function ( e ) {

	return e.applyMatrix4( this.matrixWorld );

}, worldToLocal: function ( e ) {

	return e.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

}, lookAt: function ( e, t, n ) {

	e.isVector3 ? _target.copy( e ) : _target.set( e, t, n ); const r = this.parent; this.updateWorldMatrix( ! 0, ! 1 ), _position.setFromMatrixPosition( this.matrixWorld ), this.isCamera || this.isLight ? _m1$1.lookAt( _position, _target, this.up ) : _m1$1.lookAt( _target, _position, this.up ), this.quaternion.setFromRotationMatrix( _m1$1 ), r && ( _m1$1.extractRotation( r.matrixWorld ), _q1.setFromRotationMatrix( _m1$1 ), this.quaternion.premultiply( _q1.invert() ) );

}, add: function ( e ) {

	if ( arguments.length > 1 ) {

		for ( let e = 0; e < arguments.length; e ++ ) this.add( arguments[ e ] ); return this;

	}

	return e === this ? ( console.error( "THREE.Object3D.add: object can't be added as a child of itself.", e ), this ) : ( e && e.isObject3D ? ( null !== e.parent && e.parent.remove( e ), e.parent = this, this.children.push( e ), e.dispatchEvent( _addedEvent ) ) : console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', e ), this );

}, remove: function ( e ) {

	if ( arguments.length > 1 ) {

		for ( let e = 0; e < arguments.length; e ++ ) this.remove( arguments[ e ] ); return this;

	}

	const t = this.children.indexOf( e ); return - 1 !== t && ( e.parent = null, this.children.splice( t, 1 ), e.dispatchEvent( _removedEvent ) ), this;

}, clear: function () {

	for ( let e = 0; e < this.children.length; e ++ ) {

		const t = this.children[ e ]; t.parent = null, t.dispatchEvent( _removedEvent );

	}

	return this.children.length = 0, this;

}, attach: function ( e ) {

	return this.updateWorldMatrix( ! 0, ! 1 ), _m1$1.copy( this.matrixWorld ).invert(), null !== e.parent && ( e.parent.updateWorldMatrix( ! 0, ! 1 ), _m1$1.multiply( e.parent.matrixWorld ) ), e.applyMatrix4( _m1$1 ), e.updateWorldMatrix( ! 1, ! 1 ), this.add( e ), this;

}, getObjectById: function ( e ) {

	return this.getObjectByProperty( 'id', e );

}, getObjectByName: function ( e ) {

	return this.getObjectByProperty( 'name', e );

}, getObjectByProperty: function ( e, t ) {

	if ( this[ e ] === t ) return this; for ( let n = 0, r = this.children.length; n < r; n ++ ) {

		const r = this.children[ n ].getObjectByProperty( e, t ); if ( void 0 !== r ) return r;

	}

}, getWorldPosition: function ( e ) {

	return void 0 === e && ( console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' ), e = new Vector3() ), this.updateWorldMatrix( ! 0, ! 1 ), e.setFromMatrixPosition( this.matrixWorld );

}, getWorldQuaternion: function ( e ) {

	return void 0 === e && ( console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' ), e = new Quaternion() ), this.updateWorldMatrix( ! 0, ! 1 ), this.matrixWorld.decompose( _position, e, _scale ), e;

}, getWorldScale: function ( e ) {

	return void 0 === e && ( console.warn( 'THREE.Object3D: .getWorldScale() target is now required' ), e = new Vector3() ), this.updateWorldMatrix( ! 0, ! 1 ), this.matrixWorld.decompose( _position, _quaternion$2, e ), e;

}, getWorldDirection: function ( e ) {

	void 0 === e && ( console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' ), e = new Vector3() ), this.updateWorldMatrix( ! 0, ! 1 ); const t = this.matrixWorld.elements; return e.set( t[ 8 ], t[ 9 ], t[ 10 ] ).normalize();

}, raycast: function () {}, traverse: function ( e ) {

	e( this ); const t = this.children; for ( let n = 0, r = t.length; n < r; n ++ )t[ n ].traverse( e );

}, traverseVisible: function ( e ) {

	if ( ! 1 === this.visible ) return; e( this ); const t = this.children; for ( let n = 0, r = t.length; n < r; n ++ )t[ n ].traverseVisible( e );

}, traverseAncestors: function ( e ) {

	const t = this.parent; null !== t && ( e( t ), t.traverseAncestors( e ) );

}, updateMatrix: function () {

	this.matrix.compose( this.position, this.quaternion, this.scale ), this.matrixWorldNeedsUpdate = ! 0;

}, updateMatrixWorld: function ( e ) {

	this.matrixAutoUpdate && this.updateMatrix(), ( this.matrixWorldNeedsUpdate || e ) && ( null === this.parent ? this.matrixWorld.copy( this.matrix ) : this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix ), this.matrixWorldNeedsUpdate = ! 1, e = ! 0 ); const t = this.children; for ( let n = 0, r = t.length; n < r; n ++ )t[ n ].updateMatrixWorld( e );

}, updateWorldMatrix: function ( e, t ) {

	const n = this.parent; if ( ! 0 === e && null !== n && n.updateWorldMatrix( ! 0, ! 1 ), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy( this.matrix ) : this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix ), ! 0 === t ) {

		const e = this.children; for ( let t = 0, n = e.length; t < n; t ++ )e[ t ].updateWorldMatrix( ! 1, ! 0 );

	}

}, toJSON: function ( e ) {

	const t = void 0 === e || 'string' == typeof e, n = {}; t && ( e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' } ); const r = {}; function i( t, n ) {

		return void 0 === t[ n.uuid ] && ( t[ n.uuid ] = n.toJSON( e ) ), n.uuid;

	}

	if ( r.uuid = this.uuid, r.type = this.type, '' !== this.name && ( r.name = this.name ), ! 0 === this.castShadow && ( r.castShadow = ! 0 ), ! 0 === this.receiveShadow && ( r.receiveShadow = ! 0 ), ! 1 === this.visible && ( r.visible = ! 1 ), ! 1 === this.frustumCulled && ( r.frustumCulled = ! 1 ), 0 !== this.renderOrder && ( r.renderOrder = this.renderOrder ), '{}' !== JSON.stringify( this.userData ) && ( r.userData = this.userData ), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), ! 1 === this.matrixAutoUpdate && ( r.matrixAutoUpdate = ! 1 ), this.isInstancedMesh && ( r.type = 'InstancedMesh', r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON() ), this.isMesh || this.isLine || this.isPoints ) {

		r.geometry = i( e.geometries, this.geometry ); const t = this.geometry.parameters; if ( void 0 !== t && void 0 !== t.shapes ) {

			const n = t.shapes; if ( Array.isArray( n ) ) for ( let t = 0, r = n.length; t < r; t ++ ) {

				const r = n[ t ]; i( e.shapes, r );

			} else i( e.shapes, n );

		}

	}

	if ( this.isSkinnedMesh && ( r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && ( i( e.skeletons, this.skeleton ), r.skeleton = this.skeleton.uuid ) ), void 0 !== this.material ) if ( Array.isArray( this.material ) ) {

		const t = []; for ( let n = 0, r = this.material.length; n < r; n ++ )t.push( i( e.materials, this.material[ n ] ) ); r.material = t;

	} else r.material = i( e.materials, this.material ); if ( this.children.length > 0 ) {

		r.children = []; for ( let t = 0; t < this.children.length; t ++ )r.children.push( this.children[ t ].toJSON( e ).object );

	}

	if ( this.animations.length > 0 ) {

		r.animations = []; for ( let t = 0; t < this.animations.length; t ++ ) {

			const n = this.animations[ t ]; r.animations.push( i( e.animations, n ) );

		}

	}

	if ( t ) {

		const t = o( e.geometries ), r = o( e.materials ), i = o( e.textures ), a = o( e.images ), s = o( e.shapes ), c = o( e.skeletons ), l = o( e.animations ); t.length > 0 && ( n.geometries = t ), r.length > 0 && ( n.materials = r ), i.length > 0 && ( n.textures = i ), a.length > 0 && ( n.images = a ), s.length > 0 && ( n.shapes = s ), c.length > 0 && ( n.skeletons = c ), l.length > 0 && ( n.animations = l );

	}

	return n.object = r, n; function o( e ) {

		const t = []; for ( const n in e ) {

			const r = e[ n ]; delete r.metadata, t.push( r );

		}

		return t;

	}

}, clone: function ( e ) {

	return ( new this.constructor() ).copy( this, e );

}, copy: function ( e, t = ! 0 ) {

	if ( this.name = e.name, this.up.copy( e.up ), this.position.copy( e.position ), this.rotation.order = e.rotation.order, this.quaternion.copy( e.quaternion ), this.scale.copy( e.scale ), this.matrix.copy( e.matrix ), this.matrixWorld.copy( e.matrixWorld ), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse( JSON.stringify( e.userData ) ), ! 0 === t ) for ( let t = 0; t < e.children.length; t ++ ) {

		const n = e.children[ t ]; this.add( n.clone() );

	}

	return this;

} } ); const _vector1 = new Vector3(), _vector2 = new Vector3(), _normalMatrix = new Matrix3(); class Plane {

	constructor( e, t ) {

		Object.defineProperty( this, 'isPlane', { value: ! 0 } ), this.normal = void 0 !== e ? e : new Vector3( 1, 0, 0 ), this.constant = void 0 !== t ? t : 0;

	}set( e, t ) {

		return this.normal.copy( e ), this.constant = t, this;

	}setComponents( e, t, n, r ) {

		return this.normal.set( e, t, n ), this.constant = r, this;

	}setFromNormalAndCoplanarPoint( e, t ) {

		return this.normal.copy( e ), this.constant = - t.dot( this.normal ), this;

	}setFromCoplanarPoints( e, t, n ) {

		const r = _vector1.subVectors( n, t ).cross( _vector2.subVectors( e, t ) ).normalize(); return this.setFromNormalAndCoplanarPoint( r, e ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.normal.copy( e.normal ), this.constant = e.constant, this;

	}normalize() {

		const e = 1 / this.normal.length(); return this.normal.multiplyScalar( e ), this.constant *= e, this;

	}negate() {

		return this.constant *= - 1, this.normal.negate(), this;

	}distanceToPoint( e ) {

		return this.normal.dot( e ) + this.constant;

	}distanceToSphere( e ) {

		return this.distanceToPoint( e.center ) - e.radius;

	}projectPoint( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Plane: .projectPoint() target is now required' ), t = new Vector3() ), t.copy( this.normal ).multiplyScalar( - this.distanceToPoint( e ) ).add( e );

	}intersectLine( e, t ) {

		void 0 === t && ( console.warn( 'THREE.Plane: .intersectLine() target is now required' ), t = new Vector3() ); const n = e.delta( _vector1 ), r = this.normal.dot( n ); if ( 0 === r ) return 0 === this.distanceToPoint( e.start ) ? t.copy( e.start ) : void 0; const i = - ( e.start.dot( this.normal ) + this.constant ) / r; return i < 0 || i > 1 ? void 0 : t.copy( n ).multiplyScalar( i ).add( e.start );

	}intersectsLine( e ) {

		const t = this.distanceToPoint( e.start ), n = this.distanceToPoint( e.end ); return t < 0 && n > 0 || n < 0 && t > 0;

	}intersectsBox( e ) {

		return e.intersectsPlane( this );

	}intersectsSphere( e ) {

		return e.intersectsPlane( this );

	}coplanarPoint( e ) {

		return void 0 === e && ( console.warn( 'THREE.Plane: .coplanarPoint() target is now required' ), e = new Vector3() ), e.copy( this.normal ).multiplyScalar( - this.constant );

	}applyMatrix4( e, t ) {

		const n = t || _normalMatrix.getNormalMatrix( e ), r = this.coplanarPoint( _vector1 ).applyMatrix4( e ), i = this.normal.applyMatrix3( n ).normalize(); return this.constant = - r.dot( i ), this;

	}translate( e ) {

		return this.constant -= e.dot( this.normal ), this;

	}equals( e ) {

		return e.normal.equals( this.normal ) && e.constant === this.constant;

	}

} const _v0$1 = new Vector3(), _v1$3 = new Vector3(), _v2$1 = new Vector3(), _v3 = new Vector3(), _vab = new Vector3(), _vac = new Vector3(), _vbc = new Vector3(), _vap = new Vector3(), _vbp = new Vector3(), _vcp = new Vector3(); class Triangle {

	constructor( e, t, n ) {

		this.a = void 0 !== e ? e : new Vector3(), this.b = void 0 !== t ? t : new Vector3(), this.c = void 0 !== n ? n : new Vector3();

	} static getNormal( e, t, n, r ) {

		void 0 === r && ( console.warn( 'THREE.Triangle: .getNormal() target is now required' ), r = new Vector3() ), r.subVectors( n, t ), _v0$1.subVectors( e, t ), r.cross( _v0$1 ); const i = r.lengthSq(); return i > 0 ? r.multiplyScalar( 1 / Math.sqrt( i ) ) : r.set( 0, 0, 0 );

	} static getBarycoord( e, t, n, r, i ) {

		_v0$1.subVectors( r, t ), _v1$3.subVectors( n, t ), _v2$1.subVectors( e, t ); const o = _v0$1.dot( _v0$1 ), a = _v0$1.dot( _v1$3 ), s = _v0$1.dot( _v2$1 ), c = _v1$3.dot( _v1$3 ), l = _v1$3.dot( _v2$1 ), h = o * c - a * a; if ( void 0 === i && ( console.warn( 'THREE.Triangle: .getBarycoord() target is now required' ), i = new Vector3() ), 0 === h ) return i.set( - 2, - 1, - 1 ); const u = 1 / h, d = ( c * s - a * l ) * u, p = ( o * l - a * s ) * u; return i.set( 1 - d - p, p, d );

	} static containsPoint( e, t, n, r ) {

		return this.getBarycoord( e, t, n, r, _v3 ), _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;

	} static getUV( e, t, n, r, i, o, a, s ) {

		return this.getBarycoord( e, t, n, r, _v3 ), s.set( 0, 0 ), s.addScaledVector( i, _v3.x ), s.addScaledVector( o, _v3.y ), s.addScaledVector( a, _v3.z ), s;

	} static isFrontFacing( e, t, n, r ) {

		return _v0$1.subVectors( n, t ), _v1$3.subVectors( e, t ), _v0$1.cross( _v1$3 ).dot( r ) < 0;

	}set( e, t, n ) {

		return this.a.copy( e ), this.b.copy( t ), this.c.copy( n ), this;

	}setFromPointsAndIndices( e, t, n, r ) {

		return this.a.copy( e[ t ] ), this.b.copy( e[ n ] ), this.c.copy( e[ r ] ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.a.copy( e.a ), this.b.copy( e.b ), this.c.copy( e.c ), this;

	}getArea() {

		return _v0$1.subVectors( this.c, this.b ), _v1$3.subVectors( this.a, this.b ), .5 * _v0$1.cross( _v1$3 ).length();

	}getMidpoint( e ) {

		return void 0 === e && ( console.warn( 'THREE.Triangle: .getMidpoint() target is now required' ), e = new Vector3() ), e.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}getNormal( e ) {

		return Triangle.getNormal( this.a, this.b, this.c, e );

	}getPlane( e ) {

		return void 0 === e && ( console.warn( 'THREE.Triangle: .getPlane() target is now required' ), e = new Plane() ), e.setFromCoplanarPoints( this.a, this.b, this.c );

	}getBarycoord( e, t ) {

		return Triangle.getBarycoord( e, this.a, this.b, this.c, t );

	}getUV( e, t, n, r, i ) {

		return Triangle.getUV( e, this.a, this.b, this.c, t, n, r, i );

	}containsPoint( e ) {

		return Triangle.containsPoint( e, this.a, this.b, this.c );

	}isFrontFacing( e ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, e );

	}intersectsBox( e ) {

		return e.intersectsTriangle( this );

	}closestPointToPoint( e, t ) {

		void 0 === t && ( console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' ), t = new Vector3() ); const n = this.a, r = this.b, i = this.c; let o, a; _vab.subVectors( r, n ), _vac.subVectors( i, n ), _vap.subVectors( e, n ); const s = _vab.dot( _vap ), c = _vac.dot( _vap ); if ( s <= 0 && c <= 0 ) return t.copy( n ); _vbp.subVectors( e, r ); const l = _vab.dot( _vbp ), h = _vac.dot( _vbp ); if ( l >= 0 && h <= l ) return t.copy( r ); const u = s * h - l * c; if ( u <= 0 && s >= 0 && l <= 0 ) return o = s / ( s - l ), t.copy( n ).addScaledVector( _vab, o ); _vcp.subVectors( e, i ); const d = _vab.dot( _vcp ), p = _vac.dot( _vcp ); if ( p >= 0 && d <= p ) return t.copy( i ); const m = d * c - s * p; if ( m <= 0 && c >= 0 && p <= 0 ) return a = c / ( c - p ), t.copy( n ).addScaledVector( _vac, a ); const f = l * p - d * h; if ( f <= 0 && h - l >= 0 && d - p >= 0 ) return _vbc.subVectors( i, r ), a = ( h - l ) / ( h - l + ( d - p ) ), t.copy( r ).addScaledVector( _vbc, a ); const g = 1 / ( f + m + u ); return o = m * g, a = u * g, t.copy( n ).addScaledVector( _vab, o ).addScaledVector( _vac, a );

	}equals( e ) {

		return e.a.equals( this.a ) && e.b.equals( this.b ) && e.c.equals( this.c );

	}

} const _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 }; function hue2rgb( e, t, n ) {

	return n < 0 && ( n += 1 ), n > 1 && ( n -= 1 ), n < 1 / 6 ? e + 6 * ( t - e ) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * ( t - e ) * ( 2 / 3 - n ) : e;

}

function SRGBToLinear( e ) {

	return e < .04045 ? .0773993808 * e : Math.pow( .9478672986 * e + .0521327014, 2.4 );

}

function LinearToSRGB( e ) {

	return e < .0031308 ? 12.92 * e : 1.055 * Math.pow( e, .41666 ) - .055;

}

class Color {

	constructor( e, t, n ) {

		return Object.defineProperty( this, 'isColor', { value: ! 0 } ), void 0 === t && void 0 === n ? this.set( e ) : this.setRGB( e, t, n );

	}set( e ) {

		return e && e.isColor ? this.copy( e ) : 'number' == typeof e ? this.setHex( e ) : 'string' == typeof e && this.setStyle( e ), this;

	}setScalar( e ) {

		return this.r = e, this.g = e, this.b = e, this;

	}setHex( e ) {

		return e = Math.floor( e ), this.r = ( e >> 16 & 255 ) / 255, this.g = ( e >> 8 & 255 ) / 255, this.b = ( 255 & e ) / 255, this;

	}setRGB( e, t, n ) {

		return this.r = e, this.g = t, this.b = n, this;

	}setHSL( e, t, n ) {

		if ( e = MathUtils.euclideanModulo( e, 1 ), t = MathUtils.clamp( t, 0, 1 ), n = MathUtils.clamp( n, 0, 1 ), 0 === t ) this.r = this.g = this.b = n; else {

			const r = n <= .5 ? n * ( 1 + t ) : n + t - n * t, i = 2 * n - r; this.r = hue2rgb( i, r, e + 1 / 3 ), this.g = hue2rgb( i, r, e ), this.b = hue2rgb( i, r, e - 1 / 3 );

		}

		return this;

	}setStyle( e ) {

		function t( t ) {

			void 0 !== t && parseFloat( t ) < 1 && console.warn( 'THREE.Color: Alpha component of ' + e + ' will be ignored.' );

		}

		let n; if ( n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( e ) ) {

			let e; const r = n[ 1 ], i = n[ 2 ]; switch ( r ) {

				case 'rgb':case 'rgba':if ( e = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( i ) ) return this.r = Math.min( 255, parseInt( e[ 1 ], 10 ) ) / 255, this.g = Math.min( 255, parseInt( e[ 2 ], 10 ) ) / 255, this.b = Math.min( 255, parseInt( e[ 3 ], 10 ) ) / 255, t( e[ 4 ] ), this; if ( e = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( i ) ) return this.r = Math.min( 100, parseInt( e[ 1 ], 10 ) ) / 100, this.g = Math.min( 100, parseInt( e[ 2 ], 10 ) ) / 100, this.b = Math.min( 100, parseInt( e[ 3 ], 10 ) ) / 100, t( e[ 4 ] ), this; break; case 'hsl':case 'hsla':if ( e = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( i ) ) {

					const n = parseFloat( e[ 1 ] ) / 360, r = parseInt( e[ 2 ], 10 ) / 100, i = parseInt( e[ 3 ], 10 ) / 100; return t( e[ 4 ] ), this.setHSL( n, r, i );

				}

			}

		} else if ( n = /^\#([A-Fa-f\d]+)$/.exec( e ) ) {

			const e = n[ 1 ], t = e.length; if ( 3 === t ) return this.r = parseInt( e.charAt( 0 ) + e.charAt( 0 ), 16 ) / 255, this.g = parseInt( e.charAt( 1 ) + e.charAt( 1 ), 16 ) / 255, this.b = parseInt( e.charAt( 2 ) + e.charAt( 2 ), 16 ) / 255, this; if ( 6 === t ) return this.r = parseInt( e.charAt( 0 ) + e.charAt( 1 ), 16 ) / 255, this.g = parseInt( e.charAt( 2 ) + e.charAt( 3 ), 16 ) / 255, this.b = parseInt( e.charAt( 4 ) + e.charAt( 5 ), 16 ) / 255, this;

		}

		return e && e.length > 0 ? this.setColorName( e ) : this;

	}setColorName( e ) {

		const t = _colorKeywords[ e ]; return void 0 !== t ? this.setHex( t ) : console.warn( 'THREE.Color: Unknown color ' + e ), this;

	}clone() {

		return new this.constructor( this.r, this.g, this.b );

	}copy( e ) {

		return this.r = e.r, this.g = e.g, this.b = e.b, this;

	}copyGammaToLinear( e, t = 2 ) {

		return this.r = Math.pow( e.r, t ), this.g = Math.pow( e.g, t ), this.b = Math.pow( e.b, t ), this;

	}copyLinearToGamma( e, t = 2 ) {

		const n = t > 0 ? 1 / t : 1; return this.r = Math.pow( e.r, n ), this.g = Math.pow( e.g, n ), this.b = Math.pow( e.b, n ), this;

	}convertGammaToLinear( e ) {

		return this.copyGammaToLinear( this, e ), this;

	}convertLinearToGamma( e ) {

		return this.copyLinearToGamma( this, e ), this;

	}copySRGBToLinear( e ) {

		return this.r = SRGBToLinear( e.r ), this.g = SRGBToLinear( e.g ), this.b = SRGBToLinear( e.b ), this;

	}copyLinearToSRGB( e ) {

		return this.r = LinearToSRGB( e.r ), this.g = LinearToSRGB( e.g ), this.b = LinearToSRGB( e.b ), this;

	}convertSRGBToLinear() {

		return this.copySRGBToLinear( this ), this;

	}convertLinearToSRGB() {

		return this.copyLinearToSRGB( this ), this;

	}getHex() {

		return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;

	}getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}getHSL( e ) {

		void 0 === e && ( console.warn( 'THREE.Color: .getHSL() target is now required' ), e = { h: 0, s: 0, l: 0 } ); const t = this.r, n = this.g, r = this.b, i = Math.max( t, n, r ), o = Math.min( t, n, r ); let a, s; const c = ( o + i ) / 2; if ( o === i )a = 0, s = 0; else {

			const e = i - o; switch ( s = c <= .5 ? e / ( i + o ) : e / ( 2 - i - o ), i ) {

				case t:a = ( n - r ) / e + ( n < r ? 6 : 0 ); break; case n:a = ( r - t ) / e + 2; break; case r:a = ( t - n ) / e + 4;

			}

			a /= 6;

		}

		return e.h = a, e.s = s, e.l = c, e;

	}getStyle() {

		return 'rgb(' + ( 255 * this.r | 0 ) + ',' + ( 255 * this.g | 0 ) + ',' + ( 255 * this.b | 0 ) + ')';

	}offsetHSL( e, t, n ) {

		return this.getHSL( _hslA ), _hslA.h += e, _hslA.s += t, _hslA.l += n, this.setHSL( _hslA.h, _hslA.s, _hslA.l ), this;

	}add( e ) {

		return this.r += e.r, this.g += e.g, this.b += e.b, this;

	}addColors( e, t ) {

		return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;

	}addScalar( e ) {

		return this.r += e, this.g += e, this.b += e, this;

	}sub( e ) {

		return this.r = Math.max( 0, this.r - e.r ), this.g = Math.max( 0, this.g - e.g ), this.b = Math.max( 0, this.b - e.b ), this;

	}multiply( e ) {

		return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;

	}multiplyScalar( e ) {

		return this.r *= e, this.g *= e, this.b *= e, this;

	}lerp( e, t ) {

		return this.r += ( e.r - this.r ) * t, this.g += ( e.g - this.g ) * t, this.b += ( e.b - this.b ) * t, this;

	}lerpHSL( e, t ) {

		this.getHSL( _hslA ), e.getHSL( _hslB ); const n = MathUtils.lerp( _hslA.h, _hslB.h, t ), r = MathUtils.lerp( _hslA.s, _hslB.s, t ), i = MathUtils.lerp( _hslA.l, _hslB.l, t ); return this.setHSL( n, r, i ), this;

	}equals( e ) {

		return e.r === this.r && e.g === this.g && e.b === this.b;

	}fromArray( e, t = 0 ) {

		return this.r = e[ t ], this.g = e[ t + 1 ], this.b = e[ t + 2 ], this;

	}toArray( e = [], t = 0 ) {

		return e[ t ] = this.r, e[ t + 1 ] = this.g, e[ t + 2 ] = this.b, e;

	}fromBufferAttribute( e, t ) {

		return this.r = e.getX( t ), this.g = e.getY( t ), this.b = e.getZ( t ), ! 0 === e.normalized && ( this.r /= 255, this.g /= 255, this.b /= 255 ), this;

	}toJSON() {

		return this.getHex();

	}

}Color.NAMES = _colorKeywords, Color.prototype.r = 1, Color.prototype.g = 1, Color.prototype.b = 1; class Face3 {

	constructor( e, t, n, r, i, o = 0 ) {

		this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Vector3(), this.vertexNormals = Array.isArray( r ) ? r : [], this.color = i && i.isColor ? i : new Color(), this.vertexColors = Array.isArray( i ) ? i : [], this.materialIndex = o;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy( e.normal ), this.color.copy( e.color ), this.materialIndex = e.materialIndex; for ( let t = 0, n = e.vertexNormals.length; t < n; t ++ ) this.vertexNormals[ t ] = e.vertexNormals[ t ].clone(); for ( let t = 0, n = e.vertexColors.length; t < n; t ++ ) this.vertexColors[ t ] = e.vertexColors[ t ].clone(); return this;

	}

} let materialId = 0; function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } ), this.uuid = MathUtils.generateUUID(), this.name = '', this.type = 'Material', this.fog = ! 0, this.blending = NormalBlending, this.side = FrontSide, this.flatShading = ! 1, this.vertexColors = ! 1, this.opacity = 1, this.transparent = ! 1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = ! 0, this.depthWrite = ! 0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = ! 1, this.clippingPlanes = null, this.clipIntersection = ! 1, this.clipShadows = ! 1, this.shadowSide = null, this.colorWrite = ! 0, this.precision = null, this.polygonOffset = ! 1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = ! 1, this.alphaTest = 0, this.premultipliedAlpha = ! 1, this.visible = ! 0, this.toneMapped = ! 0, this.userData = {}, this.version = 0;

}

function MeshBasicMaterial( e ) {

	Material.call( this ), this.type = 'MeshBasicMaterial', this.color = new Color( 16777215 ), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.skinning = ! 1, this.morphTargets = ! 1, this.setValues( e );

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Material, isMaterial: ! 0, onBeforeCompile: function () {}, customProgramCacheKey: function () {

	return this.onBeforeCompile.toString();

}, setValues: function ( e ) {

	if ( void 0 !== e ) for ( const t in e ) {

		const n = e[ t ]; if ( void 0 === n ) {

			console.warn( "THREE.Material: '" + t + "' parameter is undefined." ); continue;

		}

		if ( 'shading' === t ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' ), this.flatShading = 1 === n; continue;

		}

		const r = this[ t ]; void 0 !== r ? r && r.isColor ? r.set( n ) : r && r.isVector3 && n && n.isVector3 ? r.copy( n ) : this[ t ] = n : console.warn( 'THREE.' + this.type + ": '" + t + "' is not a property of this material." );

	}

}, toJSON: function ( e ) {

	const t = void 0 === e || 'string' == typeof e; t && ( e = { textures: {}, images: {} } ); const n = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } }; function r( e ) {

		const t = []; for ( const n in e ) {

			const r = e[ n ]; delete r.metadata, t.push( r );

		}

		return t;

	}

	if ( n.uuid = this.uuid, n.type = this.type, '' !== this.name && ( n.name = this.name ), this.color && this.color.isColor && ( n.color = this.color.getHex() ), void 0 !== this.roughness && ( n.roughness = this.roughness ), void 0 !== this.metalness && ( n.metalness = this.metalness ), this.sheen && this.sheen.isColor && ( n.sheen = this.sheen.getHex() ), this.emissive && this.emissive.isColor && ( n.emissive = this.emissive.getHex() ), this.emissiveIntensity && 1 !== this.emissiveIntensity && ( n.emissiveIntensity = this.emissiveIntensity ), this.specular && this.specular.isColor && ( n.specular = this.specular.getHex() ), void 0 !== this.shininess && ( n.shininess = this.shininess ), void 0 !== this.clearcoat && ( n.clearcoat = this.clearcoat ), void 0 !== this.clearcoatRoughness && ( n.clearcoatRoughness = this.clearcoatRoughness ), this.clearcoatMap && this.clearcoatMap.isTexture && ( n.clearcoatMap = this.clearcoatMap.toJSON( e ).uuid ), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && ( n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( e ).uuid ), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && ( n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( e ).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray() ), this.map && this.map.isTexture && ( n.map = this.map.toJSON( e ).uuid ), this.matcap && this.matcap.isTexture && ( n.matcap = this.matcap.toJSON( e ).uuid ), this.alphaMap && this.alphaMap.isTexture && ( n.alphaMap = this.alphaMap.toJSON( e ).uuid ), this.lightMap && this.lightMap.isTexture && ( n.lightMap = this.lightMap.toJSON( e ).uuid ), this.aoMap && this.aoMap.isTexture && ( n.aoMap = this.aoMap.toJSON( e ).uuid, n.aoMapIntensity = this.aoMapIntensity ), this.bumpMap && this.bumpMap.isTexture && ( n.bumpMap = this.bumpMap.toJSON( e ).uuid, n.bumpScale = this.bumpScale ), this.normalMap && this.normalMap.isTexture && ( n.normalMap = this.normalMap.toJSON( e ).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray() ), this.displacementMap && this.displacementMap.isTexture && ( n.displacementMap = this.displacementMap.toJSON( e ).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias ), this.roughnessMap && this.roughnessMap.isTexture && ( n.roughnessMap = this.roughnessMap.toJSON( e ).uuid ), this.metalnessMap && this.metalnessMap.isTexture && ( n.metalnessMap = this.metalnessMap.toJSON( e ).uuid ), this.emissiveMap && this.emissiveMap.isTexture && ( n.emissiveMap = this.emissiveMap.toJSON( e ).uuid ), this.specularMap && this.specularMap.isTexture && ( n.specularMap = this.specularMap.toJSON( e ).uuid ), this.envMap && this.envMap.isTexture && ( n.envMap = this.envMap.toJSON( e ).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && ( n.combine = this.combine ), void 0 !== this.envMapIntensity && ( n.envMapIntensity = this.envMapIntensity ) ), this.gradientMap && this.gradientMap.isTexture && ( n.gradientMap = this.gradientMap.toJSON( e ).uuid ), void 0 !== this.size && ( n.size = this.size ), void 0 !== this.sizeAttenuation && ( n.sizeAttenuation = this.sizeAttenuation ), this.blending !== NormalBlending && ( n.blending = this.blending ), ! 0 === this.flatShading && ( n.flatShading = this.flatShading ), this.side !== FrontSide && ( n.side = this.side ), this.vertexColors && ( n.vertexColors = ! 0 ), this.opacity < 1 && ( n.opacity = this.opacity ), ! 0 === this.transparent && ( n.transparent = this.transparent ), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && ( n.rotation = this.rotation ), ! 0 === this.polygonOffset && ( n.polygonOffset = ! 0 ), 0 !== this.polygonOffsetFactor && ( n.polygonOffsetFactor = this.polygonOffsetFactor ), 0 !== this.polygonOffsetUnits && ( n.polygonOffsetUnits = this.polygonOffsetUnits ), this.linewidth && 1 !== this.linewidth && ( n.linewidth = this.linewidth ), void 0 !== this.dashSize && ( n.dashSize = this.dashSize ), void 0 !== this.gapSize && ( n.gapSize = this.gapSize ), void 0 !== this.scale && ( n.scale = this.scale ), ! 0 === this.dithering && ( n.dithering = ! 0 ), this.alphaTest > 0 && ( n.alphaTest = this.alphaTest ), ! 0 === this.premultipliedAlpha && ( n.premultipliedAlpha = this.premultipliedAlpha ), ! 0 === this.wireframe && ( n.wireframe = this.wireframe ), this.wireframeLinewidth > 1 && ( n.wireframeLinewidth = this.wireframeLinewidth ), 'round' !== this.wireframeLinecap && ( n.wireframeLinecap = this.wireframeLinecap ), 'round' !== this.wireframeLinejoin && ( n.wireframeLinejoin = this.wireframeLinejoin ), ! 0 === this.morphTargets && ( n.morphTargets = ! 0 ), ! 0 === this.morphNormals && ( n.morphNormals = ! 0 ), ! 0 === this.skinning && ( n.skinning = ! 0 ), ! 1 === this.visible && ( n.visible = ! 1 ), ! 1 === this.toneMapped && ( n.toneMapped = ! 1 ), '{}' !== JSON.stringify( this.userData ) && ( n.userData = this.userData ), t ) {

		const t = r( e.textures ), i = r( e.images ); t.length > 0 && ( n.textures = t ), i.length > 0 && ( n.images = i );

	}

	return n;

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, copy: function ( e ) {

	this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if ( null !== t ) {

		const e = t.length; n = new Array( e ); for ( let r = 0; r !== e; ++ r )n[ r ] = t[ r ].clone();

	}

	return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse( JSON.stringify( e.userData ) ), this;

}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

} } ), Object.defineProperty( Material.prototype, 'needsUpdate', { set: function ( e ) {

	! 0 === e && this.version ++;

} } ), MeshBasicMaterial.prototype = Object.create( Material.prototype ), MeshBasicMaterial.prototype.constructor = MeshBasicMaterial, MeshBasicMaterial.prototype.isMeshBasicMaterial = ! 0, MeshBasicMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this;

};

const _vector$3 = new Vector3(), _vector2$1 = new Vector2(); function BufferAttribute( e, t, n ) {

	if ( Array.isArray( e ) ) throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' ); this.name = '', this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = ! 0 === n, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: - 1 }, this.version = 0;

}

function Int8BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Int8Array( e ), t, n );

}

function Uint8BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Uint8Array( e ), t, n );

}

function Uint8ClampedBufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Uint8ClampedArray( e ), t, n );

}

function Int16BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Int16Array( e ), t, n );

}

function Uint16BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Uint16Array( e ), t, n );

}

function Int32BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Int32Array( e ), t, n );

}

function Uint32BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Uint32Array( e ), t, n );

}

function Float16BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Uint16Array( e ), t, n );

}

function Float32BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Float32Array( e ), t, n );

}

function Float64BufferAttribute( e, t, n ) {

	BufferAttribute.call( this, new Float64Array( e ), t, n );

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', { set: function ( e ) {

	! 0 === e && this.version ++;

} } ), Object.assign( BufferAttribute.prototype, { isBufferAttribute: ! 0, onUploadCallback: function () {}, setUsage: function ( e ) {

	return this.usage = e, this;

}, copy: function ( e ) {

	return this.name = e.name, this.array = new e.array.constructor( e.array ), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;

}, copyAt: function ( e, t, n ) {

	e *= this.itemSize, n *= t.itemSize; for ( let r = 0, i = this.itemSize; r < i; r ++ ) this.array[ e + r ] = t.array[ n + r ]; return this;

}, copyArray: function ( e ) {

	return this.array.set( e ), this;

}, copyColorsArray: function ( e ) {

	const t = this.array; let n = 0; for ( let r = 0, i = e.length; r < i; r ++ ) {

		let i = e[ r ]; void 0 === i && ( console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', r ), i = new Color() ), t[ n ++ ] = i.r, t[ n ++ ] = i.g, t[ n ++ ] = i.b;

	}

	return this;

}, copyVector2sArray: function ( e ) {

	const t = this.array; let n = 0; for ( let r = 0, i = e.length; r < i; r ++ ) {

		let i = e[ r ]; void 0 === i && ( console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', r ), i = new Vector2() ), t[ n ++ ] = i.x, t[ n ++ ] = i.y;

	}

	return this;

}, copyVector3sArray: function ( e ) {

	const t = this.array; let n = 0; for ( let r = 0, i = e.length; r < i; r ++ ) {

		let i = e[ r ]; void 0 === i && ( console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', r ), i = new Vector3() ), t[ n ++ ] = i.x, t[ n ++ ] = i.y, t[ n ++ ] = i.z;

	}

	return this;

}, copyVector4sArray: function ( e ) {

	const t = this.array; let n = 0; for ( let r = 0, i = e.length; r < i; r ++ ) {

		let i = e[ r ]; void 0 === i && ( console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', r ), i = new Vector4() ), t[ n ++ ] = i.x, t[ n ++ ] = i.y, t[ n ++ ] = i.z, t[ n ++ ] = i.w;

	}

	return this;

}, applyMatrix3: function ( e ) {

	if ( 2 === this.itemSize ) for ( let t = 0, n = this.count; t < n; t ++ )_vector2$1.fromBufferAttribute( this, t ), _vector2$1.applyMatrix3( e ), this.setXY( t, _vector2$1.x, _vector2$1.y ); else if ( 3 === this.itemSize ) for ( let t = 0, n = this.count; t < n; t ++ )_vector$3.fromBufferAttribute( this, t ), _vector$3.applyMatrix3( e ), this.setXYZ( t, _vector$3.x, _vector$3.y, _vector$3.z ); return this;

}, applyMatrix4: function ( e ) {

	for ( let t = 0, n = this.count; t < n; t ++ )_vector$3.x = this.getX( t ), _vector$3.y = this.getY( t ), _vector$3.z = this.getZ( t ), _vector$3.applyMatrix4( e ), this.setXYZ( t, _vector$3.x, _vector$3.y, _vector$3.z ); return this;

}, applyNormalMatrix: function ( e ) {

	for ( let t = 0, n = this.count; t < n; t ++ )_vector$3.x = this.getX( t ), _vector$3.y = this.getY( t ), _vector$3.z = this.getZ( t ), _vector$3.applyNormalMatrix( e ), this.setXYZ( t, _vector$3.x, _vector$3.y, _vector$3.z ); return this;

}, transformDirection: function ( e ) {

	for ( let t = 0, n = this.count; t < n; t ++ )_vector$3.x = this.getX( t ), _vector$3.y = this.getY( t ), _vector$3.z = this.getZ( t ), _vector$3.transformDirection( e ), this.setXYZ( t, _vector$3.x, _vector$3.y, _vector$3.z ); return this;

}, set: function ( e, t = 0 ) {

	return this.array.set( e, t ), this;

}, getX: function ( e ) {

	return this.array[ e * this.itemSize ];

}, setX: function ( e, t ) {

	return this.array[ e * this.itemSize ] = t, this;

}, getY: function ( e ) {

	return this.array[ e * this.itemSize + 1 ];

}, setY: function ( e, t ) {

	return this.array[ e * this.itemSize + 1 ] = t, this;

}, getZ: function ( e ) {

	return this.array[ e * this.itemSize + 2 ];

}, setZ: function ( e, t ) {

	return this.array[ e * this.itemSize + 2 ] = t, this;

}, getW: function ( e ) {

	return this.array[ e * this.itemSize + 3 ];

}, setW: function ( e, t ) {

	return this.array[ e * this.itemSize + 3 ] = t, this;

}, setXY: function ( e, t, n ) {

	return e *= this.itemSize, this.array[ e + 0 ] = t, this.array[ e + 1 ] = n, this;

}, setXYZ: function ( e, t, n, r ) {

	return e *= this.itemSize, this.array[ e + 0 ] = t, this.array[ e + 1 ] = n, this.array[ e + 2 ] = r, this;

}, setXYZW: function ( e, t, n, r, i ) {

	return e *= this.itemSize, this.array[ e + 0 ] = t, this.array[ e + 1 ] = n, this.array[ e + 2 ] = r, this.array[ e + 3 ] = i, this;

}, onUpload: function ( e ) {

	return this.onUploadCallback = e, this;

}, clone: function () {

	return new this.constructor( this.array, this.itemSize ).copy( this );

}, toJSON: function () {

	return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call( this.array ), normalized: this.normalized };

} } ), Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Int8BufferAttribute.prototype.constructor = Int8BufferAttribute, Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute, Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute, Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Int16BufferAttribute.prototype.constructor = Int16BufferAttribute, Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute, Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Int32BufferAttribute.prototype.constructor = Int32BufferAttribute, Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute, Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Float16BufferAttribute.prototype.constructor = Float16BufferAttribute, Float16BufferAttribute.prototype.isFloat16BufferAttribute = ! 0, Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Float32BufferAttribute.prototype.constructor = Float32BufferAttribute, Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype ), Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; class DirectGeometry {

	constructor() {

		this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = ! 1, this.normalsNeedUpdate = ! 1, this.colorsNeedUpdate = ! 1, this.uvsNeedUpdate = ! 1, this.groupsNeedUpdate = ! 1;

	}computeGroups( e ) {

		const t = []; let n, r, i = void 0; const o = e.faces; for ( r = 0; r < o.length; r ++ ) {

			const e = o[ r ]; e.materialIndex !== i && ( i = e.materialIndex, void 0 !== n && ( n.count = 3 * r - n.start, t.push( n ) ), n = { start: 3 * r, materialIndex: i } );

		}

		void 0 !== n && ( n.count = 3 * r - n.start, t.push( n ) ), this.groups = t;

	}fromGeometry( e ) {

		const t = e.faces, n = e.vertices, r = e.faceVertexUvs, i = r[ 0 ] && r[ 0 ].length > 0, o = r[ 1 ] && r[ 1 ].length > 0, a = e.morphTargets, s = a.length; let c; if ( s > 0 ) {

			c = []; for ( let e = 0; e < s; e ++ )c[ e ] = { name: a[ e ].name, data: [] }; this.morphTargets.position = c;

		}

		const l = e.morphNormals, h = l.length; let u; if ( h > 0 ) {

			u = []; for ( let e = 0; e < h; e ++ )u[ e ] = { name: l[ e ].name, data: [] }; this.morphTargets.normal = u;

		}

		const d = e.skinIndices, p = e.skinWeights, m = d.length === n.length, f = p.length === n.length; n.length > 0 && 0 === t.length && console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' ); for ( let e = 0; e < t.length; e ++ ) {

			const g = t[ e ]; this.vertices.push( n[ g.a ], n[ g.b ], n[ g.c ] ); const v = g.vertexNormals; if ( 3 === v.length ) this.normals.push( v[ 0 ], v[ 1 ], v[ 2 ] ); else {

				const e = g.normal; this.normals.push( e, e, e );

			}

			const y = g.vertexColors; if ( 3 === y.length ) this.colors.push( y[ 0 ], y[ 1 ], y[ 2 ] ); else {

				const e = g.color; this.colors.push( e, e, e );

			}

			if ( ! 0 === i ) {

				const t = r[ 0 ][ e ]; void 0 !== t ? this.uvs.push( t[ 0 ], t[ 1 ], t[ 2 ] ) : ( console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', e ), this.uvs.push( new Vector2(), new Vector2(), new Vector2() ) );

			}

			if ( ! 0 === o ) {

				const t = r[ 1 ][ e ]; void 0 !== t ? this.uvs2.push( t[ 0 ], t[ 1 ], t[ 2 ] ) : ( console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', e ), this.uvs2.push( new Vector2(), new Vector2(), new Vector2() ) );

			}

			for ( let e = 0; e < s; e ++ ) {

				const t = a[ e ].vertices; c[ e ].data.push( t[ g.a ], t[ g.b ], t[ g.c ] );

			}

			for ( let t = 0; t < h; t ++ ) {

				const n = l[ t ].vertexNormals[ e ]; u[ t ].data.push( n.a, n.b, n.c );

			}

			m && this.skinIndices.push( d[ g.a ], d[ g.b ], d[ g.c ] ), f && this.skinWeights.push( p[ g.a ], p[ g.b ], p[ g.c ] );

		}

		return this.computeGroups( e ), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && ( this.boundingSphere = e.boundingSphere.clone() ), null !== e.boundingBox && ( this.boundingBox = e.boundingBox.clone() ), this;

	}

} function arrayMax( e ) {

	if ( 0 === e.length ) return - 1 / 0; let t = e[ 0 ]; for ( let n = 1, r = e.length; n < r; ++ n )e[ n ] > t && ( t = e[ n ] ); return t;

}

const TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: 'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function getTypedArray( e, t ) {

	return new TYPED_ARRAYS[ e ]( t );

}

let _bufferGeometryId = 1; const _m1$2 = new Matrix4(), _obj = new Object3D(), _offset = new Vector3(), _box$2 = new Box3(), _boxMorphTargets = new Box3(), _vector$4 = new Vector3(); function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } ), this.uuid = MathUtils.generateUUID(), this.name = '', this.type = 'BufferGeometry', this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = ! 1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: BufferGeometry, isBufferGeometry: ! 0, getIndex: function () {

	return this.index;

}, setIndex: function ( e ) {

	return Array.isArray( e ) ? this.index = new ( arrayMax( e ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( e, 1 ) : this.index = e, this;

}, getAttribute: function ( e ) {

	return this.attributes[ e ];

}, setAttribute: function ( e, t ) {

	return this.attributes[ e ] = t, this;

}, deleteAttribute: function ( e ) {

	return delete this.attributes[ e ], this;

}, hasAttribute: function ( e ) {

	return void 0 !== this.attributes[ e ];

}, addGroup: function ( e, t, n = 0 ) {

	this.groups.push( { start: e, count: t, materialIndex: n } );

}, clearGroups: function () {

	this.groups = [];

}, setDrawRange: function ( e, t ) {

	this.drawRange.start = e, this.drawRange.count = t;

}, applyMatrix4: function ( e ) {

	const t = this.attributes.position; void 0 !== t && ( t.applyMatrix4( e ), t.needsUpdate = ! 0 ); const n = this.attributes.normal; if ( void 0 !== n ) {

		const t = ( new Matrix3() ).getNormalMatrix( e ); n.applyNormalMatrix( t ), n.needsUpdate = ! 0;

	}

	const r = this.attributes.tangent; return void 0 !== r && ( r.transformDirection( e ), r.needsUpdate = ! 0 ), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;

}, rotateX: function ( e ) {

	return _m1$2.makeRotationX( e ), this.applyMatrix4( _m1$2 ), this;

}, rotateY: function ( e ) {

	return _m1$2.makeRotationY( e ), this.applyMatrix4( _m1$2 ), this;

}, rotateZ: function ( e ) {

	return _m1$2.makeRotationZ( e ), this.applyMatrix4( _m1$2 ), this;

}, translate: function ( e, t, n ) {

	return _m1$2.makeTranslation( e, t, n ), this.applyMatrix4( _m1$2 ), this;

}, scale: function ( e, t, n ) {

	return _m1$2.makeScale( e, t, n ), this.applyMatrix4( _m1$2 ), this;

}, lookAt: function ( e ) {

	return _obj.lookAt( e ), _obj.updateMatrix(), this.applyMatrix4( _obj.matrix ), this;

}, center: function () {

	return this.computeBoundingBox(), this.boundingBox.getCenter( _offset ).negate(), this.translate( _offset.x, _offset.y, _offset.z ), this;

}, setFromObject: function ( e ) {

	const t = e.geometry; if ( e.isPoints || e.isLine ) {

		const e = new Float32BufferAttribute( 3 * t.vertices.length, 3 ), n = new Float32BufferAttribute( 3 * t.colors.length, 3 ); if ( this.setAttribute( 'position', e.copyVector3sArray( t.vertices ) ), this.setAttribute( 'color', n.copyColorsArray( t.colors ) ), t.lineDistances && t.lineDistances.length === t.vertices.length ) {

			const e = new Float32BufferAttribute( t.lineDistances.length, 1 ); this.setAttribute( 'lineDistance', e.copyArray( t.lineDistances ) );

		}

		null !== t.boundingSphere && ( this.boundingSphere = t.boundingSphere.clone() ), null !== t.boundingBox && ( this.boundingBox = t.boundingBox.clone() );

	} else e.isMesh && t && t.isGeometry && this.fromGeometry( t ); return this;

}, setFromPoints: function ( e ) {

	const t = []; for ( let n = 0, r = e.length; n < r; n ++ ) {

		const r = e[ n ]; t.push( r.x, r.y, r.z || 0 );

	}

	return this.setAttribute( 'position', new Float32BufferAttribute( t, 3 ) ), this;

}, updateFromObject: function ( e ) {

	let t = e.geometry; if ( e.isMesh ) {

		let e = t.__directGeometry; if ( ! 0 === t.elementsNeedUpdate && ( e = void 0, t.elementsNeedUpdate = ! 1 ), void 0 === e ) return this.fromGeometry( t ); e.verticesNeedUpdate = t.verticesNeedUpdate, e.normalsNeedUpdate = t.normalsNeedUpdate, e.colorsNeedUpdate = t.colorsNeedUpdate, e.uvsNeedUpdate = t.uvsNeedUpdate, e.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = ! 1, t.normalsNeedUpdate = ! 1, t.colorsNeedUpdate = ! 1, t.uvsNeedUpdate = ! 1, t.groupsNeedUpdate = ! 1, t = e;

	}

	if ( ! 0 === t.verticesNeedUpdate ) {

		const e = this.attributes.position; void 0 !== e && ( e.copyVector3sArray( t.vertices ), e.needsUpdate = ! 0 ), t.verticesNeedUpdate = ! 1;

	}

	if ( ! 0 === t.normalsNeedUpdate ) {

		const e = this.attributes.normal; void 0 !== e && ( e.copyVector3sArray( t.normals ), e.needsUpdate = ! 0 ), t.normalsNeedUpdate = ! 1;

	}

	if ( ! 0 === t.colorsNeedUpdate ) {

		const e = this.attributes.color; void 0 !== e && ( e.copyColorsArray( t.colors ), e.needsUpdate = ! 0 ), t.colorsNeedUpdate = ! 1;

	}

	if ( t.uvsNeedUpdate ) {

		const e = this.attributes.uv; void 0 !== e && ( e.copyVector2sArray( t.uvs ), e.needsUpdate = ! 0 ), t.uvsNeedUpdate = ! 1;

	}

	if ( t.lineDistancesNeedUpdate ) {

		const e = this.attributes.lineDistance; void 0 !== e && ( e.copyArray( t.lineDistances ), e.needsUpdate = ! 0 ), t.lineDistancesNeedUpdate = ! 1;

	}

	return t.groupsNeedUpdate && ( t.computeGroups( e.geometry ), this.groups = t.groups, t.groupsNeedUpdate = ! 1 ), this;

}, fromGeometry: function ( e ) {

	return e.__directGeometry = ( new DirectGeometry() ).fromGeometry( e ), this.fromDirectGeometry( e.__directGeometry );

}, fromDirectGeometry: function ( e ) {

	const t = new Float32Array( 3 * e.vertices.length ); if ( this.setAttribute( 'position', new BufferAttribute( t, 3 ).copyVector3sArray( e.vertices ) ), e.normals.length > 0 ) {

		const t = new Float32Array( 3 * e.normals.length ); this.setAttribute( 'normal', new BufferAttribute( t, 3 ).copyVector3sArray( e.normals ) );

	}

	if ( e.colors.length > 0 ) {

		const t = new Float32Array( 3 * e.colors.length ); this.setAttribute( 'color', new BufferAttribute( t, 3 ).copyColorsArray( e.colors ) );

	}

	if ( e.uvs.length > 0 ) {

		const t = new Float32Array( 2 * e.uvs.length ); this.setAttribute( 'uv', new BufferAttribute( t, 2 ).copyVector2sArray( e.uvs ) );

	}

	if ( e.uvs2.length > 0 ) {

		const t = new Float32Array( 2 * e.uvs2.length ); this.setAttribute( 'uv2', new BufferAttribute( t, 2 ).copyVector2sArray( e.uvs2 ) );

	}

	this.groups = e.groups; for ( const t in e.morphTargets ) {

		const n = [], r = e.morphTargets[ t ]; for ( let e = 0, t = r.length; e < t; e ++ ) {

			const t = r[ e ], i = new Float32BufferAttribute( 3 * t.data.length, 3 ); i.name = t.name, n.push( i.copyVector3sArray( t.data ) );

		}

		this.morphAttributes[ t ] = n;

	}

	if ( e.skinIndices.length > 0 ) {

		const t = new Float32BufferAttribute( 4 * e.skinIndices.length, 4 ); this.setAttribute( 'skinIndex', t.copyVector4sArray( e.skinIndices ) );

	}

	if ( e.skinWeights.length > 0 ) {

		const t = new Float32BufferAttribute( 4 * e.skinWeights.length, 4 ); this.setAttribute( 'skinWeight', t.copyVector4sArray( e.skinWeights ) );

	}

	return null !== e.boundingSphere && ( this.boundingSphere = e.boundingSphere.clone() ), null !== e.boundingBox && ( this.boundingBox = e.boundingBox.clone() ), this;

}, computeBoundingBox: function () {

	null === this.boundingBox && ( this.boundingBox = new Box3() ); const e = this.attributes.position, t = this.morphAttributes.position; if ( e && e.isGLBufferAttribute ) return console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this ), void this.boundingBox.set( new Vector3( - 1 / 0, - 1 / 0, - 1 / 0 ), new Vector3( 1 / 0, 1 / 0, 1 / 0 ) ); if ( void 0 !== e ) {

		if ( this.boundingBox.setFromBufferAttribute( e ), t ) for ( let e = 0, n = t.length; e < n; e ++ ) {

			const n = t[ e ]; _box$2.setFromBufferAttribute( n ), this.morphTargetsRelative ? ( _vector$4.addVectors( this.boundingBox.min, _box$2.min ), this.boundingBox.expandByPoint( _vector$4 ), _vector$4.addVectors( this.boundingBox.max, _box$2.max ), this.boundingBox.expandByPoint( _vector$4 ) ) : ( this.boundingBox.expandByPoint( _box$2.min ), this.boundingBox.expandByPoint( _box$2.max ) );

		}

	} else this.boundingBox.makeEmpty(); ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) && console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

}, computeBoundingSphere: function () {

	null === this.boundingSphere && ( this.boundingSphere = new Sphere() ); const e = this.attributes.position, t = this.morphAttributes.position; if ( e && e.isGLBufferAttribute ) return console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this ), void this.boundingSphere.set( new Vector3(), 1 / 0 ); if ( e ) {

		const n = this.boundingSphere.center; if ( _box$2.setFromBufferAttribute( e ), t ) for ( let e = 0, n = t.length; e < n; e ++ ) {

			const n = t[ e ]; _boxMorphTargets.setFromBufferAttribute( n ), this.morphTargetsRelative ? ( _vector$4.addVectors( _box$2.min, _boxMorphTargets.min ), _box$2.expandByPoint( _vector$4 ), _vector$4.addVectors( _box$2.max, _boxMorphTargets.max ), _box$2.expandByPoint( _vector$4 ) ) : ( _box$2.expandByPoint( _boxMorphTargets.min ), _box$2.expandByPoint( _boxMorphTargets.max ) );

		}

		_box$2.getCenter( n ); let r = 0; for ( let t = 0, i = e.count; t < i; t ++ )_vector$4.fromBufferAttribute( e, t ), r = Math.max( r, n.distanceToSquared( _vector$4 ) ); if ( t ) for ( let i = 0, o = t.length; i < o; i ++ ) {

			const o = t[ i ], a = this.morphTargetsRelative; for ( let t = 0, i = o.count; t < i; t ++ )_vector$4.fromBufferAttribute( o, t ), a && ( _offset.fromBufferAttribute( e, t ), _vector$4.add( _offset ) ), r = Math.max( r, n.distanceToSquared( _vector$4 ) );

		}

		this.boundingSphere.radius = Math.sqrt( r ), isNaN( this.boundingSphere.radius ) && console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

	}

}, computeFaceNormals: function () {}, computeVertexNormals: function () {

	const e = this.index, t = this.getAttribute( 'position' ); if ( void 0 !== t ) {

		let n = this.getAttribute( 'normal' ); if ( void 0 === n )n = new BufferAttribute( new Float32Array( 3 * t.count ), 3 ), this.setAttribute( 'normal', n ); else for ( let e = 0, t = n.count; e < t; e ++ )n.setXYZ( e, 0, 0, 0 ); const r = new Vector3(), i = new Vector3(), o = new Vector3(), a = new Vector3(), s = new Vector3(), c = new Vector3(), l = new Vector3(), h = new Vector3(); if ( e ) for ( let u = 0, d = e.count; u < d; u += 3 ) {

			const d = e.getX( u + 0 ), p = e.getX( u + 1 ), m = e.getX( u + 2 ); r.fromBufferAttribute( t, d ), i.fromBufferAttribute( t, p ), o.fromBufferAttribute( t, m ), l.subVectors( o, i ), h.subVectors( r, i ), l.cross( h ), a.fromBufferAttribute( n, d ), s.fromBufferAttribute( n, p ), c.fromBufferAttribute( n, m ), a.add( l ), s.add( l ), c.add( l ), n.setXYZ( d, a.x, a.y, a.z ), n.setXYZ( p, s.x, s.y, s.z ), n.setXYZ( m, c.x, c.y, c.z );

		} else for ( let e = 0, a = t.count; e < a; e += 3 )r.fromBufferAttribute( t, e + 0 ), i.fromBufferAttribute( t, e + 1 ), o.fromBufferAttribute( t, e + 2 ), l.subVectors( o, i ), h.subVectors( r, i ), l.cross( h ), n.setXYZ( e + 0, l.x, l.y, l.z ), n.setXYZ( e + 1, l.x, l.y, l.z ), n.setXYZ( e + 2, l.x, l.y, l.z ); this.normalizeNormals(), n.needsUpdate = ! 0;

	}

}, merge: function ( e, t ) {

	if ( ! e || ! e.isBufferGeometry ) return void console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', e ); void 0 === t && ( t = 0, console.warn( 'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.' ) ); const n = this.attributes; for ( const r in n ) {

		if ( void 0 === e.attributes[ r ] ) continue; const i = n[ r ].array, o = e.attributes[ r ], a = o.array, s = o.itemSize * t, c = Math.min( a.length, i.length - s ); for ( let e = 0, t = s; e < c; e ++, t ++ )i[ t ] = a[ e ];

	}

	return this;

}, normalizeNormals: function () {

	const e = this.attributes.normal; for ( let t = 0, n = e.count; t < n; t ++ )_vector$4.fromBufferAttribute( e, t ), _vector$4.normalize(), e.setXYZ( t, _vector$4.x, _vector$4.y, _vector$4.z );

}, toNonIndexed: function () {

	function e( e, t ) {

		const n = e.array, r = e.itemSize, i = e.normalized, o = new n.constructor( t.length * r ); let a = 0, s = 0; for ( let e = 0, i = t.length; e < i; e ++ ) {

			a = t[ e ] * r; for ( let e = 0; e < r; e ++ )o[ s ++ ] = n[ a ++ ];

		}

		return new BufferAttribute( o, r, i );

	}

	if ( null === this.index ) return console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' ), this; const t = new BufferGeometry(), n = this.index.array, r = this.attributes; for ( const i in r ) {

		const o = e( r[ i ], n ); t.setAttribute( i, o );

	}

	const i = this.morphAttributes; for ( const r in i ) {

		const o = [], a = i[ r ]; for ( let t = 0, r = a.length; t < r; t ++ ) {

			const r = e( a[ t ], n ); o.push( r );

		}

		t.morphAttributes[ r ] = o;

	}

	t.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for ( let e = 0, n = o.length; e < n; e ++ ) {

		const n = o[ e ]; t.addGroup( n.start, n.count, n.materialIndex );

	}

	return t;

}, toJSON: function () {

	const e = { metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } }; if ( e.uuid = this.uuid, e.type = this.type, '' !== this.name && ( e.name = this.name ), Object.keys( this.userData ).length > 0 && ( e.userData = this.userData ), void 0 !== this.parameters ) {

		const t = this.parameters; for ( const n in t ) void 0 !== t[ n ] && ( e[ n ] = t[ n ] ); return e;

	}

	e.data = { attributes: {} }; const t = this.index; null !== t && ( e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call( t.array ) } ); const n = this.attributes; for ( const t in n ) {

		const r = n[ t ], i = r.toJSON( e.data ); '' !== r.name && ( i.name = r.name ), e.data.attributes[ t ] = i;

	}

	const r = {}; let i = ! 1; for ( const t in this.morphAttributes ) {

		const n = this.morphAttributes[ t ], o = []; for ( let t = 0, r = n.length; t < r; t ++ ) {

			const r = n[ t ], i = r.toJSON( e.data ); '' !== r.name && ( i.name = r.name ), o.push( i );

		}

		o.length > 0 && ( r[ t ] = o, i = ! 0 );

	}

	i && ( e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative ); const o = this.groups; o.length > 0 && ( e.data.groups = JSON.parse( JSON.stringify( o ) ) ); const a = this.boundingSphere; return null !== a && ( e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius } ), e;

}, clone: function () {

	return ( new BufferGeometry() ).copy( this );

}, copy: function ( e ) {

	this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex( n.clone( t ) ); const r = e.attributes; for ( const e in r ) {

		const n = r[ e ]; this.setAttribute( e, n.clone( t ) );

	}

	const i = e.morphAttributes; for ( const e in i ) {

		const n = [], r = i[ e ]; for ( let e = 0, i = r.length; e < i; e ++ )n.push( r[ e ].clone( t ) ); this.morphAttributes[ e ] = n;

	}

	this.morphTargetsRelative = e.morphTargetsRelative; const o = e.groups; for ( let e = 0, t = o.length; e < t; e ++ ) {

		const t = o[ e ]; this.addGroup( t.start, t.count, t.materialIndex );

	}

	const a = e.boundingBox; null !== a && ( this.boundingBox = a.clone() ); const s = e.boundingSphere; return null !== s && ( this.boundingSphere = s.clone() ), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;

}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

} } ); const _inverseMatrix = new Matrix4(), _ray = new Ray(), _sphere = new Sphere(), _vA = new Vector3(), _vB = new Vector3(), _vC = new Vector3(), _tempA = new Vector3(), _tempB = new Vector3(), _tempC = new Vector3(), _morphA = new Vector3(), _morphB = new Vector3(), _morphC = new Vector3(), _uvA = new Vector2(), _uvB = new Vector2(), _uvC = new Vector2(), _intersectionPoint = new Vector3(), _intersectionPointWorld = new Vector3(); function Mesh( e = new BufferGeometry(), t = new MeshBasicMaterial() ) {

	Object3D.call( this ), this.type = 'Mesh', this.geometry = e, this.material = t, this.updateMorphTargets();

}

function checkIntersection( e, t, n, r, i, o, a, s ) {

	let c; if ( null === ( c = t.side === BackSide ? r.intersectTriangle( a, o, i, ! 0, s ) : r.intersectTriangle( i, o, a, t.side !== DoubleSide, s ) ) ) return null; _intersectionPointWorld.copy( s ), _intersectionPointWorld.applyMatrix4( e.matrixWorld ); const l = n.ray.origin.distanceTo( _intersectionPointWorld ); return l < n.near || l > n.far ? null : { distance: l, point: _intersectionPointWorld.clone(), object: e };

}

function checkBufferGeometryIntersection( e, t, n, r, i, o, a, s, c, l, h, u ) {

	_vA.fromBufferAttribute( i, l ), _vB.fromBufferAttribute( i, h ), _vC.fromBufferAttribute( i, u ); const d = e.morphTargetInfluences; if ( t.morphTargets && o && d ) {

		_morphA.set( 0, 0, 0 ), _morphB.set( 0, 0, 0 ), _morphC.set( 0, 0, 0 ); for ( let e = 0, t = o.length; e < t; e ++ ) {

			const t = d[ e ], n = o[ e ]; 0 !== t && ( _tempA.fromBufferAttribute( n, l ), _tempB.fromBufferAttribute( n, h ), _tempC.fromBufferAttribute( n, u ), a ? ( _morphA.addScaledVector( _tempA, t ), _morphB.addScaledVector( _tempB, t ), _morphC.addScaledVector( _tempC, t ) ) : ( _morphA.addScaledVector( _tempA.sub( _vA ), t ), _morphB.addScaledVector( _tempB.sub( _vB ), t ), _morphC.addScaledVector( _tempC.sub( _vC ), t ) ) );

		}

		_vA.add( _morphA ), _vB.add( _morphB ), _vC.add( _morphC );

	}

	e.isSkinnedMesh && ( e.boneTransform( l, _vA ), e.boneTransform( h, _vB ), e.boneTransform( u, _vC ) ); const p = checkIntersection( e, t, n, r, _vA, _vB, _vC, _intersectionPoint ); if ( p ) {

		s && ( _uvA.fromBufferAttribute( s, l ), _uvB.fromBufferAttribute( s, h ), _uvC.fromBufferAttribute( s, u ), p.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ) ), c && ( _uvA.fromBufferAttribute( c, l ), _uvB.fromBufferAttribute( c, h ), _uvC.fromBufferAttribute( c, u ), p.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ) ); const e = new Face3( l, h, u ); Triangle.getNormal( _vA, _vB, _vC, e.normal ), p.face = e;

	}

	return p;

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Mesh, isMesh: ! 0, copy: function ( e ) {

	return Object3D.prototype.copy.call( this, e ), void 0 !== e.morphTargetInfluences && ( this.morphTargetInfluences = e.morphTargetInfluences.slice() ), void 0 !== e.morphTargetDictionary && ( this.morphTargetDictionary = Object.assign( {}, e.morphTargetDictionary ) ), this.material = e.material, this.geometry = e.geometry, this;

}, updateMorphTargets: function () {

	const e = this.geometry; if ( e.isBufferGeometry ) {

		const t = e.morphAttributes, n = Object.keys( t ); if ( n.length > 0 ) {

			const e = t[ n[ 0 ] ]; if ( void 0 !== e ) {

				this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for ( let t = 0, n = e.length; t < n; t ++ ) {

					const n = e[ t ].name || String( t ); this.morphTargetInfluences.push( 0 ), this.morphTargetDictionary[ n ] = t;

				}

			}

		}

	} else {

		const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

}, raycast: function ( e, t ) {

	const n = this.geometry, r = this.material, i = this.matrixWorld; if ( void 0 === r ) return; if ( null === n.boundingSphere && n.computeBoundingSphere(), _sphere.copy( n.boundingSphere ), _sphere.applyMatrix4( i ), ! 1 === e.ray.intersectsSphere( _sphere ) ) return; if ( _inverseMatrix.copy( i ).invert(), _ray.copy( e.ray ).applyMatrix4( _inverseMatrix ), null !== n.boundingBox && ! 1 === _ray.intersectsBox( n.boundingBox ) ) return; let o; if ( n.isBufferGeometry ) {

		const i = n.index, a = n.attributes.position, s = n.morphAttributes.position, c = n.morphTargetsRelative, l = n.attributes.uv, h = n.attributes.uv2, u = n.groups, d = n.drawRange; if ( null !== i ) if ( Array.isArray( r ) ) for ( let n = 0, p = u.length; n < p; n ++ ) {

			const p = u[ n ], m = r[ p.materialIndex ]; for ( let n = Math.max( p.start, d.start ), r = Math.min( p.start + p.count, d.start + d.count ); n < r; n += 3 ) {

				const r = i.getX( n ), u = i.getX( n + 1 ), d = i.getX( n + 2 ); ( o = checkBufferGeometryIntersection( this, m, e, _ray, a, s, c, l, h, r, u, d ) ) && ( o.faceIndex = Math.floor( n / 3 ), o.face.materialIndex = p.materialIndex, t.push( o ) );

			}

		} else {

			for ( let n = Math.max( 0, d.start ), u = Math.min( i.count, d.start + d.count ); n < u; n += 3 ) {

				const u = i.getX( n ), d = i.getX( n + 1 ), p = i.getX( n + 2 ); ( o = checkBufferGeometryIntersection( this, r, e, _ray, a, s, c, l, h, u, d, p ) ) && ( o.faceIndex = Math.floor( n / 3 ), t.push( o ) );

			}

		} else if ( void 0 !== a ) if ( Array.isArray( r ) ) for ( let n = 0, i = u.length; n < i; n ++ ) {

			const i = u[ n ], p = r[ i.materialIndex ]; for ( let n = Math.max( i.start, d.start ), r = Math.min( i.start + i.count, d.start + d.count ); n < r; n += 3 ) {

				( o = checkBufferGeometryIntersection( this, p, e, _ray, a, s, c, l, h, n, n + 1, n + 2 ) ) && ( o.faceIndex = Math.floor( n / 3 ), o.face.materialIndex = i.materialIndex, t.push( o ) );

			}

		} else {

			for ( let n = Math.max( 0, d.start ), i = Math.min( a.count, d.start + d.count ); n < i; n += 3 ) {

				( o = checkBufferGeometryIntersection( this, r, e, _ray, a, s, c, l, h, n, n + 1, n + 2 ) ) && ( o.faceIndex = Math.floor( n / 3 ), t.push( o ) );

			}

		}

	} else if ( n.isGeometry ) {

		const i = Array.isArray( r ), a = n.vertices, s = n.faces; let c; const l = n.faceVertexUvs[ 0 ]; l.length > 0 && ( c = l ); for ( let n = 0, l = s.length; n < l; n ++ ) {

			const l = s[ n ], h = i ? r[ l.materialIndex ] : r; if ( void 0 === h ) continue; const u = a[ l.a ], d = a[ l.b ], p = a[ l.c ]; if ( o = checkIntersection( this, h, e, _ray, u, d, p, _intersectionPoint ) ) {

				if ( c && c[ n ] ) {

					const e = c[ n ]; _uvA.copy( e[ 0 ] ), _uvB.copy( e[ 1 ] ), _uvC.copy( e[ 2 ] ), o.uv = Triangle.getUV( _intersectionPoint, u, d, p, _uvA, _uvB, _uvC, new Vector2() );

				}

				o.face = l, o.faceIndex = n, t.push( o );

			}

		}

	}

} } ); class BoxBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = 1, n = 1, r = 1, i = 1, o = 1 ) {

		super(), this.type = 'BoxBufferGeometry', this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: o }; const a = this; r = Math.floor( r ), i = Math.floor( i ), o = Math.floor( o ); const s = [], c = [], l = [], h = []; let u = 0, d = 0; function p( e, t, n, r, i, o, p, m, f, g, v ) {

			const y = o / f, _ = p / g, x = o / 2, b = p / 2, M = m / 2, w = f + 1, S = g + 1; let T = 0, E = 0; const A = new Vector3(); for ( let o = 0; o < S; o ++ ) {

				const a = o * _ - b; for ( let s = 0; s < w; s ++ ) {

					const u = s * y - x; A[ e ] = u * r, A[ t ] = a * i, A[ n ] = M, c.push( A.x, A.y, A.z ), A[ e ] = 0, A[ t ] = 0, A[ n ] = m > 0 ? 1 : - 1, l.push( A.x, A.y, A.z ), h.push( s / f ), h.push( 1 - o / g ), T += 1;

				}

			}

			for ( let e = 0; e < g; e ++ ) for ( let t = 0; t < f; t ++ ) {

				const n = u + t + w * e, r = u + t + w * ( e + 1 ), i = u + ( t + 1 ) + w * ( e + 1 ), o = u + ( t + 1 ) + w * e; s.push( n, r, o ), s.push( r, i, o ), E += 6;

			}

			a.addGroup( d, E, v ), d += E, u += T;

		}

		p( 'z', 'y', 'x', - 1, - 1, n, t, e, o, i, 0 ), p( 'z', 'y', 'x', 1, - 1, n, t, - e, o, i, 1 ), p( 'x', 'z', 'y', 1, 1, e, n, t, r, o, 2 ), p( 'x', 'z', 'y', 1, - 1, e, n, - t, r, o, 3 ), p( 'x', 'y', 'z', 1, - 1, e, t, n, r, i, 4 ), p( 'x', 'y', 'z', - 1, - 1, e, t, - n, r, i, 5 ), this.setIndex( s ), this.setAttribute( 'position', new Float32BufferAttribute( c, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( l, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( h, 2 ) );

	}

} function cloneUniforms( e ) {

	const t = {}; for ( const n in e ) {

		t[ n ] = {}; for ( const r in e[ n ] ) {

			const i = e[ n ][ r ]; i && ( i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture ) ? t[ n ][ r ] = i.clone() : Array.isArray( i ) ? t[ n ][ r ] = i.slice() : t[ n ][ r ] = i;

		}

	}

	return t;

}

function mergeUniforms( e ) {

	const t = {}; for ( let n = 0; n < e.length; n ++ ) {

		const r = cloneUniforms( e[ n ] ); for ( const e in r )t[ e ] = r[ e ];

	}

	return t;

}

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; var default_vertex = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}', default_fragment = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'; function ShaderMaterial( e ) {

	Material.call( this ), this.type = 'ShaderMaterial', this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.fog = ! 1, this.lights = ! 1, this.clipping = ! 1, this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.extensions = { derivatives: ! 1, fragDepth: ! 1, drawBuffers: ! 1, shaderTextureLOD: ! 1 }, this.defaultAttributeValues = { color: [ 1, 1, 1 ], uv: [ 0, 0 ], uv2: [ 0, 0 ] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = ! 1, this.glslVersion = null, void 0 !== e && ( void 0 !== e.attributes && console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' ), this.setValues( e ) );

}

function Camera() {

	Object3D.call( this ), this.type = 'Camera', this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4();

}

function PerspectiveCamera( e = 50, t = 1, n = .1, r = 2e3 ) {

	Camera.call( this ), this.type = 'PerspectiveCamera', this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();

}

ShaderMaterial.prototype = Object.create( Material.prototype ), ShaderMaterial.prototype.constructor = ShaderMaterial, ShaderMaterial.prototype.isShaderMaterial = ! 0, ShaderMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms( e.uniforms ), this.defines = Object.assign( {}, e.defines ), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign( {}, e.extensions ), this.glslVersion = e.glslVersion, this;

}, ShaderMaterial.prototype.toJSON = function ( e ) {

	const t = Material.prototype.toJSON.call( this, e ); t.glslVersion = this.glslVersion, t.uniforms = {}; for ( const n in this.uniforms ) {

		const r = this.uniforms[ n ].value; r && r.isTexture ? t.uniforms[ n ] = { type: 't', value: r.toJSON( e ).uuid } : r && r.isColor ? t.uniforms[ n ] = { type: 'c', value: r.getHex() } : r && r.isVector2 ? t.uniforms[ n ] = { type: 'v2', value: r.toArray() } : r && r.isVector3 ? t.uniforms[ n ] = { type: 'v3', value: r.toArray() } : r && r.isVector4 ? t.uniforms[ n ] = { type: 'v4', value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[ n ] = { type: 'm3', value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[ n ] = { type: 'm4', value: r.toArray() } : t.uniforms[ n ] = { value: r };

	}

	Object.keys( this.defines ).length > 0 && ( t.defines = this.defines ), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const n = {}; for ( const e in this.extensions )! 0 === this.extensions[ e ] && ( n[ e ] = ! 0 ); return Object.keys( n ).length > 0 && ( t.extensions = n ), t;

}, Camera.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Camera, isCamera: ! 0, copy: function ( e, t ) {

	return Object3D.prototype.copy.call( this, e, t ), this.matrixWorldInverse.copy( e.matrixWorldInverse ), this.projectionMatrix.copy( e.projectionMatrix ), this.projectionMatrixInverse.copy( e.projectionMatrixInverse ), this;

}, getWorldDirection: function ( e ) {

	void 0 === e && ( console.warn( 'THREE.Camera: .getWorldDirection() target is now required' ), e = new Vector3() ), this.updateWorldMatrix( ! 0, ! 1 ); const t = this.matrixWorld.elements; return e.set( - t[ 8 ], - t[ 9 ], - t[ 10 ] ).normalize();

}, updateMatrixWorld: function ( e ) {

	Object3D.prototype.updateMatrixWorld.call( this, e ), this.matrixWorldInverse.copy( this.matrixWorld ).invert();

}, updateWorldMatrix: function ( e, t ) {

	Object3D.prototype.updateWorldMatrix.call( this, e, t ), this.matrixWorldInverse.copy( this.matrixWorld ).invert();

}, clone: function () {

	return ( new this.constructor() ).copy( this );

} } ), PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: PerspectiveCamera, isPerspectiveCamera: ! 0, copy: function ( e, t ) {

	return Camera.prototype.copy.call( this, e, t ), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign( {}, e.view ), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;

}, setFocalLength: function ( e ) {

	const t = .5 * this.getFilmHeight() / e; this.fov = 2 * MathUtils.RAD2DEG * Math.atan( t ), this.updateProjectionMatrix();

}, getFocalLength: function () {

	const e = Math.tan( .5 * MathUtils.DEG2RAD * this.fov ); return .5 * this.getFilmHeight() / e;

}, getEffectiveFOV: function () {

	return 2 * MathUtils.RAD2DEG * Math.atan( Math.tan( .5 * MathUtils.DEG2RAD * this.fov ) / this.zoom );

}, getFilmWidth: function () {

	return this.filmGauge * Math.min( this.aspect, 1 );

}, getFilmHeight: function () {

	return this.filmGauge / Math.max( this.aspect, 1 );

}, setViewOffset: function ( e, t, n, r, i, o ) {

	this.aspect = e / t, null === this.view && ( this.view = { enabled: ! 0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 } ), this.view.enabled = ! 0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix();

}, clearViewOffset: function () {

	null !== this.view && ( this.view.enabled = ! 1 ), this.updateProjectionMatrix();

}, updateProjectionMatrix: function () {

	const e = this.near; let t = e * Math.tan( .5 * MathUtils.DEG2RAD * this.fov ) / this.zoom, n = 2 * t, r = this.aspect * n, i = - .5 * r; const o = this.view; if ( null !== this.view && this.view.enabled ) {

		const e = o.fullWidth, a = o.fullHeight; i += o.offsetX * r / e, t -= o.offsetY * n / a, r *= o.width / e, n *= o.height / a;

	}

	const a = this.filmOffset; 0 !== a && ( i += e * a / this.getFilmWidth() ), this.projectionMatrix.makePerspective( i, i + r, t, t - n, e, this.far ), this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

}, toJSON: function ( e ) {

	const t = Object3D.prototype.toJSON.call( this, e ); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && ( t.object.view = Object.assign( {}, this.view ) ), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;

} } ); const fov = 90, aspect = 1; function CubeCamera( e, t, n ) {

	if ( Object3D.call( this ), this.type = 'CubeCamera', ! 0 !== n.isWebGLCubeRenderTarget ) return void console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' ); this.renderTarget = n; const r = new PerspectiveCamera( fov, aspect, e, t ); r.layers = this.layers, r.up.set( 0, - 1, 0 ), r.lookAt( new Vector3( 1, 0, 0 ) ), this.add( r ); const i = new PerspectiveCamera( fov, aspect, e, t ); i.layers = this.layers, i.up.set( 0, - 1, 0 ), i.lookAt( new Vector3( - 1, 0, 0 ) ), this.add( i ); const o = new PerspectiveCamera( fov, aspect, e, t ); o.layers = this.layers, o.up.set( 0, 0, 1 ), o.lookAt( new Vector3( 0, 1, 0 ) ), this.add( o ); const a = new PerspectiveCamera( fov, aspect, e, t ); a.layers = this.layers, a.up.set( 0, 0, - 1 ), a.lookAt( new Vector3( 0, - 1, 0 ) ), this.add( a ); const s = new PerspectiveCamera( fov, aspect, e, t ); s.layers = this.layers, s.up.set( 0, - 1, 0 ), s.lookAt( new Vector3( 0, 0, 1 ) ), this.add( s ); const c = new PerspectiveCamera( fov, aspect, e, t ); c.layers = this.layers, c.up.set( 0, - 1, 0 ), c.lookAt( new Vector3( 0, 0, - 1 ) ), this.add( c ), this.update = function ( e, t ) {

		null === this.parent && this.updateMatrixWorld(); const l = e.xr.enabled, h = e.getRenderTarget(); e.xr.enabled = ! 1; const u = n.texture.generateMipmaps; n.texture.generateMipmaps = ! 1, e.setRenderTarget( n, 0 ), e.render( t, r ), e.setRenderTarget( n, 1 ), e.render( t, i ), e.setRenderTarget( n, 2 ), e.render( t, o ), e.setRenderTarget( n, 3 ), e.render( t, a ), e.setRenderTarget( n, 4 ), e.render( t, s ), n.texture.generateMipmaps = u, e.setRenderTarget( n, 5 ), e.render( t, c ), e.setRenderTarget( h ), e.xr.enabled = l;

	};

}

function CubeTexture( e, t, n, r, i, o, a, s, c, l ) {

	e = void 0 !== e ? e : [], t = void 0 !== t ? t : CubeReflectionMapping, a = void 0 !== a ? a : RGBFormat, Texture.call( this, e, t, n, r, i, o, a, s, c, l ), this.flipY = ! 1, this._needsFlipEnvMap = ! 0;

}

function WebGLCubeRenderTarget( e, t, n ) {

	Number.isInteger( t ) && ( console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' ), t = n ), WebGLRenderTarget.call( this, e, e, t ), t = t || {}, this.texture = new CubeTexture( void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding ), this.texture._needsFlipEnvMap = ! 1;

}

function DataTexture( e, t, n, r, i, o, a, s, c, l, h, u ) {

	Texture.call( this, null, o, a, s, c, l, r, i, h, u ), this.image = { data: e || null, width: t || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : NearestFilter, this.minFilter = void 0 !== l ? l : NearestFilter, this.generateMipmaps = ! 1, this.flipY = ! 1, this.unpackAlignment = 1, this.needsUpdate = ! 0;

}

CubeCamera.prototype = Object.create( Object3D.prototype ), CubeCamera.prototype.constructor = CubeCamera, CubeTexture.prototype = Object.create( Texture.prototype ), CubeTexture.prototype.constructor = CubeTexture, CubeTexture.prototype.isCubeTexture = ! 0, Object.defineProperty( CubeTexture.prototype, 'images', { get: function () {

	return this.image;

}, set: function ( e ) {

	this.image = e;

} } ), WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype ), WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget, WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = ! 0, WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( e, t ) {

	this.texture.type = t.type, this.texture.format = RGBAFormat, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: '\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t', fragmentShader: '\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t' }, r = new BoxBufferGeometry( 5, 5, 5 ), i = new ShaderMaterial( { name: 'CubemapFromEquirect', uniforms: cloneUniforms( n.uniforms ), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: BackSide, blending: NoBlending } ); i.uniforms.tEquirect.value = t; const o = new Mesh( r, i ), a = t.minFilter; return t.minFilter === LinearMipmapLinearFilter && ( t.minFilter = LinearFilter ), new CubeCamera( 1, 10, this ).update( e, o ), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;

}, WebGLCubeRenderTarget.prototype.clear = function ( e, t, n, r ) {

	const i = e.getRenderTarget(); for ( let i = 0; i < 6; i ++ )e.setRenderTarget( this, i ), e.clear( t, n, r ); e.setRenderTarget( i );

}, DataTexture.prototype = Object.create( Texture.prototype ), DataTexture.prototype.constructor = DataTexture, DataTexture.prototype.isDataTexture = ! 0; const _sphere$1 = new Sphere(), _vector$5 = new Vector3(); class Frustum {

	constructor( e, t, n, r, i, o ) {

		this.planes = [ void 0 !== e ? e : new Plane(), void 0 !== t ? t : new Plane(), void 0 !== n ? n : new Plane(), void 0 !== r ? r : new Plane(), void 0 !== i ? i : new Plane(), void 0 !== o ? o : new Plane() ];

	}set( e, t, n, r, i, o ) {

		const a = this.planes; return a[ 0 ].copy( e ), a[ 1 ].copy( t ), a[ 2 ].copy( n ), a[ 3 ].copy( r ), a[ 4 ].copy( i ), a[ 5 ].copy( o ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		const t = this.planes; for ( let n = 0; n < 6; n ++ )t[ n ].copy( e.planes[ n ] ); return this;

	}setFromProjectionMatrix( e ) {

		const t = this.planes, n = e.elements, r = n[ 0 ], i = n[ 1 ], o = n[ 2 ], a = n[ 3 ], s = n[ 4 ], c = n[ 5 ], l = n[ 6 ], h = n[ 7 ], u = n[ 8 ], d = n[ 9 ], p = n[ 10 ], m = n[ 11 ], f = n[ 12 ], g = n[ 13 ], v = n[ 14 ], y = n[ 15 ]; return t[ 0 ].setComponents( a - r, h - s, m - u, y - f ).normalize(), t[ 1 ].setComponents( a + r, h + s, m + u, y + f ).normalize(), t[ 2 ].setComponents( a + i, h + c, m + d, y + g ).normalize(), t[ 3 ].setComponents( a - i, h - c, m - d, y - g ).normalize(), t[ 4 ].setComponents( a - o, h - l, m - p, y - v ).normalize(), t[ 5 ].setComponents( a + o, h + l, m + p, y + v ).normalize(), this;

	}intersectsObject( e ) {

		const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), _sphere$1.copy( t.boundingSphere ).applyMatrix4( e.matrixWorld ), this.intersectsSphere( _sphere$1 );

	}intersectsSprite( e ) {

		return _sphere$1.center.set( 0, 0, 0 ), _sphere$1.radius = .7071067811865476, _sphere$1.applyMatrix4( e.matrixWorld ), this.intersectsSphere( _sphere$1 );

	}intersectsSphere( e ) {

		const t = this.planes, n = e.center, r = - e.radius; for ( let e = 0; e < 6; e ++ ) {

			if ( t[ e ].distanceToPoint( n ) < r ) return ! 1;

		}

		return ! 0;

	}intersectsBox( e ) {

		const t = this.planes; for ( let n = 0; n < 6; n ++ ) {

			const r = t[ n ]; if ( _vector$5.x = r.normal.x > 0 ? e.max.x : e.min.x, _vector$5.y = r.normal.y > 0 ? e.max.y : e.min.y, _vector$5.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint( _vector$5 ) < 0 ) return ! 1;

		}

		return ! 0;

	}containsPoint( e ) {

		const t = this.planes; for ( let n = 0; n < 6; n ++ ) if ( t[ n ].distanceToPoint( e ) < 0 ) return ! 1; return ! 0;

	}

} function WebGLAnimation() {

	let e = null, t = ! 1, n = null, r = null; function i( t, o ) {

		n( t, o ), r = e.requestAnimationFrame( i );

	}

	return { start: function () {

		! 0 !== t && null !== n && ( r = e.requestAnimationFrame( i ), t = ! 0 );

	}, stop: function () {

		e.cancelAnimationFrame( r ), t = ! 1;

	}, setAnimationLoop: function ( e ) {

		n = e;

	}, setContext: function ( t ) {

		e = t;

	} };

}

function WebGLAttributes( e, t ) {

	const n = t.isWebGL2, r = new WeakMap(); return { get: function ( e ) {

		return e.isInterleavedBufferAttribute && ( e = e.data ), r.get( e );

	}, remove: function ( t ) {

		t.isInterleavedBufferAttribute && ( t = t.data ); const n = r.get( t ); n && ( e.deleteBuffer( n.buffer ), r.delete( t ) );

	}, update: function ( t, i ) {

		if ( t.isGLBufferAttribute ) {

			const e = r.get( t ); return void ( ( ! e || e.version < t.version ) && r.set( t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version } ) );

		}

		t.isInterleavedBufferAttribute && ( t = t.data ); const o = r.get( t ); void 0 === o ? r.set( t, function ( t, r ) {

			const i = t.array, o = t.usage, a = e.createBuffer(); e.bindBuffer( r, a ), e.bufferData( r, i, o ), t.onUploadCallback(); let s = 5126; return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' ) : i instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? s = 5131 : console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' ) : s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && ( s = 5121 ), { buffer: a, type: s, bytesPerElement: i.BYTES_PER_ELEMENT, version: t.version };

		}( t, i ) ) : o.version < t.version && ( function ( t, r, i ) {

			const o = r.array, a = r.updateRange; e.bindBuffer( i, t ), - 1 === a.count ? e.bufferSubData( i, 0, o ) : ( n ? e.bufferSubData( i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count ) : e.bufferSubData( i, a.offset * o.BYTES_PER_ELEMENT, o.subarray( a.offset, a.offset + a.count ) ), a.count = - 1 );

		}( o.buffer, t, i ), o.version = t.version );

	} };

}

class PlaneBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = 1, n = 1, r = 1 ) {

		super(), this.type = 'PlaneBufferGeometry', this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }; const i = e / 2, o = t / 2, a = Math.floor( n ), s = Math.floor( r ), c = a + 1, l = s + 1, h = e / a, u = t / s, d = [], p = [], m = [], f = []; for ( let e = 0; e < l; e ++ ) {

			const t = e * u - o; for ( let n = 0; n < c; n ++ ) {

				const r = n * h - i; p.push( r, - t, 0 ), m.push( 0, 0, 1 ), f.push( n / a ), f.push( 1 - e / s );

			}

		}

		for ( let e = 0; e < s; e ++ ) for ( let t = 0; t < a; t ++ ) {

			const n = t + c * e, r = t + c * ( e + 1 ), i = t + 1 + c * ( e + 1 ), o = t + 1 + c * e; d.push( n, r, o ), d.push( r, i, o );

		}

		this.setIndex( d ), this.setAttribute( 'position', new Float32BufferAttribute( p, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( m, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( f, 2 ) );

	}

} var alphamap_fragment = '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif', alphamap_pars_fragment = '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif', alphatest_fragment = '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif', aomap_fragment = '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif', aomap_pars_fragment = '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif', begin_vertex = 'vec3 transformed = vec3( position );', beginnormal_vertex = 'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif', bsdfs = 'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif', bumpmap_pars_fragment = '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif', clipping_planes_fragment = '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif', clipping_planes_pars_fragment = '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif', clipping_planes_pars_vertex = '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif', clipping_planes_vertex = '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif', color_fragment = '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif', color_pars_fragment = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif', color_pars_vertex = '#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif', color_vertex = '#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif', common = '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}', cube_uv_reflection_fragment = '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif', defaultnormal_vertex = 'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif', displacementmap_pars_vertex = '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif', displacementmap_vertex = '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif', emissivemap_fragment = '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif', emissivemap_pars_fragment = '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif', encodings_fragment = 'gl_FragColor = linearToOutputTexel( gl_FragColor );', encodings_pars_fragment = '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}', envmap_fragment = '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif', envmap_common_pars_fragment = '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif', envmap_pars_fragment = '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif', envmap_pars_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif', envmap_vertex = '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif', fog_vertex = '#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif', fog_pars_vertex = '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif', fog_fragment = '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif', fog_pars_fragment = '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif', gradientmap_pars_fragment = '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}', lightmap_fragment = '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif', lightmap_pars_fragment = '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif', lights_lambert_vertex = 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif', lights_pars_begin = 'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif', envmap_physical_pars_fragment = '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif', lights_toon_fragment = 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;', lights_toon_pars_fragment = 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)', lights_phong_fragment = 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;', lights_phong_pars_fragment = 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)', lights_physical_fragment = 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif', lights_physical_pars_fragment = 'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}', lights_fragment_begin = '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif', lights_fragment_maps = '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif', lights_fragment_end = '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif', logdepthbuf_fragment = '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif', logdepthbuf_pars_fragment = '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif', logdepthbuf_pars_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif', logdepthbuf_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif', map_fragment = '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif', map_pars_fragment = '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif', map_particle_fragment = '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif', map_particle_pars_fragment = '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif', metalnessmap_fragment = 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif', metalnessmap_pars_fragment = '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif', morphnormal_vertex = '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif', morphtarget_pars_vertex = '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif', morphtarget_vertex = '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif', normal_fragment_begin = '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;', normal_fragment_maps = '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif', normalmap_pars_fragment = '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif', clearcoat_normal_fragment_begin = '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif', clearcoat_normal_fragment_maps = '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif', clearcoat_pars_fragment = '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif', packing = 'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}', premultiplied_alpha_fragment = '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif', project_vertex = 'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;', dithering_fragment = '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif', dithering_pars_fragment = '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif', roughnessmap_fragment = 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif', roughnessmap_pars_fragment = '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif', shadowmap_pars_fragment = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif', shadowmap_pars_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif', shadowmap_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif', shadowmask_pars_fragment = 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}', skinbase_vertex = '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif', skinning_pars_vertex = '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif', skinning_vertex = '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif', skinnormal_vertex = '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif', specularmap_fragment = 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif', specularmap_pars_fragment = '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif', tonemapping_fragment = '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif', tonemapping_pars_fragment = '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }', transmissionmap_fragment = '#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif', transmissionmap_pars_fragment = '#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif', uv_pars_fragment = '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif', uv_pars_vertex = '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif', uv_vertex = '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif', uv2_pars_fragment = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif', uv2_pars_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif', uv2_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif', worldpos_vertex = '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif', background_frag = 'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}', background_vert = 'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}', cube_frag = '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}', cube_vert = 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}', depth_frag = '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}', depth_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}', distanceRGBA_frag = '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}', distanceRGBA_vert = '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}', equirect_frag = 'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}', equirect_vert = 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}', linedashed_frag = 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}', linedashed_vert = 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}', meshbasic_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshbasic_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}', meshlambert_frag = 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshlambert_vert = '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}', meshmatcap_frag = '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshmatcap_vert = '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}', meshtoon_frag = '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshtoon_vert = '#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}', meshphong_frag = '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshphong_vert = '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}', meshphysical_frag = '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}', meshphysical_vert = '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}', normal_frag = '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}', normal_vert = '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}', points_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}', points_vert = 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}', shadow_frag = 'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}', shadow_vert = '#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}', sprite_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}', sprite_vert = 'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}'; const ShaderChunk = { alphamap_fragment: alphamap_fragment, alphamap_pars_fragment: alphamap_pars_fragment, alphatest_fragment: alphatest_fragment, aomap_fragment: aomap_fragment, aomap_pars_fragment: aomap_pars_fragment, begin_vertex: begin_vertex, beginnormal_vertex: beginnormal_vertex, bsdfs: bsdfs, bumpmap_pars_fragment: bumpmap_pars_fragment, clipping_planes_fragment: clipping_planes_fragment, clipping_planes_pars_fragment: clipping_planes_pars_fragment, clipping_planes_pars_vertex: clipping_planes_pars_vertex, clipping_planes_vertex: clipping_planes_vertex, color_fragment: color_fragment, color_pars_fragment: color_pars_fragment, color_pars_vertex: color_pars_vertex, color_vertex: color_vertex, common: common, cube_uv_reflection_fragment: cube_uv_reflection_fragment, defaultnormal_vertex: defaultnormal_vertex, displacementmap_pars_vertex: displacementmap_pars_vertex, displacementmap_vertex: displacementmap_vertex, emissivemap_fragment: emissivemap_fragment, emissivemap_pars_fragment: emissivemap_pars_fragment, encodings_fragment: encodings_fragment, encodings_pars_fragment: encodings_pars_fragment, envmap_fragment: envmap_fragment, envmap_common_pars_fragment: envmap_common_pars_fragment, envmap_pars_fragment: envmap_pars_fragment, envmap_pars_vertex: envmap_pars_vertex, envmap_physical_pars_fragment: envmap_physical_pars_fragment, envmap_vertex: envmap_vertex, fog_vertex: fog_vertex, fog_pars_vertex: fog_pars_vertex, fog_fragment: fog_fragment, fog_pars_fragment: fog_pars_fragment, gradientmap_pars_fragment: gradientmap_pars_fragment, lightmap_fragment: lightmap_fragment, lightmap_pars_fragment: lightmap_pars_fragment, lights_lambert_vertex: lights_lambert_vertex, lights_pars_begin: lights_pars_begin, lights_toon_fragment: lights_toon_fragment, lights_toon_pars_fragment: lights_toon_pars_fragment, lights_phong_fragment: lights_phong_fragment, lights_phong_pars_fragment: lights_phong_pars_fragment, lights_physical_fragment: lights_physical_fragment, lights_physical_pars_fragment: lights_physical_pars_fragment, lights_fragment_begin: lights_fragment_begin, lights_fragment_maps: lights_fragment_maps, lights_fragment_end: lights_fragment_end, logdepthbuf_fragment: logdepthbuf_fragment, logdepthbuf_pars_fragment: logdepthbuf_pars_fragment, logdepthbuf_pars_vertex: logdepthbuf_pars_vertex, logdepthbuf_vertex: logdepthbuf_vertex, map_fragment: map_fragment, map_pars_fragment: map_pars_fragment, map_particle_fragment: map_particle_fragment, map_particle_pars_fragment: map_particle_pars_fragment, metalnessmap_fragment: metalnessmap_fragment, metalnessmap_pars_fragment: metalnessmap_pars_fragment, morphnormal_vertex: morphnormal_vertex, morphtarget_pars_vertex: morphtarget_pars_vertex, morphtarget_vertex: morphtarget_vertex, normal_fragment_begin: normal_fragment_begin, normal_fragment_maps: normal_fragment_maps, normalmap_pars_fragment: normalmap_pars_fragment, clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps, clearcoat_pars_fragment: clearcoat_pars_fragment, packing: packing, premultiplied_alpha_fragment: premultiplied_alpha_fragment, project_vertex: project_vertex, dithering_fragment: dithering_fragment, dithering_pars_fragment: dithering_pars_fragment, roughnessmap_fragment: roughnessmap_fragment, roughnessmap_pars_fragment: roughnessmap_pars_fragment, shadowmap_pars_fragment: shadowmap_pars_fragment, shadowmap_pars_vertex: shadowmap_pars_vertex, shadowmap_vertex: shadowmap_vertex, shadowmask_pars_fragment: shadowmask_pars_fragment, skinbase_vertex: skinbase_vertex, skinning_pars_vertex: skinning_pars_vertex, skinning_vertex: skinning_vertex, skinnormal_vertex: skinnormal_vertex, specularmap_fragment: specularmap_fragment, specularmap_pars_fragment: specularmap_pars_fragment, tonemapping_fragment: tonemapping_fragment, tonemapping_pars_fragment: tonemapping_pars_fragment, transmissionmap_fragment: transmissionmap_fragment, transmissionmap_pars_fragment: transmissionmap_pars_fragment, uv_pars_fragment: uv_pars_fragment, uv_pars_vertex: uv_pars_vertex, uv_vertex: uv_vertex, uv2_pars_fragment: uv2_pars_fragment, uv2_pars_vertex: uv2_pars_vertex, uv2_vertex: uv2_vertex, worldpos_vertex: worldpos_vertex, background_frag: background_frag, background_vert: background_vert, cube_frag: cube_frag, cube_vert: cube_vert, depth_frag: depth_frag, depth_vert: depth_vert, distanceRGBA_frag: distanceRGBA_frag, distanceRGBA_vert: distanceRGBA_vert, equirect_frag: equirect_frag, equirect_vert: equirect_vert, linedashed_frag: linedashed_frag, linedashed_vert: linedashed_vert, meshbasic_frag: meshbasic_frag, meshbasic_vert: meshbasic_vert, meshlambert_frag: meshlambert_frag, meshlambert_vert: meshlambert_vert, meshmatcap_frag: meshmatcap_frag, meshmatcap_vert: meshmatcap_vert, meshtoon_frag: meshtoon_frag, meshtoon_vert: meshtoon_vert, meshphong_frag: meshphong_frag, meshphong_vert: meshphong_vert, meshphysical_frag: meshphysical_frag, meshphysical_vert: meshphysical_vert, normal_frag: normal_frag, normal_vert: normal_vert, points_frag: points_frag, points_vert: points_vert, shadow_frag: shadow_frag, shadow_vert: shadow_vert, sprite_frag: sprite_frag, sprite_vert: sprite_vert }, UniformsLib = { common: { diffuse: { value: new Color( 15658734 ) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Matrix3() }, uv2Transform: { value: new Matrix3() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: - 1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Vector2( 1, 1 ) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color( 16777215 ) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color( 15658734 ) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Matrix3() } }, sprite: { diffuse: { value: new Color( 15658734 ) }, opacity: { value: 1 }, center: { value: new Vector2( .5, .5 ) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Matrix3() } } }, ShaderLib = { basic: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog ] ), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color( 0 ) } } ] ), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color( 0 ) }, specular: { value: new Color( 1118481 ) }, shininess: { value: 30 } } ] ), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color( 0 ) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } } ] ), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color( 0 ) } } ] ), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } } ] ), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: mergeUniforms( [ UniformsLib.points, UniformsLib.fog ] ), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } } ] ), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.displacementmap ] ), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } } ] ), vertexShader: ShaderChunk.normal_vert, fragmentShader: ShaderChunk.normal_frag }, sprite: { uniforms: mergeUniforms( [ UniformsLib.sprite, UniformsLib.fog ] ), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3() }, t2D: { value: null } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, cube: { uniforms: mergeUniforms( [ UniformsLib.envmap, { opacity: { value: 1 } } ] ), vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms( [ UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } } ] ), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms( [ UniformsLib.lights, UniformsLib.fog, { color: { value: new Color( 0 ) }, opacity: { value: 1 } } ] ), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } }; function WebGLBackground( e, t, n, r, i ) {

	const o = new Color( 0 ); let a, s, c = 0, l = null, h = 0, u = null; function d( e, t ) {

		n.buffers.color.setClear( e.r, e.g, e.b, t, i );

	}

	return { getClearColor: function () {

		return o;

	}, setClearColor: function ( e, t = 1 ) {

		o.set( e ), d( o, c = t );

	}, getClearAlpha: function () {

		return c;

	}, setClearAlpha: function ( e ) {

		d( o, c = e );

	}, render: function ( n, i, p, m ) {

		let f = ! 0 === i.isScene ? i.background : null; f && f.isTexture && ( f = t.get( f ) ); const g = e.xr, v = g.getSession && g.getSession(); v && 'additive' === v.environmentBlendMode && ( f = null ), null === f ? d( o, c ) : f && f.isColor && ( d( f, 1 ), m = ! 0 ), ( e.autoClear || m ) && e.clear( e.autoClearColor, e.autoClearDepth, e.autoClearStencil ), f && ( f.isCubeTexture || f.isWebGLCubeRenderTarget || f.mapping === CubeUVReflectionMapping ) ? ( void 0 === s && ( ( s = new Mesh( new BoxBufferGeometry( 1, 1, 1 ), new ShaderMaterial( { name: 'BackgroundCubeMaterial', uniforms: cloneUniforms( ShaderLib.cube.uniforms ), vertexShader: ShaderLib.cube.vertexShader, fragmentShader: ShaderLib.cube.fragmentShader, side: BackSide, depthTest: ! 1, depthWrite: ! 1, fog: ! 1 } ) ) ).geometry.deleteAttribute( 'normal' ), s.geometry.deleteAttribute( 'uv' ), s.onBeforeRender = function ( e, t, n ) {

			this.matrixWorld.copyPosition( n.matrixWorld );

		}, Object.defineProperty( s.material, 'envMap', { get: function () {

			return this.uniforms.envMap.value;

		} } ), r.update( s ) ), f.isWebGLCubeRenderTarget && ( f = f.texture ), s.material.uniforms.envMap.value = f, s.material.uniforms.flipEnvMap.value = f.isCubeTexture && f._needsFlipEnvMap ? - 1 : 1, l === f && h === f.version && u === e.toneMapping || ( s.material.needsUpdate = ! 0, l = f, h = f.version, u = e.toneMapping ), n.unshift( s, s.geometry, s.material, 0, 0, null ) ) : f && f.isTexture && ( void 0 === a && ( ( a = new Mesh( new PlaneBufferGeometry( 2, 2 ), new ShaderMaterial( { name: 'BackgroundMaterial', uniforms: cloneUniforms( ShaderLib.background.uniforms ), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: ! 1, depthWrite: ! 1, fog: ! 1 } ) ) ).geometry.deleteAttribute( 'normal' ), Object.defineProperty( a.material, 'map', { get: function () {

			return this.uniforms.t2D.value;

		} } ), r.update( a ) ), a.material.uniforms.t2D.value = f, ! 0 === f.matrixAutoUpdate && f.updateMatrix(), a.material.uniforms.uvTransform.value.copy( f.matrix ), l === f && h === f.version && u === e.toneMapping || ( a.material.needsUpdate = ! 0, l = f, h = f.version, u = e.toneMapping ), n.unshift( a, a.geometry, a.material, 0, 0, null ) );

	} };

}

function WebGLBindingStates( e, t, n, r ) {

	const i = e.getParameter( 34921 ), o = r.isWebGL2 ? null : t.get( 'OES_vertex_array_object' ), a = r.isWebGL2 || null !== o, s = {}, c = d( null ); let l = c; function h( t ) {

		return r.isWebGL2 ? e.bindVertexArray( t ) : o.bindVertexArrayOES( t );

	}

	function u( t ) {

		return r.isWebGL2 ? e.deleteVertexArray( t ) : o.deleteVertexArrayOES( t );

	}

	function d( e ) {

		const t = [], n = [], r = []; for ( let e = 0; e < i; e ++ )t[ e ] = 0, n[ e ] = 0, r[ e ] = 0; return { geometry: null, program: null, wireframe: ! 1, newAttributes: t, enabledAttributes: n, attributeDivisors: r, object: e, attributes: {}, index: null };

	}

	function p() {

		const e = l.newAttributes; for ( let t = 0, n = e.length; t < n; t ++ )e[ t ] = 0;

	}

	function m( e ) {

		f( e, 0 );

	}

	function f( n, i ) {

		const o = l.newAttributes, a = l.enabledAttributes, s = l.attributeDivisors; if ( o[ n ] = 1, 0 === a[ n ] && ( e.enableVertexAttribArray( n ), a[ n ] = 1 ), s[ n ] !== i ) {

			( r.isWebGL2 ? e : t.get( 'ANGLE_instanced_arrays' ) )[ r.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( n, i ), s[ n ] = i;

		}

	}

	function g() {

		const t = l.newAttributes, n = l.enabledAttributes; for ( let r = 0, i = n.length; r < i; r ++ )n[ r ] !== t[ r ] && ( e.disableVertexAttribArray( r ), n[ r ] = 0 );

	}

	function v( t, n, i, o, a, s ) {

		! 0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer( t, n, i, o, a, s ) : e.vertexAttribIPointer( t, n, i, a, s );

	}

	function y() {

		_(), l !== c && h( ( l = c ).object );

	}

	function _() {

		c.geometry = null, c.program = null, c.wireframe = ! 1;

	}

	return { setup: function ( i, c, u, y, _ ) {

		let x = ! 1; if ( a ) {

			const t = function ( t, n, i ) {

				const a = ! 0 === i.wireframe; let c = s[ t.id ]; void 0 === c && ( c = {}, s[ t.id ] = c ); let l = c[ n.id ]; void 0 === l && ( l = {}, c[ n.id ] = l ); let h = l[ a ]; return void 0 === h && ( h = d( r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES() ), l[ a ] = h ), h;

			}( y, u, c ); l !== t && h( ( l = t ).object ), ( x = function ( e, t ) {

				const n = l.attributes, r = e.attributes; let i = 0; for ( const e in r ) {

					const t = n[ e ], o = r[ e ]; if ( void 0 === t ) return ! 0; if ( t.attribute !== o ) return ! 0; if ( t.data !== o.data ) return ! 0; i ++;

				}

				return l.attributesNum !== i || l.index !== t;

			}( y, _ ) ) && function ( e, t ) {

				const n = {}, r = e.attributes; let i = 0; for ( const e in r ) {

					const t = r[ e ], o = {}; o.attribute = t, t.data && ( o.data = t.data ), n[ e ] = o, i ++;

				}

				l.attributes = n, l.attributesNum = i, l.index = t;

			}( y, _ );

		} else {

			const e = ! 0 === c.wireframe; l.geometry === y.id && l.program === u.id && l.wireframe === e || ( l.geometry = y.id, l.program = u.id, l.wireframe = e, x = ! 0 );

		}

		! 0 === i.isInstancedMesh && ( x = ! 0 ), null !== _ && n.update( _, 34963 ), x && ( function ( i, o, a, s ) {

			if ( ! 1 === r.isWebGL2 && ( i.isInstancedMesh || s.isInstancedBufferGeometry ) && null === t.get( 'ANGLE_instanced_arrays' ) ) return; p(); const c = s.attributes, l = a.getAttributes(), h = o.defaultAttributeValues; for ( const t in l ) {

				const r = l[ t ]; if ( r >= 0 ) {

					const o = c[ t ]; if ( void 0 !== o ) {

						const t = o.normalized, i = o.itemSize, a = n.get( o ); if ( void 0 === a ) continue; const c = a.buffer, l = a.type, h = a.bytesPerElement; if ( o.isInterleavedBufferAttribute ) {

							const n = o.data, a = n.stride, u = o.offset; n && n.isInstancedInterleavedBuffer ? ( f( r, n.meshPerAttribute ), void 0 === s._maxInstanceCount && ( s._maxInstanceCount = n.meshPerAttribute * n.count ) ) : m( r ), e.bindBuffer( 34962, c ), v( r, i, l, t, a * h, u * h );

						} else o.isInstancedBufferAttribute ? ( f( r, o.meshPerAttribute ), void 0 === s._maxInstanceCount && ( s._maxInstanceCount = o.meshPerAttribute * o.count ) ) : m( r ), e.bindBuffer( 34962, c ), v( r, i, l, t, 0, 0 );

					} else if ( 'instanceMatrix' === t ) {

						const t = n.get( i.instanceMatrix ); if ( void 0 === t ) continue; const o = t.buffer, a = t.type; f( r + 0, 1 ), f( r + 1, 1 ), f( r + 2, 1 ), f( r + 3, 1 ), e.bindBuffer( 34962, o ), e.vertexAttribPointer( r + 0, 4, a, ! 1, 64, 0 ), e.vertexAttribPointer( r + 1, 4, a, ! 1, 64, 16 ), e.vertexAttribPointer( r + 2, 4, a, ! 1, 64, 32 ), e.vertexAttribPointer( r + 3, 4, a, ! 1, 64, 48 );

					} else if ( 'instanceColor' === t ) {

						const t = n.get( i.instanceColor ); if ( void 0 === t ) continue; const o = t.buffer, a = t.type; f( r, 1 ), e.bindBuffer( 34962, o ), e.vertexAttribPointer( r, 3, a, ! 1, 12, 0 );

					} else if ( void 0 !== h ) {

						const n = h[ t ]; if ( void 0 !== n ) switch ( n.length ) {

							case 2:e.vertexAttrib2fv( r, n ); break; case 3:e.vertexAttrib3fv( r, n ); break; case 4:e.vertexAttrib4fv( r, n ); break; default:e.vertexAttrib1fv( r, n );

						}

					}

				}

			}

			g();

		}( i, c, u, y ), null !== _ && e.bindBuffer( 34963, n.get( _ ).buffer ) );

	}, reset: y, resetDefaultState: _, dispose: function () {

		y(); for ( const e in s ) {

			const t = s[ e ]; for ( const e in t ) {

				const n = t[ e ]; for ( const e in n )u( n[ e ].object ), delete n[ e ]; delete t[ e ];

			}

			delete s[ e ];

		}

	}, releaseStatesOfGeometry: function ( e ) {

		if ( void 0 === s[ e.id ] ) return; const t = s[ e.id ]; for ( const e in t ) {

			const n = t[ e ]; for ( const e in n )u( n[ e ].object ), delete n[ e ]; delete t[ e ];

		}

		delete s[ e.id ];

	}, releaseStatesOfProgram: function ( e ) {

		for ( const t in s ) {

			const n = s[ t ]; if ( void 0 === n[ e.id ] ) continue; const r = n[ e.id ]; for ( const e in r )u( r[ e ].object ), delete r[ e ]; delete n[ e.id ];

		}

	}, initAttributes: p, enableAttribute: m, disableUnusedAttributes: g };

}

function WebGLBufferRenderer( e, t, n, r ) {

	const i = r.isWebGL2; let o; this.setMode = function ( e ) {

		o = e;

	}, this.render = function ( t, r ) {

		e.drawArrays( o, t, r ), n.update( r, o, 1 );

	}, this.renderInstances = function ( r, a, s ) {

		if ( 0 === s ) return; let c, l; if ( i )c = e, l = 'drawArraysInstanced'; else if ( l = 'drawArraysInstancedANGLE', null === ( c = t.get( 'ANGLE_instanced_arrays' ) ) ) return void console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' ); c[ l ]( o, r, a, s ), n.update( a, o, s );

	};

}

function WebGLCapabilities( e, t, n ) {

	let r; function i( t ) {

		if ( 'highp' === t ) {

			if ( e.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 && e.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) return 'highp'; t = 'mediump';

		}

		return 'mediump' === t && e.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 && e.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ? 'mediump' : 'lowp';

	}

	const o = 'undefined' != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || 'undefined' != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let a = void 0 !== n.precision ? n.precision : 'highp'; const s = i( a ); s !== a && ( console.warn( 'THREE.WebGLRenderer:', a, 'not supported, using', s, 'instead.' ), a = s ); const c = ! 0 === n.logarithmicDepthBuffer, l = e.getParameter( 34930 ), h = e.getParameter( 35660 ), u = e.getParameter( 3379 ), d = e.getParameter( 34076 ), p = e.getParameter( 34921 ), m = e.getParameter( 36347 ), f = e.getParameter( 36348 ), g = e.getParameter( 36349 ), v = h > 0, y = o || !! t.get( 'OES_texture_float' ); return { isWebGL2: o, getMaxAnisotropy: function () {

		if ( void 0 !== r ) return r; const n = t.get( 'EXT_texture_filter_anisotropic' ); return r = null !== n ? e.getParameter( n.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	}, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: m, maxVaryings: f, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: o ? e.getParameter( 36183 ) : 0 };

}

function WebGLClipping( e ) {

	const t = this; let n = null, r = 0, i = ! 1, o = ! 1; const a = new Plane(), s = new Matrix3(), c = { value: null, needsUpdate: ! 1 }; function l() {

		c.value !== n && ( c.value = n, c.needsUpdate = r > 0 ), t.numPlanes = r, t.numIntersection = 0;

	}

	function h( e, n, r, i ) {

		const o = null !== e ? e.length : 0; let l = null; if ( 0 !== o ) {

			if ( l = c.value, ! 0 !== i || null === l ) {

				const t = r + 4 * o, i = n.matrixWorldInverse; s.getNormalMatrix( i ), ( null === l || l.length < t ) && ( l = new Float32Array( t ) ); for ( let t = 0, n = r; t !== o; ++ t, n += 4 )a.copy( e[ t ] ).applyMatrix4( i, s ), a.normal.toArray( l, n ), l[ n + 3 ] = a.constant;

			}

			c.value = l, c.needsUpdate = ! 0;

		}

		return t.numPlanes = o, t.numIntersection = 0, l;

	}

	this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function ( e, t, o ) {

		const a = 0 !== e.length || t || 0 !== r || i; return i = t, n = h( e, o, 0 ), r = e.length, a;

	}, this.beginShadows = function () {

		o = ! 0, h( null );

	}, this.endShadows = function () {

		o = ! 1, l();

	}, this.setState = function ( t, a, s ) {

		const u = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, m = e.get( t ); if ( ! i || null === u || 0 === u.length || o && ! p )o ? h( null ) : l(); else {

			const e = o ? 0 : r, t = 4 * e; let i = m.clippingState || null; c.value = i, i = h( u, a, t, s ); for ( let e = 0; e !== t; ++ e )i[ e ] = n[ e ]; m.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e;

		}

	};

}

function WebGLCubeMaps( e ) {

	let t = new WeakMap(); function n( e, t ) {

		return t === EquirectangularReflectionMapping ? e.mapping = CubeReflectionMapping : t === EquirectangularRefractionMapping && ( e.mapping = CubeRefractionMapping ), e;

	}

	function r( e ) {

		const n = e.target; n.removeEventListener( 'dispose', r ); const i = t.get( n ); void 0 !== i && ( t.delete( n ), i.dispose() );

	}

	return { get: function ( i ) {

		if ( i && i.isTexture ) {

			const o = i.mapping; if ( o === EquirectangularReflectionMapping || o === EquirectangularRefractionMapping ) {

				if ( t.has( i ) ) return n( t.get( i ).texture, i.mapping ); {

					const o = i.image; if ( o && o.height > 0 ) {

						const a = e.getRenderList(), s = e.getRenderTarget(), c = new WebGLCubeRenderTarget( o.height / 2 ); return c.fromEquirectangularTexture( e, i ), t.set( i, c ), e.setRenderTarget( s ), e.setRenderList( a ), i.addEventListener( 'dispose', r ), n( c.texture, i.mapping );

					}

					return null;

				}

			}

		}

		return i;

	}, dispose: function () {

		t = new WeakMap();

	} };

}

function WebGLExtensions( e ) {

	const t = {}; return { has: function ( n ) {

		if ( void 0 !== t[ n ] ) return null !== t[ n ]; let r; switch ( n ) {

			case 'WEBGL_depth_texture':r = e.getExtension( 'WEBGL_depth_texture' ) || e.getExtension( 'MOZ_WEBGL_depth_texture' ) || e.getExtension( 'WEBKIT_WEBGL_depth_texture' ); break; case 'EXT_texture_filter_anisotropic':r = e.getExtension( 'EXT_texture_filter_anisotropic' ) || e.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || e.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' ); break; case 'WEBGL_compressed_texture_s3tc':r = e.getExtension( 'WEBGL_compressed_texture_s3tc' ) || e.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || e.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' ); break; case 'WEBGL_compressed_texture_pvrtc':r = e.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || e.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' ); break; default:r = e.getExtension( n );

		}

		return t[ n ] = r, null !== r;

	}, get: function ( e ) {

		return this.has( e ) || console.warn( 'THREE.WebGLRenderer: ' + e + ' extension not supported.' ), t[ e ];

	} };

}

function WebGLGeometries( e, t, n, r ) {

	const i = new WeakMap(), o = new WeakMap(); function a( e ) {

		const s = e.target, c = i.get( s ); null !== c.index && t.remove( c.index ); for ( const e in c.attributes )t.remove( c.attributes[ e ] ); s.removeEventListener( 'dispose', a ), i.delete( s ); const l = o.get( c ); l && ( t.remove( l ), o.delete( c ) ), r.releaseStatesOfGeometry( c ), ! 0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries --;

	}

	function s( e ) {

		const n = [], r = e.index, i = e.attributes.position; let a = 0; if ( null !== r ) {

			const e = r.array; a = r.version; for ( let t = 0, r = e.length; t < r; t += 3 ) {

				const r = e[ t + 0 ], i = e[ t + 1 ], o = e[ t + 2 ]; n.push( r, i, i, o, o, r );

			}

		} else {

			const e = i.array; a = i.version; for ( let t = 0, r = e.length / 3 - 1; t < r; t += 3 ) {

				const e = t + 0, r = t + 1, i = t + 2; n.push( e, r, r, i, i, e );

			}

		}

		const s = new ( arrayMax( n ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( n, 1 ); s.version = a; const c = o.get( e ); c && t.remove( c ), o.set( e, s );

	}

	return { get: function ( e, t ) {

		let r = i.get( t ); return r || ( t.addEventListener( 'dispose', a ), t.isBufferGeometry ? r = t : t.isGeometry && ( void 0 === t._bufferGeometry && ( t._bufferGeometry = ( new BufferGeometry() ).setFromObject( e ) ), r = t._bufferGeometry ), i.set( t, r ), n.memory.geometries ++, r );

	}, update: function ( e ) {

		const n = e.attributes; for ( const e in n )t.update( n[ e ], 34962 ); const r = e.morphAttributes; for ( const e in r ) {

			const n = r[ e ]; for ( let e = 0, r = n.length; e < r; e ++ )t.update( n[ e ], 34962 );

		}

	}, getWireframeAttribute: function ( e ) {

		const t = o.get( e ); if ( t ) {

			const n = e.index; null !== n && t.version < n.version && s( e );

		} else s( e ); return o.get( e );

	} };

}

function WebGLIndexedBufferRenderer( e, t, n, r ) {

	const i = r.isWebGL2; let o, a, s; this.setMode = function ( e ) {

		o = e;

	}, this.setIndex = function ( e ) {

		a = e.type, s = e.bytesPerElement;

	}, this.render = function ( t, r ) {

		e.drawElements( o, r, a, t * s ), n.update( r, o, 1 );

	}, this.renderInstances = function ( r, c, l ) {

		if ( 0 === l ) return; let h, u; if ( i )h = e, u = 'drawElementsInstanced'; else if ( u = 'drawElementsInstancedANGLE', null === ( h = t.get( 'ANGLE_instanced_arrays' ) ) ) return void console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' ); h[ u ]( o, c, a, r * s, l ), n.update( c, o, l );

	};

}

function WebGLInfo( e ) {

	const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: ! 0, reset: function () {

		t.frame ++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;

	}, update: function ( e, n, r ) {

		switch ( t.calls ++, n ) {

			case 4:t.triangles += r * ( e / 3 ); break; case 1:t.lines += r * ( e / 2 ); break; case 3:t.lines += r * ( e - 1 ); break; case 2:t.lines += r * e; break; case 0:t.points += r * e; break; default:console.error( 'THREE.WebGLInfo: Unknown draw mode:', n );

		}

	} };

}

function numericalSort( e, t ) {

	return e[ 0 ] - t[ 0 ];

}

function absNumericalSort( e, t ) {

	return Math.abs( t[ 1 ] ) - Math.abs( e[ 1 ] );

}

function WebGLMorphtargets( e ) {

	const t = {}, n = new Float32Array( 8 ), r = []; for ( let e = 0; e < 8; e ++ )r[ e ] = [ e, 0 ]; return { update: function ( i, o, a, s ) {

		const c = i.morphTargetInfluences, l = void 0 === c ? 0 : c.length; let h = t[ o.id ]; if ( void 0 === h ) {

			h = []; for ( let e = 0; e < l; e ++ )h[ e ] = [ e, 0 ]; t[ o.id ] = h;

		}

		for ( let e = 0; e < l; e ++ ) {

			const t = h[ e ]; t[ 0 ] = e, t[ 1 ] = c[ e ];

		}

		h.sort( absNumericalSort ); for ( let e = 0; e < 8; e ++ )e < l && h[ e ][ 1 ] ? ( r[ e ][ 0 ] = h[ e ][ 0 ], r[ e ][ 1 ] = h[ e ][ 1 ] ) : ( r[ e ][ 0 ] = Number.MAX_SAFE_INTEGER, r[ e ][ 1 ] = 0 ); r.sort( numericalSort ); const u = a.morphTargets && o.morphAttributes.position, d = a.morphNormals && o.morphAttributes.normal; let p = 0; for ( let e = 0; e < 8; e ++ ) {

			const t = r[ e ], i = t[ 0 ], a = t[ 1 ]; i !== Number.MAX_SAFE_INTEGER && a ? ( u && o.getAttribute( 'morphTarget' + e ) !== u[ i ] && o.setAttribute( 'morphTarget' + e, u[ i ] ), d && o.getAttribute( 'morphNormal' + e ) !== d[ i ] && o.setAttribute( 'morphNormal' + e, d[ i ] ), n[ e ] = a, p += a ) : ( u && ! 0 === o.hasAttribute( 'morphTarget' + e ) && o.deleteAttribute( 'morphTarget' + e ), d && ! 0 === o.hasAttribute( 'morphNormal' + e ) && o.deleteAttribute( 'morphNormal' + e ), n[ e ] = 0 );

		}

		const m = o.morphTargetsRelative ? 1 : 1 - p; s.getUniforms().setValue( e, 'morphTargetBaseInfluence', m ), s.getUniforms().setValue( e, 'morphTargetInfluences', n );

	} };

}

function WebGLObjects( e, t, n, r ) {

	let i = new WeakMap(); function o( e ) {

		const t = e.target; t.removeEventListener( 'dispose', o ), n.remove( t.instanceMatrix ), null !== t.instanceColor && n.remove( t.instanceColor );

	}

	return { update: function ( e ) {

		const a = r.render.frame, s = e.geometry, c = t.get( e, s ); return i.get( c ) !== a && ( s.isGeometry && c.updateFromObject( e ), t.update( c ), i.set( c, a ) ), e.isInstancedMesh && ( ! 1 === e.hasEventListener( 'dispose', o ) && e.addEventListener( 'dispose', o ), n.update( e.instanceMatrix, 34962 ), null !== e.instanceColor && n.update( e.instanceColor, 34962 ) ), c;

	}, dispose: function () {

		i = new WeakMap();

	} };

}

function DataTexture2DArray( e = null, t = 1, n = 1, r = 1 ) {

	Texture.call( this, null ), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = ! 1, this.flipY = ! 1, this.needsUpdate = ! 0;

}

function DataTexture3D( e = null, t = 1, n = 1, r = 1 ) {

	Texture.call( this, null ), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = ! 1, this.flipY = ! 1, this.needsUpdate = ! 0;

}

ShaderLib.physical = { uniforms: mergeUniforms( [ ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Vector2( 1, 1 ) }, clearcoatNormalMap: { value: null }, sheen: { value: new Color( 0 ) }, transmission: { value: 0 }, transmissionMap: { value: null } } ] ), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, DataTexture2DArray.prototype = Object.create( Texture.prototype ), DataTexture2DArray.prototype.constructor = DataTexture2DArray, DataTexture2DArray.prototype.isDataTexture2DArray = ! 0, DataTexture3D.prototype = Object.create( Texture.prototype ), DataTexture3D.prototype.constructor = DataTexture3D, DataTexture3D.prototype.isDataTexture3D = ! 0; const emptyTexture = new Texture(), emptyTexture2dArray = new DataTexture2DArray(), emptyTexture3d = new DataTexture3D(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array( 16 ), mat3array = new Float32Array( 9 ), mat2array = new Float32Array( 4 ); function flatten( e, t, n ) {

	const r = e[ 0 ]; if ( r <= 0 || r > 0 ) return e; const i = t * n; let o = arrayCacheF32[ i ]; if ( void 0 === o && ( o = new Float32Array( i ), arrayCacheF32[ i ] = o ), 0 !== t ) {

		r.toArray( o, 0 ); for ( let r = 1, i = 0; r !== t; ++ r )i += n, e[ r ].toArray( o, i );

	}

	return o;

}

function arraysEqual( e, t ) {

	if ( e.length !== t.length ) return ! 1; for ( let n = 0, r = e.length; n < r; n ++ ) if ( e[ n ] !== t[ n ] ) return ! 1; return ! 0;

}

function copyArray( e, t ) {

	for ( let n = 0, r = t.length; n < r; n ++ )e[ n ] = t[ n ];

}

function allocTexUnits( e, t ) {

	let n = arrayCacheI32[ t ]; void 0 === n && ( n = new Int32Array( t ), arrayCacheI32[ t ] = n ); for ( let r = 0; r !== t; ++ r )n[ r ] = e.allocateTextureUnit(); return n;

}

function setValueV1f( e, t ) {

	const n = this.cache; n[ 0 ] !== t && ( e.uniform1f( this.addr, t ), n[ 0 ] = t );

}

function setValueV2f( e, t ) {

	const n = this.cache; if ( void 0 !== t.x )n[ 0 ] === t.x && n[ 1 ] === t.y || ( e.uniform2f( this.addr, t.x, t.y ), n[ 0 ] = t.x, n[ 1 ] = t.y ); else {

		if ( arraysEqual( n, t ) ) return; e.uniform2fv( this.addr, t ), copyArray( n, t );

	}

}

function setValueV3f( e, t ) {

	const n = this.cache; if ( void 0 !== t.x )n[ 0 ] === t.x && n[ 1 ] === t.y && n[ 2 ] === t.z || ( e.uniform3f( this.addr, t.x, t.y, t.z ), n[ 0 ] = t.x, n[ 1 ] = t.y, n[ 2 ] = t.z ); else if ( void 0 !== t.r )n[ 0 ] === t.r && n[ 1 ] === t.g && n[ 2 ] === t.b || ( e.uniform3f( this.addr, t.r, t.g, t.b ), n[ 0 ] = t.r, n[ 1 ] = t.g, n[ 2 ] = t.b ); else {

		if ( arraysEqual( n, t ) ) return; e.uniform3fv( this.addr, t ), copyArray( n, t );

	}

}

function setValueV4f( e, t ) {

	const n = this.cache; if ( void 0 !== t.x )n[ 0 ] === t.x && n[ 1 ] === t.y && n[ 2 ] === t.z && n[ 3 ] === t.w || ( e.uniform4f( this.addr, t.x, t.y, t.z, t.w ), n[ 0 ] = t.x, n[ 1 ] = t.y, n[ 2 ] = t.z, n[ 3 ] = t.w ); else {

		if ( arraysEqual( n, t ) ) return; e.uniform4fv( this.addr, t ), copyArray( n, t );

	}

}

function setValueM2( e, t ) {

	const n = this.cache, r = t.elements; if ( void 0 === r ) {

		if ( arraysEqual( n, t ) ) return; e.uniformMatrix2fv( this.addr, ! 1, t ), copyArray( n, t );

	} else {

		if ( arraysEqual( n, r ) ) return; mat2array.set( r ), e.uniformMatrix2fv( this.addr, ! 1, mat2array ), copyArray( n, r );

	}

}

function setValueM3( e, t ) {

	const n = this.cache, r = t.elements; if ( void 0 === r ) {

		if ( arraysEqual( n, t ) ) return; e.uniformMatrix3fv( this.addr, ! 1, t ), copyArray( n, t );

	} else {

		if ( arraysEqual( n, r ) ) return; mat3array.set( r ), e.uniformMatrix3fv( this.addr, ! 1, mat3array ), copyArray( n, r );

	}

}

function setValueM4( e, t ) {

	const n = this.cache, r = t.elements; if ( void 0 === r ) {

		if ( arraysEqual( n, t ) ) return; e.uniformMatrix4fv( this.addr, ! 1, t ), copyArray( n, t );

	} else {

		if ( arraysEqual( n, r ) ) return; mat4array.set( r ), e.uniformMatrix4fv( this.addr, ! 1, mat4array ), copyArray( n, r );

	}

}

function setValueT1( e, t, n ) {

	const r = this.cache, i = n.allocateTextureUnit(); r[ 0 ] !== i && ( e.uniform1i( this.addr, i ), r[ 0 ] = i ), n.safeSetTexture2D( t || emptyTexture, i );

}

function setValueT2DArray1( e, t, n ) {

	const r = this.cache, i = n.allocateTextureUnit(); r[ 0 ] !== i && ( e.uniform1i( this.addr, i ), r[ 0 ] = i ), n.setTexture2DArray( t || emptyTexture2dArray, i );

}

function setValueT3D1( e, t, n ) {

	const r = this.cache, i = n.allocateTextureUnit(); r[ 0 ] !== i && ( e.uniform1i( this.addr, i ), r[ 0 ] = i ), n.setTexture3D( t || emptyTexture3d, i );

}

function setValueT6( e, t, n ) {

	const r = this.cache, i = n.allocateTextureUnit(); r[ 0 ] !== i && ( e.uniform1i( this.addr, i ), r[ 0 ] = i ), n.safeSetTextureCube( t || emptyCubeTexture, i );

}

function setValueV1i( e, t ) {

	const n = this.cache; n[ 0 ] !== t && ( e.uniform1i( this.addr, t ), n[ 0 ] = t );

}

function setValueV2i( e, t ) {

	const n = this.cache; arraysEqual( n, t ) || ( e.uniform2iv( this.addr, t ), copyArray( n, t ) );

}

function setValueV3i( e, t ) {

	const n = this.cache; arraysEqual( n, t ) || ( e.uniform3iv( this.addr, t ), copyArray( n, t ) );

}

function setValueV4i( e, t ) {

	const n = this.cache; arraysEqual( n, t ) || ( e.uniform4iv( this.addr, t ), copyArray( n, t ) );

}

function setValueV1ui( e, t ) {

	const n = this.cache; n[ 0 ] !== t && ( e.uniform1ui( this.addr, t ), n[ 0 ] = t );

}

function getSingularSetter( e ) {

	switch ( e ) {

		case 5126:return setValueV1f; case 35664:return setValueV2f; case 35665:return setValueV3f; case 35666:return setValueV4f; case 35674:return setValueM2; case 35675:return setValueM3; case 35676:return setValueM4; case 5124:case 35670:return setValueV1i; case 35667:case 35671:return setValueV2i; case 35668:case 35672:return setValueV3i; case 35669:case 35673:return setValueV4i; case 5125:return setValueV1ui; case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1; case 35679:case 36299:case 36307:return setValueT3D1; case 35680:case 36300:case 36308:case 36293:return setValueT6; case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1;

	}

}

function setValueV1fArray( e, t ) {

	e.uniform1fv( this.addr, t );

}

function setValueV1iArray( e, t ) {

	e.uniform1iv( this.addr, t );

}

function setValueV2iArray( e, t ) {

	e.uniform2iv( this.addr, t );

}

function setValueV3iArray( e, t ) {

	e.uniform3iv( this.addr, t );

}

function setValueV4iArray( e, t ) {

	e.uniform4iv( this.addr, t );

}

function setValueV2fArray( e, t ) {

	const n = flatten( t, this.size, 2 ); e.uniform2fv( this.addr, n );

}

function setValueV3fArray( e, t ) {

	const n = flatten( t, this.size, 3 ); e.uniform3fv( this.addr, n );

}

function setValueV4fArray( e, t ) {

	const n = flatten( t, this.size, 4 ); e.uniform4fv( this.addr, n );

}

function setValueM2Array( e, t ) {

	const n = flatten( t, this.size, 4 ); e.uniformMatrix2fv( this.addr, ! 1, n );

}

function setValueM3Array( e, t ) {

	const n = flatten( t, this.size, 9 ); e.uniformMatrix3fv( this.addr, ! 1, n );

}

function setValueM4Array( e, t ) {

	const n = flatten( t, this.size, 16 ); e.uniformMatrix4fv( this.addr, ! 1, n );

}

function setValueT1Array( e, t, n ) {

	const r = t.length, i = allocTexUnits( n, r ); e.uniform1iv( this.addr, i ); for ( let e = 0; e !== r; ++ e )n.safeSetTexture2D( t[ e ] || emptyTexture, i[ e ] );

}

function setValueT6Array( e, t, n ) {

	const r = t.length, i = allocTexUnits( n, r ); e.uniform1iv( this.addr, i ); for ( let e = 0; e !== r; ++ e )n.safeSetTextureCube( t[ e ] || emptyCubeTexture, i[ e ] );

}

function getPureArraySetter( e ) {

	switch ( e ) {

		case 5126:return setValueV1fArray; case 35664:return setValueV2fArray; case 35665:return setValueV3fArray; case 35666:return setValueV4fArray; case 35674:return setValueM2Array; case 35675:return setValueM3Array; case 35676:return setValueM4Array; case 5124:case 35670:return setValueV1iArray; case 35667:case 35671:return setValueV2iArray; case 35668:case 35672:return setValueV3iArray; case 35669:case 35673:return setValueV4iArray; case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array; case 35680:case 36300:case 36308:case 36293:return setValueT6Array;

	}

}

function SingleUniform( e, t, n ) {

	this.id = e, this.addr = n, this.cache = [], this.setValue = getSingularSetter( t.type );

}

function PureArrayUniform( e, t, n ) {

	this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = getPureArraySetter( t.type );

}

function StructuredUniform( e ) {

	this.id = e, this.seq = [], this.map = {};

}

PureArrayUniform.prototype.updateCache = function ( e ) {

	const t = this.cache; e instanceof Float32Array && t.length !== e.length && ( this.cache = new Float32Array( e.length ) ), copyArray( t, e );

}, StructuredUniform.prototype.setValue = function ( e, t, n ) {

	const r = this.seq; for ( let i = 0, o = r.length; i !== o; ++ i ) {

		const o = r[ i ]; o.setValue( e, t[ o.id ], n );

	}

};

const RePathPart = /(\w+)(\])?(\[|\.)?/g; function addUniform( e, t ) {

	e.seq.push( t ), e.map[ t.id ] = t;

}

function parseUniform( e, t, n ) {

	const r = e.name, i = r.length; for ( RePathPart.lastIndex = 0; ; ) {

		const o = RePathPart.exec( r ), a = RePathPart.lastIndex; let s = o[ 1 ]; const c = ']' === o[ 2 ], l = o[ 3 ]; if ( c && ( s |= 0 ), void 0 === l || '[' === l && a + 2 === i ) {

			addUniform( n, void 0 === l ? new SingleUniform( s, e, t ) : new PureArrayUniform( s, e, t ) ); break;

		}

		{

			let e = n.map[ s ]; void 0 === e && addUniform( n, e = new StructuredUniform( s ) ), n = e;

		}

	}

}

function WebGLUniforms( e, t ) {

	this.seq = [], this.map = {}; const n = e.getProgramParameter( t, 35718 ); for ( let r = 0; r < n; ++ r ) {

		const n = e.getActiveUniform( t, r ); parseUniform( n, e.getUniformLocation( t, n.name ), this );

	}

}

function WebGLShader( e, t, n ) {

	const r = e.createShader( t ); return e.shaderSource( r, n ), e.compileShader( r ), r;

}

WebGLUniforms.prototype.setValue = function ( e, t, n, r ) {

	const i = this.map[ t ]; void 0 !== i && i.setValue( e, n, r );

}, WebGLUniforms.prototype.setOptional = function ( e, t, n ) {

	const r = t[ n ]; void 0 !== r && this.setValue( e, n, r );

}, WebGLUniforms.upload = function ( e, t, n, r ) {

	for ( let i = 0, o = t.length; i !== o; ++ i ) {

		const o = t[ i ], a = n[ o.id ]; ! 1 !== a.needsUpdate && o.setValue( e, a.value, r );

	}

}, WebGLUniforms.seqWithValue = function ( e, t ) {

	const n = []; for ( let r = 0, i = e.length; r !== i; ++ r ) {

		const i = e[ r ]; i.id in t && n.push( i );

	}

	return n;

};

let programIdCount = 0; function addLineNumbers( e ) {

	const t = e.split( '\n' ); for ( let e = 0; e < t.length; e ++ )t[ e ] = e + 1 + ': ' + t[ e ]; return t.join( '\n' );

}

function getEncodingComponents( e ) {

	switch ( e ) {

		case LinearEncoding:return [ 'Linear', '( value )' ]; case sRGBEncoding:return [ 'sRGB', '( value )' ]; case RGBEEncoding:return [ 'RGBE', '( value )' ]; case RGBM7Encoding:return [ 'RGBM', '( value, 7.0 )' ]; case RGBM16Encoding:return [ 'RGBM', '( value, 16.0 )' ]; case RGBDEncoding:return [ 'RGBD', '( value, 256.0 )' ]; case GammaEncoding:return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ]; case LogLuvEncoding:return [ 'LogLuv', '( value )' ]; default:return console.warn( 'THREE.WebGLProgram: Unsupported encoding:', e ), [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( e, t, n ) {

	const r = e.getShaderParameter( t, 35713 ), i = e.getShaderInfoLog( t ).trim(); return r && '' === i ? '' : 'THREE.WebGLShader: gl.getShaderInfoLog() ' + n + '\n' + i + addLineNumbers( e.getShaderSource( t ) );

}

function getTexelDecodingFunction( e, t ) {

	const n = getEncodingComponents( t ); return 'vec4 ' + e + '( vec4 value ) { return ' + n[ 0 ] + 'ToLinear' + n[ 1 ] + '; }';

}

function getTexelEncodingFunction( e, t ) {

	const n = getEncodingComponents( t ); return 'vec4 ' + e + '( vec4 value ) { return LinearTo' + n[ 0 ] + n[ 1 ] + '; }';

}

function getToneMappingFunction( e, t ) {

	let n; switch ( t ) {

		case LinearToneMapping:n = 'Linear'; break; case ReinhardToneMapping:n = 'Reinhard'; break; case CineonToneMapping:n = 'OptimizedCineon'; break; case ACESFilmicToneMapping:n = 'ACESFilmic'; break; case CustomToneMapping:n = 'Custom'; break; default:console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', t ), n = 'Linear';

	}

	return 'vec3 ' + e + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }';

}

function generateExtensions( e ) {

	return [ e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || 'physical' === e.shaderID ? '#extension GL_OES_standard_derivatives : enable' : '', ( e.extensionFragDepth || e.logarithmicDepthBuffer ) && e.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', ( e.extensionShaderTextureLOD || e.envMap ) && e.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : '' ].filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( e ) {

	const t = []; for ( const n in e ) {

		const r = e[ n ]; ! 1 !== r && t.push( '#define ' + n + ' ' + r );

	}

	return t.join( '\n' );

}

function fetchAttributeLocations( e, t ) {

	const n = {}, r = e.getProgramParameter( t, 35721 ); for ( let i = 0; i < r; i ++ ) {

		const r = e.getActiveAttrib( t, i ).name; n[ r ] = e.getAttribLocation( t, r );

	}

	return n;

}

function filterEmptyLine( e ) {

	return '' !== e;

}

function replaceLightNums( e, t ) {

	return e.replace( /NUM_DIR_LIGHTS/g, t.numDirLights ).replace( /NUM_SPOT_LIGHTS/g, t.numSpotLights ).replace( /NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights ).replace( /NUM_POINT_LIGHTS/g, t.numPointLights ).replace( /NUM_HEMI_LIGHTS/g, t.numHemiLights ).replace( /NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows ).replace( /NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows ).replace( /NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows );

}

function replaceClippingPlaneNums( e, t ) {

	return e.replace( /NUM_CLIPPING_PLANES/g, t.numClippingPlanes ).replace( /UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection );

}

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm; function resolveIncludes( e ) {

	return e.replace( includePattern, includeReplacer );

}

function includeReplacer( e, t ) {

	const n = ShaderChunk[ t ]; if ( void 0 === n ) throw new Error( 'Can not resolve #include <' + t + '>' ); return resolveIncludes( n );

}

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function unrollLoops( e ) {

	return e.replace( unrollLoopPattern, loopReplacer ).replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( e, t, n, r ) {

	return console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' ), loopReplacer( e, t, n, r );

}

function loopReplacer( e, t, n, r ) {

	let i = ''; for ( let e = parseInt( t ); e < parseInt( n ); e ++ )i += r.replace( /\[\s*i\s*\]/g, '[ ' + e + ' ]' ).replace( /UNROLLED_LOOP_INDEX/g, e ); return i;

}

function generatePrecision( e ) {

	let t = 'precision ' + e.precision + ' float;\nprecision ' + e.precision + ' int;'; return 'highp' === e.precision ? t += '\n#define HIGH_PRECISION' : 'mediump' === e.precision ? t += '\n#define MEDIUM_PRECISION' : 'lowp' === e.precision && ( t += '\n#define LOW_PRECISION' ), t;

}

function generateShadowMapTypeDefine( e ) {

	let t = 'SHADOWMAP_TYPE_BASIC'; return e.shadowMapType === PCFShadowMap ? t = 'SHADOWMAP_TYPE_PCF' : e.shadowMapType === PCFSoftShadowMap ? t = 'SHADOWMAP_TYPE_PCF_SOFT' : e.shadowMapType === VSMShadowMap && ( t = 'SHADOWMAP_TYPE_VSM' ), t;

}

function generateEnvMapTypeDefine( e ) {

	let t = 'ENVMAP_TYPE_CUBE'; if ( e.envMap ) switch ( e.envMapMode ) {

		case CubeReflectionMapping:case CubeRefractionMapping:t = 'ENVMAP_TYPE_CUBE'; break; case CubeUVReflectionMapping:case CubeUVRefractionMapping:t = 'ENVMAP_TYPE_CUBE_UV';

	}

	return t;

}

function generateEnvMapModeDefine( e ) {

	let t = 'ENVMAP_MODE_REFLECTION'; if ( e.envMap ) switch ( e.envMapMode ) {

		case CubeRefractionMapping:case CubeUVRefractionMapping:t = 'ENVMAP_MODE_REFRACTION';

	}

	return t;

}

function generateEnvMapBlendingDefine( e ) {

	let t = 'ENVMAP_BLENDING_NONE'; if ( e.envMap ) switch ( e.combine ) {

		case MultiplyOperation:t = 'ENVMAP_BLENDING_MULTIPLY'; break; case MixOperation:t = 'ENVMAP_BLENDING_MIX'; break; case AddOperation:t = 'ENVMAP_BLENDING_ADD';

	}

	return t;

}

function WebGLProgram( e, t, n, r ) {

	const i = e.getContext(), o = n.defines; let a = n.vertexShader, s = n.fragmentShader; const c = generateShadowMapTypeDefine( n ), l = generateEnvMapTypeDefine( n ), h = generateEnvMapModeDefine( n ), u = generateEnvMapBlendingDefine( n ), d = e.gammaFactor > 0 ? e.gammaFactor : 1, p = n.isWebGL2 ? '' : generateExtensions( n ), m = generateDefines( o ), f = i.createProgram(); let g, v, y = n.glslVersion ? '#version ' + n.glslVersion + '\n' : ''; n.isRawShaderMaterial ? ( ( g = [ m ].filter( filterEmptyLine ).join( '\n' ) ).length > 0 && ( g += '\n' ), ( v = [ p, m ].filter( filterEmptyLine ).join( '\n' ) ).length > 0 && ( v += '\n' ) ) : ( g = [ generatePrecision( n ), '#define SHADER_NAME ' + n.shaderName, m, n.instancing ? '#define USE_INSTANCING' : '', n.instancingColor ? '#define USE_INSTANCING_COLOR' : '', n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + d, '#define MAX_BONES ' + n.maxBones, n.useFog && n.fog ? '#define USE_FOG' : '', n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '', n.map ? '#define USE_MAP' : '', n.envMap ? '#define USE_ENVMAP' : '', n.envMap ? '#define ' + h : '', n.lightMap ? '#define USE_LIGHTMAP' : '', n.aoMap ? '#define USE_AOMAP' : '', n.emissiveMap ? '#define USE_EMISSIVEMAP' : '', n.bumpMap ? '#define USE_BUMPMAP' : '', n.normalMap ? '#define USE_NORMALMAP' : '', n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', n.displacementMap && n.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', n.specularMap ? '#define USE_SPECULARMAP' : '', n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', n.metalnessMap ? '#define USE_METALNESSMAP' : '', n.alphaMap ? '#define USE_ALPHAMAP' : '', n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', n.vertexTangents ? '#define USE_TANGENT' : '', n.vertexColors ? '#define USE_COLOR' : '', n.vertexUvs ? '#define USE_UV' : '', n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', n.flatShading ? '#define FLAT_SHADED' : '', n.skinning ? '#define USE_SKINNING' : '', n.useVertexTexture ? '#define BONE_TEXTURE' : '', n.morphTargets ? '#define USE_MORPHTARGETS' : '', n.morphNormals && ! 1 === n.flatShading ? '#define USE_MORPHNORMALS' : '', n.doubleSided ? '#define DOUBLE_SIDED' : '', n.flipSided ? '#define FLIP_SIDED' : '', n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', n.shadowMapEnabled ? '#define ' + c : '', n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '\tattribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '\tattribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\n' ].filter( filterEmptyLine ).join( '\n' ), v = [ p, generatePrecision( n ), '#define SHADER_NAME ' + n.shaderName, m, n.alphaTest ? '#define ALPHATEST ' + n.alphaTest + ( n.alphaTest % 1 ? '' : '.0' ) : '', '#define GAMMA_FACTOR ' + d, n.useFog && n.fog ? '#define USE_FOG' : '', n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '', n.map ? '#define USE_MAP' : '', n.matcap ? '#define USE_MATCAP' : '', n.envMap ? '#define USE_ENVMAP' : '', n.envMap ? '#define ' + l : '', n.envMap ? '#define ' + h : '', n.envMap ? '#define ' + u : '', n.lightMap ? '#define USE_LIGHTMAP' : '', n.aoMap ? '#define USE_AOMAP' : '', n.emissiveMap ? '#define USE_EMISSIVEMAP' : '', n.bumpMap ? '#define USE_BUMPMAP' : '', n.normalMap ? '#define USE_NORMALMAP' : '', n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', n.specularMap ? '#define USE_SPECULARMAP' : '', n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', n.metalnessMap ? '#define USE_METALNESSMAP' : '', n.alphaMap ? '#define USE_ALPHAMAP' : '', n.sheen ? '#define USE_SHEEN' : '', n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', n.vertexTangents ? '#define USE_TANGENT' : '', n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '', n.vertexUvs ? '#define USE_UV' : '', n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', n.gradientMap ? '#define USE_GRADIENTMAP' : '', n.flatShading ? '#define FLAT_SHADED' : '', n.doubleSided ? '#define DOUBLE_SIDED' : '', n.flipSided ? '#define FLIP_SIDED' : '', n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', n.shadowMapEnabled ? '#define ' + c : '', n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', n.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', ( n.extensionShaderTextureLOD || n.envMap ) && n.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', n.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', n.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : '', n.toneMapping !== NoToneMapping ? getToneMappingFunction( 'toneMapping', n.toneMapping ) : '', n.dithering ? '#define DITHERING' : '', ShaderChunk.encodings_pars_fragment, n.map ? getTexelDecodingFunction( 'mapTexelToLinear', n.mapEncoding ) : '', n.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', n.matcapEncoding ) : '', n.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', n.envMapEncoding ) : '', n.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', n.emissiveMapEncoding ) : '', n.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', n.lightMapEncoding ) : '', getTexelEncodingFunction( 'linearToOutputTexel', n.outputEncoding ), n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '', '\n' ].filter( filterEmptyLine ).join( '\n' ) ), a = replaceClippingPlaneNums( a = replaceLightNums( a = resolveIncludes( a ), n ), n ), s = replaceClippingPlaneNums( s = replaceLightNums( s = resolveIncludes( s ), n ), n ), a = unrollLoops( a ), s = unrollLoops( s ), n.isWebGL2 && ! 0 !== n.isRawShaderMaterial && ( y = '#version 300 es\n', g = [ '#define attribute in', '#define varying out', '#define texture2D texture' ].join( '\n' ) + '\n' + g, v = [ '#define varying in', n.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', n.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad' ].join( '\n' ) + '\n' + v ); const _ = y + v + s, x = WebGLShader( i, 35633, y + g + a ), b = WebGLShader( i, 35632, _ ); if ( i.attachShader( f, x ), i.attachShader( f, b ), void 0 !== n.index0AttributeName ? i.bindAttribLocation( f, 0, n.index0AttributeName ) : ! 0 === n.morphTargets && i.bindAttribLocation( f, 0, 'position' ), i.linkProgram( f ), e.debug.checkShaderErrors ) {

		const e = i.getProgramInfoLog( f ).trim(), t = i.getShaderInfoLog( x ).trim(), n = i.getShaderInfoLog( b ).trim(); let r = ! 0, o = ! 0; if ( ! 1 === i.getProgramParameter( f, 35714 ) ) {

			r = ! 1; const t = getShaderErrors( i, x, 'vertex' ), n = getShaderErrors( i, b, 'fragment' ); console.error( 'THREE.WebGLProgram: shader error: ', i.getError(), '35715', i.getProgramParameter( f, 35715 ), 'gl.getProgramInfoLog', e, t, n );

		} else '' !== e ? console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', e ) : '' !== t && '' !== n || ( o = ! 1 ); o && ( this.diagnostics = { runnable: r, programLog: e, vertexShader: { log: t, prefix: g }, fragmentShader: { log: n, prefix: v } } );

	}

	let M, w; return i.deleteShader( x ), i.deleteShader( b ), this.getUniforms = function () {

		return void 0 === M && ( M = new WebGLUniforms( i, f ) ), M;

	}, this.getAttributes = function () {

		return void 0 === w && ( w = fetchAttributeLocations( i, f ) ), w;

	}, this.destroy = function () {

		r.releaseStatesOfProgram( this ), i.deleteProgram( f ), this.program = void 0;

	}, this.name = n.shaderName, this.id = programIdCount ++, this.cacheKey = t, this.usedTimes = 1, this.program = f, this.vertexShader = x, this.fragmentShader = b, this;

}

function WebGLPrograms( e, t, n, r, i, o ) {

	const a = [], s = r.isWebGL2, c = r.logarithmicDepthBuffer, l = r.floatVertexTextures, h = r.maxVertexUniforms, u = r.vertexTextures; let d = r.precision; const p = { MeshDepthMaterial: 'depth', MeshDistanceMaterial: 'distanceRGBA', MeshNormalMaterial: 'normal', MeshBasicMaterial: 'basic', MeshLambertMaterial: 'lambert', MeshPhongMaterial: 'phong', MeshToonMaterial: 'toon', MeshStandardMaterial: 'physical', MeshPhysicalMaterial: 'physical', MeshMatcapMaterial: 'matcap', LineBasicMaterial: 'basic', LineDashedMaterial: 'dashed', PointsMaterial: 'points', ShadowMaterial: 'shadow', SpriteMaterial: 'sprite' }, m = [ 'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmissionMap' ]; function f( e ) {

		let t; return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? ( console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." ), t = e.texture.encoding ) : t = LinearEncoding, t;

	}

	return { getParameters: function ( i, a, m, g, v ) {

		const y = g.fog, _ = i.isMeshStandardMaterial ? g.environment : null, x = t.get( i.envMap || _ ), b = p[ i.type ], M = v.isSkinnedMesh ? function ( e ) {

			const t = e.skeleton.bones; if ( l ) return 1024; {

				const e = h, n = Math.floor( ( e - 20 ) / 4 ), r = Math.min( n, t.length ); return r < t.length ? ( console.warn( 'THREE.WebGLRenderer: Skeleton has ' + t.length + ' bones. This GPU supports ' + r + '.' ), 0 ) : r;

			}

		}( v ) : 0; let w, S; if ( null !== i.precision && ( d = r.getMaxPrecision( i.precision ) ) !== i.precision && console.warn( 'THREE.WebGLProgram.getParameters:', i.precision, 'not supported, using', d, 'instead.' ), b ) {

			const e = ShaderLib[ b ]; w = e.vertexShader, S = e.fragmentShader;

		} else w = i.vertexShader, S = i.fragmentShader; const T = e.getRenderTarget(); return { isWebGL2: s, shaderID: b, shaderName: i.type, vertexShader: w, fragmentShader: S, defines: i.defines, isRawShaderMaterial: ! 0 === i.isRawShaderMaterial, glslVersion: i.glslVersion, precision: d, instancing: ! 0 === v.isInstancedMesh, instancingColor: ! 0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: u, outputEncoding: null !== T ? f( T.texture ) : e.outputEncoding, map: !! i.map, mapEncoding: f( i.map ), matcap: !! i.matcap, matcapEncoding: f( i.matcap ), envMap: !! x, envMapMode: x && x.mapping, envMapEncoding: f( x ), envMapCubeUV: !! x && ( x.mapping === CubeUVReflectionMapping || x.mapping === CubeUVRefractionMapping ), lightMap: !! i.lightMap, lightMapEncoding: f( i.lightMap ), aoMap: !! i.aoMap, emissiveMap: !! i.emissiveMap, emissiveMapEncoding: f( i.emissiveMap ), bumpMap: !! i.bumpMap, normalMap: !! i.normalMap, objectSpaceNormalMap: i.normalMapType === ObjectSpaceNormalMap, tangentSpaceNormalMap: i.normalMapType === TangentSpaceNormalMap, clearcoatMap: !! i.clearcoatMap, clearcoatRoughnessMap: !! i.clearcoatRoughnessMap, clearcoatNormalMap: !! i.clearcoatNormalMap, displacementMap: !! i.displacementMap, roughnessMap: !! i.roughnessMap, metalnessMap: !! i.metalnessMap, specularMap: !! i.specularMap, alphaMap: !! i.alphaMap, gradientMap: !! i.gradientMap, sheen: !! i.sheen, transmissionMap: !! i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !! ( i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap ), uvsVertexOnly: ! ( i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || ! i.displacementMap ), fog: !! y, useFog: i.fog, fogExp2: y && y.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: c, skinning: i.skinning && M > 0, maxBones: M, useVertexTexture: l, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numDirLightShadows: a.directionalShadowMap.length, numPointLightShadows: a.pointShadowMap.length, numSpotLightShadows: a.spotShadowMap.length, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: i.dithering, shadowMapEnabled: e.shadowMap.enabled && m.length > 0, shadowMapType: e.shadowMap.type, toneMapping: i.toneMapped ? e.toneMapping : NoToneMapping, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === DoubleSide, flipSided: i.side === BackSide, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: s || n.has( 'EXT_frag_depth' ), rendererExtensionDrawBuffers: s || n.has( 'WEBGL_draw_buffers' ), rendererExtensionShaderTextureLod: s || n.has( 'EXT_shader_texture_lod' ), customProgramCacheKey: i.customProgramCacheKey() };

	}, getProgramCacheKey: function ( t ) {

		const n = []; if ( t.shaderID ? n.push( t.shaderID ) : ( n.push( t.fragmentShader ), n.push( t.vertexShader ) ), void 0 !== t.defines ) for ( const e in t.defines )n.push( e ), n.push( t.defines[ e ] ); if ( ! 1 === t.isRawShaderMaterial ) {

			for ( let e = 0; e < m.length; e ++ )n.push( t[ m[ e ] ] ); n.push( e.outputEncoding ), n.push( e.gammaFactor );

		}

		return n.push( t.customProgramCacheKey ), n.join();

	}, getUniforms: function ( e ) {

		const t = p[ e.type ]; let n; if ( t ) {

			const e = ShaderLib[ t ]; n = UniformsUtils.clone( e.uniforms );

		} else n = e.uniforms; return n;

	}, acquireProgram: function ( t, n ) {

		let r; for ( let e = 0, t = a.length; e < t; e ++ ) {

			const t = a[ e ]; if ( t.cacheKey === n ) {

				++ ( r = t ).usedTimes; break;

			}

		}

		return void 0 === r && ( r = new WebGLProgram( e, n, t, i ), a.push( r ) ), r;

	}, releaseProgram: function ( e ) {

		if ( 0 == -- e.usedTimes ) {

			const t = a.indexOf( e ); a[ t ] = a[ a.length - 1 ], a.pop(), e.destroy();

		}

	}, programs: a };

}

function WebGLProperties() {

	let e = new WeakMap(); return { get: function ( t ) {

		let n = e.get( t ); return void 0 === n && ( n = {}, e.set( t, n ) ), n;

	}, remove: function ( t ) {

		e.delete( t );

	}, update: function ( t, n, r ) {

		e.get( t )[ n ] = r;

	}, dispose: function () {

		e = new WeakMap();

	} };

}

function painterSortStable( e, t ) {

	return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;

}

function reversePainterSortStable( e, t ) {

	return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;

}

function WebGLRenderList( e ) {

	const t = []; let n = 0; const r = [], i = [], o = { id: - 1 }; function a( r, i, a, s, c, l ) {

		let h = t[ n ]; const u = e.get( a ); return void 0 === h ? ( h = { id: r.id, object: r, geometry: i, material: a, program: u.program || o, groupOrder: s, renderOrder: r.renderOrder, z: c, group: l }, t[ n ] = h ) : ( h.id = r.id, h.object = r, h.geometry = i, h.material = a, h.program = u.program || o, h.groupOrder = s, h.renderOrder = r.renderOrder, h.z = c, h.group = l ), n ++, h;

	}

	return { opaque: r, transparent: i, init: function () {

		n = 0, r.length = 0, i.length = 0;

	}, push: function ( e, t, n, o, s, c ) {

		const l = a( e, t, n, o, s, c ); ( ! 0 === n.transparent ? i : r ).push( l );

	}, unshift: function ( e, t, n, o, s, c ) {

		const l = a( e, t, n, o, s, c ); ( ! 0 === n.transparent ? i : r ).unshift( l );

	}, finish: function () {

		for ( let e = n, r = t.length; e < r; e ++ ) {

			const n = t[ e ]; if ( null === n.id ) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null;

		}

	}, sort: function ( e, t ) {

		r.length > 1 && r.sort( e || painterSortStable ), i.length > 1 && i.sort( t || reversePainterSortStable );

	} };

}

function WebGLRenderLists( e ) {

	let t = new WeakMap(); return { get: function ( n, r ) {

		const i = t.get( n ); let o; return void 0 === i ? ( o = new WebGLRenderList( e ), t.set( n, new WeakMap() ), t.get( n ).set( r, o ) ) : void 0 === ( o = i.get( r ) ) && ( o = new WebGLRenderList( e ), i.set( r, o ) ), o;

	}, dispose: function () {

		t = new WeakMap();

	} };

}

function UniformsCache() {

	const e = {}; return { get: function ( t ) {

		if ( void 0 !== e[ t.id ] ) return e[ t.id ]; let n; switch ( t.type ) {

			case 'DirectionalLight':n = { direction: new Vector3(), color: new Color() }; break; case 'SpotLight':n = { position: new Vector3(), direction: new Vector3(), color: new Color(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case 'PointLight':n = { position: new Vector3(), color: new Color(), distance: 0, decay: 0 }; break; case 'HemisphereLight':n = { direction: new Vector3(), skyColor: new Color(), groundColor: new Color() }; break; case 'RectAreaLight':n = { color: new Color(), position: new Vector3(), halfWidth: new Vector3(), halfHeight: new Vector3() };

		}

		return e[ t.id ] = n, n;

	} };

}

function ShadowUniformsCache() {

	const e = {}; return { get: function ( t ) {

		if ( void 0 !== e[ t.id ] ) return e[ t.id ]; let n; switch ( t.type ) {

			case 'DirectionalLight':case 'SpotLight':n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2() }; break; case 'PointLight':n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadowCameraNear: 1, shadowCameraFar: 1e3 };

		}

		return e[ t.id ] = n, n;

	} };

}

let nextVersion = 0; function shadowCastingLightsFirst( e, t ) {

	return ( t.castShadow ? 1 : 0 ) - ( e.castShadow ? 1 : 0 );

}

function WebGLLights( e, t ) {

	const n = new UniformsCache(), r = ShadowUniformsCache(), i = { version: 0, hash: { directionalLength: - 1, pointLength: - 1, spotLength: - 1, rectAreaLength: - 1, hemiLength: - 1, numDirectionalShadows: - 1, numPointShadows: - 1, numSpotShadows: - 1 }, ambient: [ 0, 0, 0 ], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for ( let e = 0; e < 9; e ++ )i.probe.push( new Vector3() ); const o = new Vector3(), a = new Matrix4(), s = new Matrix4(); return { setup: function ( o ) {

		let a = 0, s = 0, c = 0; for ( let e = 0; e < 9; e ++ )i.probe[ e ].set( 0, 0, 0 ); let l = 0, h = 0, u = 0, d = 0, p = 0, m = 0, f = 0, g = 0; o.sort( shadowCastingLightsFirst ); for ( let e = 0, t = o.length; e < t; e ++ ) {

			const t = o[ e ], v = t.color, y = t.intensity, _ = t.distance, x = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if ( t.isAmbientLight )a += v.r * y, s += v.g * y, c += v.b * y; else if ( t.isLightProbe ) for ( let e = 0; e < 9; e ++ )i.probe[ e ].addScaledVector( t.sh.coefficients[ e ], y ); else if ( t.isDirectionalLight ) {

				const e = n.get( t ); if ( e.color.copy( t.color ).multiplyScalar( t.intensity ), t.castShadow ) {

					const e = t.shadow, n = r.get( t ); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[ l ] = n, i.directionalShadowMap[ l ] = x, i.directionalShadowMatrix[ l ] = t.shadow.matrix, m ++;

				}

				i.directional[ l ] = e, l ++;

			} else if ( t.isSpotLight ) {

				const e = n.get( t ); if ( e.position.setFromMatrixPosition( t.matrixWorld ), e.color.copy( v ).multiplyScalar( y ), e.distance = _, e.coneCos = Math.cos( t.angle ), e.penumbraCos = Math.cos( t.angle * ( 1 - t.penumbra ) ), e.decay = t.decay, t.castShadow ) {

					const e = t.shadow, n = r.get( t ); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.spotShadow[ u ] = n, i.spotShadowMap[ u ] = x, i.spotShadowMatrix[ u ] = t.shadow.matrix, g ++;

				}

				i.spot[ u ] = e, u ++;

			} else if ( t.isRectAreaLight ) {

				const e = n.get( t ); e.color.copy( v ).multiplyScalar( y ), e.halfWidth.set( .5 * t.width, 0, 0 ), e.halfHeight.set( 0, .5 * t.height, 0 ), i.rectArea[ d ] = e, d ++;

			} else if ( t.isPointLight ) {

				const e = n.get( t ); if ( e.color.copy( t.color ).multiplyScalar( t.intensity ), e.distance = t.distance, e.decay = t.decay, t.castShadow ) {

					const e = t.shadow, n = r.get( t ); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[ h ] = n, i.pointShadowMap[ h ] = x, i.pointShadowMatrix[ h ] = t.shadow.matrix, f ++;

				}

				i.point[ h ] = e, h ++;

			} else if ( t.isHemisphereLight ) {

				const e = n.get( t ); e.skyColor.copy( t.color ).multiplyScalar( y ), e.groundColor.copy( t.groundColor ).multiplyScalar( y ), i.hemi[ p ] = e, p ++;

			}

		}

		d > 0 && ( t.isWebGL2 ? ( i.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, i.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2 ) : ! 0 === e.has( 'OES_texture_float_linear' ) ? ( i.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, i.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2 ) : ! 0 === e.has( 'OES_texture_half_float_linear' ) ? ( i.rectAreaLTC1 = UniformsLib.LTC_HALF_1, i.rectAreaLTC2 = UniformsLib.LTC_HALF_2 ) : console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' ) ), i.ambient[ 0 ] = a, i.ambient[ 1 ] = s, i.ambient[ 2 ] = c; const v = i.hash; v.directionalLength === l && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === m && v.numPointShadows === f && v.numSpotShadows === g || ( i.directional.length = l, i.spot.length = u, i.rectArea.length = d, i.point.length = h, i.hemi.length = p, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = f, i.pointShadowMap.length = f, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = f, i.spotShadowMatrix.length = g, v.directionalLength = l, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = m, v.numPointShadows = f, v.numSpotShadows = g, i.version = nextVersion ++ );

	}, setupView: function ( e, t ) {

		let n = 0, r = 0, c = 0, l = 0, h = 0; const u = t.matrixWorldInverse; for ( let t = 0, d = e.length; t < d; t ++ ) {

			const d = e[ t ]; if ( d.isDirectionalLight ) {

				const e = i.directional[ n ]; e.direction.setFromMatrixPosition( d.matrixWorld ), o.setFromMatrixPosition( d.target.matrixWorld ), e.direction.sub( o ), e.direction.transformDirection( u ), n ++;

			} else if ( d.isSpotLight ) {

				const e = i.spot[ c ]; e.position.setFromMatrixPosition( d.matrixWorld ), e.position.applyMatrix4( u ), e.direction.setFromMatrixPosition( d.matrixWorld ), o.setFromMatrixPosition( d.target.matrixWorld ), e.direction.sub( o ), e.direction.transformDirection( u ), c ++;

			} else if ( d.isRectAreaLight ) {

				const e = i.rectArea[ l ]; e.position.setFromMatrixPosition( d.matrixWorld ), e.position.applyMatrix4( u ), s.identity(), a.copy( d.matrixWorld ), a.premultiply( u ), s.extractRotation( a ), e.halfWidth.set( .5 * d.width, 0, 0 ), e.halfHeight.set( 0, .5 * d.height, 0 ), e.halfWidth.applyMatrix4( s ), e.halfHeight.applyMatrix4( s ), l ++;

			} else if ( d.isPointLight ) {

				const e = i.point[ r ]; e.position.setFromMatrixPosition( d.matrixWorld ), e.position.applyMatrix4( u ), r ++;

			} else if ( d.isHemisphereLight ) {

				const e = i.hemi[ h ]; e.direction.setFromMatrixPosition( d.matrixWorld ), e.direction.transformDirection( u ), e.direction.normalize(), h ++;

			}

		}

	}, state: i };

}

function WebGLRenderState( e, t ) {

	const n = new WebGLLights( e, t ), r = [], i = []; return { init: function () {

		r.length = 0, i.length = 0;

	}, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function () {

		n.setup( r );

	}, setupLightsView: function ( e ) {

		n.setupView( r, e );

	}, pushLight: function ( e ) {

		r.push( e );

	}, pushShadow: function ( e ) {

		i.push( e );

	} };

}

function WebGLRenderStates( e, t ) {

	let n = new WeakMap(); return { get: function ( r, i = 0 ) {

		let o; return ! 1 === n.has( r ) ? ( o = new WebGLRenderState( e, t ), n.set( r, [] ), n.get( r ).push( o ) ) : i >= n.get( r ).length ? ( o = new WebGLRenderState( e, t ), n.get( r ).push( o ) ) : o = n.get( r )[ i ], o;

	}, dispose: function () {

		n = new WeakMap();

	} };

}

function MeshDepthMaterial( e ) {

	Material.call( this ), this.type = 'MeshDepthMaterial', this.depthPacking = BasicDepthPacking, this.skinning = ! 1, this.morphTargets = ! 1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.fog = ! 1, this.setValues( e );

}

function MeshDistanceMaterial( e ) {

	Material.call( this ), this.type = 'MeshDistanceMaterial', this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = ! 1, this.morphTargets = ! 1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = ! 1, this.setValues( e );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype ), MeshDepthMaterial.prototype.constructor = MeshDepthMaterial, MeshDepthMaterial.prototype.isMeshDepthMaterial = ! 0, MeshDepthMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;

}, MeshDistanceMaterial.prototype = Object.create( Material.prototype ), MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial, MeshDistanceMaterial.prototype.isMeshDistanceMaterial = ! 0, MeshDistanceMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.referencePosition.copy( e.referencePosition ), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;

};

var vsm_frag = 'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}', vsm_vert = 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}'; function WebGLShadowMap( e, t, n ) {

	let r = new Frustum(); const i = new Vector2(), o = new Vector2(), a = new Vector4(), s = [], c = [], l = {}, h = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, u = new ShaderMaterial( { defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2() }, radius: { value: 4 } }, vertexShader: vsm_vert, fragmentShader: vsm_frag } ), d = u.clone(); d.defines.HORIZONTAL_PASS = 1; const p = new BufferGeometry(); p.setAttribute( 'position', new BufferAttribute( new Float32Array( [ - 1, - 1, .5, 3, - 1, .5, - 1, 3, .5 ] ), 3 ) ); const m = new Mesh( p, u ), f = this; function g( n, r ) {

		const i = t.update( m ); u.uniforms.shadow_pass.value = n.map.texture, u.uniforms.resolution.value = n.mapSize, u.uniforms.radius.value = n.radius, e.setRenderTarget( n.mapPass ), e.clear(), e.renderBufferDirect( r, null, i, u, m, null ), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget( n.map ), e.clear(), e.renderBufferDirect( r, null, i, d, m, null );

	}

	function v( e, t, n ) {

		const r = e << 0 | t << 1 | n << 2; let i = s[ r ]; return void 0 === i && ( i = new MeshDepthMaterial( { depthPacking: RGBADepthPacking, morphTargets: e, skinning: t } ), s[ r ] = i ), i;

	}

	function y( e, t, n ) {

		const r = e << 0 | t << 1 | n << 2; let i = c[ r ]; return void 0 === i && ( i = new MeshDistanceMaterial( { morphTargets: e, skinning: t } ), c[ r ] = i ), i;

	}

	function _( t, n, r, i, o, a, s ) {

		let c = null, u = v, d = t.customDepthMaterial; if ( ! 0 === i.isPointLight && ( u = y, d = t.customDistanceMaterial ), void 0 === d ) {

			let e = ! 1; ! 0 === r.morphTargets && ( e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0 ); let i = ! 1; ! 0 === t.isSkinnedMesh && ( ! 0 === r.skinning ? i = ! 0 : console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', t ) ), c = u( e, i, ! 0 === t.isInstancedMesh );

		} else c = d; if ( e.localClippingEnabled && ! 0 === r.clipShadows && 0 !== r.clippingPlanes.length ) {

			const e = c.uuid, t = r.uuid; let n = l[ e ]; void 0 === n && ( n = {}, l[ e ] = n ); let i = n[ t ]; void 0 === i && ( i = c.clone(), n[ t ] = i ), c = i;

		}

		return c.visible = r.visible, c.wireframe = r.wireframe, c.side = s === VSMShadowMap ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[ r.side ], c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, ! 0 === i.isPointLight && ! 0 === c.isMeshDistanceMaterial && ( c.referencePosition.setFromMatrixPosition( i.matrixWorld ), c.nearDistance = o, c.farDistance = a ), c;

	}

	function x( n, i, o, a, s ) {

		if ( ! 1 === n.visible ) return; if ( n.layers.test( i.layers ) && ( n.isMesh || n.isLine || n.isPoints ) && ( n.castShadow || n.receiveShadow && s === VSMShadowMap ) && ( ! n.frustumCulled || r.intersectsObject( n ) ) ) {

			n.modelViewMatrix.multiplyMatrices( o.matrixWorldInverse, n.matrixWorld ); const r = t.update( n ), i = n.material; if ( Array.isArray( i ) ) {

				const t = r.groups; for ( let c = 0, l = t.length; c < l; c ++ ) {

					const l = t[ c ], h = i[ l.materialIndex ]; if ( h && h.visible ) {

						const t = _( n, r, h, a, o.near, o.far, s ); e.renderBufferDirect( o, null, r, t, n, l );

					}

				}

			} else if ( i.visible ) {

				const t = _( n, r, i, a, o.near, o.far, s ); e.renderBufferDirect( o, null, r, t, n, null );

			}

		}

		const c = n.children; for ( let e = 0, t = c.length; e < t; e ++ )x( c[ e ], i, o, a, s );

	}

	this.enabled = ! 1, this.autoUpdate = ! 0, this.needsUpdate = ! 1, this.type = PCFShadowMap, this.render = function ( t, s, c ) {

		if ( ! 1 === f.enabled ) return; if ( ! 1 === f.autoUpdate && ! 1 === f.needsUpdate ) return; if ( 0 === t.length ) return; const l = e.getRenderTarget(), h = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), d = e.state; d.setBlending( NoBlending ), d.buffers.color.setClear( 1, 1, 1, 1 ), d.buffers.depth.setTest( ! 0 ), d.setScissorTest( ! 1 ); for ( let l = 0, h = t.length; l < h; l ++ ) {

			const h = t[ l ], u = h.shadow; if ( void 0 === u ) {

				console.warn( 'THREE.WebGLShadowMap:', h, 'has no shadow.' ); continue;

			}

			if ( ! 1 === u.autoUpdate && ! 1 === u.needsUpdate ) continue; i.copy( u.mapSize ); const p = u.getFrameExtents(); if ( i.multiply( p ), o.copy( u.mapSize ), ( i.x > n || i.y > n ) && ( i.x > n && ( o.x = Math.floor( n / p.x ), i.x = o.x * p.x, u.mapSize.x = o.x ), i.y > n && ( o.y = Math.floor( n / p.y ), i.y = o.y * p.y, u.mapSize.y = o.y ) ), null === u.map && ! u.isPointLightShadow && this.type === VSMShadowMap ) {

				const e = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }; u.map = new WebGLRenderTarget( i.x, i.y, e ), u.map.texture.name = h.name + '.shadowMap', u.mapPass = new WebGLRenderTarget( i.x, i.y, e ), u.camera.updateProjectionMatrix();

			}

			if ( null === u.map ) {

				const e = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }; u.map = new WebGLRenderTarget( i.x, i.y, e ), u.map.texture.name = h.name + '.shadowMap', u.camera.updateProjectionMatrix();

			}

			e.setRenderTarget( u.map ), e.clear(); const m = u.getViewportCount(); for ( let e = 0; e < m; e ++ ) {

				const t = u.getViewport( e ); a.set( o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w ), d.viewport( a ), u.updateMatrices( h, e ), r = u.getFrustum(), x( s, c, u.camera, h, this.type );

			}

			u.isPointLightShadow || this.type !== VSMShadowMap || g( u, c ), u.needsUpdate = ! 1;

		}

		f.needsUpdate = ! 1, e.setRenderTarget( l, h, u );

	};

}

function WebGLState( e, t, n ) {

	const r = n.isWebGL2; const i = new function () {

			let t = ! 1; const n = new Vector4(); let r = null; const i = new Vector4( 0, 0, 0, 0 ); return { setMask: function ( n ) {

				r === n || t || ( e.colorMask( n, n, n, n ), r = n );

			}, setLocked: function ( e ) {

				t = e;

			}, setClear: function ( t, r, o, a, s ) {

				! 0 === s && ( t *= a, r *= a, o *= a ), n.set( t, r, o, a ), ! 1 === i.equals( n ) && ( e.clearColor( t, r, o, a ), i.copy( n ) );

			}, reset: function () {

				t = ! 1, r = null, i.set( - 1, 0, 0, 0 );

			} };

		}(), o = new function () {

			let t = ! 1, n = null, r = null, i = null; return { setTest: function ( e ) {

				e ? D( 2929 ) : G( 2929 );

			}, setMask: function ( r ) {

				n === r || t || ( e.depthMask( r ), n = r );

			}, setFunc: function ( t ) {

				if ( r !== t ) {

					if ( t ) switch ( t ) {

						case NeverDepth:e.depthFunc( 512 ); break; case AlwaysDepth:e.depthFunc( 519 ); break; case LessDepth:e.depthFunc( 513 ); break; case LessEqualDepth:e.depthFunc( 515 ); break; case EqualDepth:e.depthFunc( 514 ); break; case GreaterEqualDepth:e.depthFunc( 518 ); break; case GreaterDepth:e.depthFunc( 516 ); break; case NotEqualDepth:e.depthFunc( 517 ); break; default:e.depthFunc( 515 );

					} else e.depthFunc( 515 ); r = t;

				}

			}, setLocked: function ( e ) {

				t = e;

			}, setClear: function ( t ) {

				i !== t && ( e.clearDepth( t ), i = t );

			}, reset: function () {

				t = ! 1, n = null, r = null, i = null;

			} };

		}(), a = new function () {

			let t = ! 1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, l = null; return { setTest: function ( e ) {

				t || ( e ? D( 2960 ) : G( 2960 ) );

			}, setMask: function ( r ) {

				n === r || t || ( e.stencilMask( r ), n = r );

			}, setFunc: function ( t, n, a ) {

				r === t && i === n && o === a || ( e.stencilFunc( t, n, a ), r = t, i = n, o = a );

			}, setOp: function ( t, n, r ) {

				a === t && s === n && c === r || ( e.stencilOp( t, n, r ), a = t, s = n, c = r );

			}, setLocked: function ( e ) {

				t = e;

			}, setClear: function ( t ) {

				l !== t && ( e.clearStencil( t ), l = t );

			}, reset: function () {

				t = ! 1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, l = null;

			} };

		}(); let s = {}, c = null, l = null, h = null, u = null, d = null, p = null, m = null, f = null, g = null, v = ! 1, y = null, _ = null, x = null, b = null, M = null; const w = e.getParameter( 35661 ); let S = ! 1, T = 0; const E = e.getParameter( 7938 ); - 1 !== E.indexOf( 'WebGL' ) ? ( T = parseFloat( /^WebGL (\d)/.exec( E )[ 1 ] ), S = T >= 1 ) : - 1 !== E.indexOf( 'OpenGL ES' ) && ( T = parseFloat( /^OpenGL ES (\d)/.exec( E )[ 1 ] ), S = T >= 2 ); let A = null, L = {}; const C = new Vector4(), R = new Vector4(); function P( t, n, r ) {

		const i = new Uint8Array( 4 ), o = e.createTexture(); e.bindTexture( t, o ), e.texParameteri( t, 10241, 9728 ), e.texParameteri( t, 10240, 9728 ); for ( let t = 0; t < r; t ++ )e.texImage2D( n + t, 0, 6408, 1, 1, 0, 6408, 5121, i ); return o;

	}

	const B = {}; function D( t ) {

		! 0 !== s[ t ] && ( e.enable( t ), s[ t ] = ! 0 );

	}

	function G( t ) {

		! 1 !== s[ t ] && ( e.disable( t ), s[ t ] = ! 1 );

	}

	B[ 3553 ] = P( 3553, 3553, 1 ), B[ 34067 ] = P( 34067, 34069, 6 ), i.setClear( 0, 0, 0, 1 ), o.setClear( 1 ), a.setClear( 0 ), D( 2929 ), o.setFunc( LessEqualDepth ), O( ! 1 ), U( CullFaceBack ), D( 2884 ), N( NoBlending ); const I = { [ AddEquation ]: 32774, [ SubtractEquation ]: 32778, [ ReverseSubtractEquation ]: 32779 }; if ( r )I[ MinEquation ] = 32775, I[ MaxEquation ] = 32776; else {

		const e = t.get( 'EXT_blend_minmax' ); null !== e && ( I[ MinEquation ] = e.MIN_EXT, I[ MaxEquation ] = e.MAX_EXT );

	}

	const F = { [ ZeroFactor ]: 0, [ OneFactor ]: 1, [ SrcColorFactor ]: 768, [ SrcAlphaFactor ]: 770, [ SrcAlphaSaturateFactor ]: 776, [ DstColorFactor ]: 774, [ DstAlphaFactor ]: 772, [ OneMinusSrcColorFactor ]: 769, [ OneMinusSrcAlphaFactor ]: 771, [ OneMinusDstColorFactor ]: 775, [ OneMinusDstAlphaFactor ]: 773 }; function N( t, n, r, i, o, a, s, c ) {

		if ( t !== NoBlending ) {

			if ( l || ( D( 3042 ), l = ! 0 ), t === CustomBlending )o = o || n, a = a || r, s = s || i, n === u && o === m || ( e.blendEquationSeparate( I[ n ], I[ o ] ), u = n, m = o ), r === d && i === p && a === f && s === g || ( e.blendFuncSeparate( F[ r ], F[ i ], F[ a ], F[ s ] ), d = r, p = i, f = a, g = s ), h = t, v = null; else if ( t !== h || c !== v ) {

				if ( u === AddEquation && m === AddEquation || ( e.blendEquation( 32774 ), u = AddEquation, m = AddEquation ), c ) switch ( t ) {

					case NormalBlending:e.blendFuncSeparate( 1, 771, 1, 771 ); break; case AdditiveBlending:e.blendFunc( 1, 1 ); break; case SubtractiveBlending:e.blendFuncSeparate( 0, 0, 769, 771 ); break; case MultiplyBlending:e.blendFuncSeparate( 0, 768, 0, 770 ); break; default:console.error( 'THREE.WebGLState: Invalid blending: ', t );

				} else switch ( t ) {

					case NormalBlending:e.blendFuncSeparate( 770, 771, 1, 771 ); break; case AdditiveBlending:e.blendFunc( 770, 1 ); break; case SubtractiveBlending:e.blendFunc( 0, 769 ); break; case MultiplyBlending:e.blendFunc( 0, 768 ); break; default:console.error( 'THREE.WebGLState: Invalid blending: ', t );

				}

				d = null, p = null, f = null, g = null, h = t, v = c;

			}

		} else l && ( G( 3042 ), l = ! 1 );

	}

	function O( t ) {

		y !== t && ( t ? e.frontFace( 2304 ) : e.frontFace( 2305 ), y = t );

	}

	function U( t ) {

		t !== CullFaceNone ? ( D( 2884 ), t !== _ && ( t === CullFaceBack ? e.cullFace( 1029 ) : t === CullFaceFront ? e.cullFace( 1028 ) : e.cullFace( 1032 ) ) ) : G( 2884 ), _ = t;

	}

	function V( t, n, r ) {

		t ? ( D( 32823 ), b === n && M === r || ( e.polygonOffset( n, r ), b = n, M = r ) ) : G( 32823 );

	}

	function z( t ) {

		void 0 === t && ( t = 33984 + w - 1 ), A !== t && ( e.activeTexture( t ), A = t );

	}

	return { buffers: { color: i, depth: o, stencil: a }, enable: D, disable: G, useProgram: function ( t ) {

		return c !== t && ( e.useProgram( t ), c = t, ! 0 );

	}, setBlending: N, setMaterial: function ( e, t ) {

		e.side === DoubleSide ? G( 2884 ) : D( 2884 ); let n = e.side === BackSide; t && ( n = ! n ), O( n ), e.blending === NormalBlending && ! 1 === e.transparent ? N( NoBlending ) : N( e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha ), o.setFunc( e.depthFunc ), o.setTest( e.depthTest ), o.setMask( e.depthWrite ), i.setMask( e.colorWrite ); const r = e.stencilWrite; a.setTest( r ), r && ( a.setMask( e.stencilWriteMask ), a.setFunc( e.stencilFunc, e.stencilRef, e.stencilFuncMask ), a.setOp( e.stencilFail, e.stencilZFail, e.stencilZPass ) ), V( e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits );

	}, setFlipSided: O, setCullFace: U, setLineWidth: function ( t ) {

		t !== x && ( S && e.lineWidth( t ), x = t );

	}, setPolygonOffset: V, setScissorTest: function ( e ) {

		e ? D( 3089 ) : G( 3089 );

	}, activeTexture: z, bindTexture: function ( t, n ) {

		null === A && z(); let r = L[ A ]; void 0 === r && ( r = { type: void 0, texture: void 0 }, L[ A ] = r ), r.type === t && r.texture === n || ( e.bindTexture( t, n || B[ t ] ), r.type = t, r.texture = n );

	}, unbindTexture: function () {

		const t = L[ A ]; void 0 !== t && void 0 !== t.type && ( e.bindTexture( t.type, null ), t.type = void 0, t.texture = void 0 );

	}, compressedTexImage2D: function () {

		try {

			e.compressedTexImage2D.apply( e, arguments );

		} catch ( e ) {

			console.error( 'THREE.WebGLState:', e );

		}

	}, texImage2D: function () {

		try {

			e.texImage2D.apply( e, arguments );

		} catch ( e ) {

			console.error( 'THREE.WebGLState:', e );

		}

	}, texImage3D: function () {

		try {

			e.texImage3D.apply( e, arguments );

		} catch ( e ) {

			console.error( 'THREE.WebGLState:', e );

		}

	}, scissor: function ( t ) {

		! 1 === C.equals( t ) && ( e.scissor( t.x, t.y, t.z, t.w ), C.copy( t ) );

	}, viewport: function ( t ) {

		! 1 === R.equals( t ) && ( e.viewport( t.x, t.y, t.z, t.w ), R.copy( t ) );

	}, reset: function () {

		s = {}, A = null, L = {}, c = null, l = null, h = null, u = null, d = null, p = null, m = null, f = null, g = null, v = ! 1, y = null, _ = null, x = null, b = null, M = null, i.reset(), o.reset(), a.reset();

	} };

}

function WebGLTextures( e, t, n, r, i, o, a ) {

	const s = i.isWebGL2, c = i.maxTextures, l = i.maxCubemapSize, h = i.maxTextureSize, u = i.maxSamples, d = new WeakMap(); let p, m = ! 1; try {

		m = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas( 1, 1 ).getContext( '2d' );

	} catch ( e ) {}

	function f( e, t ) {

		return m ? new OffscreenCanvas( e, t ) : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function g( e, t, n, r ) {

		let i = 1; if ( ( e.width > r || e.height > r ) && ( i = r / Math.max( e.width, e.height ) ), i < 1 || ! 0 === t ) {

			if ( 'undefined' != typeof HTMLImageElement && e instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && e instanceof ImageBitmap ) {

				const r = t ? MathUtils.floorPowerOfTwo : Math.floor, o = r( i * e.width ), a = r( i * e.height ); void 0 === p && ( p = f( o, a ) ); const s = n ? f( o, a ) : p; return s.width = o, s.height = a, s.getContext( '2d' ).drawImage( e, 0, 0, o, a ), console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + e.width + 'x' + e.height + ') to (' + o + 'x' + a + ').' ), s;

			}

			return 'data' in e && console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + e.width + 'x' + e.height + ').' ), e;

		}

		return e;

	}

	function v( e ) {

		return MathUtils.isPowerOfTwo( e.width ) && MathUtils.isPowerOfTwo( e.height );

	}

	function y( e, t ) {

		return e.generateMipmaps && t && e.minFilter !== NearestFilter && e.minFilter !== LinearFilter;

	}

	function _( t, n, i, o ) {

		e.generateMipmap( t ), r.get( n ).__maxMipLevel = Math.log( Math.max( i, o ) ) * Math.LOG2E;

	}

	function x( n, r, i ) {

		if ( ! 1 === s ) return r; if ( null !== n ) {

			if ( void 0 !== e[ n ] ) return e[ n ]; console.warn( "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'" );

		}

		let o = r; return 6403 === r && ( 5126 === i && ( o = 33326 ), 5131 === i && ( o = 33325 ), 5121 === i && ( o = 33321 ) ), 6407 === r && ( 5126 === i && ( o = 34837 ), 5131 === i && ( o = 34843 ), 5121 === i && ( o = 32849 ) ), 6408 === r && ( 5126 === i && ( o = 34836 ), 5131 === i && ( o = 34842 ), 5121 === i && ( o = 32856 ) ), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || t.get( 'EXT_color_buffer_float' ), o;

	}

	function b( e ) {

		return e === NearestFilter || e === NearestMipmapNearestFilter || e === NearestMipmapLinearFilter ? 9728 : 9729;

	}

	function M( t ) {

		const n = t.target; n.removeEventListener( 'dispose', M ), function ( t ) {

			const n = r.get( t ); if ( void 0 === n.__webglInit ) return; e.deleteTexture( n.__webglTexture ), r.remove( t );

		}( n ), n.isVideoTexture && d.delete( n ), a.memory.textures --;

	}

	function w( t ) {

		const n = t.target; n.removeEventListener( 'dispose', w ), function ( t ) {

			const n = r.get( t ), i = r.get( t.texture ); if ( ! t ) return; void 0 !== i.__webglTexture && e.deleteTexture( i.__webglTexture ); t.depthTexture && t.depthTexture.dispose(); if ( t.isWebGLCubeRenderTarget ) for ( let t = 0; t < 6; t ++ )e.deleteFramebuffer( n.__webglFramebuffer[ t ] ), n.__webglDepthbuffer && e.deleteRenderbuffer( n.__webglDepthbuffer[ t ] ); else e.deleteFramebuffer( n.__webglFramebuffer ), n.__webglDepthbuffer && e.deleteRenderbuffer( n.__webglDepthbuffer ), n.__webglMultisampledFramebuffer && e.deleteFramebuffer( n.__webglMultisampledFramebuffer ), n.__webglColorRenderbuffer && e.deleteRenderbuffer( n.__webglColorRenderbuffer ), n.__webglDepthRenderbuffer && e.deleteRenderbuffer( n.__webglDepthRenderbuffer ); r.remove( t.texture ), r.remove( t );

		}( n ), a.memory.textures --;

	}

	let S = 0; function T( e, t ) {

		const i = r.get( e ); if ( e.isVideoTexture && function ( e ) {

			const t = a.render.frame; d.get( e ) !== t && ( d.set( e, t ), e.update() );

		}( e ), e.version > 0 && i.__version !== e.version ) {

			const n = e.image; if ( void 0 === n )console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' ); else {

				if ( ! 1 !== n.complete ) return void P( i, e, t ); console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			}

		}

		n.activeTexture( 33984 + t ), n.bindTexture( 3553, i.__webglTexture );

	}

	function E( t, i ) {

		const a = r.get( t ); t.version > 0 && a.__version !== t.version ? function ( t, r, i ) {

			if ( 6 !== r.image.length ) return; R( t, r ), n.activeTexture( 33984 + i ), n.bindTexture( 34067, t.__webglTexture ), e.pixelStorei( 37440, r.flipY ); const a = r && ( r.isCompressedTexture || r.image[ 0 ].isCompressedTexture ), c = r.image[ 0 ] && r.image[ 0 ].isDataTexture, h = []; for ( let e = 0; e < 6; e ++ )h[ e ] = a || c ? c ? r.image[ e ].image : r.image[ e ] : g( r.image[ e ], ! 1, ! 0, l ); const u = h[ 0 ], d = v( u ) || s, p = o.convert( r.format ), m = o.convert( r.type ), f = x( r.internalFormat, p, m ); let b; if ( C( 34067, r, d ), a ) {

				for ( let e = 0; e < 6; e ++ ) {

					b = h[ e ].mipmaps; for ( let t = 0; t < b.length; t ++ ) {

						const i = b[ t ]; r.format !== RGBAFormat && r.format !== RGBFormat ? null !== p ? n.compressedTexImage2D( 34069 + e, t, f, i.width, i.height, 0, i.data ) : console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' ) : n.texImage2D( 34069 + e, t, f, i.width, i.height, 0, p, m, i.data );

					}

				}

				t.__maxMipLevel = b.length - 1;

			} else {

				b = r.mipmaps; for ( let e = 0; e < 6; e ++ ) if ( c ) {

					n.texImage2D( 34069 + e, 0, f, h[ e ].width, h[ e ].height, 0, p, m, h[ e ].data ); for ( let t = 0; t < b.length; t ++ ) {

						const r = b[ t ], i = r.image[ e ].image; n.texImage2D( 34069 + e, t + 1, f, i.width, i.height, 0, p, m, i.data );

					}

				} else {

					n.texImage2D( 34069 + e, 0, f, p, m, h[ e ] ); for ( let t = 0; t < b.length; t ++ ) {

						const r = b[ t ]; n.texImage2D( 34069 + e, t + 1, f, p, m, r.image[ e ] );

					}

				}

				t.__maxMipLevel = b.length;

			}

			y( r, d ) && _( 34067, r, u.width, u.height ); t.__version = r.version, r.onUpdate && r.onUpdate( r );

		}( a, t, i ) : ( n.activeTexture( 33984 + i ), n.bindTexture( 34067, a.__webglTexture ) );

	}

	const A = { [ RepeatWrapping ]: 10497, [ ClampToEdgeWrapping ]: 33071, [ MirroredRepeatWrapping ]: 33648 }, L = { [ NearestFilter ]: 9728, [ NearestMipmapNearestFilter ]: 9984, [ NearestMipmapLinearFilter ]: 9986, [ LinearFilter ]: 9729, [ LinearMipmapNearestFilter ]: 9985, [ LinearMipmapLinearFilter ]: 9987 }; function C( n, o, a ) {

		a ? ( e.texParameteri( n, 10242, A[ o.wrapS ] ), e.texParameteri( n, 10243, A[ o.wrapT ] ), 32879 !== n && 35866 !== n || e.texParameteri( n, 32882, A[ o.wrapR ] ), e.texParameteri( n, 10240, L[ o.magFilter ] ), e.texParameteri( n, 10241, L[ o.minFilter ] ) ) : ( e.texParameteri( n, 10242, 33071 ), e.texParameteri( n, 10243, 33071 ), 32879 !== n && 35866 !== n || e.texParameteri( n, 32882, 33071 ), o.wrapS === ClampToEdgeWrapping && o.wrapT === ClampToEdgeWrapping || console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' ), e.texParameteri( n, 10240, b( o.magFilter ) ), e.texParameteri( n, 10241, b( o.minFilter ) ), o.minFilter !== NearestFilter && o.minFilter !== LinearFilter && console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' ) ); const c = t.get( 'EXT_texture_filter_anisotropic' ); if ( c ) {

			if ( o.type === FloatType && null === t.get( 'OES_texture_float_linear' ) ) return; if ( o.type === HalfFloatType && null === ( s || t.get( 'OES_texture_half_float_linear' ) ) ) return; ( o.anisotropy > 1 || r.get( o ).__currentAnisotropy ) && ( e.texParameterf( n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( o.anisotropy, i.getMaxAnisotropy() ) ), r.get( o ).__currentAnisotropy = o.anisotropy );

		}

	}

	function R( t, n ) {

		void 0 === t.__webglInit && ( t.__webglInit = ! 0, n.addEventListener( 'dispose', M ), t.__webglTexture = e.createTexture(), a.memory.textures ++ );

	}

	function P( t, r, i ) {

		let a = 3553; r.isDataTexture2DArray && ( a = 35866 ), r.isDataTexture3D && ( a = 32879 ), R( t, r ), n.activeTexture( 33984 + i ), n.bindTexture( a, t.__webglTexture ), e.pixelStorei( 37440, r.flipY ), e.pixelStorei( 37441, r.premultiplyAlpha ), e.pixelStorei( 3317, r.unpackAlignment ); const c = function ( e ) {

				return ! s && ( e.wrapS !== ClampToEdgeWrapping || e.wrapT !== ClampToEdgeWrapping || e.minFilter !== NearestFilter && e.minFilter !== LinearFilter );

			}( r ) && ! 1 === v( r.image ), l = g( r.image, c, ! 1, h ), u = v( l ) || s, d = o.convert( r.format ); let p, m = o.convert( r.type ), f = x( r.internalFormat, d, m ); C( a, r, u ); const b = r.mipmaps; if ( r.isDepthTexture )f = 6402, s ? f = r.type === FloatType ? 36012 : r.type === UnsignedIntType ? 33190 : r.type === UnsignedInt248Type ? 35056 : 33189 : r.type === FloatType && console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' ), r.format === DepthFormat && 6402 === f && r.type !== UnsignedShortType && r.type !== UnsignedIntType && ( console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' ), r.type = UnsignedShortType, m = o.convert( r.type ) ), r.format === DepthStencilFormat && 6402 === f && ( f = 34041, r.type !== UnsignedInt248Type && ( console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' ), r.type = UnsignedInt248Type, m = o.convert( r.type ) ) ), n.texImage2D( 3553, 0, f, l.width, l.height, 0, d, m, null ); else if ( r.isDataTexture ) if ( b.length > 0 && u ) {

			for ( let e = 0, t = b.length; e < t; e ++ )p = b[ e ], n.texImage2D( 3553, e, f, p.width, p.height, 0, d, m, p.data ); r.generateMipmaps = ! 1, t.__maxMipLevel = b.length - 1;

		} else n.texImage2D( 3553, 0, f, l.width, l.height, 0, d, m, l.data ), t.__maxMipLevel = 0; else if ( r.isCompressedTexture ) {

			for ( let e = 0, t = b.length; e < t; e ++ )p = b[ e ], r.format !== RGBAFormat && r.format !== RGBFormat ? null !== d ? n.compressedTexImage2D( 3553, e, f, p.width, p.height, 0, p.data ) : console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' ) : n.texImage2D( 3553, e, f, p.width, p.height, 0, d, m, p.data ); t.__maxMipLevel = b.length - 1;

		} else if ( r.isDataTexture2DArray )n.texImage3D( 35866, 0, f, l.width, l.height, l.depth, 0, d, m, l.data ), t.__maxMipLevel = 0; else if ( r.isDataTexture3D )n.texImage3D( 32879, 0, f, l.width, l.height, l.depth, 0, d, m, l.data ), t.__maxMipLevel = 0; else if ( b.length > 0 && u ) {

			for ( let e = 0, t = b.length; e < t; e ++ )p = b[ e ], n.texImage2D( 3553, e, f, d, m, p ); r.generateMipmaps = ! 1, t.__maxMipLevel = b.length - 1;

		} else n.texImage2D( 3553, 0, f, d, m, l ), t.__maxMipLevel = 0; y( r, u ) && _( a, r, l.width, l.height ), t.__version = r.version, r.onUpdate && r.onUpdate( r );

	}

	function B( t, i, a, s ) {

		const c = o.convert( i.texture.format ), l = o.convert( i.texture.type ), h = x( i.texture.internalFormat, c, l ); n.texImage2D( s, 0, h, i.width, i.height, 0, c, l, null ), e.bindFramebuffer( 36160, t ), e.framebufferTexture2D( 36160, a, s, r.get( i.texture ).__webglTexture, 0 ), e.bindFramebuffer( 36160, null );

	}

	function D( t, n, r ) {

		if ( e.bindRenderbuffer( 36161, t ), n.depthBuffer && ! n.stencilBuffer ) {

			let i = 33189; if ( r ) {

				const t = n.depthTexture; t && t.isDepthTexture && ( t.type === FloatType ? i = 36012 : t.type === UnsignedIntType && ( i = 33190 ) ); const r = I( n ); e.renderbufferStorageMultisample( 36161, r, i, n.width, n.height );

			} else e.renderbufferStorage( 36161, i, n.width, n.height ); e.framebufferRenderbuffer( 36160, 36096, 36161, t );

		} else if ( n.depthBuffer && n.stencilBuffer ) {

			if ( r ) {

				const t = I( n ); e.renderbufferStorageMultisample( 36161, t, 35056, n.width, n.height );

			} else e.renderbufferStorage( 36161, 34041, n.width, n.height ); e.framebufferRenderbuffer( 36160, 33306, 36161, t );

		} else {

			const t = o.convert( n.texture.format ), i = o.convert( n.texture.type ), a = x( n.texture.internalFormat, t, i ); if ( r ) {

				const t = I( n ); e.renderbufferStorageMultisample( 36161, t, a, n.width, n.height );

			} else e.renderbufferStorage( 36161, a, n.width, n.height );

		}

		e.bindRenderbuffer( 36161, null );

	}

	function G( t ) {

		const n = r.get( t ), i = ! 0 === t.isWebGLCubeRenderTarget; if ( t.depthTexture ) {

			if ( i ) throw new Error( 'target.depthTexture not supported in Cube render targets' ); ! function ( t, n ) {

				if ( n && n.isWebGLCubeRenderTarget ) throw new Error( 'Depth Texture with cube render targets is not supported' ); if ( e.bindFramebuffer( 36160, t ), ! n.depthTexture || ! n.depthTexture.isDepthTexture ) throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' ); r.get( n.depthTexture ).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || ( n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = ! 0 ), T( n.depthTexture, 0 ); const i = r.get( n.depthTexture ).__webglTexture; if ( n.depthTexture.format === DepthFormat )e.framebufferTexture2D( 36160, 36096, 3553, i, 0 ); else {

					if ( n.depthTexture.format !== DepthStencilFormat ) throw new Error( 'Unknown depthTexture format' ); e.framebufferTexture2D( 36160, 33306, 3553, i, 0 );

				}

			}( n.__webglFramebuffer, t );

		} else if ( i ) {

			n.__webglDepthbuffer = []; for ( let r = 0; r < 6; r ++ )e.bindFramebuffer( 36160, n.__webglFramebuffer[ r ] ), n.__webglDepthbuffer[ r ] = e.createRenderbuffer(), D( n.__webglDepthbuffer[ r ], t, ! 1 );

		} else e.bindFramebuffer( 36160, n.__webglFramebuffer ), n.__webglDepthbuffer = e.createRenderbuffer(), D( n.__webglDepthbuffer, t, ! 1 ); e.bindFramebuffer( 36160, null );

	}

	function I( e ) {

		return s && e.isWebGLMultisampleRenderTarget ? Math.min( u, e.samples ) : 0;

	}

	let F = ! 1, N = ! 1; this.allocateTextureUnit = function () {

		const e = S; return e >= c && console.warn( 'THREE.WebGLTextures: Trying to use ' + e + ' texture units while this GPU supports only ' + c ), S += 1, e;

	}, this.resetTextureUnits = function () {

		S = 0;

	}, this.setTexture2D = T, this.setTexture2DArray = function ( e, t ) {

		const i = r.get( e ); e.version > 0 && i.__version !== e.version ? P( i, e, t ) : ( n.activeTexture( 33984 + t ), n.bindTexture( 35866, i.__webglTexture ) );

	}, this.setTexture3D = function ( e, t ) {

		const i = r.get( e ); e.version > 0 && i.__version !== e.version ? P( i, e, t ) : ( n.activeTexture( 33984 + t ), n.bindTexture( 32879, i.__webglTexture ) );

	}, this.setTextureCube = E, this.setupRenderTarget = function ( t ) {

		const i = r.get( t ), c = r.get( t.texture ); t.addEventListener( 'dispose', w ), c.__webglTexture = e.createTexture(), a.memory.textures ++; const l = ! 0 === t.isWebGLCubeRenderTarget, h = ! 0 === t.isWebGLMultisampleRenderTarget, u = v( t ) || s; if ( ! s || t.texture.format !== RGBFormat || t.texture.type !== FloatType && t.texture.type !== HalfFloatType || ( t.texture.format = RGBAFormat, console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' ) ), l ) {

			i.__webglFramebuffer = []; for ( let t = 0; t < 6; t ++ )i.__webglFramebuffer[ t ] = e.createFramebuffer();

		} else if ( i.__webglFramebuffer = e.createFramebuffer(), h ) if ( s ) {

			i.__webglMultisampledFramebuffer = e.createFramebuffer(), i.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer( 36161, i.__webglColorRenderbuffer ); const n = o.convert( t.texture.format ), r = o.convert( t.texture.type ), a = x( t.texture.internalFormat, n, r ), s = I( t ); e.renderbufferStorageMultisample( 36161, s, a, t.width, t.height ), e.bindFramebuffer( 36160, i.__webglMultisampledFramebuffer ), e.framebufferRenderbuffer( 36160, 36064, 36161, i.__webglColorRenderbuffer ), e.bindRenderbuffer( 36161, null ), t.depthBuffer && ( i.__webglDepthRenderbuffer = e.createRenderbuffer(), D( i.__webglDepthRenderbuffer, t, ! 0 ) ), e.bindFramebuffer( 36160, null );

		} else console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); if ( l ) {

			n.bindTexture( 34067, c.__webglTexture ), C( 34067, t.texture, u ); for ( let e = 0; e < 6; e ++ )B( i.__webglFramebuffer[ e ], t, 36064, 34069 + e ); y( t.texture, u ) && _( 34067, t.texture, t.width, t.height ), n.bindTexture( 34067, null );

		} else n.bindTexture( 3553, c.__webglTexture ), C( 3553, t.texture, u ), B( i.__webglFramebuffer, t, 36064, 3553 ), y( t.texture, u ) && _( 3553, t.texture, t.width, t.height ), n.bindTexture( 3553, null ); t.depthBuffer && G( t );

	}, this.updateRenderTargetMipmap = function ( e ) {

		const t = e.texture; if ( y( t, v( e ) || s ) ) {

			const i = e.isWebGLCubeRenderTarget ? 34067 : 3553, o = r.get( t ).__webglTexture; n.bindTexture( i, o ), _( i, t, e.width, e.height ), n.bindTexture( i, null );

		}

	}, this.updateMultisampleRenderTarget = function ( t ) {

		if ( t.isWebGLMultisampleRenderTarget ) if ( s ) {

			const n = r.get( t ); e.bindFramebuffer( 36008, n.__webglMultisampledFramebuffer ), e.bindFramebuffer( 36009, n.__webglFramebuffer ); const i = t.width, o = t.height; let a = 16384; t.depthBuffer && ( a |= 256 ), t.stencilBuffer && ( a |= 1024 ), e.blitFramebuffer( 0, 0, i, o, 0, 0, i, o, a, 9728 ), e.bindFramebuffer( 36160, n.__webglMultisampledFramebuffer );

		} else console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

	}, this.safeSetTexture2D = function ( e, t ) {

		e && e.isWebGLRenderTarget && ( ! 1 === F && ( console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." ), F = ! 0 ), e = e.texture ), T( e, t );

	}, this.safeSetTextureCube = function ( e, t ) {

		e && e.isWebGLCubeRenderTarget && ( ! 1 === N && ( console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." ), N = ! 0 ), e = e.texture ), E( e, t );

	};

}

function WebGLUtils( e, t, n ) {

	const r = n.isWebGL2; return { convert: function ( e ) {

		let n; if ( e === UnsignedByteType ) return 5121; if ( e === UnsignedShort4444Type ) return 32819; if ( e === UnsignedShort5551Type ) return 32820; if ( e === UnsignedShort565Type ) return 33635; if ( e === ByteType ) return 5120; if ( e === ShortType ) return 5122; if ( e === UnsignedShortType ) return 5123; if ( e === IntType ) return 5124; if ( e === UnsignedIntType ) return 5125; if ( e === FloatType ) return 5126; if ( e === HalfFloatType ) return r ? 5131 : null !== ( n = t.get( 'OES_texture_half_float' ) ) ? n.HALF_FLOAT_OES : null; if ( e === AlphaFormat ) return 6406; if ( e === RGBFormat ) return 6407; if ( e === RGBAFormat ) return 6408; if ( e === LuminanceFormat ) return 6409; if ( e === LuminanceAlphaFormat ) return 6410; if ( e === DepthFormat ) return 6402; if ( e === DepthStencilFormat ) return 34041; if ( e === RedFormat ) return 6403; if ( e === RedIntegerFormat ) return 36244; if ( e === RGFormat ) return 33319; if ( e === RGIntegerFormat ) return 33320; if ( e === RGBIntegerFormat ) return 36248; if ( e === RGBAIntegerFormat ) return 36249; if ( e === RGB_S3TC_DXT1_Format || e === RGBA_S3TC_DXT1_Format || e === RGBA_S3TC_DXT3_Format || e === RGBA_S3TC_DXT5_Format ) {

			if ( null === ( n = t.get( 'WEBGL_compressed_texture_s3tc' ) ) ) return null; if ( e === RGB_S3TC_DXT1_Format ) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if ( e === RGBA_S3TC_DXT1_Format ) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if ( e === RGBA_S3TC_DXT3_Format ) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if ( e === RGBA_S3TC_DXT5_Format ) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		if ( e === RGB_PVRTC_4BPPV1_Format || e === RGB_PVRTC_2BPPV1_Format || e === RGBA_PVRTC_4BPPV1_Format || e === RGBA_PVRTC_2BPPV1_Format ) {

			if ( null === ( n = t.get( 'WEBGL_compressed_texture_pvrtc' ) ) ) return null; if ( e === RGB_PVRTC_4BPPV1_Format ) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if ( e === RGB_PVRTC_2BPPV1_Format ) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if ( e === RGBA_PVRTC_4BPPV1_Format ) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if ( e === RGBA_PVRTC_2BPPV1_Format ) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		if ( e === RGB_ETC1_Format ) return null !== ( n = t.get( 'WEBGL_compressed_texture_etc1' ) ) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ( ( e === RGB_ETC2_Format || e === RGBA_ETC2_EAC_Format ) && null !== ( n = t.get( 'WEBGL_compressed_texture_etc' ) ) ) {

			if ( e === RGB_ETC2_Format ) return n.COMPRESSED_RGB8_ETC2; if ( e === RGBA_ETC2_EAC_Format ) return n.COMPRESSED_RGBA8_ETC2_EAC;

		}

		return e === RGBA_ASTC_4x4_Format || e === RGBA_ASTC_5x4_Format || e === RGBA_ASTC_5x5_Format || e === RGBA_ASTC_6x5_Format || e === RGBA_ASTC_6x6_Format || e === RGBA_ASTC_8x5_Format || e === RGBA_ASTC_8x6_Format || e === RGBA_ASTC_8x8_Format || e === RGBA_ASTC_10x5_Format || e === RGBA_ASTC_10x6_Format || e === RGBA_ASTC_10x8_Format || e === RGBA_ASTC_10x10_Format || e === RGBA_ASTC_12x10_Format || e === RGBA_ASTC_12x12_Format || e === SRGB8_ALPHA8_ASTC_4x4_Format || e === SRGB8_ALPHA8_ASTC_5x4_Format || e === SRGB8_ALPHA8_ASTC_5x5_Format || e === SRGB8_ALPHA8_ASTC_6x5_Format || e === SRGB8_ALPHA8_ASTC_6x6_Format || e === SRGB8_ALPHA8_ASTC_8x5_Format || e === SRGB8_ALPHA8_ASTC_8x6_Format || e === SRGB8_ALPHA8_ASTC_8x8_Format || e === SRGB8_ALPHA8_ASTC_10x5_Format || e === SRGB8_ALPHA8_ASTC_10x6_Format || e === SRGB8_ALPHA8_ASTC_10x8_Format || e === SRGB8_ALPHA8_ASTC_10x10_Format || e === SRGB8_ALPHA8_ASTC_12x10_Format || e === SRGB8_ALPHA8_ASTC_12x12_Format ? null !== ( n = t.get( 'WEBGL_compressed_texture_astc' ) ) ? e : null : e === RGBA_BPTC_Format ? null !== ( n = t.get( 'EXT_texture_compression_bptc' ) ) ? e : null : e === UnsignedInt248Type ? r ? 34042 : null !== ( n = t.get( 'WEBGL_depth_texture' ) ) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0;

	} };

}

function ArrayCamera( e = [] ) {

	PerspectiveCamera.call( this ), this.cameras = e;

}

function Group() {

	Object3D.call( this ), this.type = 'Group';

}

function WebXRController() {

	this._targetRay = null, this._grip = null, this._hand = null;

}

function WebXRManager( e, t ) {

	const n = this; let r = null, i = 1, o = null, a = 'local-floor', s = null; const c = [], l = new Map(), h = new PerspectiveCamera(); h.layers.enable( 1 ), h.viewport = new Vector4(); const u = new PerspectiveCamera(); u.layers.enable( 2 ), u.viewport = new Vector4(); const d = [ h, u ], p = new ArrayCamera(); p.layers.enable( 1 ), p.layers.enable( 2 ); let m = null, f = null; function g( e ) {

		const t = l.get( e.inputSource ); t && t.dispatchEvent( { type: e.type, data: e.inputSource } );

	}

	function v() {

		l.forEach( function ( e, t ) {

			e.disconnect( t );

		} ), l.clear(), e.setFramebuffer( null ), e.setRenderTarget( e.getRenderTarget() ), S.stop(), n.isPresenting = ! 1, n.dispatchEvent( { type: 'sessionend' } );

	}

	function y( e ) {

		o = e, S.setContext( r ), S.start(), n.isPresenting = ! 0, n.dispatchEvent( { type: 'sessionstart' } );

	}

	function _( e ) {

		const t = r.inputSources; for ( let e = 0; e < c.length; e ++ )l.set( t[ e ], c[ e ] ); for ( let t = 0; t < e.removed.length; t ++ ) {

			const n = e.removed[ t ], r = l.get( n ); r && ( r.dispatchEvent( { type: 'disconnected', data: n } ), l.delete( n ) );

		}

		for ( let t = 0; t < e.added.length; t ++ ) {

			const n = e.added[ t ], r = l.get( n ); r && r.dispatchEvent( { type: 'connected', data: n } );

		}

	}

	this.enabled = ! 1, this.isPresenting = ! 1, this.getController = function ( e ) {

		let t = c[ e ]; return void 0 === t && ( t = new WebXRController(), c[ e ] = t ), t.getTargetRaySpace();

	}, this.getControllerGrip = function ( e ) {

		let t = c[ e ]; return void 0 === t && ( t = new WebXRController(), c[ e ] = t ), t.getGripSpace();

	}, this.getHand = function ( e ) {

		let t = c[ e ]; return void 0 === t && ( t = new WebXRController(), c[ e ] = t ), t.getHandSpace();

	}, this.setFramebufferScaleFactor = function ( e ) {

		i = e, ! 0 === n.isPresenting && console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

	}, this.setReferenceSpaceType = function ( e ) {

		a = e, ! 0 === n.isPresenting && console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

	}, this.getReferenceSpace = function () {

		return o;

	}, this.getSession = function () {

		return r;

	}, this.setSession = function ( e ) {

		if ( null !== ( r = e ) ) {

			r.addEventListener( 'select', g ), r.addEventListener( 'selectstart', g ), r.addEventListener( 'selectend', g ), r.addEventListener( 'squeeze', g ), r.addEventListener( 'squeezestart', g ), r.addEventListener( 'squeezeend', g ), r.addEventListener( 'end', v ); const e = t.getContextAttributes(); ! 0 !== e.xrCompatible && t.makeXRCompatible(); const n = { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: i }, o = new XRWebGLLayer( r, t, n ); r.updateRenderState( { baseLayer: o } ), r.requestReferenceSpace( a ).then( y ), r.addEventListener( 'inputsourceschange', _ );

		}

	};

	const x = new Vector3(), b = new Vector3(); function M( e, t ) {

		null === t ? e.matrixWorld.copy( e.matrix ) : e.matrixWorld.multiplyMatrices( t.matrixWorld, e.matrix ), e.matrixWorldInverse.copy( e.matrixWorld ).invert();

	}

	this.getCamera = function ( e ) {

		p.near = u.near = h.near = e.near, p.far = u.far = h.far = e.far, m === p.near && f === p.far || ( r.updateRenderState( { depthNear: p.near, depthFar: p.far } ), m = p.near, f = p.far ); const t = e.parent, n = p.cameras; M( p, t ); for ( let e = 0; e < n.length; e ++ )M( n[ e ], t ); e.matrixWorld.copy( p.matrixWorld ); const i = e.children; for ( let e = 0, t = i.length; e < t; e ++ )i[ e ].updateMatrixWorld( ! 0 ); return 2 === n.length ? function ( e, t, n ) {

			x.setFromMatrixPosition( t.matrixWorld ), b.setFromMatrixPosition( n.matrixWorld ); const r = x.distanceTo( b ), i = t.projectionMatrix.elements, o = n.projectionMatrix.elements, a = i[ 14 ] / ( i[ 10 ] - 1 ), s = i[ 14 ] / ( i[ 10 ] + 1 ), c = ( i[ 9 ] + 1 ) / i[ 5 ], l = ( i[ 9 ] - 1 ) / i[ 5 ], h = ( i[ 8 ] - 1 ) / i[ 0 ], u = ( o[ 8 ] + 1 ) / o[ 0 ], d = a * h, p = a * u, m = r / ( - h + u ), f = m * - h; t.matrixWorld.decompose( e.position, e.quaternion, e.scale ), e.translateX( f ), e.translateZ( m ), e.matrixWorld.compose( e.position, e.quaternion, e.scale ), e.matrixWorldInverse.copy( e.matrixWorld ).invert(); const g = a + m, v = s + m, y = d - f, _ = p + ( r - f ), M = c * s / v * g, w = l * s / v * g; e.projectionMatrix.makePerspective( y, _, M, w, g, v );

		}( p, h, u ) : p.projectionMatrix.copy( h.projectionMatrix ), p;

	};

	let w = null; const S = new WebGLAnimation(); S.setAnimationLoop( function ( t, n ) {

		if ( null !== ( s = n.getViewerPose( o ) ) ) {

			const t = s.views, n = r.renderState.baseLayer; e.setFramebuffer( n.framebuffer ); let i = ! 1; t.length !== p.cameras.length && ( p.cameras.length = 0, i = ! 0 ); for ( let e = 0; e < t.length; e ++ ) {

				const r = t[ e ], o = n.getViewport( r ), a = d[ e ]; a.matrix.fromArray( r.transform.matrix ), a.projectionMatrix.fromArray( r.projectionMatrix ), a.viewport.set( o.x, o.y, o.width, o.height ), 0 === e && p.matrix.copy( a.matrix ), ! 0 === i && p.cameras.push( a );

			}

		}

		const i = r.inputSources; for ( let e = 0; e < c.length; e ++ ) {

			const t = c[ e ], r = i[ e ]; t.update( r, n, o );

		}

		w && w( t, n );

	} ), this.setAnimationLoop = function ( e ) {

		w = e;

	}, this.dispose = function () {};

}

function WebGLMaterials( e ) {

	function t( t, n ) {

		t.opacity.value = n.opacity, n.color && t.diffuse.value.copy( n.color ), n.emissive && t.emissive.value.copy( n.emissive ).multiplyScalar( n.emissiveIntensity ), n.map && ( t.map.value = n.map ), n.alphaMap && ( t.alphaMap.value = n.alphaMap ), n.specularMap && ( t.specularMap.value = n.specularMap ); const r = e.get( n ).envMap; if ( r ) {

			t.envMap.value = r, t.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? - 1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio; const i = e.get( r ).__maxMipLevel; void 0 !== i && ( t.maxMipLevel.value = i );

		}

		let i, o; n.lightMap && ( t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity ), n.aoMap && ( t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity ), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && ( i = n.clearcoatRoughnessMap ), void 0 !== i && ( i.isWebGLRenderTarget && ( i = i.texture ), ! 0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy( i.matrix ) ), n.aoMap ? o = n.aoMap : n.lightMap && ( o = n.lightMap ), void 0 !== o && ( o.isWebGLRenderTarget && ( o = o.texture ), ! 0 === o.matrixAutoUpdate && o.updateMatrix(), t.uv2Transform.value.copy( o.matrix ) );

	}

	function n( t, n ) {

		t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && ( t.roughnessMap.value = n.roughnessMap ), n.metalnessMap && ( t.metalnessMap.value = n.metalnessMap ), n.emissiveMap && ( t.emissiveMap.value = n.emissiveMap ), n.bumpMap && ( t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === BackSide && ( t.bumpScale.value *= - 1 ) ), n.normalMap && ( t.normalMap.value = n.normalMap, t.normalScale.value.copy( n.normalScale ), n.side === BackSide && t.normalScale.value.negate() ), n.displacementMap && ( t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias ), e.get( n ).envMap && ( t.envMapIntensity.value = n.envMapIntensity );

	}

	return { refreshFogUniforms: function ( e, t ) {

		e.fogColor.value.copy( t.color ), t.isFog ? ( e.fogNear.value = t.near, e.fogFar.value = t.far ) : t.isFogExp2 && ( e.fogDensity.value = t.density );

	}, refreshMaterialUniforms: function ( e, r, i, o ) {

		r.isMeshBasicMaterial ? t( e, r ) : r.isMeshLambertMaterial ? ( t( e, r ), function ( e, t ) {

			t.emissiveMap && ( e.emissiveMap.value = t.emissiveMap );

		}( e, r ) ) : r.isMeshToonMaterial ? ( t( e, r ), function ( e, t ) {

			t.gradientMap && ( e.gradientMap.value = t.gradientMap ), t.emissiveMap && ( e.emissiveMap.value = t.emissiveMap ), t.bumpMap && ( e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && ( e.bumpScale.value *= - 1 ) ), t.normalMap && ( e.normalMap.value = t.normalMap, e.normalScale.value.copy( t.normalScale ), t.side === BackSide && e.normalScale.value.negate() ), t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias );

		}( e, r ) ) : r.isMeshPhongMaterial ? ( t( e, r ), function ( e, t ) {

			e.specular.value.copy( t.specular ), e.shininess.value = Math.max( t.shininess, 1e-4 ), t.emissiveMap && ( e.emissiveMap.value = t.emissiveMap ), t.bumpMap && ( e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && ( e.bumpScale.value *= - 1 ) ), t.normalMap && ( e.normalMap.value = t.normalMap, e.normalScale.value.copy( t.normalScale ), t.side === BackSide && e.normalScale.value.negate() ), t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias );

		}( e, r ) ) : r.isMeshStandardMaterial ? ( t( e, r ), r.isMeshPhysicalMaterial ? function ( e, t ) {

			n( e, t ), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy( t.sheen ), t.clearcoatMap && ( e.clearcoatMap.value = t.clearcoatMap ), t.clearcoatRoughnessMap && ( e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap ), t.clearcoatNormalMap && ( e.clearcoatNormalScale.value.copy( t.clearcoatNormalScale ), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === BackSide && e.clearcoatNormalScale.value.negate() ), e.transmission.value = t.transmission, t.transmissionMap && ( e.transmissionMap.value = t.transmissionMap );

		}( e, r ) : n( e, r ) ) : r.isMeshMatcapMaterial ? ( t( e, r ), function ( e, t ) {

			t.matcap && ( e.matcap.value = t.matcap ), t.bumpMap && ( e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && ( e.bumpScale.value *= - 1 ) ), t.normalMap && ( e.normalMap.value = t.normalMap, e.normalScale.value.copy( t.normalScale ), t.side === BackSide && e.normalScale.value.negate() ), t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias );

		}( e, r ) ) : r.isMeshDepthMaterial ? ( t( e, r ), function ( e, t ) {

			t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias );

		}( e, r ) ) : r.isMeshDistanceMaterial ? ( t( e, r ), function ( e, t ) {

			t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias ), e.referencePosition.value.copy( t.referencePosition ), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance;

		}( e, r ) ) : r.isMeshNormalMaterial ? ( t( e, r ), function ( e, t ) {

			t.bumpMap && ( e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && ( e.bumpScale.value *= - 1 ) ), t.normalMap && ( e.normalMap.value = t.normalMap, e.normalScale.value.copy( t.normalScale ), t.side === BackSide && e.normalScale.value.negate() ), t.displacementMap && ( e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias );

		}( e, r ) ) : r.isLineBasicMaterial ? ( function ( e, t ) {

			e.diffuse.value.copy( t.color ), e.opacity.value = t.opacity;

		}( e, r ), r.isLineDashedMaterial && function ( e, t ) {

			e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale;

		}( e, r ) ) : r.isPointsMaterial ? function ( e, t, n, r ) {

			let i; e.diffuse.value.copy( t.color ), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && ( e.map.value = t.map ), t.alphaMap && ( e.alphaMap.value = t.alphaMap ), t.map ? i = t.map : t.alphaMap && ( i = t.alphaMap ), void 0 !== i && ( ! 0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy( i.matrix ) );

		}( e, r, i, o ) : r.isSpriteMaterial ? function ( e, t ) {

			let n; e.diffuse.value.copy( t.color ), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && ( e.map.value = t.map ), t.alphaMap && ( e.alphaMap.value = t.alphaMap ), t.map ? n = t.map : t.alphaMap && ( n = t.alphaMap ), void 0 !== n && ( ! 0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy( n.matrix ) );

		}( e, r ) : r.isShadowMaterial ? ( e.color.value.copy( r.color ), e.opacity.value = r.opacity ) : r.isShaderMaterial && ( r.uniformsNeedUpdate = ! 1 );

	} };

}

function createCanvasElement() {

	const e = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); return e.style.display = 'block', e;

}

function WebGLRenderer( e ) {

	const t = void 0 !== ( e = e || {} ).canvas ? e.canvas : createCanvasElement(), n = void 0 !== e.context ? e.context : null, r = void 0 !== e.alpha && e.alpha, i = void 0 === e.depth || e.depth, o = void 0 === e.stencil || e.stencil, a = void 0 !== e.antialias && e.antialias, s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, l = void 0 !== e.powerPreference ? e.powerPreference : 'default', h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let u = null, d = null; const p = []; this.domElement = t, this.debug = { checkShaderErrors: ! 0 }, this.autoClear = ! 0, this.autoClearColor = ! 0, this.autoClearDepth = ! 0, this.autoClearStencil = ! 0, this.sortObjects = ! 0, this.clippingPlanes = [], this.localClippingEnabled = ! 1, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = ! 1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const m = this; let f = ! 1, g = null, v = 0, y = 0, _ = null, x = null, b = - 1, M = null; const w = new Vector4(), S = new Vector4(); let T = null, E = t.width, A = t.height, L = 1, C = null, R = null; const P = new Vector4( 0, 0, E, A ), B = new Vector4( 0, 0, E, A ); let D = ! 1; const G = new Frustum(); let I = ! 1, F = ! 1; const N = new Matrix4(), O = new Vector3(), U = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: ! 0 }; function V() {

		return null === _ ? L : 1;

	}

	let z, H, k, W, j, q, $, X, Y, Z, J, Q, K, ee, te, ne, re, ie, oe, ae, se, ce = n; function le( e, n ) {

		for ( let r = 0; r < e.length; r ++ ) {

			const i = e[ r ], o = t.getContext( i, n ); if ( null !== o ) return o;

		}

		return null;

	}

	try {

		const e = { alpha: r, depth: i, stencil: o, antialias: a, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: h }; if ( t.addEventListener( 'webglcontextlost', pe, ! 1 ), t.addEventListener( 'webglcontextrestored', me, ! 1 ), null === ce ) {

			const t = [ 'webgl2', 'webgl', 'experimental-webgl' ]; if ( ! 0 === m.isWebGL1Renderer && t.shift(), null === ( ce = le( t, e ) ) ) throw le( t ) ? new Error( 'Error creating WebGL context with your selected attributes.' ) : new Error( 'Error creating WebGL context.' );

		}

		void 0 === ce.getShaderPrecisionFormat && ( ce.getShaderPrecisionFormat = function () {

			return { rangeMin: 1, rangeMax: 1, precision: 1 };

		} );

	} catch ( e ) {

		throw console.error( 'THREE.WebGLRenderer: ' + e.message ), e;

	}

	function he() {

		z = new WebGLExtensions( ce ), ! 1 === ( H = new WebGLCapabilities( ce, z, e ) ).isWebGL2 && ( z.get( 'WEBGL_depth_texture' ), z.get( 'OES_texture_float' ), z.get( 'OES_texture_half_float' ), z.get( 'OES_texture_half_float_linear' ), z.get( 'OES_standard_derivatives' ), z.get( 'OES_element_index_uint' ), z.get( 'OES_vertex_array_object' ), z.get( 'ANGLE_instanced_arrays' ) ), z.get( 'OES_texture_float_linear' ), ae = new WebGLUtils( ce, z, H ), ( k = new WebGLState( ce, z, H ) ).scissor( S.copy( B ).multiplyScalar( L ).floor() ), k.viewport( w.copy( P ).multiplyScalar( L ).floor() ), W = new WebGLInfo( ce ), j = new WebGLProperties(), q = new WebGLTextures( ce, z, k, j, H, ae, W ), $ = new WebGLCubeMaps( m ), X = new WebGLAttributes( ce, H ), se = new WebGLBindingStates( ce, z, X, H ), Y = new WebGLGeometries( ce, X, W, se ), Z = new WebGLObjects( ce, Y, X, W ), re = new WebGLMorphtargets( ce ), te = new WebGLClipping( j ), J = new WebGLPrograms( m, $, z, H, se, te ), Q = new WebGLMaterials( j ), K = new WebGLRenderLists( j ), ee = new WebGLRenderStates( z, H ), ne = new WebGLBackground( m, $, k, Z, s ), ie = new WebGLBufferRenderer( ce, z, W, H ), oe = new WebGLIndexedBufferRenderer( ce, z, W, H ), W.programs = J.programs, m.capabilities = H, m.extensions = z, m.properties = j, m.renderLists = K, m.state = k, m.info = W;

	}

	he(); const ue = new WebXRManager( m, ce ); this.xr = ue; const de = new WebGLShadowMap( m, Z, H.maxTextureSize ); function pe( e ) {

		e.preventDefault(), console.log( 'THREE.WebGLRenderer: Context Lost.' ), f = ! 0;

	}

	function me() {

		console.log( 'THREE.WebGLRenderer: Context Restored.' ), f = ! 1, he();

	}

	function fe( e ) {

		const t = e.target; t.removeEventListener( 'dispose', fe ), function ( e ) {

			ge( e ), j.remove( e );

		}( t );

	}

	function ge( e ) {

		const t = j.get( e ).program; void 0 !== t && J.releaseProgram( t );

	}

	this.shadowMap = de, this.getContext = function () {

		return ce;

	}, this.getContextAttributes = function () {

		return ce.getContextAttributes();

	}, this.forceContextLoss = function () {

		const e = z.get( 'WEBGL_lose_context' ); e && e.loseContext();

	}, this.forceContextRestore = function () {

		const e = z.get( 'WEBGL_lose_context' ); e && e.restoreContext();

	}, this.getPixelRatio = function () {

		return L;

	}, this.setPixelRatio = function ( e ) {

		void 0 !== e && ( L = e, this.setSize( E, A, ! 1 ) );

	}, this.getSize = function ( e ) {

		return void 0 === e && ( console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' ), e = new Vector2() ), e.set( E, A );

	}, this.setSize = function ( e, n, r ) {

		ue.isPresenting ? console.warn( "THREE.WebGLRenderer: Can't change size while VR device is presenting." ) : ( E = e, A = n, t.width = Math.floor( e * L ), t.height = Math.floor( n * L ), ! 1 !== r && ( t.style.width = e + 'px', t.style.height = n + 'px' ), this.setViewport( 0, 0, e, n ) );

	}, this.getDrawingBufferSize = function ( e ) {

		return void 0 === e && ( console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' ), e = new Vector2() ), e.set( E * L, A * L ).floor();

	}, this.setDrawingBufferSize = function ( e, n, r ) {

		E = e, A = n, L = r, t.width = Math.floor( e * r ), t.height = Math.floor( n * r ), this.setViewport( 0, 0, e, n );

	}, this.getCurrentViewport = function ( e ) {

		return void 0 === e && ( console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' ), e = new Vector4() ), e.copy( w );

	}, this.getViewport = function ( e ) {

		return e.copy( P );

	}, this.setViewport = function ( e, t, n, r ) {

		e.isVector4 ? P.set( e.x, e.y, e.z, e.w ) : P.set( e, t, n, r ), k.viewport( w.copy( P ).multiplyScalar( L ).floor() );

	}, this.getScissor = function ( e ) {

		return e.copy( B );

	}, this.setScissor = function ( e, t, n, r ) {

		e.isVector4 ? B.set( e.x, e.y, e.z, e.w ) : B.set( e, t, n, r ), k.scissor( S.copy( B ).multiplyScalar( L ).floor() );

	}, this.getScissorTest = function () {

		return D;

	}, this.setScissorTest = function ( e ) {

		k.setScissorTest( D = e );

	}, this.setOpaqueSort = function ( e ) {

		C = e;

	}, this.setTransparentSort = function ( e ) {

		R = e;

	}, this.getClearColor = function ( e ) {

		return void 0 === e && ( console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' ), e = new Color() ), e.copy( ne.getClearColor() );

	}, this.setClearColor = function () {

		ne.setClearColor.apply( ne, arguments );

	}, this.getClearAlpha = function () {

		return ne.getClearAlpha();

	}, this.setClearAlpha = function () {

		ne.setClearAlpha.apply( ne, arguments );

	}, this.clear = function ( e, t, n ) {

		let r = 0; ( void 0 === e || e ) && ( r |= 16384 ), ( void 0 === t || t ) && ( r |= 256 ), ( void 0 === n || n ) && ( r |= 1024 ), ce.clear( r );

	}, this.clearColor = function () {

		this.clear( ! 0, ! 1, ! 1 );

	}, this.clearDepth = function () {

		this.clear( ! 1, ! 0, ! 1 );

	}, this.clearStencil = function () {

		this.clear( ! 1, ! 1, ! 0 );

	}, this.dispose = function () {

		t.removeEventListener( 'webglcontextlost', pe, ! 1 ), t.removeEventListener( 'webglcontextrestored', me, ! 1 ), K.dispose(), ee.dispose(), j.dispose(), $.dispose(), Z.dispose(), se.dispose(), ue.dispose(), ye.stop();

	}, this.renderBufferImmediate = function ( e, t ) {

		se.initAttributes(); const n = j.get( e ); e.hasPositions && ! n.position && ( n.position = ce.createBuffer() ), e.hasNormals && ! n.normal && ( n.normal = ce.createBuffer() ), e.hasUvs && ! n.uv && ( n.uv = ce.createBuffer() ), e.hasColors && ! n.color && ( n.color = ce.createBuffer() ); const r = t.getAttributes(); e.hasPositions && ( ce.bindBuffer( 34962, n.position ), ce.bufferData( 34962, e.positionArray, 35048 ), se.enableAttribute( r.position ), ce.vertexAttribPointer( r.position, 3, 5126, ! 1, 0, 0 ) ), e.hasNormals && ( ce.bindBuffer( 34962, n.normal ), ce.bufferData( 34962, e.normalArray, 35048 ), se.enableAttribute( r.normal ), ce.vertexAttribPointer( r.normal, 3, 5126, ! 1, 0, 0 ) ), e.hasUvs && ( ce.bindBuffer( 34962, n.uv ), ce.bufferData( 34962, e.uvArray, 35048 ), se.enableAttribute( r.uv ), ce.vertexAttribPointer( r.uv, 2, 5126, ! 1, 0, 0 ) ), e.hasColors && ( ce.bindBuffer( 34962, n.color ), ce.bufferData( 34962, e.colorArray, 35048 ), se.enableAttribute( r.color ), ce.vertexAttribPointer( r.color, 3, 5126, ! 1, 0, 0 ) ), se.disableUnusedAttributes(), ce.drawArrays( 4, 0, e.count ), e.count = 0;

	}, this.renderBufferDirect = function ( e, t, n, r, i, o ) {

		null === t && ( t = U ); const a = i.isMesh && i.matrixWorld.determinant() < 0, s = Me( e, t, r, i ); k.setMaterial( r, a ); let c = n.index; const l = n.attributes.position; if ( null === c ) {

			if ( void 0 === l || 0 === l.count ) return;

		} else if ( 0 === c.count ) return; let h, u = 1; ! 0 === r.wireframe && ( c = Y.getWireframeAttribute( n ), u = 2 ), ( r.morphTargets || r.morphNormals ) && re.update( i, n, r, s ), se.setup( i, r, s, n, c ); let d = ie; null !== c && ( h = X.get( c ), ( d = oe ).setIndex( h ) ); const p = null !== c ? c.count : l.count, m = n.drawRange.start * u, f = n.drawRange.count * u, g = null !== o ? o.start * u : 0, v = null !== o ? o.count * u : 1 / 0, y = Math.max( m, g ), _ = Math.min( p, m + f, g + v ) - 1, x = Math.max( 0, _ - y + 1 ); if ( 0 !== x ) {

			if ( i.isMesh )! 0 === r.wireframe ? ( k.setLineWidth( r.wireframeLinewidth * V() ), d.setMode( 1 ) ) : d.setMode( 4 ); else if ( i.isLine ) {

				let e = r.linewidth; void 0 === e && ( e = 1 ), k.setLineWidth( e * V() ), i.isLineSegments ? d.setMode( 1 ) : i.isLineLoop ? d.setMode( 2 ) : d.setMode( 3 );

			} else i.isPoints ? d.setMode( 0 ) : i.isSprite && d.setMode( 4 ); if ( i.isInstancedMesh )d.renderInstances( y, x, i.count ); else if ( n.isInstancedBufferGeometry ) {

				const e = Math.min( n.instanceCount, n._maxInstanceCount ); d.renderInstances( y, x, e );

			} else d.render( y, x );

		}

	}, this.compile = function ( e, t ) {

		( d = ee.get( e ) ).init(), e.traverseVisible( function ( e ) {

			e.isLight && e.layers.test( t.layers ) && ( d.pushLight( e ), e.castShadow && d.pushShadow( e ) );

		} ), d.setupLights(); const n = new WeakMap(); e.traverse( function ( t ) {

			const r = t.material; if ( r ) if ( Array.isArray( r ) ) for ( let i = 0; i < r.length; i ++ ) {

				const o = r[ i ]; ! 1 === n.has( o ) && ( be( o, e, t ), n.set( o ) );

			} else ! 1 === n.has( r ) && ( be( r, e, t ), n.set( r ) );

		} );

	};

	let ve = null; const ye = new WebGLAnimation(); function _e( e, t, n ) {

		const r = ! 0 === t.isScene ? t.overrideMaterial : null; for ( let i = 0, o = e.length; i < o; i ++ ) {

			const o = e[ i ], a = o.object, s = o.geometry, c = null === r ? o.material : r, l = o.group; if ( n.isArrayCamera ) {

				const e = n.cameras; for ( let n = 0, r = e.length; n < r; n ++ ) {

					const r = e[ n ]; a.layers.test( r.layers ) && ( k.viewport( w.copy( r.viewport ) ), d.setupLightsView( r ), xe( a, t, r, s, c, l ) );

				}

			} else xe( a, t, n, s, c, l );

		}

	}

	function xe( e, t, n, r, i, o ) {

		if ( e.onBeforeRender( m, t, n, r, i, o ), e.modelViewMatrix.multiplyMatrices( n.matrixWorldInverse, e.matrixWorld ), e.normalMatrix.getNormalMatrix( e.modelViewMatrix ), e.isImmediateRenderObject ) {

			const r = Me( n, t, i, e ); k.setMaterial( i ), se.reset(), function ( e, t ) {

				e.render( function ( e ) {

					m.renderBufferImmediate( e, t );

				} );

			}( e, r );

		} else m.renderBufferDirect( n, t, r, i, e, o ); e.onAfterRender( m, t, n, r, i, o );

	}

	function be( e, t, n ) {

		! 0 !== t.isScene && ( t = U ); const r = j.get( e ), i = d.state.lights, o = d.state.shadowsArray, a = i.state.version, s = J.getParameters( e, i.state, o, t, n ), c = J.getProgramCacheKey( s ); let l = r.program, h = ! 0; if ( void 0 === l )e.addEventListener( 'dispose', fe ); else if ( l.cacheKey !== c )ge( e ); else if ( r.lightsStateVersion !== a )h = ! 1; else {

			if ( void 0 !== s.shaderID ) {

				const n = e.isMeshStandardMaterial ? t.environment : null; return void ( r.envMap = $.get( e.envMap || n ) );

			}

			h = ! 1;

		}

		h && ( s.uniforms = J.getUniforms( e ), e.onBeforeCompile( s, m ), l = J.acquireProgram( s, c ), r.program = l, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding ); const u = r.uniforms; ( e.isShaderMaterial || e.isRawShaderMaterial ) && ! 0 !== e.clipping || ( r.numClippingPlanes = te.numPlanes, r.numIntersection = te.numIntersection, u.clippingPlanes = te.uniform ), r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = $.get( e.envMap || r.environment ), r.needsLights = function ( e ) {

			return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && ! 0 === e.lights;

		}( e ), r.lightsStateVersion = a, r.needsLights && ( u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotShadowMatrix.value = i.state.spotShadowMatrix, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix ); const p = r.program.getUniforms(), f = WebGLUniforms.seqWithValue( p.seq, u ); r.uniformsList = f;

	}

	function Me( e, t, n, r ) {

		! 0 !== t.isScene && ( t = U ), q.resetTextureUnits(); const i = t.fog, o = n.isMeshStandardMaterial ? t.environment : null, a = null === _ ? m.outputEncoding : _.texture.encoding, s = $.get( n.envMap || o ), c = j.get( n ), l = d.state.lights; if ( ! 0 === I && ( ! 0 === F || e !== M ) ) {

			const t = e === M && n.id === b; te.setState( n, e, t );

		}

		n.version === c.__version ? n.fog && c.fog !== i ? be( n, t, r ) : c.environment !== o ? be( n, t, r ) : c.needsLights && c.lightsStateVersion !== l.state.version ? be( n, t, r ) : void 0 === c.numClippingPlanes || c.numClippingPlanes === te.numPlanes && c.numIntersection === te.numIntersection ? c.outputEncoding !== a ? be( n, t, r ) : c.envMap !== s && be( n, t, r ) : be( n, t, r ) : ( be( n, t, r ), c.__version = n.version ); let h = ! 1, u = ! 1, p = ! 1; const f = c.program, g = f.getUniforms(), v = c.uniforms; if ( k.useProgram( f.program ) && ( h = ! 0, u = ! 0, p = ! 0 ), n.id !== b && ( b = n.id, u = ! 0 ), h || M !== e ) {

			if ( g.setValue( ce, 'projectionMatrix', e.projectionMatrix ), H.logarithmicDepthBuffer && g.setValue( ce, 'logDepthBufFC', 2 / ( Math.log( e.far + 1 ) / Math.LN2 ) ), M !== e && ( M = e, u = ! 0, p = ! 0 ), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap ) {

				const t = g.map.cameraPosition; void 0 !== t && t.setValue( ce, O.setFromMatrixPosition( e.matrixWorld ) );

			}

			( n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial ) && g.setValue( ce, 'isOrthographic', ! 0 === e.isOrthographicCamera ), ( n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning ) && g.setValue( ce, 'viewMatrix', e.matrixWorldInverse );

		}

		if ( n.skinning ) {

			g.setOptional( ce, r, 'bindMatrix' ), g.setOptional( ce, r, 'bindMatrixInverse' ); const e = r.skeleton; if ( e ) {

				const t = e.bones; if ( H.floatVertexTextures ) {

					if ( null === e.boneTexture ) {

						let n = Math.sqrt( 4 * t.length ); n = MathUtils.ceilPowerOfTwo( n ), n = Math.max( n, 4 ); const r = new Float32Array( n * n * 4 ); r.set( e.boneMatrices ); const i = new DataTexture( r, n, n, RGBAFormat, FloatType ); e.boneMatrices = r, e.boneTexture = i, e.boneTextureSize = n;

					}

					g.setValue( ce, 'boneTexture', e.boneTexture, q ), g.setValue( ce, 'boneTextureSize', e.boneTextureSize );

				} else g.setOptional( ce, e, 'boneMatrices' );

			}

		}

		var y, x; return ( u || c.receiveShadow !== r.receiveShadow ) && ( c.receiveShadow = r.receiveShadow, g.setValue( ce, 'receiveShadow', r.receiveShadow ) ), u && ( g.setValue( ce, 'toneMappingExposure', m.toneMappingExposure ), c.needsLights && ( x = p, ( y = v ).ambientLightColor.needsUpdate = x, y.lightProbe.needsUpdate = x, y.directionalLights.needsUpdate = x, y.directionalLightShadows.needsUpdate = x, y.pointLights.needsUpdate = x, y.pointLightShadows.needsUpdate = x, y.spotLights.needsUpdate = x, y.spotLightShadows.needsUpdate = x, y.rectAreaLights.needsUpdate = x, y.hemisphereLights.needsUpdate = x ), i && n.fog && Q.refreshFogUniforms( v, i ), Q.refreshMaterialUniforms( v, n, L, A ), WebGLUniforms.upload( ce, c.uniformsList, v, q ) ), n.isShaderMaterial && ! 0 === n.uniformsNeedUpdate && ( WebGLUniforms.upload( ce, c.uniformsList, v, q ), n.uniformsNeedUpdate = ! 1 ), n.isSpriteMaterial && g.setValue( ce, 'center', r.center ), g.setValue( ce, 'modelViewMatrix', r.modelViewMatrix ), g.setValue( ce, 'normalMatrix', r.normalMatrix ), g.setValue( ce, 'modelMatrix', r.matrixWorld ), f;

	}

	ye.setAnimationLoop( function ( e ) {

		ue.isPresenting || ve && ve( e );

	} ), 'undefined' != typeof window && ye.setContext( window ), this.setAnimationLoop = function ( e ) {

		ve = e, ue.setAnimationLoop( e ), null === e ? ye.stop() : ye.start();

	}, this.render = function ( e, t ) {

		let n, r; if ( void 0 !== arguments[ 2 ] && ( console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' ), n = arguments[ 2 ] ), void 0 !== arguments[ 3 ] && ( console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' ), r = arguments[ 3 ] ), void 0 !== t && ! 0 !== t.isCamera ) return void console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' ); if ( ! 0 === f ) return; se.resetDefaultState(), b = - 1, M = null, ! 0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), ! 0 === ue.enabled && ! 0 === ue.isPresenting && ( t = ue.getCamera( t ) ), ! 0 === e.isScene && e.onBeforeRender( m, e, t, n || _ ), ( d = ee.get( e, p.length ) ).init(), p.push( d ), N.multiplyMatrices( t.projectionMatrix, t.matrixWorldInverse ), G.setFromProjectionMatrix( N ), F = this.localClippingEnabled, I = te.init( this.clippingPlanes, F, t ), ( u = K.get( e, t ) ).init(), function e( t, n, r, i ) {

			if ( ! 1 === t.visible ) return; const o = t.layers.test( n.layers ); if ( o ) if ( t.isGroup )r = t.renderOrder; else if ( t.isLOD )! 0 === t.autoUpdate && t.update( n ); else if ( t.isLight )d.pushLight( t ), t.castShadow && d.pushShadow( t ); else if ( t.isSprite ) {

				if ( ! t.frustumCulled || G.intersectsSprite( t ) ) {

					i && O.setFromMatrixPosition( t.matrixWorld ).applyMatrix4( N ); const e = Z.update( t ), n = t.material; n.visible && u.push( t, e, n, r, O.z, null );

				}

			} else if ( t.isImmediateRenderObject )i && O.setFromMatrixPosition( t.matrixWorld ).applyMatrix4( N ), u.push( t, null, t.material, r, O.z, null ); else if ( ( t.isMesh || t.isLine || t.isPoints ) && ( t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && ( t.skeleton.update(), t.skeleton.frame = W.render.frame ), ! t.frustumCulled || G.intersectsObject( t ) ) ) {

				i && O.setFromMatrixPosition( t.matrixWorld ).applyMatrix4( N ); const e = Z.update( t ), n = t.material; if ( Array.isArray( n ) ) {

					const i = e.groups; for ( let o = 0, a = i.length; o < a; o ++ ) {

						const a = i[ o ], s = n[ a.materialIndex ]; s && s.visible && u.push( t, e, s, r, O.z, a );

					}

				} else n.visible && u.push( t, e, n, r, O.z, null );

			}

			const a = t.children; for ( let t = 0, o = a.length; t < o; t ++ )e( a[ t ], n, r, i );

		}( e, t, 0, m.sortObjects ), u.finish(), ! 0 === m.sortObjects && u.sort( C, R ), ! 0 === I && te.beginShadows(); const i = d.state.shadowsArray; de.render( i, e, t ), d.setupLights(), d.setupLightsView( t ), ! 0 === I && te.endShadows(), ! 0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget( n ), ne.render( u, e, t, r ); const o = u.opaque, a = u.transparent; o.length > 0 && _e( o, e, t ), a.length > 0 && _e( a, e, t ), ! 0 === e.isScene && e.onAfterRender( m, e, t ), null !== _ && ( q.updateRenderTargetMipmap( _ ), q.updateMultisampleRenderTarget( _ ) ), k.buffers.depth.setTest( ! 0 ), k.buffers.depth.setMask( ! 0 ), k.buffers.color.setMask( ! 0 ), k.setPolygonOffset( ! 1 ), p.pop(), d = p.length > 0 ? p[ p.length - 1 ] : null, u = null;

	}, this.setFramebuffer = function ( e ) {

		g !== e && null === _ && ce.bindFramebuffer( 36160, e ), g = e;

	}, this.getActiveCubeFace = function () {

		return v;

	}, this.getActiveMipmapLevel = function () {

		return y;

	}, this.getRenderList = function () {

		return u;

	}, this.setRenderList = function ( e ) {

		u = e;

	}, this.getRenderTarget = function () {

		return _;

	}, this.setRenderTarget = function ( e, t = 0, n = 0 ) {

		_ = e, v = t, y = n, e && void 0 === j.get( e ).__webglFramebuffer && q.setupRenderTarget( e ); let r = g, i = ! 1; if ( e ) {

			const n = j.get( e ).__webglFramebuffer; e.isWebGLCubeRenderTarget ? ( r = n[ t ], i = ! 0 ) : r = e.isWebGLMultisampleRenderTarget ? j.get( e ).__webglMultisampledFramebuffer : n, w.copy( e.viewport ), S.copy( e.scissor ), T = e.scissorTest;

		} else w.copy( P ).multiplyScalar( L ).floor(), S.copy( B ).multiplyScalar( L ).floor(), T = D; if ( x !== r && ( ce.bindFramebuffer( 36160, r ), x = r ), k.viewport( w ), k.scissor( S ), k.setScissorTest( T ), i ) {

			const r = j.get( e.texture ); ce.framebufferTexture2D( 36160, 36064, 34069 + t, r.__webglTexture, n );

		}

	}, this.readRenderTargetPixels = function ( e, t, n, r, i, o, a ) {

		if ( ! e || ! e.isWebGLRenderTarget ) return void console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' ); let s = j.get( e ).__webglFramebuffer; if ( e.isWebGLCubeRenderTarget && void 0 !== a && ( s = s[ a ] ), s ) {

			let a = ! 1; s !== x && ( ce.bindFramebuffer( 36160, s ), a = ! 0 ); try {

				const s = e.texture, c = s.format, l = s.type; if ( c !== RGBAFormat && ae.convert( c ) !== ce.getParameter( 35739 ) ) return void console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' ); if ( ! ( l === UnsignedByteType || ae.convert( l ) === ce.getParameter( 35738 ) || l === FloatType && ( H.isWebGL2 || z.get( 'OES_texture_float' ) || z.get( 'WEBGL_color_buffer_float' ) ) || l === HalfFloatType && ( H.isWebGL2 ? z.get( 'EXT_color_buffer_float' ) : z.get( 'EXT_color_buffer_half_float' ) ) ) ) return void console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' ); 36053 === ce.checkFramebufferStatus( 36160 ) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ce.readPixels( t, n, r, i, ae.convert( c ), ae.convert( l ), o ) : console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

			} finally {

				a && ce.bindFramebuffer( 36160, x );

			}

		}

	}, this.copyFramebufferToTexture = function ( e, t, n = 0 ) {

		const r = Math.pow( 2, - n ), i = Math.floor( t.image.width * r ), o = Math.floor( t.image.height * r ), a = ae.convert( t.format ); q.setTexture2D( t, 0 ), ce.copyTexImage2D( 3553, n, a, e.x, e.y, i, o, 0 ), k.unbindTexture();

	}, this.copyTextureToTexture = function ( e, t, n, r = 0 ) {

		const i = t.image.width, o = t.image.height, a = ae.convert( n.format ), s = ae.convert( n.type ); q.setTexture2D( n, 0 ), ce.pixelStorei( 37440, n.flipY ), ce.pixelStorei( 37441, n.premultiplyAlpha ), ce.pixelStorei( 3317, n.unpackAlignment ), t.isDataTexture ? ce.texSubImage2D( 3553, r, e.x, e.y, i, o, a, s, t.image.data ) : t.isCompressedTexture ? ce.compressedTexSubImage2D( 3553, r, e.x, e.y, t.mipmaps[ 0 ].width, t.mipmaps[ 0 ].height, a, t.mipmaps[ 0 ].data ) : ce.texSubImage2D( 3553, r, e.x, e.y, a, s, t.image ), 0 === r && n.generateMipmaps && ce.generateMipmap( 3553 ), k.unbindTexture();

	}, this.initTexture = function ( e ) {

		q.setTexture2D( e, 0 ), k.unbindTexture();

	}, this.resetState = function () {

		k.reset(), se.reset();

	}, 'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

}

function WebGL1Renderer( e ) {

	WebGLRenderer.call( this, e );

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), { constructor: ArrayCamera, isArrayCamera: ! 0 } ), Group.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Group, isGroup: ! 0 } ), Object.assign( WebXRController.prototype, { constructor: WebXRController, getHandSpace: function () {

	if ( null === this._hand && ( this._hand = new Group(), this._hand.matrixAutoUpdate = ! 1, this._hand.visible = ! 1, this._hand.joints = [], this._hand.inputState = { pinching: ! 1 }, window.XRHand ) ) for ( let e = 0; e <= window.XRHand.LITTLE_PHALANX_TIP; e ++ ) {

		const e = new Group(); e.matrixAutoUpdate = ! 1, e.visible = ! 1, this._hand.joints.push( e ), this._hand.add( e );

	}

	return this._hand;

}, getTargetRaySpace: function () {

	return null === this._targetRay && ( this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = ! 1, this._targetRay.visible = ! 1 ), this._targetRay;

}, getGripSpace: function () {

	return null === this._grip && ( this._grip = new Group(), this._grip.matrixAutoUpdate = ! 1, this._grip.visible = ! 1 ), this._grip;

}, dispatchEvent: function ( e ) {

	return null !== this._targetRay && this._targetRay.dispatchEvent( e ), null !== this._grip && this._grip.dispatchEvent( e ), null !== this._hand && this._hand.dispatchEvent( e ), this;

}, disconnect: function ( e ) {

	return this.dispatchEvent( { type: 'disconnected', data: e } ), null !== this._targetRay && ( this._targetRay.visible = ! 1 ), null !== this._grip && ( this._grip.visible = ! 1 ), null !== this._hand && ( this._hand.visible = ! 1 ), this;

}, update: function ( e, t, n ) {

	let r = null, i = null, o = null; const a = this._targetRay, s = this._grip, c = this._hand; if ( e && 'visible-blurred' !== t.session.visibilityState ) if ( c && e.hand ) {

		o = ! 0; for ( let r = 0; r <= window.XRHand.LITTLE_PHALANX_TIP; r ++ ) if ( e.hand[ r ] ) {

			const i = t.getJointPose( e.hand[ r ], n ), o = c.joints[ r ]; null !== i && ( o.matrix.fromArray( i.transform.matrix ), o.matrix.decompose( o.position, o.rotation, o.scale ), o.jointRadius = i.radius ), o.visible = null !== i; const a = c.joints[ window.XRHand.INDEX_PHALANX_TIP ], s = c.joints[ window.XRHand.THUMB_PHALANX_TIP ], l = a.position.distanceTo( s.position ), h = .02, u = .005; c.inputState.pinching && l > h + u ? ( c.inputState.pinching = ! 1, this.dispatchEvent( { type: 'pinchend', handedness: e.handedness, target: this } ) ) : ! c.inputState.pinching && l <= h - u && ( c.inputState.pinching = ! 0, this.dispatchEvent( { type: 'pinchstart', handedness: e.handedness, target: this } ) );

		}

	} else null !== a && null !== ( r = t.getPose( e.targetRaySpace, n ) ) && ( a.matrix.fromArray( r.transform.matrix ), a.matrix.decompose( a.position, a.rotation, a.scale ) ), null !== s && e.gripSpace && null !== ( i = t.getPose( e.gripSpace, n ) ) && ( s.matrix.fromArray( i.transform.matrix ), s.matrix.decompose( s.position, s.rotation, s.scale ) ); return null !== a && ( a.visible = null !== r ), null !== s && ( s.visible = null !== i ), null !== c && ( c.visible = null !== o ), this;

} } ), Object.assign( WebXRManager.prototype, EventDispatcher.prototype ), WebGL1Renderer.prototype = Object.assign( Object.create( WebGLRenderer.prototype ), { constructor: WebGL1Renderer, isWebGL1Renderer: ! 0 } ); class FogExp2 {

	constructor( e, t ) {

		Object.defineProperty( this, 'isFogExp2', { value: ! 0 } ), this.name = '', this.color = new Color( e ), this.density = void 0 !== t ? t : 25e-5;

	}clone() {

		return new FogExp2( this.color, this.density );

	}toJSON() {

		return { type: 'FogExp2', color: this.color.getHex(), density: this.density };

	}

} class Fog {

	constructor( e, t, n ) {

		Object.defineProperty( this, 'isFog', { value: ! 0 } ), this.name = '', this.color = new Color( e ), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3;

	}clone() {

		return new Fog( this.color, this.near, this.far );

	}toJSON() {

		return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far };

	}

} class Scene extends Object3D {

	constructor() {

		super(), Object.defineProperty( this, 'isScene', { value: ! 0 } ), this.type = 'Scene', this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = ! 0, 'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

	}copy( e, t ) {

		return super.copy( e, t ), null !== e.background && ( this.background = e.background.clone() ), null !== e.environment && ( this.environment = e.environment.clone() ), null !== e.fog && ( this.fog = e.fog.clone() ), null !== e.overrideMaterial && ( this.overrideMaterial = e.overrideMaterial.clone() ), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;

	}toJSON( e ) {

		const t = super.toJSON( e ); return null !== this.background && ( t.object.background = this.background.toJSON( e ) ), null !== this.environment && ( t.object.environment = this.environment.toJSON( e ) ), null !== this.fog && ( t.object.fog = this.fog.toJSON() ), t;

	}

} function InterleavedBuffer( e, t ) {

	this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: - 1 }, this.version = 0, this.uuid = MathUtils.generateUUID();

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', { set: function ( e ) {

	! 0 === e && this.version ++;

} } ), Object.assign( InterleavedBuffer.prototype, { isInterleavedBuffer: ! 0, onUploadCallback: function () {}, setUsage: function ( e ) {

	return this.usage = e, this;

}, copy: function ( e ) {

	return this.array = new e.array.constructor( e.array ), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;

}, copyAt: function ( e, t, n ) {

	e *= this.stride, n *= t.stride; for ( let r = 0, i = this.stride; r < i; r ++ ) this.array[ e + r ] = t.array[ n + r ]; return this;

}, set: function ( e, t = 0 ) {

	return this.array.set( e, t ), this;

}, clone: function ( e ) {

	void 0 === e.arrayBuffers && ( e.arrayBuffers = {} ), void 0 === this.array.buffer._uuid && ( this.array.buffer._uuid = MathUtils.generateUUID() ), void 0 === e.arrayBuffers[ this.array.buffer._uuid ] && ( e.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer ); const t = new InterleavedBuffer( new this.array.constructor( e.arrayBuffers[ this.array.buffer._uuid ] ), this.stride ); return t.setUsage( this.usage ), t;

}, onUpload: function ( e ) {

	return this.onUploadCallback = e, this;

}, toJSON: function ( e ) {

	return void 0 === e.arrayBuffers && ( e.arrayBuffers = {} ), void 0 === this.array.buffer._uuid && ( this.array.buffer._uuid = MathUtils.generateUUID() ), void 0 === e.arrayBuffers[ this.array.buffer._uuid ] && ( e.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) ) ), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };

} } ); const _vector$6 = new Vector3(); function InterleavedBufferAttribute( e, t, n, r ) {

	this.name = '', this.data = e, this.itemSize = t, this.offset = n, this.normalized = ! 0 === r;

}

function SpriteMaterial( e ) {

	Material.call( this ), this.type = 'SpriteMaterial', this.color = new Color( 16777215 ), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = ! 0, this.transparent = ! 0, this.setValues( e );

}

let _geometry; Object.defineProperties( InterleavedBufferAttribute.prototype, { count: { get: function () {

	return this.data.count;

} }, array: { get: function () {

	return this.data.array;

} }, needsUpdate: { set: function ( e ) {

	this.data.needsUpdate = e;

} } } ), Object.assign( InterleavedBufferAttribute.prototype, { isInterleavedBufferAttribute: ! 0, applyMatrix4: function ( e ) {

	for ( let t = 0, n = this.data.count; t < n; t ++ )_vector$6.x = this.getX( t ), _vector$6.y = this.getY( t ), _vector$6.z = this.getZ( t ), _vector$6.applyMatrix4( e ), this.setXYZ( t, _vector$6.x, _vector$6.y, _vector$6.z ); return this;

}, setX: function ( e, t ) {

	return this.data.array[ e * this.data.stride + this.offset ] = t, this;

}, setY: function ( e, t ) {

	return this.data.array[ e * this.data.stride + this.offset + 1 ] = t, this;

}, setZ: function ( e, t ) {

	return this.data.array[ e * this.data.stride + this.offset + 2 ] = t, this;

}, setW: function ( e, t ) {

	return this.data.array[ e * this.data.stride + this.offset + 3 ] = t, this;

}, getX: function ( e ) {

	return this.data.array[ e * this.data.stride + this.offset ];

}, getY: function ( e ) {

	return this.data.array[ e * this.data.stride + this.offset + 1 ];

}, getZ: function ( e ) {

	return this.data.array[ e * this.data.stride + this.offset + 2 ];

}, getW: function ( e ) {

	return this.data.array[ e * this.data.stride + this.offset + 3 ];

}, setXY: function ( e, t, n ) {

	return e = e * this.data.stride + this.offset, this.data.array[ e + 0 ] = t, this.data.array[ e + 1 ] = n, this;

}, setXYZ: function ( e, t, n, r ) {

	return e = e * this.data.stride + this.offset, this.data.array[ e + 0 ] = t, this.data.array[ e + 1 ] = n, this.data.array[ e + 2 ] = r, this;

}, setXYZW: function ( e, t, n, r, i ) {

	return e = e * this.data.stride + this.offset, this.data.array[ e + 0 ] = t, this.data.array[ e + 1 ] = n, this.data.array[ e + 2 ] = r, this.data.array[ e + 3 ] = i, this;

}, clone: function ( e ) {

	if ( void 0 === e ) {

		console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' ); const e = []; for ( let t = 0; t < this.count; t ++ ) {

			const n = t * this.data.stride + this.offset; for ( let t = 0; t < this.itemSize; t ++ )e.push( this.data.array[ n + t ] );

		}

		return new BufferAttribute( new this.array.constructor( e ), this.itemSize, this.normalized );

	}

	return void 0 === e.interleavedBuffers && ( e.interleavedBuffers = {} ), void 0 === e.interleavedBuffers[ this.data.uuid ] && ( e.interleavedBuffers[ this.data.uuid ] = this.data.clone( e ) ), new InterleavedBufferAttribute( e.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

}, toJSON: function ( e ) {

	if ( void 0 === e ) {

		console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' ); const e = []; for ( let t = 0; t < this.count; t ++ ) {

			const n = t * this.data.stride + this.offset; for ( let t = 0; t < this.itemSize; t ++ )e.push( this.data.array[ n + t ] );

		}

		return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };

	}

	return void 0 === e.interleavedBuffers && ( e.interleavedBuffers = {} ), void 0 === e.interleavedBuffers[ this.data.uuid ] && ( e.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( e ) ), { isInterleavedBufferAttribute: ! 0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };

} } ), SpriteMaterial.prototype = Object.create( Material.prototype ), SpriteMaterial.prototype.constructor = SpriteMaterial, SpriteMaterial.prototype.isSpriteMaterial = ! 0, SpriteMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this;

};

const _intersectPoint = new Vector3(), _worldScale = new Vector3(), _mvPosition = new Vector3(), _alignedPosition = new Vector2(), _rotatedPosition = new Vector2(), _viewWorldMatrix = new Matrix4(), _vA$1 = new Vector3(), _vB$1 = new Vector3(), _vC$1 = new Vector3(), _uvA$1 = new Vector2(), _uvB$1 = new Vector2(), _uvC$1 = new Vector2(); function Sprite( e ) {

	if ( Object3D.call( this ), this.type = 'Sprite', void 0 === _geometry ) {

		_geometry = new BufferGeometry(); const e = new InterleavedBuffer( new Float32Array( [ - .5, - .5, 0, 0, 0, .5, - .5, 0, 1, 0, .5, .5, 0, 1, 1, - .5, .5, 0, 0, 1 ] ), 5 ); _geometry.setIndex( [ 0, 1, 2, 0, 2, 3 ] ), _geometry.setAttribute( 'position', new InterleavedBufferAttribute( e, 3, 0, ! 1 ) ), _geometry.setAttribute( 'uv', new InterleavedBufferAttribute( e, 2, 3, ! 1 ) );

	}

	this.geometry = _geometry, this.material = void 0 !== e ? e : new SpriteMaterial(), this.center = new Vector2( .5, .5 );

}

function transformVertex( e, t, n, r, i, o ) {

	_alignedPosition.subVectors( e, n ).addScalar( .5 ).multiply( r ), void 0 !== i ? ( _rotatedPosition.x = o * _alignedPosition.x - i * _alignedPosition.y, _rotatedPosition.y = i * _alignedPosition.x + o * _alignedPosition.y ) : _rotatedPosition.copy( _alignedPosition ), e.copy( t ), e.x += _rotatedPosition.x, e.y += _rotatedPosition.y, e.applyMatrix4( _viewWorldMatrix );

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Sprite, isSprite: ! 0, raycast: function ( e, t ) {

	null === e.camera && console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' ), _worldScale.setFromMatrixScale( this.matrixWorld ), _viewWorldMatrix.copy( e.camera.matrixWorld ), this.modelViewMatrix.multiplyMatrices( e.camera.matrixWorldInverse, this.matrixWorld ), _mvPosition.setFromMatrixPosition( this.modelViewMatrix ), e.camera.isPerspectiveCamera && ! 1 === this.material.sizeAttenuation && _worldScale.multiplyScalar( - _mvPosition.z ); const n = this.material.rotation; let r, i; 0 !== n && ( i = Math.cos( n ), r = Math.sin( n ) ); const o = this.center; transformVertex( _vA$1.set( - .5, - .5, 0 ), _mvPosition, o, _worldScale, r, i ), transformVertex( _vB$1.set( .5, - .5, 0 ), _mvPosition, o, _worldScale, r, i ), transformVertex( _vC$1.set( .5, .5, 0 ), _mvPosition, o, _worldScale, r, i ), _uvA$1.set( 0, 0 ), _uvB$1.set( 1, 0 ), _uvC$1.set( 1, 1 ); let a = e.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, ! 1, _intersectPoint ); if ( null === a && ( transformVertex( _vB$1.set( - .5, .5, 0 ), _mvPosition, o, _worldScale, r, i ), _uvB$1.set( 0, 1 ), null === ( a = e.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, ! 1, _intersectPoint ) ) ) ) return; const s = e.ray.origin.distanceTo( _intersectPoint ); s < e.near || s > e.far || t.push( { distance: s, point: _intersectPoint.clone(), uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ), face: null, object: this } );

}, copy: function ( e ) {

	return Object3D.prototype.copy.call( this, e ), void 0 !== e.center && this.center.copy( e.center ), this.material = e.material, this;

} } ); const _v1$4 = new Vector3(), _v2$2 = new Vector3(); function LOD() {

	Object3D.call( this ), this._currentLevel = 0, this.type = 'LOD', Object.defineProperties( this, { levels: { enumerable: ! 0, value: [] } } ), this.autoUpdate = ! 0;

}

LOD.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: LOD, isLOD: ! 0, copy: function ( e ) {

	Object3D.prototype.copy.call( this, e, ! 1 ); const t = e.levels; for ( let e = 0, n = t.length; e < n; e ++ ) {

		const n = t[ e ]; this.addLevel( n.object.clone(), n.distance );

	}

	return this.autoUpdate = e.autoUpdate, this;

}, addLevel: function ( e, t = 0 ) {

	t = Math.abs( t ); const n = this.levels; let r; for ( r = 0; r < n.length && ! ( t < n[ r ].distance ); r ++ );return n.splice( r, 0, { distance: t, object: e } ), this.add( e ), this;

}, getCurrentLevel: function () {

	return this._currentLevel;

}, getObjectForDistance: function ( e ) {

	const t = this.levels; if ( t.length > 0 ) {

		let n, r; for ( n = 1, r = t.length; n < r && ! ( e < t[ n ].distance ); n ++ );return t[ n - 1 ].object;

	}

	return null;

}, raycast: function ( e, t ) {

	if ( this.levels.length > 0 ) {

		_v1$4.setFromMatrixPosition( this.matrixWorld ); const n = e.ray.origin.distanceTo( _v1$4 ); this.getObjectForDistance( n ).raycast( e, t );

	}

}, update: function ( e ) {

	const t = this.levels; if ( t.length > 1 ) {

		_v1$4.setFromMatrixPosition( e.matrixWorld ), _v2$2.setFromMatrixPosition( this.matrixWorld ); const n = _v1$4.distanceTo( _v2$2 ) / e.zoom; let r, i; for ( t[ 0 ].object.visible = ! 0, r = 1, i = t.length; r < i && n >= t[ r ].distance; r ++ )t[ r - 1 ].object.visible = ! 1, t[ r ].object.visible = ! 0; for ( this._currentLevel = r - 1; r < i; r ++ )t[ r ].object.visible = ! 1;

	}

}, toJSON: function ( e ) {

	const t = Object3D.prototype.toJSON.call( this, e ); ! 1 === this.autoUpdate && ( t.object.autoUpdate = ! 1 ), t.object.levels = []; const n = this.levels; for ( let e = 0, r = n.length; e < r; e ++ ) {

		const r = n[ e ]; t.object.levels.push( { object: r.object.uuid, distance: r.distance } );

	}

	return t;

} } ); const _basePosition = new Vector3(), _skinIndex = new Vector4(), _skinWeight = new Vector4(), _vector$7 = new Vector3(), _matrix$1 = new Matrix4(); function SkinnedMesh( e, t ) {

	e && e.isGeometry && console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' ), Mesh.call( this, e, t ), this.type = 'SkinnedMesh', this.bindMode = 'attached', this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();

}

function Bone() {

	Object3D.call( this ), this.type = 'Bone';

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), { constructor: SkinnedMesh, isSkinnedMesh: ! 0, copy: function ( e ) {

	return Mesh.prototype.copy.call( this, e ), this.bindMode = e.bindMode, this.bindMatrix.copy( e.bindMatrix ), this.bindMatrixInverse.copy( e.bindMatrixInverse ), this.skeleton = e.skeleton, this;

}, bind: function ( e, t ) {

	this.skeleton = e, void 0 === t && ( this.updateMatrixWorld( ! 0 ), this.skeleton.calculateInverses(), t = this.matrixWorld ), this.bindMatrix.copy( t ), this.bindMatrixInverse.copy( t ).invert();

}, pose: function () {

	this.skeleton.pose();

}, normalizeSkinWeights: function () {

	const e = new Vector4(), t = this.geometry.attributes.skinWeight; for ( let n = 0, r = t.count; n < r; n ++ ) {

		e.x = t.getX( n ), e.y = t.getY( n ), e.z = t.getZ( n ), e.w = t.getW( n ); const r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar( r ) : e.set( 1, 0, 0, 0 ), t.setXYZW( n, e.x, e.y, e.z, e.w );

	}

}, updateMatrixWorld: function ( e ) {

	Mesh.prototype.updateMatrixWorld.call( this, e ), 'attached' === this.bindMode ? this.bindMatrixInverse.copy( this.matrixWorld ).invert() : 'detached' === this.bindMode ? this.bindMatrixInverse.copy( this.bindMatrix ).invert() : console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

}, boneTransform: function ( e, t ) {

	const n = this.skeleton, r = this.geometry; _skinIndex.fromBufferAttribute( r.attributes.skinIndex, e ), _skinWeight.fromBufferAttribute( r.attributes.skinWeight, e ), _basePosition.fromBufferAttribute( r.attributes.position, e ).applyMatrix4( this.bindMatrix ), t.set( 0, 0, 0 ); for ( let e = 0; e < 4; e ++ ) {

		const r = _skinWeight.getComponent( e ); if ( 0 !== r ) {

			const i = _skinIndex.getComponent( e ); _matrix$1.multiplyMatrices( n.bones[ i ].matrixWorld, n.boneInverses[ i ] ), t.addScaledVector( _vector$7.copy( _basePosition ).applyMatrix4( _matrix$1 ), r );

		}

	}

	return t.applyMatrix4( this.bindMatrixInverse );

} } ), Bone.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Bone, isBone: ! 0 } ); const _offsetMatrix = new Matrix4(), _identityMatrix = new Matrix4(); function Skeleton( e = [], t = [] ) {

	this.uuid = MathUtils.generateUUID(), this.bones = e.slice( 0 ), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = - 1, this.init();

}

Object.assign( Skeleton.prototype, { init: function () {

	const e = this.bones, t = this.boneInverses; if ( this.boneMatrices = new Float32Array( 16 * e.length ), 0 === t.length ) this.calculateInverses(); else if ( e.length !== t.length ) {

		console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' ), this.boneInverses = []; for ( let e = 0, t = this.bones.length; e < t; e ++ ) this.boneInverses.push( new Matrix4() );

	}

}, calculateInverses: function () {

	this.boneInverses.length = 0; for ( let e = 0, t = this.bones.length; e < t; e ++ ) {

		const t = new Matrix4(); this.bones[ e ] && t.copy( this.bones[ e ].matrixWorld ).invert(), this.boneInverses.push( t );

	}

}, pose: function () {

	for ( let e = 0, t = this.bones.length; e < t; e ++ ) {

		const t = this.bones[ e ]; t && t.matrixWorld.copy( this.boneInverses[ e ] ).invert();

	}

	for ( let e = 0, t = this.bones.length; e < t; e ++ ) {

		const t = this.bones[ e ]; t && ( t.parent && t.parent.isBone ? ( t.matrix.copy( t.parent.matrixWorld ).invert(), t.matrix.multiply( t.matrixWorld ) ) : t.matrix.copy( t.matrixWorld ), t.matrix.decompose( t.position, t.quaternion, t.scale ) );

	}

}, update: function () {

	const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for ( let r = 0, i = e.length; r < i; r ++ ) {

		const i = e[ r ] ? e[ r ].matrixWorld : _identityMatrix; _offsetMatrix.multiplyMatrices( i, t[ r ] ), _offsetMatrix.toArray( n, 16 * r );

	}

	null !== r && ( r.needsUpdate = ! 0 );

}, clone: function () {

	return new Skeleton( this.bones, this.boneInverses );

}, getBoneByName: function ( e ) {

	for ( let t = 0, n = this.bones.length; t < n; t ++ ) {

		const n = this.bones[ t ]; if ( n.name === e ) return n;

	}

}, dispose: function () {

	null !== this.boneTexture && ( this.boneTexture.dispose(), this.boneTexture = null );

}, fromJSON: function ( e, t ) {

	this.uuid = e.uuid; for ( let n = 0, r = e.bones.length; n < r; n ++ ) {

		const r = e.bones[ n ]; let i = t[ r ]; void 0 === i && ( console.warn( 'THREE.Skeleton: No bone found with UUID:', r ), i = new Bone() ), this.bones.push( i ), this.boneInverses.push( ( new Matrix4() ).fromArray( e.boneInverses[ n ] ) );

	}

	return this.init(), this;

}, toJSON: function () {

	const e = { metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for ( let r = 0, i = t.length; r < i; r ++ ) {

		const i = t[ r ]; e.bones.push( i.uuid ); const o = n[ r ]; e.boneInverses.push( o.toArray() );

	}

	return e;

} } ); const _instanceLocalMatrix = new Matrix4(), _instanceWorldMatrix = new Matrix4(), _instanceIntersects = [], _mesh = new Mesh(); function InstancedMesh( e, t, n ) {

	Mesh.call( this, e, t ), this.instanceMatrix = new BufferAttribute( new Float32Array( 16 * n ), 16 ), this.instanceColor = null, this.count = n, this.frustumCulled = ! 1;

}

function LineBasicMaterial( e ) {

	Material.call( this ), this.type = 'LineBasicMaterial', this.color = new Color( 16777215 ), this.linewidth = 1, this.linecap = 'round', this.linejoin = 'round', this.morphTargets = ! 1, this.setValues( e );

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), { constructor: InstancedMesh, isInstancedMesh: ! 0, copy: function ( e ) {

	return Mesh.prototype.copy.call( this, e ), this.instanceMatrix.copy( e.instanceMatrix ), this.count = e.count, this;

}, getColorAt: function ( e, t ) {

	t.fromArray( this.instanceColor.array, 3 * e );

}, getMatrixAt: function ( e, t ) {

	t.fromArray( this.instanceMatrix.array, 16 * e );

}, raycast: function ( e, t ) {

	const n = this.matrixWorld, r = this.count; if ( _mesh.geometry = this.geometry, _mesh.material = this.material, void 0 !== _mesh.material ) for ( let i = 0; i < r; i ++ ) {

		this.getMatrixAt( i, _instanceLocalMatrix ), _instanceWorldMatrix.multiplyMatrices( n, _instanceLocalMatrix ), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast( e, _instanceIntersects ); for ( let e = 0, n = _instanceIntersects.length; e < n; e ++ ) {

			const n = _instanceIntersects[ e ]; n.instanceId = i, n.object = this, t.push( n );

		}

		_instanceIntersects.length = 0;

	}

}, setColorAt: function ( e, t ) {

	null === this.instanceColor && ( this.instanceColor = new BufferAttribute( new Float32Array( 3 * this.count ), 3 ) ), t.toArray( this.instanceColor.array, 3 * e );

}, setMatrixAt: function ( e, t ) {

	t.toArray( this.instanceMatrix.array, 16 * e );

}, updateMorphTargets: function () {}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

} } ), LineBasicMaterial.prototype = Object.create( Material.prototype ), LineBasicMaterial.prototype.constructor = LineBasicMaterial, LineBasicMaterial.prototype.isLineBasicMaterial = ! 0, LineBasicMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this;

};

const _start = new Vector3(), _end = new Vector3(), _inverseMatrix$1 = new Matrix4(), _ray$1 = new Ray(), _sphere$2 = new Sphere(); function Line( e = new BufferGeometry(), t = new LineBasicMaterial() ) {

	Object3D.call( this ), this.type = 'Line', this.geometry = e, this.material = t, this.updateMorphTargets();

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Line, isLine: ! 0, copy: function ( e ) {

	return Object3D.prototype.copy.call( this, e ), this.material = e.material, this.geometry = e.geometry, this;

}, computeLineDistances: function () {

	const e = this.geometry; if ( e.isBufferGeometry ) if ( null === e.index ) {

		const t = e.attributes.position, n = [ 0 ]; for ( let e = 1, r = t.count; e < r; e ++ )_start.fromBufferAttribute( t, e - 1 ), _end.fromBufferAttribute( t, e ), n[ e ] = n[ e - 1 ], n[ e ] += _start.distanceTo( _end ); e.setAttribute( 'lineDistance', new Float32BufferAttribute( n, 1 ) );

	} else console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); else if ( e.isGeometry ) {

		const t = e.vertices, n = e.lineDistances; n[ 0 ] = 0; for ( let e = 1, r = t.length; e < r; e ++ )n[ e ] = n[ e - 1 ], n[ e ] += t[ e - 1 ].distanceTo( t[ e ] );

	}

	return this;

}, raycast: function ( e, t ) {

	const n = this.geometry, r = this.matrixWorld, i = e.params.Line.threshold; if ( null === n.boundingSphere && n.computeBoundingSphere(), _sphere$2.copy( n.boundingSphere ), _sphere$2.applyMatrix4( r ), _sphere$2.radius += i, ! 1 === e.ray.intersectsSphere( _sphere$2 ) ) return; _inverseMatrix$1.copy( r ).invert(), _ray$1.copy( e.ray ).applyMatrix4( _inverseMatrix$1 ); const o = i / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ), a = o * o, s = new Vector3(), c = new Vector3(), l = new Vector3(), h = new Vector3(), u = this.isLineSegments ? 2 : 1; if ( n.isBufferGeometry ) {

		const r = n.index, i = n.attributes.position; if ( null !== r ) {

			const n = r.array; for ( let r = 0, o = n.length - 1; r < o; r += u ) {

				const o = n[ r ], u = n[ r + 1 ]; if ( s.fromBufferAttribute( i, o ), c.fromBufferAttribute( i, u ), _ray$1.distanceSqToSegment( s, c, h, l ) > a ) continue; h.applyMatrix4( this.matrixWorld ); const d = e.ray.origin.distanceTo( h ); d < e.near || d > e.far || t.push( { distance: d, point: l.clone().applyMatrix4( this.matrixWorld ), index: r, face: null, faceIndex: null, object: this } );

			}

		} else for ( let n = 0, r = i.count - 1; n < r; n += u ) {

			if ( s.fromBufferAttribute( i, n ), c.fromBufferAttribute( i, n + 1 ), _ray$1.distanceSqToSegment( s, c, h, l ) > a ) continue; h.applyMatrix4( this.matrixWorld ); const r = e.ray.origin.distanceTo( h ); r < e.near || r > e.far || t.push( { distance: r, point: l.clone().applyMatrix4( this.matrixWorld ), index: n, face: null, faceIndex: null, object: this } );

		}

	} else if ( n.isGeometry ) {

		const r = n.vertices, i = r.length; for ( let n = 0; n < i - 1; n += u ) {

			if ( _ray$1.distanceSqToSegment( r[ n ], r[ n + 1 ], h, l ) > a ) continue; h.applyMatrix4( this.matrixWorld ); const i = e.ray.origin.distanceTo( h ); i < e.near || i > e.far || t.push( { distance: i, point: l.clone().applyMatrix4( this.matrixWorld ), index: n, face: null, faceIndex: null, object: this } );

		}

	}

}, updateMorphTargets: function () {

	const e = this.geometry; if ( e.isBufferGeometry ) {

		const t = e.morphAttributes, n = Object.keys( t ); if ( n.length > 0 ) {

			const e = t[ n[ 0 ] ]; if ( void 0 !== e ) {

				this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for ( let t = 0, n = e.length; t < n; t ++ ) {

					const n = e[ t ].name || String( t ); this.morphTargetInfluences.push( 0 ), this.morphTargetDictionary[ n ] = t;

				}

			}

		}

	} else {

		const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

} } ); const _start$1 = new Vector3(), _end$1 = new Vector3(); function LineSegments( e, t ) {

	Line.call( this, e, t ), this.type = 'LineSegments';

}

function LineLoop( e, t ) {

	Line.call( this, e, t ), this.type = 'LineLoop';

}

function PointsMaterial( e ) {

	Material.call( this ), this.type = 'PointsMaterial', this.color = new Color( 16777215 ), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = ! 0, this.morphTargets = ! 1, this.setValues( e );

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineSegments, isLineSegments: ! 0, computeLineDistances: function () {

	const e = this.geometry; if ( e.isBufferGeometry ) if ( null === e.index ) {

		const t = e.attributes.position, n = []; for ( let e = 0, r = t.count; e < r; e += 2 )_start$1.fromBufferAttribute( t, e ), _end$1.fromBufferAttribute( t, e + 1 ), n[ e ] = 0 === e ? 0 : n[ e - 1 ], n[ e + 1 ] = n[ e ] + _start$1.distanceTo( _end$1 ); e.setAttribute( 'lineDistance', new Float32BufferAttribute( n, 1 ) );

	} else console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); else if ( e.isGeometry ) {

		const t = e.vertices, n = e.lineDistances; for ( let e = 0, r = t.length; e < r; e += 2 )_start$1.copy( t[ e ] ), _end$1.copy( t[ e + 1 ] ), n[ e ] = 0 === e ? 0 : n[ e - 1 ], n[ e + 1 ] = n[ e ] + _start$1.distanceTo( _end$1 );

	}

	return this;

} } ), LineLoop.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineLoop, isLineLoop: ! 0 } ), PointsMaterial.prototype = Object.create( Material.prototype ), PointsMaterial.prototype.constructor = PointsMaterial, PointsMaterial.prototype.isPointsMaterial = ! 0, PointsMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;

};

const _inverseMatrix$2 = new Matrix4(), _ray$2 = new Ray(), _sphere$3 = new Sphere(), _position$1 = new Vector3(); function Points( e = new BufferGeometry(), t = new PointsMaterial() ) {

	Object3D.call( this ), this.type = 'Points', this.geometry = e, this.material = t, this.updateMorphTargets();

}

function testPoint( e, t, n, r, i, o, a ) {

	const s = _ray$2.distanceSqToPoint( e ); if ( s < n ) {

		const n = new Vector3(); _ray$2.closestPointToPoint( e, n ), n.applyMatrix4( r ); const c = i.ray.origin.distanceTo( n ); if ( c < i.near || c > i.far ) return; o.push( { distance: c, distanceToRay: Math.sqrt( s ), point: n, index: t, face: null, object: a } );

	}

}

function VideoTexture( e, t, n, r, i, o, a, s, c ) {

	Texture.call( this, e, t, n, r, i, o, a, s, c ), this.format = void 0 !== a ? a : RGBFormat, this.minFilter = void 0 !== o ? o : LinearFilter, this.magFilter = void 0 !== i ? i : LinearFilter, this.generateMipmaps = ! 1; const l = this; 'requestVideoFrameCallback' in e && e.requestVideoFrameCallback( function t() {

		l.needsUpdate = ! 0, e.requestVideoFrameCallback( t );

	} );

}

function CompressedTexture( e, t, n, r, i, o, a, s, c, l, h, u ) {

	Texture.call( this, null, o, a, s, c, l, r, i, h, u ), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = ! 1, this.generateMipmaps = ! 1;

}

function CanvasTexture( e, t, n, r, i, o, a, s, c ) {

	Texture.call( this, e, t, n, r, i, o, a, s, c ), this.needsUpdate = ! 0;

}

function DepthTexture( e, t, n, r, i, o, a, s, c, l ) {

	if ( ( l = void 0 !== l ? l : DepthFormat ) !== DepthFormat && l !== DepthStencilFormat ) throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' ); void 0 === n && l === DepthFormat && ( n = UnsignedShortType ), void 0 === n && l === DepthStencilFormat && ( n = UnsignedInt248Type ), Texture.call( this, null, r, i, o, a, s, l, n, c ), this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : NearestFilter, this.minFilter = void 0 !== s ? s : NearestFilter, this.flipY = ! 1, this.generateMipmaps = ! 1;

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Points, isPoints: ! 0, copy: function ( e ) {

	return Object3D.prototype.copy.call( this, e ), this.material = e.material, this.geometry = e.geometry, this;

}, raycast: function ( e, t ) {

	const n = this.geometry, r = this.matrixWorld, i = e.params.Points.threshold; if ( null === n.boundingSphere && n.computeBoundingSphere(), _sphere$3.copy( n.boundingSphere ), _sphere$3.applyMatrix4( r ), _sphere$3.radius += i, ! 1 === e.ray.intersectsSphere( _sphere$3 ) ) return; _inverseMatrix$2.copy( r ).invert(), _ray$2.copy( e.ray ).applyMatrix4( _inverseMatrix$2 ); const o = i / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ), a = o * o; if ( n.isBufferGeometry ) {

		const i = n.index, o = n.attributes.position; if ( null !== i ) {

			const n = i.array; for ( let i = 0, s = n.length; i < s; i ++ ) {

				const s = n[ i ]; _position$1.fromBufferAttribute( o, s ), testPoint( _position$1, s, a, r, e, t, this );

			}

		} else for ( let n = 0, i = o.count; n < i; n ++ )_position$1.fromBufferAttribute( o, n ), testPoint( _position$1, n, a, r, e, t, this );

	} else {

		const i = n.vertices; for ( let n = 0, o = i.length; n < o; n ++ )testPoint( i[ n ], n, a, r, e, t, this );

	}

}, updateMorphTargets: function () {

	const e = this.geometry; if ( e.isBufferGeometry ) {

		const t = e.morphAttributes, n = Object.keys( t ); if ( n.length > 0 ) {

			const e = t[ n[ 0 ] ]; if ( void 0 !== e ) {

				this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for ( let t = 0, n = e.length; t < n; t ++ ) {

					const n = e[ t ].name || String( t ); this.morphTargetInfluences.push( 0 ), this.morphTargetDictionary[ n ] = t;

				}

			}

		}

	} else {

		const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

} } ), VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), { constructor: VideoTexture, clone: function () {

	return new this.constructor( this.image ).copy( this );

}, isVideoTexture: ! 0, update: function () {

	const e = this.image; ! 1 === 'requestVideoFrameCallback' in e && e.readyState >= e.HAVE_CURRENT_DATA && ( this.needsUpdate = ! 0 );

} } ), CompressedTexture.prototype = Object.create( Texture.prototype ), CompressedTexture.prototype.constructor = CompressedTexture, CompressedTexture.prototype.isCompressedTexture = ! 0, CanvasTexture.prototype = Object.create( Texture.prototype ), CanvasTexture.prototype.constructor = CanvasTexture, CanvasTexture.prototype.isCanvasTexture = ! 0, DepthTexture.prototype = Object.create( Texture.prototype ), DepthTexture.prototype.constructor = DepthTexture, DepthTexture.prototype.isDepthTexture = ! 0; let _geometryId = 0; const _m1$3 = new Matrix4(), _obj$1 = new Object3D(), _offset$1 = new Vector3(); function Geometry() {

	Object.defineProperty( this, 'id', { value: _geometryId += 2 } ), this.uuid = MathUtils.generateUUID(), this.name = '', this.type = 'Geometry', this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = ! 1, this.verticesNeedUpdate = ! 1, this.uvsNeedUpdate = ! 1, this.normalsNeedUpdate = ! 1, this.colorsNeedUpdate = ! 1, this.lineDistancesNeedUpdate = ! 1, this.groupsNeedUpdate = ! 1;

}

Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Geometry, isGeometry: ! 0, applyMatrix4: function ( e ) {

	const t = ( new Matrix3() ).getNormalMatrix( e ); for ( let t = 0, n = this.vertices.length; t < n; t ++ ) {

		this.vertices[ t ].applyMatrix4( e );

	}

	for ( let e = 0, n = this.faces.length; e < n; e ++ ) {

		const n = this.faces[ e ]; n.normal.applyMatrix3( t ).normalize(); for ( let e = 0, r = n.vertexNormals.length; e < r; e ++ )n.vertexNormals[ e ].applyMatrix3( t ).normalize();

	}

	return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = ! 0, this.normalsNeedUpdate = ! 0, this;

}, rotateX: function ( e ) {

	return _m1$3.makeRotationX( e ), this.applyMatrix4( _m1$3 ), this;

}, rotateY: function ( e ) {

	return _m1$3.makeRotationY( e ), this.applyMatrix4( _m1$3 ), this;

}, rotateZ: function ( e ) {

	return _m1$3.makeRotationZ( e ), this.applyMatrix4( _m1$3 ), this;

}, translate: function ( e, t, n ) {

	return _m1$3.makeTranslation( e, t, n ), this.applyMatrix4( _m1$3 ), this;

}, scale: function ( e, t, n ) {

	return _m1$3.makeScale( e, t, n ), this.applyMatrix4( _m1$3 ), this;

}, lookAt: function ( e ) {

	return _obj$1.lookAt( e ), _obj$1.updateMatrix(), this.applyMatrix4( _obj$1.matrix ), this;

}, fromBufferGeometry: function ( e ) {

	const t = this, n = null !== e.index ? e.index : void 0, r = e.attributes; if ( void 0 === r.position ) return console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' ), this; const i = r.position, o = r.normal, a = r.color, s = r.uv, c = r.uv2; void 0 !== c && ( this.faceVertexUvs[ 1 ] = [] ); for ( let e = 0; e < i.count; e ++ )t.vertices.push( ( new Vector3() ).fromBufferAttribute( i, e ) ), void 0 !== a && t.colors.push( ( new Color() ).fromBufferAttribute( a, e ) ); function l( e, n, r, i ) {

		const l = void 0 === a ? [] : [ t.colors[ e ].clone(), t.colors[ n ].clone(), t.colors[ r ].clone() ], h = void 0 === o ? [] : [ ( new Vector3() ).fromBufferAttribute( o, e ), ( new Vector3() ).fromBufferAttribute( o, n ), ( new Vector3() ).fromBufferAttribute( o, r ) ], u = new Face3( e, n, r, h, l, i ); t.faces.push( u ), void 0 !== s && t.faceVertexUvs[ 0 ].push( [ ( new Vector2() ).fromBufferAttribute( s, e ), ( new Vector2() ).fromBufferAttribute( s, n ), ( new Vector2() ).fromBufferAttribute( s, r ) ] ), void 0 !== c && t.faceVertexUvs[ 1 ].push( [ ( new Vector2() ).fromBufferAttribute( c, e ), ( new Vector2() ).fromBufferAttribute( c, n ), ( new Vector2() ).fromBufferAttribute( c, r ) ] );

	}

	const h = e.groups; if ( h.length > 0 ) for ( let e = 0; e < h.length; e ++ ) {

		const t = h[ e ], r = t.start; for ( let e = r, i = r + t.count; e < i; e += 3 ) void 0 !== n ? l( n.getX( e ), n.getX( e + 1 ), n.getX( e + 2 ), t.materialIndex ) : l( e, e + 1, e + 2, t.materialIndex );

	} else if ( void 0 !== n ) for ( let e = 0; e < n.count; e += 3 )l( n.getX( e ), n.getX( e + 1 ), n.getX( e + 2 ) ); else for ( let e = 0; e < i.count; e += 3 )l( e, e + 1, e + 2 ); return this.computeFaceNormals(), null !== e.boundingBox && ( this.boundingBox = e.boundingBox.clone() ), null !== e.boundingSphere && ( this.boundingSphere = e.boundingSphere.clone() ), this;

}, center: function () {

	return this.computeBoundingBox(), this.boundingBox.getCenter( _offset$1 ).negate(), this.translate( _offset$1.x, _offset$1.y, _offset$1.z ), this;

}, normalize: function () {

	this.computeBoundingSphere(); const e = this.boundingSphere.center, t = this.boundingSphere.radius, n = 0 === t ? 1 : 1 / t, r = new Matrix4(); return r.set( n, 0, 0, - n * e.x, 0, n, 0, - n * e.y, 0, 0, n, - n * e.z, 0, 0, 0, 1 ), this.applyMatrix4( r ), this;

}, computeFaceNormals: function () {

	const e = new Vector3(), t = new Vector3(); for ( let n = 0, r = this.faces.length; n < r; n ++ ) {

		const r = this.faces[ n ], i = this.vertices[ r.a ], o = this.vertices[ r.b ], a = this.vertices[ r.c ]; e.subVectors( a, o ), t.subVectors( i, o ), e.cross( t ), e.normalize(), r.normal.copy( e );

	}

}, computeVertexNormals: function ( e = ! 0 ) {

	const t = new Array( this.vertices.length ); for ( let e = 0, n = this.vertices.length; e < n; e ++ )t[ e ] = new Vector3(); if ( e ) {

		const e = new Vector3(), n = new Vector3(); for ( let r = 0, i = this.faces.length; r < i; r ++ ) {

			const i = this.faces[ r ], o = this.vertices[ i.a ], a = this.vertices[ i.b ], s = this.vertices[ i.c ]; e.subVectors( s, a ), n.subVectors( o, a ), e.cross( n ), t[ i.a ].add( e ), t[ i.b ].add( e ), t[ i.c ].add( e );

		}

	} else {

		this.computeFaceNormals(); for ( let e = 0, n = this.faces.length; e < n; e ++ ) {

			const n = this.faces[ e ]; t[ n.a ].add( n.normal ), t[ n.b ].add( n.normal ), t[ n.c ].add( n.normal );

		}

	}

	for ( let e = 0, n = this.vertices.length; e < n; e ++ )t[ e ].normalize(); for ( let e = 0, n = this.faces.length; e < n; e ++ ) {

		const n = this.faces[ e ], r = n.vertexNormals; 3 === r.length ? ( r[ 0 ].copy( t[ n.a ] ), r[ 1 ].copy( t[ n.b ] ), r[ 2 ].copy( t[ n.c ] ) ) : ( r[ 0 ] = t[ n.a ].clone(), r[ 1 ] = t[ n.b ].clone(), r[ 2 ] = t[ n.c ].clone() );

	}

	this.faces.length > 0 && ( this.normalsNeedUpdate = ! 0 );

}, computeFlatVertexNormals: function () {

	this.computeFaceNormals(); for ( let e = 0, t = this.faces.length; e < t; e ++ ) {

		const t = this.faces[ e ], n = t.vertexNormals; 3 === n.length ? ( n[ 0 ].copy( t.normal ), n[ 1 ].copy( t.normal ), n[ 2 ].copy( t.normal ) ) : ( n[ 0 ] = t.normal.clone(), n[ 1 ] = t.normal.clone(), n[ 2 ] = t.normal.clone() );

	}

	this.faces.length > 0 && ( this.normalsNeedUpdate = ! 0 );

}, computeMorphNormals: function () {

	for ( let e = 0, t = this.faces.length; e < t; e ++ ) {

		const t = this.faces[ e ]; t.__originalFaceNormal ? t.__originalFaceNormal.copy( t.normal ) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || ( t.__originalVertexNormals = [] ); for ( let e = 0, n = t.vertexNormals.length; e < n; e ++ )t.__originalVertexNormals[ e ] ? t.__originalVertexNormals[ e ].copy( t.vertexNormals[ e ] ) : t.__originalVertexNormals[ e ] = t.vertexNormals[ e ].clone();

	}

	const e = new Geometry(); e.faces = this.faces; for ( let t = 0, n = this.morphTargets.length; t < n; t ++ ) {

		if ( ! this.morphNormals[ t ] ) {

			this.morphNormals[ t ] = {}, this.morphNormals[ t ].faceNormals = [], this.morphNormals[ t ].vertexNormals = []; const e = this.morphNormals[ t ].faceNormals, n = this.morphNormals[ t ].vertexNormals; for ( let t = 0, r = this.faces.length; t < r; t ++ ) {

				const t = new Vector3(), r = { a: new Vector3(), b: new Vector3(), c: new Vector3() }; e.push( t ), n.push( r );

			}

		}

		const n = this.morphNormals[ t ]; e.vertices = this.morphTargets[ t ].vertices, e.computeFaceNormals(), e.computeVertexNormals(); for ( let e = 0, t = this.faces.length; e < t; e ++ ) {

			const t = this.faces[ e ], r = n.faceNormals[ e ], i = n.vertexNormals[ e ]; r.copy( t.normal ), i.a.copy( t.vertexNormals[ 0 ] ), i.b.copy( t.vertexNormals[ 1 ] ), i.c.copy( t.vertexNormals[ 2 ] );

		}

	}

	for ( let e = 0, t = this.faces.length; e < t; e ++ ) {

		const t = this.faces[ e ]; t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals;

	}

}, computeBoundingBox: function () {

	null === this.boundingBox && ( this.boundingBox = new Box3() ), this.boundingBox.setFromPoints( this.vertices );

}, computeBoundingSphere: function () {

	null === this.boundingSphere && ( this.boundingSphere = new Sphere() ), this.boundingSphere.setFromPoints( this.vertices );

}, merge: function ( e, t, n = 0 ) {

	if ( ! e || ! e.isGeometry ) return void console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', e ); let r; const i = this.vertices.length, o = this.vertices, a = e.vertices, s = this.faces, c = e.faces, l = this.colors, h = e.colors; void 0 !== t && ( r = ( new Matrix3() ).getNormalMatrix( t ) ); for ( let e = 0, n = a.length; e < n; e ++ ) {

		const n = a[ e ].clone(); void 0 !== t && n.applyMatrix4( t ), o.push( n );

	}

	for ( let e = 0, t = h.length; e < t; e ++ )l.push( h[ e ].clone() ); for ( let e = 0, t = c.length; e < t; e ++ ) {

		const t = c[ e ]; let o, a; const l = t.vertexNormals, h = t.vertexColors, u = new Face3( t.a + i, t.b + i, t.c + i ); u.normal.copy( t.normal ), void 0 !== r && u.normal.applyMatrix3( r ).normalize(); for ( let e = 0, t = l.length; e < t; e ++ )o = l[ e ].clone(), void 0 !== r && o.applyMatrix3( r ).normalize(), u.vertexNormals.push( o ); u.color.copy( t.color ); for ( let e = 0, t = h.length; e < t; e ++ )a = h[ e ], u.vertexColors.push( a.clone() ); u.materialIndex = t.materialIndex + n, s.push( u );

	}

	for ( let t = 0, n = e.faceVertexUvs.length; t < n; t ++ ) {

		const n = e.faceVertexUvs[ t ]; void 0 === this.faceVertexUvs[ t ] && ( this.faceVertexUvs[ t ] = [] ); for ( let e = 0, r = n.length; e < r; e ++ ) {

			const r = n[ e ], i = []; for ( let e = 0, t = r.length; e < t; e ++ )i.push( r[ e ].clone() ); this.faceVertexUvs[ t ].push( i );

		}

	}

}, mergeMesh: function ( e ) {

	e && e.isMesh ? ( e.matrixAutoUpdate && e.updateMatrix(), this.merge( e.geometry, e.matrix ) ) : console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', e );

}, mergeVertices: function ( e = 4 ) {

	const t = {}, n = [], r = [], i = Math.pow( 10, e ); for ( let e = 0, o = this.vertices.length; e < o; e ++ ) {

		const o = this.vertices[ e ], a = Math.round( o.x * i ) + '_' + Math.round( o.y * i ) + '_' + Math.round( o.z * i ); void 0 === t[ a ] ? ( t[ a ] = e, n.push( this.vertices[ e ] ), r[ e ] = n.length - 1 ) : r[ e ] = r[ t[ a ] ];

	}

	const o = []; for ( let e = 0, t = this.faces.length; e < t; e ++ ) {

		const t = this.faces[ e ]; t.a = r[ t.a ], t.b = r[ t.b ], t.c = r[ t.c ]; const n = [ t.a, t.b, t.c ]; for ( let t = 0; t < 3; t ++ ) if ( n[ t ] === n[ ( t + 1 ) % 3 ] ) {

			o.push( e ); break;

		}

	}

	for ( let e = o.length - 1; e >= 0; e -- ) {

		const t = o[ e ]; this.faces.splice( t, 1 ); for ( let e = 0, n = this.faceVertexUvs.length; e < n; e ++ ) this.faceVertexUvs[ e ].splice( t, 1 );

	}

	const a = this.vertices.length - n.length; return this.vertices = n, a;

}, setFromPoints: function ( e ) {

	this.vertices = []; for ( let t = 0, n = e.length; t < n; t ++ ) {

		const n = e[ t ]; this.vertices.push( new Vector3( n.x, n.y, n.z || 0 ) );

	}

	return this;

}, sortFacesByMaterialIndex: function () {

	const e = this.faces, t = e.length; for ( let n = 0; n < t; n ++ )e[ n ]._id = n; e.sort( function ( e, t ) {

		return e.materialIndex - t.materialIndex;

	} ); const n = this.faceVertexUvs[ 0 ], r = this.faceVertexUvs[ 1 ]; let i, o; n && n.length === t && ( i = [] ), r && r.length === t && ( o = [] ); for ( let a = 0; a < t; a ++ ) {

		const t = e[ a ]._id; i && i.push( n[ t ] ), o && o.push( r[ t ] );

	}

	i && ( this.faceVertexUvs[ 0 ] = i ), o && ( this.faceVertexUvs[ 1 ] = o );

}, toJSON: function () {

	const e = { metadata: { version: 4.5, type: 'Geometry', generator: 'Geometry.toJSON' } }; if ( e.uuid = this.uuid, e.type = this.type, '' !== this.name && ( e.name = this.name ), void 0 !== this.parameters ) {

		const t = this.parameters; for ( const n in t ) void 0 !== t[ n ] && ( e[ n ] = t[ n ] ); return e;

	}

	const t = []; for ( let e = 0; e < this.vertices.length; e ++ ) {

		const n = this.vertices[ e ]; t.push( n.x, n.y, n.z );

	}

	const n = [], r = [], i = {}, o = [], a = {}, s = [], c = {}; for ( let e = 0; e < this.faces.length; e ++ ) {

		const t = this.faces[ e ], r = ! 0, i = ! 1, o = void 0 !== this.faceVertexUvs[ 0 ][ e ], a = t.normal.length() > 0, s = t.vertexNormals.length > 0, c = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b, p = t.vertexColors.length > 0; let m = 0; if ( m = l( m = l( m = l( m = l( m = l( m = l( m = l( m = l( m, 0, 0 ), 1, r ), 2, i ), 3, o ), 4, a ), 5, s ), 6, c ), 7, p ), n.push( m ), n.push( t.a, t.b, t.c ), n.push( t.materialIndex ), o ) {

			const t = this.faceVertexUvs[ 0 ][ e ]; n.push( d( t[ 0 ] ), d( t[ 1 ] ), d( t[ 2 ] ) );

		}

		if ( a && n.push( h( t.normal ) ), s ) {

			const e = t.vertexNormals; n.push( h( e[ 0 ] ), h( e[ 1 ] ), h( e[ 2 ] ) );

		}

		if ( c && n.push( u( t.color ) ), p ) {

			const e = t.vertexColors; n.push( u( e[ 0 ] ), u( e[ 1 ] ), u( e[ 2 ] ) );

		}

	}

	function l( e, t, n ) {

		return n ? e | 1 << t : e & ~ ( 1 << t );

	}

	function h( e ) {

		const t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== i[ t ] ? i[ t ] : ( i[ t ] = r.length / 3, r.push( e.x, e.y, e.z ), i[ t ] );

	}

	function u( e ) {

		const t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== a[ t ] ? a[ t ] : ( a[ t ] = o.length, o.push( e.getHex() ), a[ t ] );

	}

	function d( e ) {

		const t = e.x.toString() + e.y.toString(); return void 0 !== c[ t ] ? c[ t ] : ( c[ t ] = s.length / 2, s.push( e.x, e.y ), c[ t ] );

	}

	return e.data = {}, e.data.vertices = t, e.data.normals = r, o.length > 0 && ( e.data.colors = o ), s.length > 0 && ( e.data.uvs = [ s ] ), e.data.faces = n, e;

}, clone: function () {

	return ( new Geometry() ).copy( this );

}, copy: function ( e ) {

	this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; const t = e.vertices; for ( let e = 0, n = t.length; e < n; e ++ ) this.vertices.push( t[ e ].clone() ); const n = e.colors; for ( let e = 0, t = n.length; e < t; e ++ ) this.colors.push( n[ e ].clone() ); const r = e.faces; for ( let e = 0, t = r.length; e < t; e ++ ) this.faces.push( r[ e ].clone() ); for ( let t = 0, n = e.faceVertexUvs.length; t < n; t ++ ) {

		const n = e.faceVertexUvs[ t ]; void 0 === this.faceVertexUvs[ t ] && ( this.faceVertexUvs[ t ] = [] ); for ( let e = 0, r = n.length; e < r; e ++ ) {

			const r = n[ e ], i = []; for ( let e = 0, t = r.length; e < t; e ++ ) {

				const t = r[ e ]; i.push( t.clone() );

			}

			this.faceVertexUvs[ t ].push( i );

		}

	}

	const i = e.morphTargets; for ( let e = 0, t = i.length; e < t; e ++ ) {

		const t = {}; if ( t.name = i[ e ].name, void 0 !== i[ e ].vertices ) {

			t.vertices = []; for ( let n = 0, r = i[ e ].vertices.length; n < r; n ++ )t.vertices.push( i[ e ].vertices[ n ].clone() );

		}

		if ( void 0 !== i[ e ].normals ) {

			t.normals = []; for ( let n = 0, r = i[ e ].normals.length; n < r; n ++ )t.normals.push( i[ e ].normals[ n ].clone() );

		}

		this.morphTargets.push( t );

	}

	const o = e.morphNormals; for ( let e = 0, t = o.length; e < t; e ++ ) {

		const t = {}; if ( void 0 !== o[ e ].vertexNormals ) {

			t.vertexNormals = []; for ( let n = 0, r = o[ e ].vertexNormals.length; n < r; n ++ ) {

				const r = o[ e ].vertexNormals[ n ], i = {}; i.a = r.a.clone(), i.b = r.b.clone(), i.c = r.c.clone(), t.vertexNormals.push( i );

			}

		}

		if ( void 0 !== o[ e ].faceNormals ) {

			t.faceNormals = []; for ( let n = 0, r = o[ e ].faceNormals.length; n < r; n ++ )t.faceNormals.push( o[ e ].faceNormals[ n ].clone() );

		}

		this.morphNormals.push( t );

	}

	const a = e.skinWeights; for ( let e = 0, t = a.length; e < t; e ++ ) this.skinWeights.push( a[ e ].clone() ); const s = e.skinIndices; for ( let e = 0, t = s.length; e < t; e ++ ) this.skinIndices.push( s[ e ].clone() ); const c = e.lineDistances; for ( let e = 0, t = c.length; e < t; e ++ ) this.lineDistances.push( c[ e ] ); const l = e.boundingBox; null !== l && ( this.boundingBox = l.clone() ); const h = e.boundingSphere; return null !== h && ( this.boundingSphere = h.clone() ), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;

}, dispose: function () {

	this.dispatchEvent( { type: 'dispose' } );

} } ); class BoxGeometry extends Geometry {

	constructor( e, t, n, r, i, o ) {

		super(), this.type = 'BoxGeometry', this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: o }, this.fromBufferGeometry( new BoxBufferGeometry( e, t, n, r, i, o ) ), this.mergeVertices();

	}

} class CircleBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = 8, n = 0, r = 2 * Math.PI ) {

		super(), this.type = 'CircleBufferGeometry', this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, t = Math.max( 3, t ); const i = [], o = [], a = [], s = [], c = new Vector3(), l = new Vector2(); o.push( 0, 0, 0 ), a.push( 0, 0, 1 ), s.push( .5, .5 ); for ( let i = 0, h = 3; i <= t; i ++, h += 3 ) {

			const u = n + i / t * r; c.x = e * Math.cos( u ), c.y = e * Math.sin( u ), o.push( c.x, c.y, c.z ), a.push( 0, 0, 1 ), l.x = ( o[ h ] / e + 1 ) / 2, l.y = ( o[ h + 1 ] / e + 1 ) / 2, s.push( l.x, l.y );

		}

		for ( let e = 1; e <= t; e ++ )i.push( e, e + 1, 0 ); this.setIndex( i ), this.setAttribute( 'position', new Float32BufferAttribute( o, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( a, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( s, 2 ) );

	}

} class CircleGeometry extends Geometry {

	constructor( e, t, n, r ) {

		super(), this.type = 'CircleGeometry', this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, this.fromBufferGeometry( new CircleBufferGeometry( e, t, n, r ) ), this.mergeVertices();

	}

} class CylinderBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = 1, n = 1, r = 8, i = 1, o = ! 1, a = 0, s = 2 * Math.PI ) {

		super(), this.type = 'CylinderBufferGeometry', this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }; const c = this; r = Math.floor( r ), i = Math.floor( i ); const l = [], h = [], u = [], d = []; let p = 0; const m = [], f = n / 2; let g = 0; function v( n ) {

			const i = p, o = new Vector2(), m = new Vector3(); let v = 0; const y = ! 0 === n ? e : t, _ = ! 0 === n ? 1 : - 1; for ( let e = 1; e <= r; e ++ )h.push( 0, f * _, 0 ), u.push( 0, _, 0 ), d.push( .5, .5 ), p ++; const x = p; for ( let e = 0; e <= r; e ++ ) {

				const t = e / r * s + a, n = Math.cos( t ), i = Math.sin( t ); m.x = y * i, m.y = f * _, m.z = y * n, h.push( m.x, m.y, m.z ), u.push( 0, _, 0 ), o.x = .5 * n + .5, o.y = .5 * i * _ + .5, d.push( o.x, o.y ), p ++;

			}

			for ( let e = 0; e < r; e ++ ) {

				const t = i + e, r = x + e; ! 0 === n ? l.push( r, r + 1, t ) : l.push( r + 1, r, t ), v += 3;

			}

			c.addGroup( g, v, ! 0 === n ? 1 : 2 ), g += v;

		}

		! function () {

			const o = new Vector3(), v = new Vector3(); let y = 0; const _ = ( t - e ) / n; for ( let c = 0; c <= i; c ++ ) {

				const l = [], g = c / i, y = g * ( t - e ) + e; for ( let e = 0; e <= r; e ++ ) {

					const t = e / r, i = t * s + a, c = Math.sin( i ), m = Math.cos( i ); v.x = y * c, v.y = - g * n + f, v.z = y * m, h.push( v.x, v.y, v.z ), o.set( c, _, m ).normalize(), u.push( o.x, o.y, o.z ), d.push( t, 1 - g ), l.push( p ++ );

				}

				m.push( l );

			}

			for ( let e = 0; e < r; e ++ ) for ( let t = 0; t < i; t ++ ) {

				const n = m[ t ][ e ], r = m[ t + 1 ][ e ], i = m[ t + 1 ][ e + 1 ], o = m[ t ][ e + 1 ]; l.push( n, r, o ), l.push( r, i, o ), y += 6;

			}

			c.addGroup( g, y, 0 ), g += y;

		}(), ! 1 === o && ( e > 0 && v( ! 0 ), t > 0 && v( ! 1 ) ), this.setIndex( l ), this.setAttribute( 'position', new Float32BufferAttribute( h, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( u, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( d, 2 ) );

	}

} class CylinderGeometry extends Geometry {

	constructor( e, t, n, r, i, o, a, s ) {

		super(), this.type = 'CylinderGeometry', this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }, this.fromBufferGeometry( new CylinderBufferGeometry( e, t, n, r, i, o, a, s ) ), this.mergeVertices();

	}

} class ConeGeometry extends CylinderGeometry {

	constructor( e, t, n, r, i, o, a ) {

		super( 0, e, t, n, r, i, o, a ), this.type = 'ConeGeometry', this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a };

	}

} class ConeBufferGeometry extends CylinderBufferGeometry {

	constructor( e = 1, t = 1, n = 8, r = 1, i = ! 1, o = 0, a = 2 * Math.PI ) {

		super( 0, e, t, n, r, i, o, a ), this.type = 'ConeBufferGeometry', this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a };

	}

} class PolyhedronBufferGeometry extends BufferGeometry {

	constructor( e, t, n = 1, r = 0 ) {

		super(), this.type = 'PolyhedronBufferGeometry', this.parameters = { vertices: e, indices: t, radius: n, detail: r }; const i = [], o = []; function a( e, t, n, r ) {

			const i = r + 1, o = []; for ( let r = 0; r <= i; r ++ ) {

				o[ r ] = []; const a = e.clone().lerp( n, r / i ), s = t.clone().lerp( n, r / i ), c = i - r; for ( let e = 0; e <= c; e ++ )o[ r ][ e ] = 0 === e && r === i ? a : a.clone().lerp( s, e / c );

			}

			for ( let e = 0; e < i; e ++ ) for ( let t = 0; t < 2 * ( i - e ) - 1; t ++ ) {

				const n = Math.floor( t / 2 ); t % 2 == 0 ? ( s( o[ e ][ n + 1 ] ), s( o[ e + 1 ][ n ] ), s( o[ e ][ n ] ) ) : ( s( o[ e ][ n + 1 ] ), s( o[ e + 1 ][ n + 1 ] ), s( o[ e + 1 ][ n ] ) );

			}

		}

		function s( e ) {

			i.push( e.x, e.y, e.z );

		}

		function c( t, n ) {

			const r = 3 * t; n.x = e[ r + 0 ], n.y = e[ r + 1 ], n.z = e[ r + 2 ];

		}

		function l( e, t, n, r ) {

			r < 0 && 1 === e.x && ( o[ t ] = e.x - 1 ), 0 === n.x && 0 === n.z && ( o[ t ] = r / 2 / Math.PI + .5 );

		}

		function h( e ) {

			return Math.atan2( e.z, - e.x );

		}

		! function ( e ) {

			const n = new Vector3(), r = new Vector3(), i = new Vector3(); for ( let o = 0; o < t.length; o += 3 )c( t[ o + 0 ], n ), c( t[ o + 1 ], r ), c( t[ o + 2 ], i ), a( n, r, i, e );

		}( r ), function ( e ) {

			const t = new Vector3(); for ( let n = 0; n < i.length; n += 3 )t.x = i[ n + 0 ], t.y = i[ n + 1 ], t.z = i[ n + 2 ], t.normalize().multiplyScalar( e ), i[ n + 0 ] = t.x, i[ n + 1 ] = t.y, i[ n + 2 ] = t.z;

		}( n ), function () {

			const e = new Vector3(); for ( let n = 0; n < i.length; n += 3 ) {

				e.x = i[ n + 0 ], e.y = i[ n + 1 ], e.z = i[ n + 2 ]; const r = h( e ) / 2 / Math.PI + .5, a = ( t = e, Math.atan2( - t.y, Math.sqrt( t.x * t.x + t.z * t.z ) ) / Math.PI + .5 ); o.push( r, 1 - a );

			}

			var t; ( function () {

				const e = new Vector3(), t = new Vector3(), n = new Vector3(), r = new Vector3(), a = new Vector2(), s = new Vector2(), c = new Vector2(); for ( let u = 0, d = 0; u < i.length; u += 9, d += 6 ) {

					e.set( i[ u + 0 ], i[ u + 1 ], i[ u + 2 ] ), t.set( i[ u + 3 ], i[ u + 4 ], i[ u + 5 ] ), n.set( i[ u + 6 ], i[ u + 7 ], i[ u + 8 ] ), a.set( o[ d + 0 ], o[ d + 1 ] ), s.set( o[ d + 2 ], o[ d + 3 ] ), c.set( o[ d + 4 ], o[ d + 5 ] ), r.copy( e ).add( t ).add( n ).divideScalar( 3 ); const p = h( r ); l( a, d + 0, e, p ), l( s, d + 2, t, p ), l( c, d + 4, n, p );

				}

			} )(), function () {

				for ( let e = 0; e < o.length; e += 6 ) {

					const t = o[ e + 0 ], n = o[ e + 2 ], r = o[ e + 4 ], i = Math.max( t, n, r ), a = Math.min( t, n, r ); i > .9 && a < .1 && ( t < .2 && ( o[ e + 0 ] += 1 ), n < .2 && ( o[ e + 2 ] += 1 ), r < .2 && ( o[ e + 4 ] += 1 ) );

				}

			}();

		}(), this.setAttribute( 'position', new Float32BufferAttribute( i, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( i.slice(), 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( o, 2 ) ), 0 === r ? this.computeVertexNormals() : this.normalizeNormals();

	}

} class DodecahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( e = 1, t = 0 ) {

		const n = ( 1 + Math.sqrt( 5 ) ) / 2, r = 1 / n; super( [ - 1, - 1, - 1, - 1, - 1, 1, - 1, 1, - 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, 1, 1, 1, - 1, 1, 1, 1, 0, - r, - n, 0, - r, n, 0, r, - n, 0, r, n, - r, - n, 0, - r, n, 0, r, - n, 0, r, n, 0, - n, 0, - r, n, 0, - r, - n, 0, r, n, 0, r ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], e, t ), this.type = 'DodecahedronBufferGeometry', this.parameters = { radius: e, detail: t };

	}

} class DodecahedronGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'DodecahedronGeometry', this.parameters = { radius: e, detail: t }, this.fromBufferGeometry( new DodecahedronBufferGeometry( e, t ) ), this.mergeVertices();

	}

} const _v0$2 = new Vector3(), _v1$5 = new Vector3(), _normal$1 = new Vector3(), _triangle = new Triangle(); class EdgesGeometry extends BufferGeometry {

	constructor( e, t ) {

		super(), this.type = 'EdgesGeometry', this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1, e.isGeometry && ( e = ( new BufferGeometry() ).fromGeometry( e ) ); const n = Math.pow( 10, 4 ), r = Math.cos( MathUtils.DEG2RAD * t ), i = e.getIndex(), o = e.getAttribute( 'position' ), a = i ? i.count : o.count, s = [ 0, 0, 0 ], c = [ 'a', 'b', 'c' ], l = new Array( 3 ), h = {}, u = []; for ( let e = 0; e < a; e += 3 ) {

			i ? ( s[ 0 ] = i.getX( e ), s[ 1 ] = i.getX( e + 1 ), s[ 2 ] = i.getX( e + 2 ) ) : ( s[ 0 ] = e, s[ 1 ] = e + 1, s[ 2 ] = e + 2 ); const { a: t, b: a, c: d } = _triangle; if ( t.fromBufferAttribute( o, s[ 0 ] ), a.fromBufferAttribute( o, s[ 1 ] ), d.fromBufferAttribute( o, s[ 2 ] ), _triangle.getNormal( _normal$1 ), l[ 0 ] = `${Math.round( t.x * n )},${Math.round( t.y * n )},${Math.round( t.z * n )}`, l[ 1 ] = `${Math.round( a.x * n )},${Math.round( a.y * n )},${Math.round( a.z * n )}`, l[ 2 ] = `${Math.round( d.x * n )},${Math.round( d.y * n )},${Math.round( d.z * n )}`, l[ 0 ] !== l[ 1 ] && l[ 1 ] !== l[ 2 ] && l[ 2 ] !== l[ 0 ] ) for ( let e = 0; e < 3; e ++ ) {

				const t = ( e + 1 ) % 3, n = l[ e ], i = l[ t ], o = _triangle[ c[ e ] ], a = _triangle[ c[ t ] ], d = `${n}_${i}`, p = `${i}_${n}`; p in h && h[ p ] ? ( _normal$1.dot( h[ p ].normal ) <= r && ( u.push( o.x, o.y, o.z ), u.push( a.x, a.y, a.z ) ), h[ p ] = null ) : d in h || ( h[ d ] = { index0: s[ e ], index1: s[ t ], normal: _normal$1.clone() } );

			}

		}

		for ( const e in h ) if ( h[ e ] ) {

			const { index0: t, index1: n } = h[ e ]; _v0$2.fromBufferAttribute( o, t ), _v1$5.fromBufferAttribute( o, n ), u.push( _v0$2.x, _v0$2.y, _v0$2.z ), u.push( _v1$5.x, _v1$5.y, _v1$5.z );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( u, 3 ) );

	}

} const Earcut = { triangulate: function ( e, t, n ) {

	n = n || 2; const r = t && t.length, i = r ? t[ 0 ] * n : e.length; let o = linkedList( e, 0, i, n, ! 0 ); const a = []; if ( ! o || o.next === o.prev ) return a; let s, c, l, h, u, d, p; if ( r && ( o = eliminateHoles( e, t, o, n ) ), e.length > 80 * n ) {

		s = l = e[ 0 ], c = h = e[ 1 ]; for ( let t = n; t < i; t += n )( u = e[ t ] ) < s && ( s = u ), ( d = e[ t + 1 ] ) < c && ( c = d ), u > l && ( l = u ), d > h && ( h = d ); p = 0 !== ( p = Math.max( l - s, h - c ) ) ? 1 / p : 0;

	}

	return earcutLinked( o, a, n, s, c, p ), a;

} }; function linkedList( e, t, n, r, i ) {

	let o, a; if ( i === signedArea( e, t, n, r ) > 0 ) for ( o = t; o < n; o += r )a = insertNode( o, e[ o ], e[ o + 1 ], a ); else for ( o = n - r; o >= t; o -= r )a = insertNode( o, e[ o ], e[ o + 1 ], a ); return a && equals( a, a.next ) && ( removeNode( a ), a = a.next ), a;

}

function filterPoints( e, t ) {

	if ( ! e ) return e; t || ( t = e ); let n, r = e; do {

		if ( n = ! 1, r.steiner || ! equals( r, r.next ) && 0 !== area( r.prev, r, r.next ) )r = r.next; else {

			if ( removeNode( r ), ( r = t = r.prev ) === r.next ) break; n = ! 0;

		}

	} while ( n || r !== t );

	return t;

}

function earcutLinked( e, t, n, r, i, o, a ) {

	if ( ! e ) return; ! a && o && indexCurve( e, r, i, o ); let s, c, l = e; for ( ;e.prev !== e.next; ) if ( s = e.prev, c = e.next, o ? isEarHashed( e, r, i, o ) : isEar( e ) )t.push( s.i / n ), t.push( e.i / n ), t.push( c.i / n ), removeNode( e ), e = c.next, l = c.next; else if ( ( e = c ) === l ) {

		a ? 1 === a ? earcutLinked( e = cureLocalIntersections( filterPoints( e ), t, n ), t, n, r, i, o, 2 ) : 2 === a && splitEarcut( e, t, n, r, i, o ) : earcutLinked( filterPoints( e ), t, n, r, i, o, 1 ); break;

	}

}

function isEar( e ) {

	const t = e.prev, n = e, r = e.next; if ( area( t, n, r ) >= 0 ) return ! 1; let i = e.next.next; for ( ;i !== e.prev; ) {

		if ( pointInTriangle( t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y ) && area( i.prev, i, i.next ) >= 0 ) return ! 1; i = i.next;

	}

	return ! 0;

}

function isEarHashed( e, t, n, r ) {

	const i = e.prev, o = e, a = e.next; if ( area( i, o, a ) >= 0 ) return ! 1; const s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, l = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, h = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, u = zOrder( s, c, t, n, r ), d = zOrder( l, h, t, n, r ); let p = e.prevZ, m = e.nextZ; for ( ;p && p.z >= u && m && m.z <= d; ) {

		if ( p !== e.prev && p !== e.next && pointInTriangle( i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return ! 1; if ( p = p.prevZ, m !== e.prev && m !== e.next && pointInTriangle( i.x, i.y, o.x, o.y, a.x, a.y, m.x, m.y ) && area( m.prev, m, m.next ) >= 0 ) return ! 1; m = m.nextZ;

	}

	for ( ;p && p.z >= u; ) {

		if ( p !== e.prev && p !== e.next && pointInTriangle( i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return ! 1; p = p.prevZ;

	}

	for ( ;m && m.z <= d; ) {

		if ( m !== e.prev && m !== e.next && pointInTriangle( i.x, i.y, o.x, o.y, a.x, a.y, m.x, m.y ) && area( m.prev, m, m.next ) >= 0 ) return ! 1; m = m.nextZ;

	}

	return ! 0;

}

function cureLocalIntersections( e, t, n ) {

	let r = e; do {

		const i = r.prev, o = r.next.next; ! equals( i, o ) && intersects( i, r, r.next, o ) && locallyInside( i, o ) && locallyInside( o, i ) && ( t.push( i.i / n ), t.push( r.i / n ), t.push( o.i / n ), removeNode( r ), removeNode( r.next ), r = e = o ), r = r.next;

	} while ( r !== e );

	return filterPoints( r );

}

function splitEarcut( e, t, n, r, i, o ) {

	let a = e; do {

		let e = a.next.next; for ( ;e !== a.prev; ) {

			if ( a.i !== e.i && isValidDiagonal( a, e ) ) {

				let s = splitPolygon( a, e ); return a = filterPoints( a, a.next ), s = filterPoints( s, s.next ), earcutLinked( a, t, n, r, i, o ), void earcutLinked( s, t, n, r, i, o );

			}

			e = e.next;

		}

		a = a.next;

	} while ( a !== e );

}

function eliminateHoles( e, t, n, r ) {

	const i = []; let o, a, s, c, l; for ( o = 0, a = t.length; o < a; o ++ )( l = linkedList( e, s = t[ o ] * r, c = o < a - 1 ? t[ o + 1 ] * r : e.length, r, ! 1 ) ) === l.next && ( l.steiner = ! 0 ), i.push( getLeftmost( l ) ); for ( i.sort( compareX ), o = 0; o < i.length; o ++ )eliminateHole( i[ o ], n ), n = filterPoints( n, n.next ); return n;

}

function compareX( e, t ) {

	return e.x - t.x;

}

function eliminateHole( e, t ) {

	if ( t = findHoleBridge( e, t ) ) {

		const n = splitPolygon( t, e ); filterPoints( t, t.next ), filterPoints( n, n.next );

	}

}

function findHoleBridge( e, t ) {

	let n = t; const r = e.x, i = e.y; let o, a = - 1 / 0; do {

		if ( i <= n.y && i >= n.next.y && n.next.y !== n.y ) {

			const e = n.x + ( i - n.y ) * ( n.next.x - n.x ) / ( n.next.y - n.y ); if ( e <= r && e > a ) {

				if ( a = e, e === r ) {

					if ( i === n.y ) return n; if ( i === n.next.y ) return n.next;

				}

				o = n.x < n.next.x ? n : n.next;

			}

		}

		n = n.next;

	} while ( n !== t );

	if ( ! o ) return null; if ( r === a ) return o; const s = o, c = o.x, l = o.y; let h, u = 1 / 0; n = o; do {

		r >= n.x && n.x >= c && r !== n.x && pointInTriangle( i < l ? r : a, i, c, l, i < l ? a : r, i, n.x, n.y ) && ( h = Math.abs( i - n.y ) / ( r - n.x ), locallyInside( n, e ) && ( h < u || h === u && ( n.x > o.x || n.x === o.x && sectorContainsSector( o, n ) ) ) && ( o = n, u = h ) ), n = n.next;

	} while ( n !== s );

	return o;

}

function sectorContainsSector( e, t ) {

	return area( e.prev, e, t.prev ) < 0 && area( t.next, e, e.next ) < 0;

}

function indexCurve( e, t, n, r ) {

	let i = e; do {

		null === i.z && ( i.z = zOrder( i.x, i.y, t, n, r ) ), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;

	} while ( i !== e );

	i.prevZ.nextZ = null, i.prevZ = null, sortLinked( i );

}

function sortLinked( e ) {

	let t, n, r, i, o, a, s, c, l = 1; do {

		for ( n = e, e = null, o = null, a = 0; n; ) {

			for ( a ++, r = n, s = 0, t = 0; t < l && ( s ++, r = r.nextZ ); t ++ );for ( c = l; s > 0 || c > 0 && r; )0 !== s && ( 0 === c || ! r || n.z <= r.z ) ? ( i = n, n = n.nextZ, s -- ) : ( i = r, r = r.nextZ, c -- ), o ? o.nextZ = i : e = i, i.prevZ = o, o = i; n = r;

		}

		o.nextZ = null, l *= 2;

	} while ( a > 1 );

	return e;

}

function zOrder( e, t, n, r, i ) {

	return ( e = 1431655765 & ( ( e = 858993459 & ( ( e = 252645135 & ( ( e = 16711935 & ( ( e = 32767 * ( e - n ) * i ) | e << 8 ) ) | e << 4 ) ) | e << 2 ) ) | e << 1 ) ) | ( t = 1431655765 & ( ( t = 858993459 & ( ( t = 252645135 & ( ( t = 16711935 & ( ( t = 32767 * ( t - r ) * i ) | t << 8 ) ) | t << 4 ) ) | t << 2 ) ) | t << 1 ) ) << 1;

}

function getLeftmost( e ) {

	let t = e, n = e; do {

		( t.x < n.x || t.x === n.x && t.y < n.y ) && ( n = t ), t = t.next;

	} while ( t !== e );

	return n;

}

function pointInTriangle( e, t, n, r, i, o, a, s ) {

	return ( i - a ) * ( t - s ) - ( e - a ) * ( o - s ) >= 0 && ( e - a ) * ( r - s ) - ( n - a ) * ( t - s ) >= 0 && ( n - a ) * ( o - s ) - ( i - a ) * ( r - s ) >= 0;

}

function isValidDiagonal( e, t ) {

	return e.next.i !== t.i && e.prev.i !== t.i && ! intersectsPolygon( e, t ) && ( locallyInside( e, t ) && locallyInside( t, e ) && middleInside( e, t ) && ( area( e.prev, e, t.prev ) || area( e, t.prev, t ) ) || equals( e, t ) && area( e.prev, e, e.next ) > 0 && area( t.prev, t, t.next ) > 0 );

}

function area( e, t, n ) {

	return ( t.y - e.y ) * ( n.x - t.x ) - ( t.x - e.x ) * ( n.y - t.y );

}

function equals( e, t ) {

	return e.x === t.x && e.y === t.y;

}

function intersects( e, t, n, r ) {

	const i = sign( area( e, t, n ) ), o = sign( area( e, t, r ) ), a = sign( area( n, r, e ) ), s = sign( area( n, r, t ) ); return i !== o && a !== s || ( ! ( 0 !== i || ! onSegment( e, n, t ) ) || ( ! ( 0 !== o || ! onSegment( e, r, t ) ) || ( ! ( 0 !== a || ! onSegment( n, e, r ) ) || ! ( 0 !== s || ! onSegment( n, t, r ) ) ) ) );

}

function onSegment( e, t, n ) {

	return t.x <= Math.max( e.x, n.x ) && t.x >= Math.min( e.x, n.x ) && t.y <= Math.max( e.y, n.y ) && t.y >= Math.min( e.y, n.y );

}

function sign( e ) {

	return e > 0 ? 1 : e < 0 ? - 1 : 0;

}

function intersectsPolygon( e, t ) {

	let n = e; do {

		if ( n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && intersects( n, n.next, e, t ) ) return ! 0; n = n.next;

	} while ( n !== e );

	return ! 1;

}

function locallyInside( e, t ) {

	return area( e.prev, e, e.next ) < 0 ? area( e, t, e.next ) >= 0 && area( e, e.prev, t ) >= 0 : area( e, t, e.prev ) < 0 || area( e, e.next, t ) < 0;

}

function middleInside( e, t ) {

	let n = e, r = ! 1; const i = ( e.x + t.x ) / 2, o = ( e.y + t.y ) / 2; do {

		n.y > o != n.next.y > o && n.next.y !== n.y && i < ( n.next.x - n.x ) * ( o - n.y ) / ( n.next.y - n.y ) + n.x && ( r = ! r ), n = n.next;

	} while ( n !== e );

	return r;

}

function splitPolygon( e, t ) {

	const n = new Node( e.i, e.x, e.y ), r = new Node( t.i, t.x, t.y ), i = e.next, o = t.prev; return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r;

}

function insertNode( e, t, n, r ) {

	const i = new Node( e, t, n ); return r ? ( i.next = r.next, i.prev = r, r.next.prev = i, r.next = i ) : ( i.prev = i, i.next = i ), i;

}

function removeNode( e ) {

	e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && ( e.prevZ.nextZ = e.nextZ ), e.nextZ && ( e.nextZ.prevZ = e.prevZ );

}

function Node( e, t, n ) {

	this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = ! 1;

}

function signedArea( e, t, n, r ) {

	let i = 0; for ( let o = t, a = n - r; o < n; o += r )i += ( e[ a ] - e[ o ] ) * ( e[ o + 1 ] + e[ a + 1 ] ), a = o; return i;

}

const ShapeUtils = { area: function ( e ) {

	const t = e.length; let n = 0; for ( let r = t - 1, i = 0; i < t; r = i ++ )n += e[ r ].x * e[ i ].y - e[ i ].x * e[ r ].y; return .5 * n;

}, isClockWise: function ( e ) {

	return ShapeUtils.area( e ) < 0;

}, triangulateShape: function ( e, t ) {

	const n = [], r = [], i = []; removeDupEndPts( e ), addContour( n, e ); let o = e.length; t.forEach( removeDupEndPts ); for ( let e = 0; e < t.length; e ++ )r.push( o ), o += t[ e ].length, addContour( n, t[ e ] ); const a = Earcut.triangulate( n, r ); for ( let e = 0; e < a.length; e += 3 )i.push( a.slice( e, e + 3 ) ); return i;

} }; function removeDupEndPts( e ) {

	const t = e.length; t > 2 && e[ t - 1 ].equals( e[ 0 ] ) && e.pop();

}

function addContour( e, t ) {

	for ( let n = 0; n < t.length; n ++ )e.push( t[ n ].x ), e.push( t[ n ].y );

}

class ExtrudeBufferGeometry extends BufferGeometry {

	constructor( e, t ) {

		super(), this.type = 'ExtrudeBufferGeometry', this.parameters = { shapes: e, options: t }, e = Array.isArray( e ) ? e : [ e ]; const n = this, r = [], i = []; for ( let t = 0, n = e.length; t < n; t ++ ) {

			o( e[ t ] );

		}

		function o( e ) {

			const o = [], a = void 0 !== t.curveSegments ? t.curveSegments : 12, s = void 0 !== t.steps ? t.steps : 1; let c = void 0 !== t.depth ? t.depth : 100, l = void 0 === t.bevelEnabled || t.bevelEnabled, h = void 0 !== t.bevelThickness ? t.bevelThickness : 6, u = void 0 !== t.bevelSize ? t.bevelSize : h - 2, d = void 0 !== t.bevelOffset ? t.bevelOffset : 0, p = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const m = t.extrudePath, f = void 0 !== t.UVGenerator ? t.UVGenerator : WorldUVGenerator; void 0 !== t.amount && ( console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' ), c = t.amount ); let g, v, y, _, x, b = ! 1; m && ( g = m.getSpacedPoints( s ), b = ! 0, l = ! 1, v = m.computeFrenetFrames( s, ! 1 ), y = new Vector3(), _ = new Vector3(), x = new Vector3() ), l || ( p = 0, h = 0, u = 0, d = 0 ); const M = e.extractPoints( a ); let w = M.shape; const S = M.holes; if ( ! ShapeUtils.isClockWise( w ) ) {

				w = w.reverse(); for ( let e = 0, t = S.length; e < t; e ++ ) {

					const t = S[ e ]; ShapeUtils.isClockWise( t ) && ( S[ e ] = t.reverse() );

				}

			}

			const T = ShapeUtils.triangulateShape( w, S ), E = w; for ( let e = 0, t = S.length; e < t; e ++ ) {

				const t = S[ e ]; w = w.concat( t );

			}

			function A( e, t, n ) {

				return t || console.error( 'THREE.ExtrudeGeometry: vec does not exist' ), t.clone().multiplyScalar( n ).add( e );

			}

			const L = w.length, C = T.length; function R( e, t, n ) {

				let r, i, o; const a = e.x - t.x, s = e.y - t.y, c = n.x - e.x, l = n.y - e.y, h = a * a + s * s, u = a * l - s * c; if ( Math.abs( u ) > Number.EPSILON ) {

					const u = Math.sqrt( h ), d = Math.sqrt( c * c + l * l ), p = t.x - s / u, m = t.y + a / u, f = ( ( n.x - l / d - p ) * l - ( n.y + c / d - m ) * c ) / ( a * l - s * c ), g = ( r = p + a * f - e.x ) * r + ( i = m + s * f - e.y ) * i; if ( g <= 2 ) return new Vector2( r, i ); o = Math.sqrt( g / 2 );

				} else {

					let e = ! 1; a > Number.EPSILON ? c > Number.EPSILON && ( e = ! 0 ) : a < - Number.EPSILON ? c < - Number.EPSILON && ( e = ! 0 ) : Math.sign( s ) === Math.sign( l ) && ( e = ! 0 ), e ? ( r = - s, i = a, o = Math.sqrt( h ) ) : ( r = a, i = s, o = Math.sqrt( h / 2 ) );

				}

				return new Vector2( r / o, i / o );

			}

			const P = []; for ( let e = 0, t = E.length, n = t - 1, r = e + 1; e < t; e ++, n ++, r ++ )n === t && ( n = 0 ), r === t && ( r = 0 ), P[ e ] = R( E[ e ], E[ n ], E[ r ] ); const B = []; let D, G = P.concat(); for ( let e = 0, t = S.length; e < t; e ++ ) {

				const t = S[ e ]; D = []; for ( let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e ++, r ++, i ++ )r === n && ( r = 0 ), i === n && ( i = 0 ), D[ e ] = R( t[ e ], t[ r ], t[ i ] ); B.push( D ), G = G.concat( D );

			}

			for ( let e = 0; e < p; e ++ ) {

				const t = e / p, n = h * Math.cos( t * Math.PI / 2 ), r = u * Math.sin( t * Math.PI / 2 ) + d; for ( let e = 0, t = E.length; e < t; e ++ ) {

					const t = A( E[ e ], P[ e ], r ); N( t.x, t.y, - n );

				}

				for ( let e = 0, t = S.length; e < t; e ++ ) {

					const t = S[ e ]; D = B[ e ]; for ( let e = 0, i = t.length; e < i; e ++ ) {

						const i = A( t[ e ], D[ e ], r ); N( i.x, i.y, - n );

					}

				}

			}

			const I = u + d; for ( let e = 0; e < L; e ++ ) {

				const t = l ? A( w[ e ], G[ e ], I ) : w[ e ]; b ? ( _.copy( v.normals[ 0 ] ).multiplyScalar( t.x ), y.copy( v.binormals[ 0 ] ).multiplyScalar( t.y ), x.copy( g[ 0 ] ).add( _ ).add( y ), N( x.x, x.y, x.z ) ) : N( t.x, t.y, 0 );

			}

			for ( let e = 1; e <= s; e ++ ) for ( let t = 0; t < L; t ++ ) {

				const n = l ? A( w[ t ], G[ t ], I ) : w[ t ]; b ? ( _.copy( v.normals[ e ] ).multiplyScalar( n.x ), y.copy( v.binormals[ e ] ).multiplyScalar( n.y ), x.copy( g[ e ] ).add( _ ).add( y ), N( x.x, x.y, x.z ) ) : N( n.x, n.y, c / s * e );

			}

			for ( let e = p - 1; e >= 0; e -- ) {

				const t = e / p, n = h * Math.cos( t * Math.PI / 2 ), r = u * Math.sin( t * Math.PI / 2 ) + d; for ( let e = 0, t = E.length; e < t; e ++ ) {

					const t = A( E[ e ], P[ e ], r ); N( t.x, t.y, c + n );

				}

				for ( let e = 0, t = S.length; e < t; e ++ ) {

					const t = S[ e ]; D = B[ e ]; for ( let e = 0, i = t.length; e < i; e ++ ) {

						const i = A( t[ e ], D[ e ], r ); b ? N( i.x, i.y + g[ s - 1 ].y, g[ s - 1 ].x + n ) : N( i.x, i.y, c + n );

					}

				}

			}

			function F( e, t ) {

				let n = e.length; for ( ;-- n >= 0; ) {

					const r = n; let i = n - 1; i < 0 && ( i = e.length - 1 ); for ( let e = 0, n = s + 2 * p; e < n; e ++ ) {

						const n = L * e, o = L * ( e + 1 ); U( t + r + n, t + i + n, t + i + o, t + r + o );

					}

				}

			}

			function N( e, t, n ) {

				o.push( e ), o.push( t ), o.push( n );

			}

			function O( e, t, i ) {

				V( e ), V( t ), V( i ); const o = r.length / 3, a = f.generateTopUV( n, r, o - 3, o - 2, o - 1 ); z( a[ 0 ] ), z( a[ 1 ] ), z( a[ 2 ] );

			}

			function U( e, t, i, o ) {

				V( e ), V( t ), V( o ), V( t ), V( i ), V( o ); const a = r.length / 3, s = f.generateSideWallUV( n, r, a - 6, a - 3, a - 2, a - 1 ); z( s[ 0 ] ), z( s[ 1 ] ), z( s[ 3 ] ), z( s[ 1 ] ), z( s[ 2 ] ), z( s[ 3 ] );

			}

			function V( e ) {

				r.push( o[ 3 * e + 0 ] ), r.push( o[ 3 * e + 1 ] ), r.push( o[ 3 * e + 2 ] );

			}

			function z( e ) {

				i.push( e.x ), i.push( e.y );

			}

			! function () {

				const e = r.length / 3; if ( l ) {

					let e = 0, t = L * e; for ( let e = 0; e < C; e ++ ) {

						const n = T[ e ]; O( n[ 2 ] + t, n[ 1 ] + t, n[ 0 ] + t );

					}

					t = L * ( e = s + 2 * p ); for ( let e = 0; e < C; e ++ ) {

						const n = T[ e ]; O( n[ 0 ] + t, n[ 1 ] + t, n[ 2 ] + t );

					}

				} else {

					for ( let e = 0; e < C; e ++ ) {

						const t = T[ e ]; O( t[ 2 ], t[ 1 ], t[ 0 ] );

					}

					for ( let e = 0; e < C; e ++ ) {

						const t = T[ e ]; O( t[ 0 ] + L * s, t[ 1 ] + L * s, t[ 2 ] + L * s );

					}

				}

				n.addGroup( e, r.length / 3 - e, 0 );

			}(), function () {

				const e = r.length / 3; let t = 0; F( E, t ), t += E.length; for ( let e = 0, n = S.length; e < n; e ++ ) {

					const n = S[ e ]; F( n, t ), t += n.length;

				}

				n.addGroup( e, r.length / 3 - e, 1 );

			}();

		}

		this.setAttribute( 'position', new Float32BufferAttribute( r, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( i, 2 ) ), this.computeVertexNormals();

	}toJSON() {

		const e = BufferGeometry.prototype.toJSON.call( this ); return toJSON( this.parameters.shapes, this.parameters.options, e );

	}

} const WorldUVGenerator = { generateTopUV: function ( e, t, n, r, i ) {

	const o = t[ 3 * n ], a = t[ 3 * n + 1 ], s = t[ 3 * r ], c = t[ 3 * r + 1 ], l = t[ 3 * i ], h = t[ 3 * i + 1 ]; return [ new Vector2( o, a ), new Vector2( s, c ), new Vector2( l, h ) ];

}, generateSideWallUV: function ( e, t, n, r, i, o ) {

	const a = t[ 3 * n ], s = t[ 3 * n + 1 ], c = t[ 3 * n + 2 ], l = t[ 3 * r ], h = t[ 3 * r + 1 ], u = t[ 3 * r + 2 ], d = t[ 3 * i ], p = t[ 3 * i + 1 ], m = t[ 3 * i + 2 ], f = t[ 3 * o ], g = t[ 3 * o + 1 ], v = t[ 3 * o + 2 ]; return Math.abs( s - h ) < .01 ? [ new Vector2( a, 1 - c ), new Vector2( l, 1 - u ), new Vector2( d, 1 - m ), new Vector2( f, 1 - v ) ] : [ new Vector2( s, 1 - c ), new Vector2( h, 1 - u ), new Vector2( p, 1 - m ), new Vector2( g, 1 - v ) ];

} }; function toJSON( e, t, n ) {

	if ( n.shapes = [], Array.isArray( e ) ) for ( let t = 0, r = e.length; t < r; t ++ ) {

		const r = e[ t ]; n.shapes.push( r.uuid );

	} else n.shapes.push( e.uuid ); return void 0 !== t.extrudePath && ( n.options.extrudePath = t.extrudePath.toJSON() ), n;

}

class ExtrudeGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'ExtrudeGeometry', this.parameters = { shapes: e, options: t }, this.fromBufferGeometry( new ExtrudeBufferGeometry( e, t ) ), this.mergeVertices();

	}toJSON() {

		const e = super.toJSON(); return toJSON$1( this.parameters.shapes, this.parameters.options, e );

	}

} function toJSON$1( e, t, n ) {

	if ( n.shapes = [], Array.isArray( e ) ) for ( let t = 0, r = e.length; t < r; t ++ ) {

		const r = e[ t ]; n.shapes.push( r.uuid );

	} else n.shapes.push( e.uuid ); return void 0 !== t.extrudePath && ( n.options.extrudePath = t.extrudePath.toJSON() ), n;

}

class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( e = 1, t = 0 ) {

		const n = ( 1 + Math.sqrt( 5 ) ) / 2; super( [ - 1, n, 0, 1, n, 0, - 1, - n, 0, 1, - n, 0, 0, - 1, n, 0, 1, n, 0, - 1, - n, 0, 1, - n, n, 0, - 1, n, 0, 1, - n, 0, - 1, - n, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], e, t ), this.type = 'IcosahedronBufferGeometry', this.parameters = { radius: e, detail: t };

	}

} class IcosahedronGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'IcosahedronGeometry', this.parameters = { radius: e, detail: t }, this.fromBufferGeometry( new IcosahedronBufferGeometry( e, t ) ), this.mergeVertices();

	}

} class LatheBufferGeometry extends BufferGeometry {

	constructor( e, t = 12, n = 0, r = 2 * Math.PI ) {

		super(), this.type = 'LatheBufferGeometry', this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor( t ), r = MathUtils.clamp( r, 0, 2 * Math.PI ); const i = [], o = [], a = [], s = 1 / t, c = new Vector3(), l = new Vector2(); for ( let i = 0; i <= t; i ++ ) {

			const h = n + i * s * r, u = Math.sin( h ), d = Math.cos( h ); for ( let n = 0; n <= e.length - 1; n ++ )c.x = e[ n ].x * u, c.y = e[ n ].y, c.z = e[ n ].x * d, o.push( c.x, c.y, c.z ), l.x = i / t, l.y = n / ( e.length - 1 ), a.push( l.x, l.y );

		}

		for ( let n = 0; n < t; n ++ ) for ( let t = 0; t < e.length - 1; t ++ ) {

			const r = t + n * e.length, o = r, a = r + e.length, s = r + e.length + 1, c = r + 1; i.push( o, a, c ), i.push( a, s, c );

		}

		if ( this.setIndex( i ), this.setAttribute( 'position', new Float32BufferAttribute( o, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( a, 2 ) ), this.computeVertexNormals(), r === 2 * Math.PI ) {

			const n = this.attributes.normal.array, r = new Vector3(), i = new Vector3(), o = new Vector3(), a = t * e.length * 3; for ( let t = 0, s = 0; t < e.length; t ++, s += 3 )r.x = n[ s + 0 ], r.y = n[ s + 1 ], r.z = n[ s + 2 ], i.x = n[ a + s + 0 ], i.y = n[ a + s + 1 ], i.z = n[ a + s + 2 ], o.addVectors( r, i ).normalize(), n[ s + 0 ] = n[ a + s + 0 ] = o.x, n[ s + 1 ] = n[ a + s + 1 ] = o.y, n[ s + 2 ] = n[ a + s + 2 ] = o.z;

		}

	}

} class LatheGeometry extends Geometry {

	constructor( e, t, n, r ) {

		super(), this.type = 'LatheGeometry', this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, this.fromBufferGeometry( new LatheBufferGeometry( e, t, n, r ) ), this.mergeVertices();

	}

} class OctahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( e = 1, t = 0 ) {

		super( [ 1, 0, 0, - 1, 0, 0, 0, 1, 0, 0, - 1, 0, 0, 0, 1, 0, 0, - 1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], e, t ), this.type = 'OctahedronBufferGeometry', this.parameters = { radius: e, detail: t };

	}

} class OctahedronGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'OctahedronGeometry', this.parameters = { radius: e, detail: t }, this.fromBufferGeometry( new OctahedronBufferGeometry( e, t ) ), this.mergeVertices();

	}

} function ParametricBufferGeometry( e, t, n ) {

	BufferGeometry.call( this ), this.type = 'ParametricBufferGeometry', this.parameters = { func: e, slices: t, stacks: n }; const r = [], i = [], o = [], a = [], s = new Vector3(), c = new Vector3(), l = new Vector3(), h = new Vector3(), u = new Vector3(); e.length < 3 && console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' ); const d = t + 1; for ( let r = 0; r <= n; r ++ ) {

		const d = r / n; for ( let n = 0; n <= t; n ++ ) {

			const r = n / t; e( r, d, c ), i.push( c.x, c.y, c.z ), r - 1e-5 >= 0 ? ( e( r - 1e-5, d, l ), h.subVectors( c, l ) ) : ( e( r + 1e-5, d, l ), h.subVectors( l, c ) ), d - 1e-5 >= 0 ? ( e( r, d - 1e-5, l ), u.subVectors( c, l ) ) : ( e( r, d + 1e-5, l ), u.subVectors( l, c ) ), s.crossVectors( h, u ).normalize(), o.push( s.x, s.y, s.z ), a.push( r, d );

		}

	}

	for ( let e = 0; e < n; e ++ ) for ( let n = 0; n < t; n ++ ) {

		const t = e * d + n, i = e * d + n + 1, o = ( e + 1 ) * d + n + 1, a = ( e + 1 ) * d + n; r.push( t, i, a ), r.push( i, o, a );

	}

	this.setIndex( r ), this.setAttribute( 'position', new Float32BufferAttribute( i, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( o, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( a, 2 ) );

}

function ParametricGeometry( e, t, n ) {

	Geometry.call( this ), this.type = 'ParametricGeometry', this.parameters = { func: e, slices: t, stacks: n }, this.fromBufferGeometry( new ParametricBufferGeometry( e, t, n ) ), this.mergeVertices();

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype ), ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry, ParametricGeometry.prototype = Object.create( Geometry.prototype ), ParametricGeometry.prototype.constructor = ParametricGeometry; class PlaneGeometry extends Geometry {

	constructor( e, t, n, r ) {

		super(), this.type = 'PlaneGeometry', this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }, this.fromBufferGeometry( new PlaneBufferGeometry( e, t, n, r ) ), this.mergeVertices();

	}

} class PolyhedronGeometry extends Geometry {

	constructor( e, t, n, r ) {

		super(), this.type = 'PolyhedronGeometry', this.parameters = { vertices: e, indices: t, radius: n, detail: r }, this.fromBufferGeometry( new PolyhedronBufferGeometry( e, t, n, r ) ), this.mergeVertices();

	}

} class RingBufferGeometry extends BufferGeometry {

	constructor( e = .5, t = 1, n = 8, r = 1, i = 0, o = 2 * Math.PI ) {

		super(), this.type = 'RingBufferGeometry', this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, n = Math.max( 3, n ); const a = [], s = [], c = [], l = []; let h = e; const u = ( t - e ) / ( r = Math.max( 1, r ) ), d = new Vector3(), p = new Vector2(); for ( let e = 0; e <= r; e ++ ) {

			for ( let e = 0; e <= n; e ++ ) {

				const r = i + e / n * o; d.x = h * Math.cos( r ), d.y = h * Math.sin( r ), s.push( d.x, d.y, d.z ), c.push( 0, 0, 1 ), p.x = ( d.x / t + 1 ) / 2, p.y = ( d.y / t + 1 ) / 2, l.push( p.x, p.y );

			}

			h += u;

		}

		for ( let e = 0; e < r; e ++ ) {

			const t = e * ( n + 1 ); for ( let e = 0; e < n; e ++ ) {

				const r = e + t, i = r, o = r + n + 1, s = r + n + 2, c = r + 1; a.push( i, o, c ), a.push( o, s, c );

			}

		}

		this.setIndex( a ), this.setAttribute( 'position', new Float32BufferAttribute( s, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( c, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( l, 2 ) );

	}

} class RingGeometry extends Geometry {

	constructor( e, t, n, r, i, o ) {

		super(), this.type = 'RingGeometry', this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, this.fromBufferGeometry( new RingBufferGeometry( e, t, n, r, i, o ) ), this.mergeVertices();

	}

} class ShapeBufferGeometry extends BufferGeometry {

	constructor( e, t = 12 ) {

		super(), this.type = 'ShapeBufferGeometry', this.parameters = { shapes: e, curveSegments: t }; const n = [], r = [], i = [], o = []; let a = 0, s = 0; if ( ! 1 === Array.isArray( e ) )c( e ); else for ( let t = 0; t < e.length; t ++ )c( e[ t ] ), this.addGroup( a, s, t ), a += s, s = 0; function c( e ) {

			const a = r.length / 3, c = e.extractPoints( t ); let l = c.shape; const h = c.holes; ! 1 === ShapeUtils.isClockWise( l ) && ( l = l.reverse() ); for ( let e = 0, t = h.length; e < t; e ++ ) {

				const t = h[ e ]; ! 0 === ShapeUtils.isClockWise( t ) && ( h[ e ] = t.reverse() );

			}

			const u = ShapeUtils.triangulateShape( l, h ); for ( let e = 0, t = h.length; e < t; e ++ ) {

				const t = h[ e ]; l = l.concat( t );

			}

			for ( let e = 0, t = l.length; e < t; e ++ ) {

				const t = l[ e ]; r.push( t.x, t.y, 0 ), i.push( 0, 0, 1 ), o.push( t.x, t.y );

			}

			for ( let e = 0, t = u.length; e < t; e ++ ) {

				const t = u[ e ], r = t[ 0 ] + a, i = t[ 1 ] + a, o = t[ 2 ] + a; n.push( r, i, o ), s += 3;

			}

		}

		this.setIndex( n ), this.setAttribute( 'position', new Float32BufferAttribute( r, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( i, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( o, 2 ) );

	}toJSON() {

		const e = BufferGeometry.prototype.toJSON.call( this ); return toJSON$2( this.parameters.shapes, e );

	}

} function toJSON$2( e, t ) {

	if ( t.shapes = [], Array.isArray( e ) ) for ( let n = 0, r = e.length; n < r; n ++ ) {

		const r = e[ n ]; t.shapes.push( r.uuid );

	} else t.shapes.push( e.uuid ); return t;

}

class ShapeGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'ShapeGeometry', 'object' == typeof t && ( console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' ), t = t.curveSegments ), this.parameters = { shapes: e, curveSegments: t }, this.fromBufferGeometry( new ShapeBufferGeometry( e, t ) ), this.mergeVertices();

	}toJSON() {

		const e = Geometry.prototype.toJSON.call( this ); return toJSON$3( this.parameters.shapes, e );

	}

} function toJSON$3( e, t ) {

	if ( t.shapes = [], Array.isArray( e ) ) for ( let n = 0, r = e.length; n < r; n ++ ) {

		const r = e[ n ]; t.shapes.push( r.uuid );

	} else t.shapes.push( e.uuid ); return t;

}

class SphereBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = 8, n = 6, r = 0, i = 2 * Math.PI, o = 0, a = Math.PI ) {

		super(), this.type = 'SphereBufferGeometry', this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, t = Math.max( 3, Math.floor( t ) ), n = Math.max( 2, Math.floor( n ) ); const s = Math.min( o + a, Math.PI ); let c = 0; const l = [], h = new Vector3(), u = new Vector3(), d = [], p = [], m = [], f = []; for ( let d = 0; d <= n; d ++ ) {

			const g = [], v = d / n; let y = 0; 0 == d && 0 == o ? y = .5 / t : d == n && s == Math.PI && ( y = - .5 / t ); for ( let n = 0; n <= t; n ++ ) {

				const s = n / t; h.x = - e * Math.cos( r + s * i ) * Math.sin( o + v * a ), h.y = e * Math.cos( o + v * a ), h.z = e * Math.sin( r + s * i ) * Math.sin( o + v * a ), p.push( h.x, h.y, h.z ), u.copy( h ).normalize(), m.push( u.x, u.y, u.z ), f.push( s + y, 1 - v ), g.push( c ++ );

			}

			l.push( g );

		}

		for ( let e = 0; e < n; e ++ ) for ( let r = 0; r < t; r ++ ) {

			const t = l[ e ][ r + 1 ], i = l[ e ][ r ], a = l[ e + 1 ][ r ], c = l[ e + 1 ][ r + 1 ]; ( 0 !== e || o > 0 ) && d.push( t, i, c ), ( e !== n - 1 || s < Math.PI ) && d.push( i, a, c );

		}

		this.setIndex( d ), this.setAttribute( 'position', new Float32BufferAttribute( p, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( m, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( f, 2 ) );

	}

} class SphereGeometry extends Geometry {

	constructor( e, t, n, r, i, o, a ) {

		super(), this.type = 'SphereGeometry', this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, this.fromBufferGeometry( new SphereBufferGeometry( e, t, n, r, i, o, a ) ), this.mergeVertices();

	}

} class TetrahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( e = 1, t = 0 ) {

		super( [ 1, 1, 1, - 1, - 1, 1, - 1, 1, - 1, 1, - 1, - 1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], e, t ), this.type = 'TetrahedronBufferGeometry', this.parameters = { radius: e, detail: t };

	}

} class TetrahedronGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'TetrahedronGeometry', this.parameters = { radius: e, detail: t }, this.fromBufferGeometry( new TetrahedronBufferGeometry( e, t ) ), this.mergeVertices();

	}

} class TextBufferGeometry extends ExtrudeBufferGeometry {

	constructor( e, t = {} ) {

		const n = t.font; if ( ! n || ! n.isFont ) return console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' ), new BufferGeometry(); const r = n.generateShapes( e, t.size ); t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && ( t.bevelThickness = 10 ), void 0 === t.bevelSize && ( t.bevelSize = 8 ), void 0 === t.bevelEnabled && ( t.bevelEnabled = ! 1 ), super( r, t ), this.type = 'TextBufferGeometry';

	}

} class TextGeometry extends Geometry {

	constructor( e, t ) {

		super(), this.type = 'TextGeometry', this.parameters = { text: e, parameters: t }, this.fromBufferGeometry( new TextBufferGeometry( e, t ) ), this.mergeVertices();

	}

} class TorusBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI ) {

		super(), this.type = 'TorusBufferGeometry', this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, n = Math.floor( n ), r = Math.floor( r ); const o = [], a = [], s = [], c = [], l = new Vector3(), h = new Vector3(), u = new Vector3(); for ( let o = 0; o <= n; o ++ ) for ( let d = 0; d <= r; d ++ ) {

			const p = d / r * i, m = o / n * Math.PI * 2; h.x = ( e + t * Math.cos( m ) ) * Math.cos( p ), h.y = ( e + t * Math.cos( m ) ) * Math.sin( p ), h.z = t * Math.sin( m ), a.push( h.x, h.y, h.z ), l.x = e * Math.cos( p ), l.y = e * Math.sin( p ), u.subVectors( h, l ).normalize(), s.push( u.x, u.y, u.z ), c.push( d / r ), c.push( o / n );

		}

		for ( let e = 1; e <= n; e ++ ) for ( let t = 1; t <= r; t ++ ) {

			const n = ( r + 1 ) * e + t - 1, i = ( r + 1 ) * ( e - 1 ) + t - 1, a = ( r + 1 ) * ( e - 1 ) + t, s = ( r + 1 ) * e + t; o.push( n, i, s ), o.push( i, a, s );

		}

		this.setIndex( o ), this.setAttribute( 'position', new Float32BufferAttribute( a, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( s, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( c, 2 ) );

	}

} class TorusGeometry extends Geometry {

	constructor( e, t, n, r, i ) {

		super(), this.type = 'TorusGeometry', this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, this.fromBufferGeometry( new TorusBufferGeometry( e, t, n, r, i ) ), this.mergeVertices();

	}

} class TorusKnotBufferGeometry extends BufferGeometry {

	constructor( e = 1, t = .4, n = 64, r = 8, i = 2, o = 3 ) {

		super(), this.type = 'TorusKnotBufferGeometry', this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: o }, n = Math.floor( n ), r = Math.floor( r ); const a = [], s = [], c = [], l = [], h = new Vector3(), u = new Vector3(), d = new Vector3(), p = new Vector3(), m = new Vector3(), f = new Vector3(), g = new Vector3(); for ( let a = 0; a <= n; ++ a ) {

			const y = a / n * i * Math.PI * 2; v( y, i, o, e, d ), v( y + .01, i, o, e, p ), f.subVectors( p, d ), g.addVectors( p, d ), m.crossVectors( f, g ), g.crossVectors( m, f ), m.normalize(), g.normalize(); for ( let e = 0; e <= r; ++ e ) {

				const i = e / r * Math.PI * 2, o = - t * Math.cos( i ), p = t * Math.sin( i ); h.x = d.x + ( o * g.x + p * m.x ), h.y = d.y + ( o * g.y + p * m.y ), h.z = d.z + ( o * g.z + p * m.z ), s.push( h.x, h.y, h.z ), u.subVectors( h, d ).normalize(), c.push( u.x, u.y, u.z ), l.push( a / n ), l.push( e / r );

			}

		}

		for ( let e = 1; e <= n; e ++ ) for ( let t = 1; t <= r; t ++ ) {

			const n = ( r + 1 ) * ( e - 1 ) + ( t - 1 ), i = ( r + 1 ) * e + ( t - 1 ), o = ( r + 1 ) * e + t, s = ( r + 1 ) * ( e - 1 ) + t; a.push( n, i, s ), a.push( i, o, s );

		}

		function v( e, t, n, r, i ) {

			const o = Math.cos( e ), a = Math.sin( e ), s = n / t * e, c = Math.cos( s ); i.x = r * ( 2 + c ) * .5 * o, i.y = r * ( 2 + c ) * a * .5, i.z = r * Math.sin( s ) * .5;

		}

		this.setIndex( a ), this.setAttribute( 'position', new Float32BufferAttribute( s, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( c, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( l, 2 ) );

	}

} class TorusKnotGeometry extends Geometry {

	constructor( e, t, n, r, i, o, a ) {

		super(), this.type = 'TorusKnotGeometry', this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: o }, void 0 !== a && console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ), this.fromBufferGeometry( new TorusKnotBufferGeometry( e, t, n, r, i, o ) ), this.mergeVertices();

	}

} class TubeBufferGeometry extends BufferGeometry {

	constructor( e, t = 64, n = 1, r = 8, i = ! 1 ) {

		super(), this.type = 'TubeBufferGeometry', this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }; const o = e.computeFrenetFrames( t, i ); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const a = new Vector3(), s = new Vector3(), c = new Vector2(); let l = new Vector3(); const h = [], u = [], d = [], p = []; function m( i ) {

			l = e.getPointAt( i / t, l ); const c = o.normals[ i ], d = o.binormals[ i ]; for ( let e = 0; e <= r; e ++ ) {

				const t = e / r * Math.PI * 2, i = Math.sin( t ), o = - Math.cos( t ); s.x = o * c.x + i * d.x, s.y = o * c.y + i * d.y, s.z = o * c.z + i * d.z, s.normalize(), u.push( s.x, s.y, s.z ), a.x = l.x + n * s.x, a.y = l.y + n * s.y, a.z = l.z + n * s.z, h.push( a.x, a.y, a.z );

			}

		}

		! function () {

			for ( let e = 0; e < t; e ++ )m( e ); m( ! 1 === i ? t : 0 ), function () {

				for ( let e = 0; e <= t; e ++ ) for ( let n = 0; n <= r; n ++ )c.x = e / t, c.y = n / r, d.push( c.x, c.y );

			}(), function () {

				for ( let e = 1; e <= t; e ++ ) for ( let t = 1; t <= r; t ++ ) {

					const n = ( r + 1 ) * ( e - 1 ) + ( t - 1 ), i = ( r + 1 ) * e + ( t - 1 ), o = ( r + 1 ) * e + t, a = ( r + 1 ) * ( e - 1 ) + t; p.push( n, i, a ), p.push( i, o, a );

				}

			}();

		}(), this.setIndex( p ), this.setAttribute( 'position', new Float32BufferAttribute( h, 3 ) ), this.setAttribute( 'normal', new Float32BufferAttribute( u, 3 ) ), this.setAttribute( 'uv', new Float32BufferAttribute( d, 2 ) );

	}toJSON() {

		const e = BufferGeometry.prototype.toJSON.call( this ); return e.path = this.parameters.path.toJSON(), e;

	}

} class TubeGeometry extends Geometry {

	constructor( e, t, n, r, i, o ) {

		super(), this.type = 'TubeGeometry', this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }, void 0 !== o && console.warn( 'THREE.TubeGeometry: taper has been removed.' ); const a = new TubeBufferGeometry( e, t, n, r, i ); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry( a ), this.mergeVertices();

	}

} class WireframeGeometry extends BufferGeometry {

	constructor( e ) {

		super(), this.type = 'WireframeGeometry'; const t = [], n = [ 0, 0 ], r = {}, i = [ 'a', 'b', 'c' ]; if ( e && e.isGeometry ) {

			const o = e.faces; for ( let e = 0, t = o.length; e < t; e ++ ) {

				const t = o[ e ]; for ( let e = 0; e < 3; e ++ ) {

					const o = t[ i[ e ] ], a = t[ i[ ( e + 1 ) % 3 ] ]; n[ 0 ] = Math.min( o, a ), n[ 1 ] = Math.max( o, a ); const s = n[ 0 ] + ',' + n[ 1 ]; void 0 === r[ s ] && ( r[ s ] = { index1: n[ 0 ], index2: n[ 1 ] } );

				}

			}

			for ( const n in r ) {

				const i = r[ n ]; let o = e.vertices[ i.index1 ]; t.push( o.x, o.y, o.z ), o = e.vertices[ i.index2 ], t.push( o.x, o.y, o.z );

			}

		} else if ( e && e.isBufferGeometry ) {

			const i = new Vector3(); if ( null !== e.index ) {

				const o = e.attributes.position, a = e.index; let s = e.groups; 0 === s.length && ( s = [ { start: 0, count: a.count, materialIndex: 0 } ] ); for ( let e = 0, t = s.length; e < t; ++ e ) {

					const t = s[ e ], i = t.start; for ( let e = i, o = i + t.count; e < o; e += 3 ) for ( let t = 0; t < 3; t ++ ) {

						const i = a.getX( e + t ), o = a.getX( e + ( t + 1 ) % 3 ); n[ 0 ] = Math.min( i, o ), n[ 1 ] = Math.max( i, o ); const s = n[ 0 ] + ',' + n[ 1 ]; void 0 === r[ s ] && ( r[ s ] = { index1: n[ 0 ], index2: n[ 1 ] } );

					}

				}

				for ( const e in r ) {

					const n = r[ e ]; i.fromBufferAttribute( o, n.index1 ), t.push( i.x, i.y, i.z ), i.fromBufferAttribute( o, n.index2 ), t.push( i.x, i.y, i.z );

				}

			} else {

				const n = e.attributes.position; for ( let e = 0, r = n.count / 3; e < r; e ++ ) for ( let r = 0; r < 3; r ++ ) {

					const o = 3 * e + r; i.fromBufferAttribute( n, o ), t.push( i.x, i.y, i.z ); const a = 3 * e + ( r + 1 ) % 3; i.fromBufferAttribute( n, a ), t.push( i.x, i.y, i.z );

				}

			}

		}

		this.setAttribute( 'position', new Float32BufferAttribute( t, 3 ) );

	}

} var Geometries = Object.freeze( { __proto__: null, BoxGeometry: BoxGeometry, BoxBufferGeometry: BoxBufferGeometry, CircleGeometry: CircleGeometry, CircleBufferGeometry: CircleBufferGeometry, ConeGeometry: ConeGeometry, ConeBufferGeometry: ConeBufferGeometry, CylinderGeometry: CylinderGeometry, CylinderBufferGeometry: CylinderBufferGeometry, DodecahedronGeometry: DodecahedronGeometry, DodecahedronBufferGeometry: DodecahedronBufferGeometry, EdgesGeometry: EdgesGeometry, ExtrudeGeometry: ExtrudeGeometry, ExtrudeBufferGeometry: ExtrudeBufferGeometry, IcosahedronGeometry: IcosahedronGeometry, IcosahedronBufferGeometry: IcosahedronBufferGeometry, LatheGeometry: LatheGeometry, LatheBufferGeometry: LatheBufferGeometry, OctahedronGeometry: OctahedronGeometry, OctahedronBufferGeometry: OctahedronBufferGeometry, ParametricGeometry: ParametricGeometry, ParametricBufferGeometry: ParametricBufferGeometry, PlaneGeometry: PlaneGeometry, PlaneBufferGeometry: PlaneBufferGeometry, PolyhedronGeometry: PolyhedronGeometry, PolyhedronBufferGeometry: PolyhedronBufferGeometry, RingGeometry: RingGeometry, RingBufferGeometry: RingBufferGeometry, ShapeGeometry: ShapeGeometry, ShapeBufferGeometry: ShapeBufferGeometry, SphereGeometry: SphereGeometry, SphereBufferGeometry: SphereBufferGeometry, TetrahedronGeometry: TetrahedronGeometry, TetrahedronBufferGeometry: TetrahedronBufferGeometry, TextGeometry: TextGeometry, TextBufferGeometry: TextBufferGeometry, TorusGeometry: TorusGeometry, TorusBufferGeometry: TorusBufferGeometry, TorusKnotGeometry: TorusKnotGeometry, TorusKnotBufferGeometry: TorusKnotBufferGeometry, TubeGeometry: TubeGeometry, TubeBufferGeometry: TubeBufferGeometry, WireframeGeometry: WireframeGeometry } ); function ShadowMaterial( e ) {

	Material.call( this ), this.type = 'ShadowMaterial', this.color = new Color( 0 ), this.transparent = ! 0, this.setValues( e );

}

function RawShaderMaterial( e ) {

	ShaderMaterial.call( this, e ), this.type = 'RawShaderMaterial';

}

function MeshStandardMaterial( e ) {

	Material.call( this ), this.defines = { STANDARD: '' }, this.type = 'MeshStandardMaterial', this.color = new Color( 16777215 ), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color( 0 ), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2( 1, 1 ), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.vertexTangents = ! 1, this.setValues( e );

}

function MeshPhysicalMaterial( e ) {

	MeshStandardMaterial.call( this ), this.defines = { STANDARD: '', PHYSICAL: '' }, this.type = 'MeshPhysicalMaterial', this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2( 1, 1 ), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty( this, 'ior', { get: function () {

		return ( 1 + .4 * this.reflectivity ) / ( 1 - .4 * this.reflectivity );

	}, set: function ( e ) {

		this.reflectivity = MathUtils.clamp( 2.5 * ( e - 1 ) / ( e + 1 ), 0, 1 );

	} } ), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues( e );

}

function MeshPhongMaterial( e ) {

	Material.call( this ), this.type = 'MeshPhongMaterial', this.color = new Color( 16777215 ), this.specular = new Color( 1118481 ), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color( 0 ), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2( 1, 1 ), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.setValues( e );

}

function MeshToonMaterial( e ) {

	Material.call( this ), this.defines = { TOON: '' }, this.type = 'MeshToonMaterial', this.color = new Color( 16777215 ), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color( 0 ), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2( 1, 1 ), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.setValues( e );

}

function MeshNormalMaterial( e ) {

	Material.call( this ), this.type = 'MeshNormalMaterial', this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2( 1, 1 ), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.fog = ! 1, this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.setValues( e );

}

function MeshLambertMaterial( e ) {

	Material.call( this ), this.type = 'MeshLambertMaterial', this.color = new Color( 16777215 ), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color( 0 ), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = ! 1, this.wireframeLinewidth = 1, this.wireframeLinecap = 'round', this.wireframeLinejoin = 'round', this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.setValues( e );

}

function MeshMatcapMaterial( e ) {

	Material.call( this ), this.defines = { MATCAP: '' }, this.type = 'MeshMatcapMaterial', this.color = new Color( 16777215 ), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2( 1, 1 ), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = ! 1, this.morphTargets = ! 1, this.morphNormals = ! 1, this.setValues( e );

}

function LineDashedMaterial( e ) {

	LineBasicMaterial.call( this ), this.type = 'LineDashedMaterial', this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues( e );

}

ShadowMaterial.prototype = Object.create( Material.prototype ), ShadowMaterial.prototype.constructor = ShadowMaterial, ShadowMaterial.prototype.isShadowMaterial = ! 0, ShadowMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this;

}, RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype ), RawShaderMaterial.prototype.constructor = RawShaderMaterial, RawShaderMaterial.prototype.isRawShaderMaterial = ! 0, MeshStandardMaterial.prototype = Object.create( Material.prototype ), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial, MeshStandardMaterial.prototype.isMeshStandardMaterial = ! 0, MeshStandardMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.defines = { STANDARD: '' }, this.color.copy( e.color ), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy( e.emissive ), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy( e.normalScale ), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this;

}, MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype ), MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = ! 0, MeshPhysicalMaterial.prototype.copy = function ( e ) {

	return MeshStandardMaterial.prototype.copy.call( this, e ), this.defines = { STANDARD: '', PHYSICAL: '' }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy( e.clearcoatNormalScale ), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = ( this.sheen || new Color() ).copy( e.sheen ) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this;

}, MeshPhongMaterial.prototype = Object.create( Material.prototype ), MeshPhongMaterial.prototype.constructor = MeshPhongMaterial, MeshPhongMaterial.prototype.isMeshPhongMaterial = ! 0, MeshPhongMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.specular.copy( e.specular ), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy( e.emissive ), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy( e.normalScale ), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;

}, MeshToonMaterial.prototype = Object.create( Material.prototype ), MeshToonMaterial.prototype.constructor = MeshToonMaterial, MeshToonMaterial.prototype.isMeshToonMaterial = ! 0, MeshToonMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy( e.emissive ), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy( e.normalScale ), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;

}, MeshNormalMaterial.prototype = Object.create( Material.prototype ), MeshNormalMaterial.prototype.constructor = MeshNormalMaterial, MeshNormalMaterial.prototype.isMeshNormalMaterial = ! 0, MeshNormalMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy( e.normalScale ), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;

}, MeshLambertMaterial.prototype = Object.create( Material.prototype ), MeshLambertMaterial.prototype.constructor = MeshLambertMaterial, MeshLambertMaterial.prototype.isMeshLambertMaterial = ! 0, MeshLambertMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.color.copy( e.color ), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy( e.emissive ), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;

}, MeshMatcapMaterial.prototype = Object.create( Material.prototype ), MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial, MeshMatcapMaterial.prototype.isMeshMatcapMaterial = ! 0, MeshMatcapMaterial.prototype.copy = function ( e ) {

	return Material.prototype.copy.call( this, e ), this.defines = { MATCAP: '' }, this.color.copy( e.color ), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy( e.normalScale ), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;

}, LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype ), LineDashedMaterial.prototype.constructor = LineDashedMaterial, LineDashedMaterial.prototype.isLineDashedMaterial = ! 0, LineDashedMaterial.prototype.copy = function ( e ) {

	return LineBasicMaterial.prototype.copy.call( this, e ), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;

};

var Materials = Object.freeze( { __proto__: null, ShadowMaterial: ShadowMaterial, SpriteMaterial: SpriteMaterial, RawShaderMaterial: RawShaderMaterial, ShaderMaterial: ShaderMaterial, PointsMaterial: PointsMaterial, MeshPhysicalMaterial: MeshPhysicalMaterial, MeshStandardMaterial: MeshStandardMaterial, MeshPhongMaterial: MeshPhongMaterial, MeshToonMaterial: MeshToonMaterial, MeshNormalMaterial: MeshNormalMaterial, MeshLambertMaterial: MeshLambertMaterial, MeshDepthMaterial: MeshDepthMaterial, MeshDistanceMaterial: MeshDistanceMaterial, MeshBasicMaterial: MeshBasicMaterial, MeshMatcapMaterial: MeshMatcapMaterial, LineDashedMaterial: LineDashedMaterial, LineBasicMaterial: LineBasicMaterial, Material: Material } ); const AnimationUtils = { arraySlice: function ( e, t, n ) {

	return AnimationUtils.isTypedArray( e ) ? new e.constructor( e.subarray( t, void 0 !== n ? n : e.length ) ) : e.slice( t, n );

}, convertArray: function ( e, t, n ) {

	return ! e || ! n && e.constructor === t ? e : 'number' == typeof t.BYTES_PER_ELEMENT ? new t( e ) : Array.prototype.slice.call( e );

}, isTypedArray: function ( e ) {

	return ArrayBuffer.isView( e ) && ! ( e instanceof DataView );

}, getKeyframeOrder: function ( e ) {

	const t = e.length, n = new Array( t ); for ( let e = 0; e !== t; ++ e )n[ e ] = e; return n.sort( function ( t, n ) {

		return e[ t ] - e[ n ];

	} ), n;

}, sortedArray: function ( e, t, n ) {

	const r = e.length, i = new e.constructor( r ); for ( let o = 0, a = 0; a !== r; ++ o ) {

		const r = n[ o ] * t; for ( let n = 0; n !== t; ++ n )i[ a ++ ] = e[ r + n ];

	}

	return i;

}, flattenJSON: function ( e, t, n, r ) {

	let i = 1, o = e[ 0 ]; for ( ;void 0 !== o && void 0 === o[ r ]; )o = e[ i ++ ]; if ( void 0 === o ) return; let a = o[ r ]; if ( void 0 !== a ) if ( Array.isArray( a ) ) do {

		void 0 !== ( a = o[ r ] ) && ( t.push( o.time ), n.push.apply( n, a ) ), o = e[ i ++ ];

	} while ( void 0 !== o ); else if ( void 0 !== a.toArray ) do {

		void 0 !== ( a = o[ r ] ) && ( t.push( o.time ), a.toArray( n, n.length ) ), o = e[ i ++ ];

	} while ( void 0 !== o ); else do {

		void 0 !== ( a = o[ r ] ) && ( t.push( o.time ), n.push( a ) ), o = e[ i ++ ];

	} while ( void 0 !== o );

}, subclip: function ( e, t, n, r, i = 30 ) {

	const o = e.clone(); o.name = t; const a = []; for ( let e = 0; e < o.tracks.length; ++ e ) {

		const t = o.tracks[ e ], s = t.getValueSize(), c = [], l = []; for ( let e = 0; e < t.times.length; ++ e ) {

			const o = t.times[ e ] * i; if ( ! ( o < n || o >= r ) ) {

				c.push( t.times[ e ] ); for ( let n = 0; n < s; ++ n )l.push( t.values[ e * s + n ] );

			}

		}

		0 !== c.length && ( t.times = AnimationUtils.convertArray( c, t.times.constructor ), t.values = AnimationUtils.convertArray( l, t.values.constructor ), a.push( t ) );

	}

	o.tracks = a; let s = 1 / 0; for ( let e = 0; e < o.tracks.length; ++ e )s > o.tracks[ e ].times[ 0 ] && ( s = o.tracks[ e ].times[ 0 ] ); for ( let e = 0; e < o.tracks.length; ++ e )o.tracks[ e ].shift( - 1 * s ); return o.resetDuration(), o;

}, makeClipAdditive: function ( e, t = 0, n = e, r = 30 ) {

	r <= 0 && ( r = 30 ); const i = n.tracks.length, o = t / r; for ( let t = 0; t < i; ++ t ) {

		const r = n.tracks[ t ], i = r.ValueTypeName; if ( 'bool' === i || 'string' === i ) continue; const a = e.tracks.find( function ( e ) {

			return e.name === r.name && e.ValueTypeName === i;

		} ); if ( void 0 === a ) continue; let s = 0; const c = r.getValueSize(); r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && ( s = c / 3 ); let l = 0; const h = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && ( l = h / 3 ); const u = r.times.length - 1; let d; if ( o <= r.times[ 0 ] ) {

			const e = s, t = c - s; d = AnimationUtils.arraySlice( r.values, e, t );

		} else if ( o >= r.times[ u ] ) {

			const e = u * c + s, t = e + c - s; d = AnimationUtils.arraySlice( r.values, e, t );

		} else {

			const e = r.createInterpolant(), t = s, n = c - s; e.evaluate( o ), d = AnimationUtils.arraySlice( e.resultBuffer, t, n );

		}

		if ( 'quaternion' === i ) {

			( new Quaternion() ).fromArray( d ).normalize().conjugate().toArray( d );

		}

		const p = a.times.length; for ( let e = 0; e < p; ++ e ) {

			const t = e * h + l; if ( 'quaternion' === i )Quaternion.multiplyQuaternionsFlat( a.values, t, d, 0, a.values, t ); else {

				const e = h - 2 * l; for ( let n = 0; n < e; ++ n )a.values[ t + n ] -= d[ n ];

			}

		}

	}

	return e.blendMode = AdditiveAnimationBlendMode, e;

} }; function Interpolant( e, t, n, r ) {

	this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor( n ), this.sampleValues = t, this.valueSize = n;

}

function CubicInterpolant( e, t, n, r ) {

	Interpolant.call( this, e, t, n, r ), this._weightPrev = - 0, this._offsetPrev = - 0, this._weightNext = - 0, this._offsetNext = - 0;

}

function LinearInterpolant( e, t, n, r ) {

	Interpolant.call( this, e, t, n, r );

}

function DiscreteInterpolant( e, t, n, r ) {

	Interpolant.call( this, e, t, n, r );

}

function KeyframeTrack( e, t, n, r ) {

	if ( void 0 === e ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' ); if ( void 0 === t || 0 === t.length ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + e ); this.name = e, this.times = AnimationUtils.convertArray( t, this.TimeBufferType ), this.values = AnimationUtils.convertArray( n, this.ValueBufferType ), this.setInterpolation( r || this.DefaultInterpolation );

}

function BooleanKeyframeTrack( e, t, n ) {

	KeyframeTrack.call( this, e, t, n );

}

function ColorKeyframeTrack( e, t, n, r ) {

	KeyframeTrack.call( this, e, t, n, r );

}

function NumberKeyframeTrack( e, t, n, r ) {

	KeyframeTrack.call( this, e, t, n, r );

}

function QuaternionLinearInterpolant( e, t, n, r ) {

	Interpolant.call( this, e, t, n, r );

}

function QuaternionKeyframeTrack( e, t, n, r ) {

	KeyframeTrack.call( this, e, t, n, r );

}

function StringKeyframeTrack( e, t, n, r ) {

	KeyframeTrack.call( this, e, t, n, r );

}

function VectorKeyframeTrack( e, t, n, r ) {

	KeyframeTrack.call( this, e, t, n, r );

}

function AnimationClip( e, t = - 1, n, r = NormalAnimationBlendMode ) {

	this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = MathUtils.generateUUID(), this.duration < 0 && this.resetDuration();

}

function getTrackTypeForValueTypeName( e ) {

	switch ( e.toLowerCase() ) {

		case 'scalar':case 'double':case 'float':case 'number':case 'integer':return NumberKeyframeTrack; case 'vector':case 'vector2':case 'vector3':case 'vector4':return VectorKeyframeTrack; case 'color':return ColorKeyframeTrack; case 'quaternion':return QuaternionKeyframeTrack; case 'bool':case 'boolean':return BooleanKeyframeTrack; case 'string':return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + e );

}

function parseKeyframeTrack( e ) {

	if ( void 0 === e.type ) throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' ); const t = getTrackTypeForValueTypeName( e.type ); if ( void 0 === e.times ) {

		const t = [], n = []; AnimationUtils.flattenJSON( e.keys, t, n, 'value' ), e.times = t, e.values = n;

	}

	return void 0 !== t.parse ? t.parse( e ) : new t( e.name, e.times, e.values, e.interpolation );

}

Object.assign( Interpolant.prototype, { evaluate: function ( e ) {

	const t = this.parameterPositions; let n = this._cachedIndex, r = t[ n ], i = t[ n - 1 ]; e: {

		t: {

			let o; n: {

				r:if ( ! ( e < r ) ) {

					for ( let o = n + 2; ; ) {

						if ( void 0 === r ) {

							if ( e < i ) break r; return n = t.length, this._cachedIndex = n, this.afterEnd_( n - 1, e, i );

						}

						if ( n === o ) break; if ( i = r, e < ( r = t[ ++ n ] ) ) break t;

					}

					o = t.length; break n;

				}

				if ( e >= i ) break e; {

					const a = t[ 1 ]; e < a && ( n = 2, i = a ); for ( let o = n - 2; ; ) {

						if ( void 0 === i ) return this._cachedIndex = 0, this.beforeStart_( 0, e, r ); if ( n === o ) break; if ( r = i, e >= ( i = t[ -- n - 1 ] ) ) break t;

					}

					o = n, n = 0;

				}

			}

			for ( ;n < o; ) {

				const r = n + o >>> 1; e < t[ r ] ? o = r : n = r + 1;

			}

			if ( r = t[ n ], void 0 === ( i = t[ n - 1 ] ) ) return this._cachedIndex = 0, this.beforeStart_( 0, e, r ); if ( void 0 === r ) return n = t.length, this._cachedIndex = n, this.afterEnd_( n - 1, i, e );

		}

		this._cachedIndex = n, this.intervalChanged_( n, i, r );

	}

	return this.interpolate_( n, i, e, r );

}, settings: null, DefaultSettings_: {}, getSettings_: function () {

	return this.settings || this.DefaultSettings_;

}, copySampleValue_: function ( e ) {

	const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r; for ( let e = 0; e !== r; ++ e )t[ e ] = n[ i + e ]; return t;

}, interpolate_: function () {

	throw new Error( 'call to abstract method' );

}, intervalChanged_: function () {} } ), Object.assign( Interpolant.prototype, { beforeStart_: Interpolant.prototype.copySampleValue_, afterEnd_: Interpolant.prototype.copySampleValue_ } ), CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), { constructor: CubicInterpolant, DefaultSettings_: { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }, intervalChanged_: function ( e, t, n ) {

	const r = this.parameterPositions; let i = e - 2, o = e + 1, a = r[ i ], s = r[ o ]; if ( void 0 === a ) switch ( this.getSettings_().endingStart ) {

		case ZeroSlopeEnding:i = e, a = 2 * t - n; break; case WrapAroundEnding:a = t + r[ i = r.length - 2 ] - r[ i + 1 ]; break; default:i = e, a = n;

	}

	if ( void 0 === s ) switch ( this.getSettings_().endingEnd ) {

		case ZeroSlopeEnding:o = e, s = 2 * n - t; break; case WrapAroundEnding:o = 1, s = n + r[ 1 ] - r[ 0 ]; break; default:o = e - 1, s = t;

	}

	const c = .5 * ( n - t ), l = this.valueSize; this._weightPrev = c / ( t - a ), this._weightNext = c / ( s - n ), this._offsetPrev = i * l, this._offsetNext = o * l;

}, interpolate_: function ( e, t, n, r ) {

	const i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = ( n - t ) / ( r - t ), m = p * p, f = m * p, g = - u * f + 2 * u * m - u * p, v = ( 1 + u ) * f + ( - 1.5 - 2 * u ) * m + ( - .5 + u ) * p + 1, y = ( - 1 - d ) * f + ( 1.5 + d ) * m + .5 * p, _ = d * f - d * m; for ( let e = 0; e !== a; ++ e )i[ e ] = g * o[ l + e ] + v * o[ c + e ] + y * o[ s + e ] + _ * o[ h + e ]; return i;

} } ), LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), { constructor: LinearInterpolant, interpolate_: function ( e, t, n, r ) {

	const i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = ( n - t ) / ( r - t ), h = 1 - l; for ( let e = 0; e !== a; ++ e )i[ e ] = o[ c + e ] * h + o[ s + e ] * l; return i;

} } ), DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), { constructor: DiscreteInterpolant, interpolate_: function ( e ) {

	return this.copySampleValue_( e - 1 );

} } ), Object.assign( KeyframeTrack, { toJSON: function ( e ) {

	const t = e.constructor; let n; if ( void 0 !== t.toJSON )n = t.toJSON( e ); else {

		n = { name: e.name, times: AnimationUtils.convertArray( e.times, Array ), values: AnimationUtils.convertArray( e.values, Array ) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && ( n.interpolation = t );

	}

	return n.type = e.ValueTypeName, n;

} } ), Object.assign( KeyframeTrack.prototype, { constructor: KeyframeTrack, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function ( e ) {

	return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), e );

}, InterpolantFactoryMethodLinear: function ( e ) {

	return new LinearInterpolant( this.times, this.values, this.getValueSize(), e );

}, InterpolantFactoryMethodSmooth: function ( e ) {

	return new CubicInterpolant( this.times, this.values, this.getValueSize(), e );

}, setInterpolation: function ( e ) {

	let t; switch ( e ) {

		case 2300:t = this.InterpolantFactoryMethodDiscrete; break; case 2301:t = this.InterpolantFactoryMethodLinear; break; case 2302:t = this.InterpolantFactoryMethodSmooth;

	}

	if ( void 0 === t ) {

		const t = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name; if ( void 0 === this.createInterpolant ) {

			if ( e === this.DefaultInterpolation ) throw new Error( t ); this.setInterpolation( this.DefaultInterpolation );

		}

		return console.warn( 'THREE.KeyframeTrack:', t ), this;

	}

	return this.createInterpolant = t, this;

}, getInterpolation: function () {

	switch ( this.createInterpolant ) {

		case this.InterpolantFactoryMethodDiscrete:return 2300; case this.InterpolantFactoryMethodLinear:return 2301; case this.InterpolantFactoryMethodSmooth:return 2302;

	}

}, getValueSize: function () {

	return this.values.length / this.times.length;

}, shift: function ( e ) {

	if ( 0 !== e ) {

		const t = this.times; for ( let n = 0, r = t.length; n !== r; ++ n )t[ n ] += e;

	}

	return this;

}, scale: function ( e ) {

	if ( 1 !== e ) {

		const t = this.times; for ( let n = 0, r = t.length; n !== r; ++ n )t[ n ] *= e;

	}

	return this;

}, trim: function ( e, t ) {

	const n = this.times, r = n.length; let i = 0, o = r - 1; for ( ;i !== r && n[ i ] < e; )++ i; for ( ;- 1 !== o && n[ o ] > t; )-- o; if ( ++ o, 0 !== i || o !== r ) {

		i >= o && ( i = ( o = Math.max( o, 1 ) ) - 1 ); const e = this.getValueSize(); this.times = AnimationUtils.arraySlice( n, i, o ), this.values = AnimationUtils.arraySlice( this.values, i * e, o * e );

	}

	return this;

}, validate: function () {

	let e = ! 0; const t = this.getValueSize(); t - Math.floor( t ) != 0 && ( console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this ), e = ! 1 ); const n = this.times, r = this.values, i = n.length; 0 === i && ( console.error( 'THREE.KeyframeTrack: Track is empty.', this ), e = ! 1 ); let o = null; for ( let t = 0; t !== i; t ++ ) {

		const r = n[ t ]; if ( 'number' == typeof r && isNaN( r ) ) {

			console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, t, r ), e = ! 1; break;

		}

		if ( null !== o && o > r ) {

			console.error( 'THREE.KeyframeTrack: Out of order keys.', this, t, r, o ), e = ! 1; break;

		}

		o = r;

	}

	if ( void 0 !== r && AnimationUtils.isTypedArray( r ) ) for ( let t = 0, n = r.length; t !== n; ++ t ) {

		const n = r[ t ]; if ( isNaN( n ) ) {

			console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, t, n ), e = ! 1; break;

		}

	}

	return e;

}, optimize: function () {

	const e = AnimationUtils.arraySlice( this.times ), t = AnimationUtils.arraySlice( this.values ), n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = e.length - 1; let o = 1; for ( let a = 1; a < i; ++ a ) {

		let i = ! 1; const s = e[ a ]; if ( s !== e[ a + 1 ] && ( 1 !== a || s !== s[ 0 ] ) ) if ( r )i = ! 0; else {

			const e = a * n, r = e - n, o = e + n; for ( let a = 0; a !== n; ++ a ) {

				const n = t[ e + a ]; if ( n !== t[ r + a ] || n !== t[ o + a ] ) {

					i = ! 0; break;

				}

			}

		}

		if ( i ) {

			if ( a !== o ) {

				e[ o ] = e[ a ]; const r = a * n, i = o * n; for ( let e = 0; e !== n; ++ e )t[ i + e ] = t[ r + e ];

			}

			++ o;

		}

	}

	if ( i > 0 ) {

		e[ o ] = e[ i ]; for ( let e = i * n, r = o * n, a = 0; a !== n; ++ a )t[ r + a ] = t[ e + a ]; ++ o;

	}

	return o !== e.length ? ( this.times = AnimationUtils.arraySlice( e, 0, o ), this.values = AnimationUtils.arraySlice( t, 0, o * n ) ) : ( this.times = e, this.values = t ), this;

}, clone: function () {

	const e = AnimationUtils.arraySlice( this.times, 0 ), t = AnimationUtils.arraySlice( this.values, 0 ), n = new ( this.constructor )( this.name, e, t ); return n.createInterpolant = this.createInterpolant, n;

} } ), BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: BooleanKeyframeTrack, ValueTypeName: 'bool', ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 } ), ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: ColorKeyframeTrack, ValueTypeName: 'color' } ), NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: NumberKeyframeTrack, ValueTypeName: 'number' } ), QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), { constructor: QuaternionLinearInterpolant, interpolate_: function ( e, t, n, r ) {

	const i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = ( n - t ) / ( r - t ); let c = e * a; for ( let e = c + a; c !== e; c += 4 )Quaternion.slerpFlat( i, 0, o, c - a, o, c, s ); return i;

} } ), QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: QuaternionKeyframeTrack, ValueTypeName: 'quaternion', DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function ( e ) {

	return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), e );

}, InterpolantFactoryMethodSmooth: void 0 } ), StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: StringKeyframeTrack, ValueTypeName: 'string', ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 } ), VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), { constructor: VectorKeyframeTrack, ValueTypeName: 'vector' } ), Object.assign( AnimationClip, { parse: function ( e ) {

	const t = [], n = e.tracks, r = 1 / ( e.fps || 1 ); for ( let e = 0, i = n.length; e !== i; ++ e )t.push( parseKeyframeTrack( n[ e ] ).scale( r ) ); const i = new AnimationClip( e.name, e.duration, t, e.blendMode ); return i.uuid = e.uuid, i;

}, toJSON: function ( e ) {

	const t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for ( let e = 0, r = n.length; e !== r; ++ e )t.push( KeyframeTrack.toJSON( n[ e ] ) ); return r;

}, CreateFromMorphTargetSequence: function ( e, t, n, r ) {

	const i = t.length, o = []; for ( let e = 0; e < i; e ++ ) {

		let a = [], s = []; a.push( ( e + i - 1 ) % i, e, ( e + 1 ) % i ), s.push( 0, 1, 0 ); const c = AnimationUtils.getKeyframeOrder( a ); a = AnimationUtils.sortedArray( a, 1, c ), s = AnimationUtils.sortedArray( s, 1, c ), r || 0 !== a[ 0 ] || ( a.push( i ), s.push( s[ 0 ] ) ), o.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + t[ e ].name + ']', a, s ).scale( 1 / n ) );

	}

	return new AnimationClip( e, - 1, o );

}, findByName: function ( e, t ) {

	let n = e; if ( ! Array.isArray( e ) ) {

		const t = e; n = t.geometry && t.geometry.animations || t.animations;

	}

	for ( let e = 0; e < n.length; e ++ ) if ( n[ e ].name === t ) return n[ e ]; return null;

}, CreateClipsFromMorphTargetSequences: function ( e, t, n ) {

	const r = {}, i = /^([\w-]*?)([\d]+)$/; for ( let t = 0, n = e.length; t < n; t ++ ) {

		const n = e[ t ], o = n.name.match( i ); if ( o && o.length > 1 ) {

			const e = o[ 1 ]; let t = r[ e ]; t || ( r[ e ] = t = [] ), t.push( n );

		}

	}

	const o = []; for ( const e in r )o.push( AnimationClip.CreateFromMorphTargetSequence( e, r[ e ], t, n ) ); return o;

}, parseAnimation: function ( e, t ) {

	if ( ! e ) return console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' ), null; const n = function ( e, t, n, r, i ) {

			if ( 0 !== n.length ) {

				const o = [], a = []; AnimationUtils.flattenJSON( n, o, a, r ), 0 !== o.length && i.push( new e( t, o, a ) );

			}

		}, r = [], i = e.name || 'default', o = e.fps || 30, a = e.blendMode; let s = e.length || - 1; const c = e.hierarchy || []; for ( let e = 0; e < c.length; e ++ ) {

		const i = c[ e ].keys; if ( i && 0 !== i.length ) if ( i[ 0 ].morphTargets ) {

			const e = {}; let t; for ( t = 0; t < i.length; t ++ ) if ( i[ t ].morphTargets ) for ( let n = 0; n < i[ t ].morphTargets.length; n ++ )e[ i[ t ].morphTargets[ n ] ] = - 1; for ( const n in e ) {

				const e = [], o = []; for ( let r = 0; r !== i[ t ].morphTargets.length; ++ r ) {

					const r = i[ t ]; e.push( r.time ), o.push( r.morphTarget === n ? 1 : 0 );

				}

				r.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + n + ']', e, o ) );

			}

			s = e.length * ( o || 1 );

		} else {

			const o = '.bones[' + t[ e ].name + ']'; n( VectorKeyframeTrack, o + '.position', i, 'pos', r ), n( QuaternionKeyframeTrack, o + '.quaternion', i, 'rot', r ), n( VectorKeyframeTrack, o + '.scale', i, 'scl', r );

		}

	}

	return 0 === r.length ? null : new AnimationClip( i, s, r, a );

} } ), Object.assign( AnimationClip.prototype, { resetDuration: function () {

	let e = 0; for ( let t = 0, n = this.tracks.length; t !== n; ++ t ) {

		const n = this.tracks[ t ]; e = Math.max( e, n.times[ n.times.length - 1 ] );

	}

	return this.duration = e, this;

}, trim: function () {

	for ( let e = 0; e < this.tracks.length; e ++ ) this.tracks[ e ].trim( 0, this.duration ); return this;

}, validate: function () {

	let e = ! 0; for ( let t = 0; t < this.tracks.length; t ++ )e = e && this.tracks[ t ].validate(); return e;

}, optimize: function () {

	for ( let e = 0; e < this.tracks.length; e ++ ) this.tracks[ e ].optimize(); return this;

}, clone: function () {

	const e = []; for ( let t = 0; t < this.tracks.length; t ++ )e.push( this.tracks[ t ].clone() ); return new AnimationClip( this.name, this.duration, e, this.blendMode );

}, toJSON: function () {

	return AnimationClip.toJSON( this );

} } ); const Cache = { enabled: ! 1, files: {}, add: function ( e, t ) {

	! 1 !== this.enabled && ( this.files[ e ] = t );

}, get: function ( e ) {

	if ( ! 1 !== this.enabled ) return this.files[ e ];

}, remove: function ( e ) {

	delete this.files[ e ];

}, clear: function () {

	this.files = {};

} }; function LoadingManager( e, t, n ) {

	const r = this; let i = ! 1, o = 0, a = 0, s = void 0; const c = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function ( e ) {

		a ++, ! 1 === i && void 0 !== r.onStart && r.onStart( e, o, a ), i = ! 0;

	}, this.itemEnd = function ( e ) {

		o ++, void 0 !== r.onProgress && r.onProgress( e, o, a ), o === a && ( i = ! 1, void 0 !== r.onLoad && r.onLoad() );

	}, this.itemError = function ( e ) {

		void 0 !== r.onError && r.onError( e );

	}, this.resolveURL = function ( e ) {

		return s ? s( e ) : e;

	}, this.setURLModifier = function ( e ) {

		return s = e, this;

	}, this.addHandler = function ( e, t ) {

		return c.push( e, t ), this;

	}, this.removeHandler = function ( e ) {

		const t = c.indexOf( e ); return - 1 !== t && c.splice( t, 2 ), this;

	}, this.getHandler = function ( e ) {

		for ( let t = 0, n = c.length; t < n; t += 2 ) {

			const n = c[ t ], r = c[ t + 1 ]; if ( n.global && ( n.lastIndex = 0 ), n.test( e ) ) return r;

		}

		return null;

	};

}

const DefaultLoadingManager = new LoadingManager(); function Loader( e ) {

	this.manager = void 0 !== e ? e : DefaultLoadingManager, this.crossOrigin = 'anonymous', this.withCredentials = ! 1, this.path = '', this.resourcePath = '', this.requestHeader = {};

}

Object.assign( Loader.prototype, { load: function () {}, loadAsync: function ( e, t ) {

	const n = this; return new Promise( function ( r, i ) {

		n.load( e, r, t, i );

	} );

}, parse: function () {}, setCrossOrigin: function ( e ) {

	return this.crossOrigin = e, this;

}, setWithCredentials: function ( e ) {

	return this.withCredentials = e, this;

}, setPath: function ( e ) {

	return this.path = e, this;

}, setResourcePath: function ( e ) {

	return this.resourcePath = e, this;

}, setRequestHeader: function ( e ) {

	return this.requestHeader = e, this;

} } ); const loading = {}; function FileLoader( e ) {

	Loader.call( this, e );

}

function AnimationLoader( e ) {

	Loader.call( this, e );

}

function CompressedTextureLoader( e ) {

	Loader.call( this, e );

}

function ImageLoader( e ) {

	Loader.call( this, e );

}

function CubeTextureLoader( e ) {

	Loader.call( this, e );

}

function DataTextureLoader( e ) {

	Loader.call( this, e );

}

function TextureLoader( e ) {

	Loader.call( this, e );

}

function Curve() {

	this.type = 'Curve', this.arcLengthDivisions = 200;

}

function EllipseCurve( e, t, n, r, i, o, a, s ) {

	Curve.call( this ), this.type = 'EllipseCurve', this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || ! 1, this.aRotation = s || 0;

}

function ArcCurve( e, t, n, r, i, o ) {

	EllipseCurve.call( this, e, t, n, n, r, i, o ), this.type = 'ArcCurve';

}

function CubicPoly() {

	let e = 0, t = 0, n = 0, r = 0; function i( i, o, a, s ) {

		e = i, t = a, n = - 3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s;

	}

	return { initCatmullRom: function ( e, t, n, r, o ) {

		i( t, n, o * ( n - e ), o * ( r - t ) );

	}, initNonuniformCatmullRom: function ( e, t, n, r, o, a, s ) {

		let c = ( t - e ) / o - ( n - e ) / ( o + a ) + ( n - t ) / a, l = ( n - t ) / a - ( r - t ) / ( a + s ) + ( r - n ) / s; i( t, n, c *= a, l *= a );

	}, calc: function ( i ) {

		const o = i * i; return e + t * i + n * o + r * ( o * i );

	} };

}

FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: FileLoader, load: function ( e, t, n, r ) {

	void 0 === e && ( e = '' ), void 0 !== this.path && ( e = this.path + e ), e = this.manager.resolveURL( e ); const i = this, o = Cache.get( e ); if ( void 0 !== o ) return i.manager.itemStart( e ), setTimeout( function () {

		t && t( o ), i.manager.itemEnd( e );

	}, 0 ), o; if ( void 0 !== loading[ e ] ) return void loading[ e ].push( { onLoad: t, onProgress: n, onError: r } ); const a = e.match( /^data:(.*?)(;base64)?,(.*)$/ ); let s; if ( a ) {

		const n = a[ 1 ], o = !! a[ 2 ]; let s = a[ 3 ]; s = decodeURIComponent( s ), o && ( s = atob( s ) ); try {

			let o; const a = ( this.responseType || '' ).toLowerCase(); switch ( a ) {

				case 'arraybuffer':case 'blob':const e = new Uint8Array( s.length ); for ( let t = 0; t < s.length; t ++ )e[ t ] = s.charCodeAt( t ); o = 'blob' === a ? new Blob( [ e.buffer ], { type: n } ) : e.buffer; break; case 'document':const t = new DOMParser(); o = t.parseFromString( s, n ); break; case 'json':o = JSON.parse( s ); break; default:o = s;

			}

			setTimeout( function () {

				t && t( o ), i.manager.itemEnd( e );

			}, 0 );

		} catch ( t ) {

			setTimeout( function () {

				r && r( t ), i.manager.itemError( e ), i.manager.itemEnd( e );

			}, 0 );

		}

	} else {

		loading[ e ] = [], loading[ e ].push( { onLoad: t, onProgress: n, onError: r } ), ( s = new XMLHttpRequest() ).open( 'GET', e, ! 0 ), s.addEventListener( 'load', function ( t ) {

			const n = this.response, r = loading[ e ]; if ( delete loading[ e ], 200 === this.status || 0 === this.status ) {

				0 === this.status && console.warn( 'THREE.FileLoader: HTTP Status 0 received.' ), Cache.add( e, n ); for ( let e = 0, t = r.length; e < t; e ++ ) {

					const t = r[ e ]; t.onLoad && t.onLoad( n );

				}

				i.manager.itemEnd( e );

			} else {

				for ( let e = 0, n = r.length; e < n; e ++ ) {

					const n = r[ e ]; n.onError && n.onError( t );

				}

				i.manager.itemError( e ), i.manager.itemEnd( e );

			}

		}, ! 1 ), s.addEventListener( 'progress', function ( t ) {

			const n = loading[ e ]; for ( let e = 0, r = n.length; e < r; e ++ ) {

				const r = n[ e ]; r.onProgress && r.onProgress( t );

			}

		}, ! 1 ), s.addEventListener( 'error', function ( t ) {

			const n = loading[ e ]; delete loading[ e ]; for ( let e = 0, r = n.length; e < r; e ++ ) {

				const r = n[ e ]; r.onError && r.onError( t );

			}

			i.manager.itemError( e ), i.manager.itemEnd( e );

		}, ! 1 ), s.addEventListener( 'abort', function ( t ) {

			const n = loading[ e ]; delete loading[ e ]; for ( let e = 0, r = n.length; e < r; e ++ ) {

				const r = n[ e ]; r.onError && r.onError( t );

			}

			i.manager.itemError( e ), i.manager.itemEnd( e );

		}, ! 1 ), void 0 !== this.responseType && ( s.responseType = this.responseType ), void 0 !== this.withCredentials && ( s.withCredentials = this.withCredentials ), s.overrideMimeType && s.overrideMimeType( void 0 !== this.mimeType ? this.mimeType : 'text/plain' ); for ( const e in this.requestHeader )s.setRequestHeader( e, this.requestHeader[ e ] ); s.send( null );

	}

	return i.manager.itemStart( e ), s;

}, setResponseType: function ( e ) {

	return this.responseType = e, this;

}, setMimeType: function ( e ) {

	return this.mimeType = e, this;

} } ), AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: AnimationLoader, load: function ( e, t, n, r ) {

	const i = this, o = new FileLoader( i.manager ); o.setPath( i.path ), o.setRequestHeader( i.requestHeader ), o.setWithCredentials( i.withCredentials ), o.load( e, function ( n ) {

		try {

			t( i.parse( JSON.parse( n ) ) );

		} catch ( t ) {

			r ? r( t ) : console.error( t ), i.manager.itemError( e );

		}

	}, n, r );

}, parse: function ( e ) {

	const t = []; for ( let n = 0; n < e.length; n ++ ) {

		const r = AnimationClip.parse( e[ n ] ); t.push( r );

	}

	return t;

} } ), CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: CompressedTextureLoader, load: function ( e, t, n, r ) {

	const i = this, o = [], a = new CompressedTexture(), s = new FileLoader( this.manager ); s.setPath( this.path ), s.setResponseType( 'arraybuffer' ), s.setRequestHeader( this.requestHeader ), s.setWithCredentials( i.withCredentials ); let c = 0; function l( l ) {

		s.load( e[ l ], function ( e ) {

			const n = i.parse( e, ! 0 ); o[ l ] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === ( c += 1 ) && ( 1 === n.mipmapCount && ( a.minFilter = LinearFilter ), a.image = o, a.format = n.format, a.needsUpdate = ! 0, t && t( a ) );

		}, n, r );

	}

	if ( Array.isArray( e ) ) for ( let t = 0, n = e.length; t < n; ++ t )l( t ); else s.load( e, function ( e ) {

		const n = i.parse( e, ! 0 ); if ( n.isCubemap ) {

			const e = n.mipmaps.length / n.mipmapCount; for ( let t = 0; t < e; t ++ ) {

				o[ t ] = { mipmaps: [] }; for ( let e = 0; e < n.mipmapCount; e ++ )o[ t ].mipmaps.push( n.mipmaps[ t * n.mipmapCount + e ] ), o[ t ].format = n.format, o[ t ].width = n.width, o[ t ].height = n.height;

			}

			a.image = o;

		} else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps; 1 === n.mipmapCount && ( a.minFilter = LinearFilter ), a.format = n.format, a.needsUpdate = ! 0, t && t( a );

	}, n, r ); return a;

} } ), ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: ImageLoader, load: function ( e, t, n, r ) {

	void 0 !== this.path && ( e = this.path + e ), e = this.manager.resolveURL( e ); const i = this, o = Cache.get( e ); if ( void 0 !== o ) return i.manager.itemStart( e ), setTimeout( function () {

		t && t( o ), i.manager.itemEnd( e );

	}, 0 ), o; const a = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' ); function s() {

		a.removeEventListener( 'load', s, ! 1 ), a.removeEventListener( 'error', c, ! 1 ), Cache.add( e, this ), t && t( this ), i.manager.itemEnd( e );

	}

	function c( t ) {

		a.removeEventListener( 'load', s, ! 1 ), a.removeEventListener( 'error', c, ! 1 ), r && r( t ), i.manager.itemError( e ), i.manager.itemEnd( e );

	}

	return a.addEventListener( 'load', s, ! 1 ), a.addEventListener( 'error', c, ! 1 ), 'data:' !== e.substr( 0, 5 ) && void 0 !== this.crossOrigin && ( a.crossOrigin = this.crossOrigin ), i.manager.itemStart( e ), a.src = e, a;

} } ), CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: CubeTextureLoader, load: function ( e, t, n, r ) {

	const i = new CubeTexture(), o = new ImageLoader( this.manager ); o.setCrossOrigin( this.crossOrigin ), o.setPath( this.path ); let a = 0; function s( n ) {

		o.load( e[ n ], function ( e ) {

			i.images[ n ] = e, 6 === ++ a && ( i.needsUpdate = ! 0, t && t( i ) );

		}, void 0, r );

	}

	for ( let t = 0; t < e.length; ++ t )s( t ); return i;

} } ), DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: DataTextureLoader, load: function ( e, t, n, r ) {

	const i = this, o = new DataTexture(), a = new FileLoader( this.manager ); return a.setResponseType( 'arraybuffer' ), a.setRequestHeader( this.requestHeader ), a.setPath( this.path ), a.setWithCredentials( i.withCredentials ), a.load( e, function ( e ) {

		const n = i.parse( e ); n && ( void 0 !== n.image ? o.image = n.image : void 0 !== n.data && ( o.image.width = n.width, o.image.height = n.height, o.image.data = n.data ), o.wrapS = void 0 !== n.wrapS ? n.wrapS : ClampToEdgeWrapping, o.wrapT = void 0 !== n.wrapT ? n.wrapT : ClampToEdgeWrapping, o.magFilter = void 0 !== n.magFilter ? n.magFilter : LinearFilter, o.minFilter = void 0 !== n.minFilter ? n.minFilter : LinearFilter, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && ( o.format = n.format ), void 0 !== n.type && ( o.type = n.type ), void 0 !== n.mipmaps && ( o.mipmaps = n.mipmaps, o.minFilter = LinearMipmapLinearFilter ), 1 === n.mipmapCount && ( o.minFilter = LinearFilter ), o.needsUpdate = ! 0, t && t( o, n ) );

	}, n, r ), o;

} } ), TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: TextureLoader, load: function ( e, t, n, r ) {

	const i = new Texture(), o = new ImageLoader( this.manager ); return o.setCrossOrigin( this.crossOrigin ), o.setPath( this.path ), o.load( e, function ( n ) {

		i.image = n; const r = e.search( /\.jpe?g($|\?)/i ) > 0 || 0 === e.search( /^data\:image\/jpeg/ ); i.format = r ? RGBFormat : RGBAFormat, i.needsUpdate = ! 0, void 0 !== t && t( i );

	}, n, r ), i;

} } ), Object.assign( Curve.prototype, { getPoint: function () {

	return console.warn( 'THREE.Curve: .getPoint() not implemented.' ), null;

}, getPointAt: function ( e, t ) {

	const n = this.getUtoTmapping( e ); return this.getPoint( n, t );

}, getPoints: function ( e = 5 ) {

	const t = []; for ( let n = 0; n <= e; n ++ )t.push( this.getPoint( n / e ) ); return t;

}, getSpacedPoints: function ( e = 5 ) {

	const t = []; for ( let n = 0; n <= e; n ++ )t.push( this.getPointAt( n / e ) ); return t;

}, getLength: function () {

	const e = this.getLengths(); return e[ e.length - 1 ];

}, getLengths: function ( e ) {

	if ( void 0 === e && ( e = this.arcLengthDivisions ), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && ! this.needsUpdate ) return this.cacheArcLengths; this.needsUpdate = ! 1; const t = []; let n, r = this.getPoint( 0 ), i = 0; t.push( 0 ); for ( let o = 1; o <= e; o ++ )i += ( n = this.getPoint( o / e ) ).distanceTo( r ), t.push( i ), r = n; return this.cacheArcLengths = t, t;

}, updateArcLengths: function () {

	this.needsUpdate = ! 0, this.getLengths();

}, getUtoTmapping: function ( e, t ) {

	const n = this.getLengths(); let r = 0; const i = n.length; let o; o = t || e * n[ i - 1 ]; let a, s = 0, c = i - 1; for ( ;s <= c; ) if ( ( a = n[ r = Math.floor( s + ( c - s ) / 2 ) ] - o ) < 0 )s = r + 1; else {

		if ( ! ( a > 0 ) ) {

			c = r; break;

		}

		c = r - 1;

	}

	if ( n[ r = c ] === o ) return r / ( i - 1 ); const l = n[ r ]; return ( r + ( o - l ) / ( n[ r + 1 ] - l ) ) / ( i - 1 );

}, getTangent: function ( e, t ) {

	let n = e - 1e-4, r = e + 1e-4; n < 0 && ( n = 0 ), r > 1 && ( r = 1 ); const i = this.getPoint( n ), o = this.getPoint( r ), a = t || ( i.isVector2 ? new Vector2() : new Vector3() ); return a.copy( o ).sub( i ).normalize(), a;

}, getTangentAt: function ( e, t ) {

	const n = this.getUtoTmapping( e ); return this.getTangent( n, t );

}, computeFrenetFrames: function ( e, t ) {

	const n = new Vector3(), r = [], i = [], o = [], a = new Vector3(), s = new Matrix4(); for ( let t = 0; t <= e; t ++ ) {

		const n = t / e; r[ t ] = this.getTangentAt( n, new Vector3() ), r[ t ].normalize();

	}

	i[ 0 ] = new Vector3(), o[ 0 ] = new Vector3(); let c = Number.MAX_VALUE; const l = Math.abs( r[ 0 ].x ), h = Math.abs( r[ 0 ].y ), u = Math.abs( r[ 0 ].z ); l <= c && ( c = l, n.set( 1, 0, 0 ) ), h <= c && ( c = h, n.set( 0, 1, 0 ) ), u <= c && n.set( 0, 0, 1 ), a.crossVectors( r[ 0 ], n ).normalize(), i[ 0 ].crossVectors( r[ 0 ], a ), o[ 0 ].crossVectors( r[ 0 ], i[ 0 ] ); for ( let t = 1; t <= e; t ++ ) {

		if ( i[ t ] = i[ t - 1 ].clone(), o[ t ] = o[ t - 1 ].clone(), a.crossVectors( r[ t - 1 ], r[ t ] ), a.length() > Number.EPSILON ) {

			a.normalize(); const e = Math.acos( MathUtils.clamp( r[ t - 1 ].dot( r[ t ] ), - 1, 1 ) ); i[ t ].applyMatrix4( s.makeRotationAxis( a, e ) );

		}

		o[ t ].crossVectors( r[ t ], i[ t ] );

	}

	if ( ! 0 === t ) {

		let t = Math.acos( MathUtils.clamp( i[ 0 ].dot( i[ e ] ), - 1, 1 ) ); t /= e, r[ 0 ].dot( a.crossVectors( i[ 0 ], i[ e ] ) ) > 0 && ( t = - t ); for ( let n = 1; n <= e; n ++ )i[ n ].applyMatrix4( s.makeRotationAxis( r[ n ], t * n ) ), o[ n ].crossVectors( r[ n ], i[ n ] );

	}

	return { tangents: r, normals: i, binormals: o };

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, copy: function ( e ) {

	return this.arcLengthDivisions = e.arcLengthDivisions, this;

}, toJSON: function () {

	const e = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;

}, fromJSON: function ( e ) {

	return this.arcLengthDivisions = e.arcLengthDivisions, this;

} } ), EllipseCurve.prototype = Object.create( Curve.prototype ), EllipseCurve.prototype.constructor = EllipseCurve, EllipseCurve.prototype.isEllipseCurve = ! 0, EllipseCurve.prototype.getPoint = function ( e, t ) {

	const n = t || new Vector2(), r = 2 * Math.PI; let i = this.aEndAngle - this.aStartAngle; const o = Math.abs( i ) < Number.EPSILON; for ( ;i < 0; )i += r; for ( ;i > r; )i -= r; i < Number.EPSILON && ( i = o ? 0 : r ), ! 0 !== this.aClockwise || o || ( i === r ? i = - r : i -= r ); const a = this.aStartAngle + e * i; let s = this.aX + this.xRadius * Math.cos( a ), c = this.aY + this.yRadius * Math.sin( a ); if ( 0 !== this.aRotation ) {

		const e = Math.cos( this.aRotation ), t = Math.sin( this.aRotation ), n = s - this.aX, r = c - this.aY; s = n * e - r * t + this.aX, c = n * t + r * e + this.aY;

	}

	return n.set( s, c );

}, EllipseCurve.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;

}, EllipseCurve.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;

}, EllipseCurve.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;

}, ArcCurve.prototype = Object.create( EllipseCurve.prototype ), ArcCurve.prototype.constructor = ArcCurve, ArcCurve.prototype.isArcCurve = ! 0; const tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly(); function CatmullRomCurve3( e = [], t = ! 1, n = 'centripetal', r = .5 ) {

	Curve.call( this ), this.type = 'CatmullRomCurve3', this.points = e, this.closed = t, this.curveType = n, this.tension = r;

}

function CatmullRom( e, t, n, r, i ) {

	const o = .5 * ( r - t ), a = .5 * ( i - n ), s = e * e; return ( 2 * n - 2 * r + o + a ) * ( e * s ) + ( - 3 * n + 3 * r - 2 * o - a ) * s + o * e + n;

}

function QuadraticBezierP0( e, t ) {

	const n = 1 - e; return n * n * t;

}

function QuadraticBezierP1( e, t ) {

	return 2 * ( 1 - e ) * e * t;

}

function QuadraticBezierP2( e, t ) {

	return e * e * t;

}

function QuadraticBezier( e, t, n, r ) {

	return QuadraticBezierP0( e, t ) + QuadraticBezierP1( e, n ) + QuadraticBezierP2( e, r );

}

function CubicBezierP0( e, t ) {

	const n = 1 - e; return n * n * n * t;

}

function CubicBezierP1( e, t ) {

	const n = 1 - e; return 3 * n * n * e * t;

}

function CubicBezierP2( e, t ) {

	return 3 * ( 1 - e ) * e * e * t;

}

function CubicBezierP3( e, t ) {

	return e * e * e * t;

}

function CubicBezier( e, t, n, r, i ) {

	return CubicBezierP0( e, t ) + CubicBezierP1( e, n ) + CubicBezierP2( e, r ) + CubicBezierP3( e, i );

}

function CubicBezierCurve( e = new Vector2(), t = new Vector2(), n = new Vector2(), r = new Vector2() ) {

	Curve.call( this ), this.type = 'CubicBezierCurve', this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;

}

function CubicBezierCurve3( e = new Vector3(), t = new Vector3(), n = new Vector3(), r = new Vector3() ) {

	Curve.call( this ), this.type = 'CubicBezierCurve3', this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;

}

function LineCurve( e = new Vector2(), t = new Vector2() ) {

	Curve.call( this ), this.type = 'LineCurve', this.v1 = e, this.v2 = t;

}

function LineCurve3( e = new Vector3(), t = new Vector3() ) {

	Curve.call( this ), this.type = 'LineCurve3', this.v1 = e, this.v2 = t;

}

function QuadraticBezierCurve( e = new Vector2(), t = new Vector2(), n = new Vector2() ) {

	Curve.call( this ), this.type = 'QuadraticBezierCurve', this.v0 = e, this.v1 = t, this.v2 = n;

}

function QuadraticBezierCurve3( e = new Vector3(), t = new Vector3(), n = new Vector3() ) {

	Curve.call( this ), this.type = 'QuadraticBezierCurve3', this.v0 = e, this.v1 = t, this.v2 = n;

}

function SplineCurve( e = [] ) {

	Curve.call( this ), this.type = 'SplineCurve', this.points = e;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype ), CatmullRomCurve3.prototype.constructor = CatmullRomCurve3, CatmullRomCurve3.prototype.isCatmullRomCurve3 = ! 0, CatmullRomCurve3.prototype.getPoint = function ( e, t = new Vector3() ) {

	const n = t, r = this.points, i = r.length, o = ( i - ( this.closed ? 0 : 1 ) ) * e; let a, s, c = Math.floor( o ), l = o - c; this.closed ? c += c > 0 ? 0 : ( Math.floor( Math.abs( c ) / i ) + 1 ) * i : 0 === l && c === i - 1 && ( c = i - 2, l = 1 ), this.closed || c > 0 ? a = r[ ( c - 1 ) % i ] : ( tmp.subVectors( r[ 0 ], r[ 1 ] ).add( r[ 0 ] ), a = tmp ); const h = r[ c % i ], u = r[ ( c + 1 ) % i ]; if ( this.closed || c + 2 < i ? s = r[ ( c + 2 ) % i ] : ( tmp.subVectors( r[ i - 1 ], r[ i - 2 ] ).add( r[ i - 1 ] ), s = tmp ), 'centripetal' === this.curveType || 'chordal' === this.curveType ) {

		const e = 'chordal' === this.curveType ? .5 : .25; let t = Math.pow( a.distanceToSquared( h ), e ), n = Math.pow( h.distanceToSquared( u ), e ), r = Math.pow( u.distanceToSquared( s ), e ); n < 1e-4 && ( n = 1 ), t < 1e-4 && ( t = n ), r < 1e-4 && ( r = n ), px.initNonuniformCatmullRom( a.x, h.x, u.x, s.x, t, n, r ), py.initNonuniformCatmullRom( a.y, h.y, u.y, s.y, t, n, r ), pz.initNonuniformCatmullRom( a.z, h.z, u.z, s.z, t, n, r );

	} else 'catmullrom' === this.curveType && ( px.initCatmullRom( a.x, h.x, u.x, s.x, this.tension ), py.initCatmullRom( a.y, h.y, u.y, s.y, this.tension ), pz.initCatmullRom( a.z, h.z, u.z, s.z, this.tension ) ); return n.set( px.calc( l ), py.calc( l ), pz.calc( l ) ), n;

}, CatmullRomCurve3.prototype.copy = function ( e ) {

	Curve.prototype.copy.call( this, e ), this.points = []; for ( let t = 0, n = e.points.length; t < n; t ++ ) {

		const n = e.points[ t ]; this.points.push( n.clone() );

	}

	return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;

}, CatmullRomCurve3.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); e.points = []; for ( let t = 0, n = this.points.length; t < n; t ++ ) {

		const n = this.points[ t ]; e.points.push( n.toArray() );

	}

	return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;

}, CatmullRomCurve3.prototype.fromJSON = function ( e ) {

	Curve.prototype.fromJSON.call( this, e ), this.points = []; for ( let t = 0, n = e.points.length; t < n; t ++ ) {

		const n = e.points[ t ]; this.points.push( ( new Vector3() ).fromArray( n ) );

	}

	return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;

}, CubicBezierCurve.prototype = Object.create( Curve.prototype ), CubicBezierCurve.prototype.constructor = CubicBezierCurve, CubicBezierCurve.prototype.isCubicBezierCurve = ! 0, CubicBezierCurve.prototype.getPoint = function ( e, t = new Vector2() ) {

	const n = t, r = this.v0, i = this.v1, o = this.v2, a = this.v3; return n.set( CubicBezier( e, r.x, i.x, o.x, a.x ), CubicBezier( e, r.y, i.y, o.y, a.y ) ), n;

}, CubicBezierCurve.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v0.copy( e.v0 ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this.v3.copy( e.v3 ), this;

}, CubicBezierCurve.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;

}, CubicBezierCurve.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v0.fromArray( e.v0 ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this.v3.fromArray( e.v3 ), this;

}, CubicBezierCurve3.prototype = Object.create( Curve.prototype ), CubicBezierCurve3.prototype.constructor = CubicBezierCurve3, CubicBezierCurve3.prototype.isCubicBezierCurve3 = ! 0, CubicBezierCurve3.prototype.getPoint = function ( e, t = new Vector3() ) {

	const n = t, r = this.v0, i = this.v1, o = this.v2, a = this.v3; return n.set( CubicBezier( e, r.x, i.x, o.x, a.x ), CubicBezier( e, r.y, i.y, o.y, a.y ), CubicBezier( e, r.z, i.z, o.z, a.z ) ), n;

}, CubicBezierCurve3.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v0.copy( e.v0 ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this.v3.copy( e.v3 ), this;

}, CubicBezierCurve3.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;

}, CubicBezierCurve3.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v0.fromArray( e.v0 ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this.v3.fromArray( e.v3 ), this;

}, LineCurve.prototype = Object.create( Curve.prototype ), LineCurve.prototype.constructor = LineCurve, LineCurve.prototype.isLineCurve = ! 0, LineCurve.prototype.getPoint = function ( e, t = new Vector2() ) {

	const n = t; return 1 === e ? n.copy( this.v2 ) : ( n.copy( this.v2 ).sub( this.v1 ), n.multiplyScalar( e ).add( this.v1 ) ), n;

}, LineCurve.prototype.getPointAt = function ( e, t ) {

	return this.getPoint( e, t );

}, LineCurve.prototype.getTangent = function ( e, t ) {

	const n = t || new Vector2(); return n.copy( this.v2 ).sub( this.v1 ).normalize(), n;

}, LineCurve.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this;

}, LineCurve.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;

}, LineCurve.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this;

}, LineCurve3.prototype = Object.create( Curve.prototype ), LineCurve3.prototype.constructor = LineCurve3, LineCurve3.prototype.isLineCurve3 = ! 0, LineCurve3.prototype.getPoint = function ( e, t = new Vector3() ) {

	const n = t; return 1 === e ? n.copy( this.v2 ) : ( n.copy( this.v2 ).sub( this.v1 ), n.multiplyScalar( e ).add( this.v1 ) ), n;

}, LineCurve3.prototype.getPointAt = function ( e, t ) {

	return this.getPoint( e, t );

}, LineCurve3.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this;

}, LineCurve3.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;

}, LineCurve3.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this;

}, QuadraticBezierCurve.prototype = Object.create( Curve.prototype ), QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve, QuadraticBezierCurve.prototype.isQuadraticBezierCurve = ! 0, QuadraticBezierCurve.prototype.getPoint = function ( e, t = new Vector2() ) {

	const n = t, r = this.v0, i = this.v1, o = this.v2; return n.set( QuadraticBezier( e, r.x, i.x, o.x ), QuadraticBezier( e, r.y, i.y, o.y ) ), n;

}, QuadraticBezierCurve.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v0.copy( e.v0 ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this;

}, QuadraticBezierCurve.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;

}, QuadraticBezierCurve.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v0.fromArray( e.v0 ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this;

}, QuadraticBezierCurve3.prototype = Object.create( Curve.prototype ), QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3, QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = ! 0, QuadraticBezierCurve3.prototype.getPoint = function ( e, t = new Vector3() ) {

	const n = t, r = this.v0, i = this.v1, o = this.v2; return n.set( QuadraticBezier( e, r.x, i.x, o.x ), QuadraticBezier( e, r.y, i.y, o.y ), QuadraticBezier( e, r.z, i.z, o.z ) ), n;

}, QuadraticBezierCurve3.prototype.copy = function ( e ) {

	return Curve.prototype.copy.call( this, e ), this.v0.copy( e.v0 ), this.v1.copy( e.v1 ), this.v2.copy( e.v2 ), this;

}, QuadraticBezierCurve3.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;

}, QuadraticBezierCurve3.prototype.fromJSON = function ( e ) {

	return Curve.prototype.fromJSON.call( this, e ), this.v0.fromArray( e.v0 ), this.v1.fromArray( e.v1 ), this.v2.fromArray( e.v2 ), this;

}, SplineCurve.prototype = Object.create( Curve.prototype ), SplineCurve.prototype.constructor = SplineCurve, SplineCurve.prototype.isSplineCurve = ! 0, SplineCurve.prototype.getPoint = function ( e, t = new Vector2() ) {

	const n = t, r = this.points, i = ( r.length - 1 ) * e, o = Math.floor( i ), a = i - o, s = r[ 0 === o ? o : o - 1 ], c = r[ o ], l = r[ o > r.length - 2 ? r.length - 1 : o + 1 ], h = r[ o > r.length - 3 ? r.length - 1 : o + 2 ]; return n.set( CatmullRom( a, s.x, c.x, l.x, h.x ), CatmullRom( a, s.y, c.y, l.y, h.y ) ), n;

}, SplineCurve.prototype.copy = function ( e ) {

	Curve.prototype.copy.call( this, e ), this.points = []; for ( let t = 0, n = e.points.length; t < n; t ++ ) {

		const n = e.points[ t ]; this.points.push( n.clone() );

	}

	return this;

}, SplineCurve.prototype.toJSON = function () {

	const e = Curve.prototype.toJSON.call( this ); e.points = []; for ( let t = 0, n = this.points.length; t < n; t ++ ) {

		const n = this.points[ t ]; e.points.push( n.toArray() );

	}

	return e;

}, SplineCurve.prototype.fromJSON = function ( e ) {

	Curve.prototype.fromJSON.call( this, e ), this.points = []; for ( let t = 0, n = e.points.length; t < n; t ++ ) {

		const n = e.points[ t ]; this.points.push( ( new Vector2() ).fromArray( n ) );

	}

	return this;

};

var Curves = Object.freeze( { __proto__: null, ArcCurve: ArcCurve, CatmullRomCurve3: CatmullRomCurve3, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, EllipseCurve: EllipseCurve, LineCurve: LineCurve, LineCurve3: LineCurve3, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, SplineCurve: SplineCurve } ); function CurvePath() {

	Curve.call( this ), this.type = 'CurvePath', this.curves = [], this.autoClose = ! 1;

}

function Path( e ) {

	CurvePath.call( this ), this.type = 'Path', this.currentPoint = new Vector2(), e && this.setFromPoints( e );

}

function Shape( e ) {

	Path.call( this, e ), this.uuid = MathUtils.generateUUID(), this.type = 'Shape', this.holes = [];

}

function Light( e, t = 1 ) {

	Object3D.call( this ), this.type = 'Light', this.color = new Color( e ), this.intensity = t;

}

function HemisphereLight( e, t, n ) {

	Light.call( this, e, n ), this.type = 'HemisphereLight', this.position.copy( Object3D.DefaultUp ), this.updateMatrix(), this.groundColor = new Color( t );

}

function LightShadow( e ) {

	this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2( 512, 512 ), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = ! 0, this.needsUpdate = ! 1, this._frustum = new Frustum(), this._frameExtents = new Vector2( 1, 1 ), this._viewportCount = 1, this._viewports = [ new Vector4( 0, 0, 1, 1 ) ];

}

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, .5, 500 ) ), this.focus = 1;

}

function SpotLight( e, t, n, r, i, o ) {

	Light.call( this, e, t ), this.type = 'SpotLight', this.position.copy( Object3D.DefaultUp ), this.updateMatrix(), this.target = new Object3D(), Object.defineProperty( this, 'power', { get: function () {

		return this.intensity * Math.PI;

	}, set: function ( e ) {

		this.intensity = e / Math.PI;

	} } ), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new SpotLightShadow();

}

function PointLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 90, 1, .5, 500 ) ), this._frameExtents = new Vector2( 4, 2 ), this._viewportCount = 6, this._viewports = [ new Vector4( 2, 1, 1, 1 ), new Vector4( 0, 1, 1, 1 ), new Vector4( 3, 1, 1, 1 ), new Vector4( 1, 1, 1, 1 ), new Vector4( 3, 0, 1, 1 ), new Vector4( 1, 0, 1, 1 ) ], this._cubeDirections = [ new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 ) ], this._cubeUps = [ new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, - 1 ) ];

}

function PointLight( e, t, n, r ) {

	Light.call( this, e, t ), this.type = 'PointLight', Object.defineProperty( this, 'power', { get: function () {

		return 4 * this.intensity * Math.PI;

	}, set: function ( e ) {

		this.intensity = e / ( 4 * Math.PI );

	} } ), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new PointLightShadow();

}

function OrthographicCamera( e = - 1, t = 1, n = 1, r = - 1, i = .1, o = 2e3 ) {

	Camera.call( this ), this.type = 'OrthographicCamera', this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = o, this.updateProjectionMatrix();

}

function DirectionalLightShadow() {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, .5, 500 ) );

}

function DirectionalLight( e, t ) {

	Light.call( this, e, t ), this.type = 'DirectionalLight', this.position.copy( Object3D.DefaultUp ), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();

}

function AmbientLight( e, t ) {

	Light.call( this, e, t ), this.type = 'AmbientLight';

}

function RectAreaLight( e, t, n, r ) {

	Light.call( this, e, t ), this.type = 'RectAreaLight', this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10;

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), { constructor: CurvePath, add: function ( e ) {

	this.curves.push( e );

}, closePath: function () {

	const e = this.curves[ 0 ].getPoint( 0 ), t = this.curves[ this.curves.length - 1 ].getPoint( 1 ); e.equals( t ) || this.curves.push( new LineCurve( t, e ) );

}, getPoint: function ( e ) {

	const t = e * this.getLength(), n = this.getCurveLengths(); let r = 0; for ( ;r < n.length; ) {

		if ( n[ r ] >= t ) {

			const e = n[ r ] - t, i = this.curves[ r ], o = i.getLength(), a = 0 === o ? 0 : 1 - e / o; return i.getPointAt( a );

		}

		r ++;

	}

	return null;

}, getLength: function () {

	const e = this.getCurveLengths(); return e[ e.length - 1 ];

}, updateArcLengths: function () {

	this.needsUpdate = ! 0, this.cacheLengths = null, this.getCurveLengths();

}, getCurveLengths: function () {

	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) return this.cacheLengths; const e = []; let t = 0; for ( let n = 0, r = this.curves.length; n < r; n ++ )t += this.curves[ n ].getLength(), e.push( t ); return this.cacheLengths = e, e;

}, getSpacedPoints: function ( e = 40 ) {

	const t = []; for ( let n = 0; n <= e; n ++ )t.push( this.getPoint( n / e ) ); return this.autoClose && t.push( t[ 0 ] ), t;

}, getPoints: function ( e = 12 ) {

	const t = []; let n; for ( let r = 0, i = this.curves; r < i.length; r ++ ) {

		const o = i[ r ], a = o && o.isEllipseCurve ? 2 * e : o && ( o.isLineCurve || o.isLineCurve3 ) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints( a ); for ( let e = 0; e < s.length; e ++ ) {

			const r = s[ e ]; n && n.equals( r ) || ( t.push( r ), n = r );

		}

	}

	return this.autoClose && t.length > 1 && ! t[ t.length - 1 ].equals( t[ 0 ] ) && t.push( t[ 0 ] ), t;

}, copy: function ( e ) {

	Curve.prototype.copy.call( this, e ), this.curves = []; for ( let t = 0, n = e.curves.length; t < n; t ++ ) {

		const n = e.curves[ t ]; this.curves.push( n.clone() );

	}

	return this.autoClose = e.autoClose, this;

}, toJSON: function () {

	const e = Curve.prototype.toJSON.call( this ); e.autoClose = this.autoClose, e.curves = []; for ( let t = 0, n = this.curves.length; t < n; t ++ ) {

		const n = this.curves[ t ]; e.curves.push( n.toJSON() );

	}

	return e;

}, fromJSON: function ( e ) {

	Curve.prototype.fromJSON.call( this, e ), this.autoClose = e.autoClose, this.curves = []; for ( let t = 0, n = e.curves.length; t < n; t ++ ) {

		const n = e.curves[ t ]; this.curves.push( ( new Curves[ n.type ]() ).fromJSON( n ) );

	}

	return this;

} } ), Path.prototype = Object.assign( Object.create( CurvePath.prototype ), { constructor: Path, setFromPoints: function ( e ) {

	this.moveTo( e[ 0 ].x, e[ 0 ].y ); for ( let t = 1, n = e.length; t < n; t ++ ) this.lineTo( e[ t ].x, e[ t ].y ); return this;

}, moveTo: function ( e, t ) {

	return this.currentPoint.set( e, t ), this;

}, lineTo: function ( e, t ) {

	const n = new LineCurve( this.currentPoint.clone(), new Vector2( e, t ) ); return this.curves.push( n ), this.currentPoint.set( e, t ), this;

}, quadraticCurveTo: function ( e, t, n, r ) {

	const i = new QuadraticBezierCurve( this.currentPoint.clone(), new Vector2( e, t ), new Vector2( n, r ) ); return this.curves.push( i ), this.currentPoint.set( n, r ), this;

}, bezierCurveTo: function ( e, t, n, r, i, o ) {

	const a = new CubicBezierCurve( this.currentPoint.clone(), new Vector2( e, t ), new Vector2( n, r ), new Vector2( i, o ) ); return this.curves.push( a ), this.currentPoint.set( i, o ), this;

}, splineThru: function ( e ) {

	const t = new SplineCurve( [ this.currentPoint.clone() ].concat( e ) ); return this.curves.push( t ), this.currentPoint.copy( e[ e.length - 1 ] ), this;

}, arc: function ( e, t, n, r, i, o ) {

	const a = this.currentPoint.x, s = this.currentPoint.y; return this.absarc( e + a, t + s, n, r, i, o ), this;

}, absarc: function ( e, t, n, r, i, o ) {

	return this.absellipse( e, t, n, n, r, i, o ), this;

}, ellipse: function ( e, t, n, r, i, o, a, s ) {

	const c = this.currentPoint.x, l = this.currentPoint.y; return this.absellipse( e + c, t + l, n, r, i, o, a, s ), this;

}, absellipse: function ( e, t, n, r, i, o, a, s ) {

	const c = new EllipseCurve( e, t, n, r, i, o, a, s ); if ( this.curves.length > 0 ) {

		const e = c.getPoint( 0 ); e.equals( this.currentPoint ) || this.lineTo( e.x, e.y );

	}

	this.curves.push( c ); const l = c.getPoint( 1 ); return this.currentPoint.copy( l ), this;

}, copy: function ( e ) {

	return CurvePath.prototype.copy.call( this, e ), this.currentPoint.copy( e.currentPoint ), this;

}, toJSON: function () {

	const e = CurvePath.prototype.toJSON.call( this ); return e.currentPoint = this.currentPoint.toArray(), e;

}, fromJSON: function ( e ) {

	return CurvePath.prototype.fromJSON.call( this, e ), this.currentPoint.fromArray( e.currentPoint ), this;

} } ), Shape.prototype = Object.assign( Object.create( Path.prototype ), { constructor: Shape, getPointsHoles: function ( e ) {

	const t = []; for ( let n = 0, r = this.holes.length; n < r; n ++ )t[ n ] = this.holes[ n ].getPoints( e ); return t;

}, extractPoints: function ( e ) {

	return { shape: this.getPoints( e ), holes: this.getPointsHoles( e ) };

}, copy: function ( e ) {

	Path.prototype.copy.call( this, e ), this.holes = []; for ( let t = 0, n = e.holes.length; t < n; t ++ ) {

		const n = e.holes[ t ]; this.holes.push( n.clone() );

	}

	return this;

}, toJSON: function () {

	const e = Path.prototype.toJSON.call( this ); e.uuid = this.uuid, e.holes = []; for ( let t = 0, n = this.holes.length; t < n; t ++ ) {

		const n = this.holes[ t ]; e.holes.push( n.toJSON() );

	}

	return e;

}, fromJSON: function ( e ) {

	Path.prototype.fromJSON.call( this, e ), this.uuid = e.uuid, this.holes = []; for ( let t = 0, n = e.holes.length; t < n; t ++ ) {

		const n = e.holes[ t ]; this.holes.push( ( new Path() ).fromJSON( n ) );

	}

	return this;

} } ), Light.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Light, isLight: ! 0, copy: function ( e ) {

	return Object3D.prototype.copy.call( this, e ), this.color.copy( e.color ), this.intensity = e.intensity, this;

}, toJSON: function ( e ) {

	const t = Object3D.prototype.toJSON.call( this, e ); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && ( t.object.groundColor = this.groundColor.getHex() ), void 0 !== this.distance && ( t.object.distance = this.distance ), void 0 !== this.angle && ( t.object.angle = this.angle ), void 0 !== this.decay && ( t.object.decay = this.decay ), void 0 !== this.penumbra && ( t.object.penumbra = this.penumbra ), void 0 !== this.shadow && ( t.object.shadow = this.shadow.toJSON() ), t;

} } ), HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: HemisphereLight, isHemisphereLight: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.groundColor.copy( e.groundColor ), this;

} } ), Object.assign( LightShadow.prototype, { _projScreenMatrix: new Matrix4(), _lightPositionWorld: new Vector3(), _lookTarget: new Vector3(), getViewportCount: function () {

	return this._viewportCount;

}, getFrustum: function () {

	return this._frustum;

}, updateMatrices: function ( e ) {

	const t = this.camera, n = this.matrix, r = this._projScreenMatrix, i = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition( e.matrixWorld ), t.position.copy( o ), i.setFromMatrixPosition( e.target.matrixWorld ), t.lookAt( i ), t.updateMatrixWorld(), r.multiplyMatrices( t.projectionMatrix, t.matrixWorldInverse ), this._frustum.setFromProjectionMatrix( r ), n.set( .5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1 ), n.multiply( t.projectionMatrix ), n.multiply( t.matrixWorldInverse );

}, getViewport: function ( e ) {

	return this._viewports[ e ];

}, getFrameExtents: function () {

	return this._frameExtents;

}, copy: function ( e ) {

	return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy( e.mapSize ), this;

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, toJSON: function () {

	const e = {}; return 0 !== this.bias && ( e.bias = this.bias ), 0 !== this.normalBias && ( e.normalBias = this.normalBias ), 1 !== this.radius && ( e.radius = this.radius ), 512 === this.mapSize.x && 512 === this.mapSize.y || ( e.mapSize = this.mapSize.toArray() ), e.camera = this.camera.toJSON( ! 1 ).object, delete e.camera.matrix, e;

} } ), SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: SpotLightShadow, isSpotLightShadow: ! 0, updateMatrices: function ( e ) {

	const t = this.camera, n = 2 * MathUtils.RAD2DEG * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far; n === t.fov && r === t.aspect && i === t.far || ( t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix() ), LightShadow.prototype.updateMatrices.call( this, e );

} } ), SpotLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: SpotLight, isSpotLight: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;

} } ), PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: PointLightShadow, isPointLightShadow: ! 0, updateMatrices: function ( e, t = 0 ) {

	const n = this.camera, r = this.matrix, i = this._lightPositionWorld, o = this._lookTarget, a = this._projScreenMatrix; i.setFromMatrixPosition( e.matrixWorld ), n.position.copy( i ), o.copy( n.position ), o.add( this._cubeDirections[ t ] ), n.up.copy( this._cubeUps[ t ] ), n.lookAt( o ), n.updateMatrixWorld(), r.makeTranslation( - i.x, - i.y, - i.z ), a.multiplyMatrices( n.projectionMatrix, n.matrixWorldInverse ), this._frustum.setFromProjectionMatrix( a );

} } ), PointLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: PointLight, isPointLight: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;

} } ), OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: OrthographicCamera, isOrthographicCamera: ! 0, copy: function ( e, t ) {

	return Camera.prototype.copy.call( this, e, t ), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign( {}, e.view ), this;

}, setViewOffset: function ( e, t, n, r, i, o ) {

	null === this.view && ( this.view = { enabled: ! 0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 } ), this.view.enabled = ! 0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix();

}, clearViewOffset: function () {

	null !== this.view && ( this.view.enabled = ! 1 ), this.updateProjectionMatrix();

}, updateProjectionMatrix: function () {

	const e = ( this.right - this.left ) / ( 2 * this.zoom ), t = ( this.top - this.bottom ) / ( 2 * this.zoom ), n = ( this.right + this.left ) / 2, r = ( this.top + this.bottom ) / 2; let i = n - e, o = n + e, a = r + t, s = r - t; if ( null !== this.view && this.view.enabled ) {

		const e = ( this.right - this.left ) / this.view.fullWidth / this.zoom, t = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom; o = ( i += e * this.view.offsetX ) + e * this.view.width, s = ( a -= t * this.view.offsetY ) - t * this.view.height;

	}

	this.projectionMatrix.makeOrthographic( i, o, a, s, this.near, this.far ), this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

}, toJSON: function ( e ) {

	const t = Object3D.prototype.toJSON.call( this, e ); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && ( t.object.view = Object.assign( {}, this.view ) ), t;

} } ), DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: DirectionalLightShadow, isDirectionalLightShadow: ! 0, updateMatrices: function ( e ) {

	LightShadow.prototype.updateMatrices.call( this, e );

} } ), DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: DirectionalLight, isDirectionalLight: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;

} } ), AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: AmbientLight, isAmbientLight: ! 0 } ), RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: RectAreaLight, isRectAreaLight: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.width = e.width, this.height = e.height, this;

}, toJSON: function ( e ) {

	const t = Light.prototype.toJSON.call( this, e ); return t.object.width = this.width, t.object.height = this.height, t;

} } ); class SphericalHarmonics3 {

	constructor() {

		Object.defineProperty( this, 'isSphericalHarmonics3', { value: ! 0 } ), this.coefficients = []; for ( let e = 0; e < 9; e ++ ) this.coefficients.push( new Vector3() );

	}set( e ) {

		for ( let t = 0; t < 9; t ++ ) this.coefficients[ t ].copy( e[ t ] ); return this;

	}zero() {

		for ( let e = 0; e < 9; e ++ ) this.coefficients[ e ].set( 0, 0, 0 ); return this;

	}getAt( e, t ) {

		const n = e.x, r = e.y, i = e.z, o = this.coefficients; return t.copy( o[ 0 ] ).multiplyScalar( .282095 ), t.addScaledVector( o[ 1 ], .488603 * r ), t.addScaledVector( o[ 2 ], .488603 * i ), t.addScaledVector( o[ 3 ], .488603 * n ), t.addScaledVector( o[ 4 ], n * r * 1.092548 ), t.addScaledVector( o[ 5 ], r * i * 1.092548 ), t.addScaledVector( o[ 6 ], .315392 * ( 3 * i * i - 1 ) ), t.addScaledVector( o[ 7 ], n * i * 1.092548 ), t.addScaledVector( o[ 8 ], .546274 * ( n * n - r * r ) ), t;

	}getIrradianceAt( e, t ) {

		const n = e.x, r = e.y, i = e.z, o = this.coefficients; return t.copy( o[ 0 ] ).multiplyScalar( .886227 ), t.addScaledVector( o[ 1 ], 1.023328 * r ), t.addScaledVector( o[ 2 ], 1.023328 * i ), t.addScaledVector( o[ 3 ], 1.023328 * n ), t.addScaledVector( o[ 4 ], .858086 * n * r ), t.addScaledVector( o[ 5 ], .858086 * r * i ), t.addScaledVector( o[ 6 ], .743125 * i * i - .247708 ), t.addScaledVector( o[ 7 ], .858086 * n * i ), t.addScaledVector( o[ 8 ], .429043 * ( n * n - r * r ) ), t;

	}add( e ) {

		for ( let t = 0; t < 9; t ++ ) this.coefficients[ t ].add( e.coefficients[ t ] ); return this;

	}addScaledSH( e, t ) {

		for ( let n = 0; n < 9; n ++ ) this.coefficients[ n ].addScaledVector( e.coefficients[ n ], t ); return this;

	}scale( e ) {

		for ( let t = 0; t < 9; t ++ ) this.coefficients[ t ].multiplyScalar( e ); return this;

	}lerp( e, t ) {

		for ( let n = 0; n < 9; n ++ ) this.coefficients[ n ].lerp( e.coefficients[ n ], t ); return this;

	}equals( e ) {

		for ( let t = 0; t < 9; t ++ ) if ( ! this.coefficients[ t ].equals( e.coefficients[ t ] ) ) return ! 1; return ! 0;

	}copy( e ) {

		return this.set( e.coefficients );

	}clone() {

		return ( new this.constructor() ).copy( this );

	}fromArray( e, t = 0 ) {

		const n = this.coefficients; for ( let r = 0; r < 9; r ++ )n[ r ].fromArray( e, t + 3 * r ); return this;

	}toArray( e = [], t = 0 ) {

		const n = this.coefficients; for ( let r = 0; r < 9; r ++ )n[ r ].toArray( e, t + 3 * r ); return e;

	} static getBasisAt( e, t ) {

		const n = e.x, r = e.y, i = e.z; t[ 0 ] = .282095, t[ 1 ] = .488603 * r, t[ 2 ] = .488603 * i, t[ 3 ] = .488603 * n, t[ 4 ] = 1.092548 * n * r, t[ 5 ] = 1.092548 * r * i, t[ 6 ] = .315392 * ( 3 * i * i - 1 ), t[ 7 ] = 1.092548 * n * i, t[ 8 ] = .546274 * ( n * n - r * r );

	}

} function LightProbe( e, t ) {

	Light.call( this, void 0, t ), this.type = 'LightProbe', this.sh = void 0 !== e ? e : new SphericalHarmonics3();

}

function MaterialLoader( e ) {

	Loader.call( this, e ), this.textures = {};

}

LightProbe.prototype = Object.assign( Object.create( Light.prototype ), { constructor: LightProbe, isLightProbe: ! 0, copy: function ( e ) {

	return Light.prototype.copy.call( this, e ), this.sh.copy( e.sh ), this;

}, fromJSON: function ( e ) {

	return this.intensity = e.intensity, this.sh.fromArray( e.sh ), this;

}, toJSON: function ( e ) {

	const t = Light.prototype.toJSON.call( this, e ); return t.object.sh = this.sh.toArray(), t;

} } ), MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: MaterialLoader, load: function ( e, t, n, r ) {

	const i = this, o = new FileLoader( i.manager ); o.setPath( i.path ), o.setRequestHeader( i.requestHeader ), o.setWithCredentials( i.withCredentials ), o.load( e, function ( n ) {

		try {

			t( i.parse( JSON.parse( n ) ) );

		} catch ( t ) {

			r ? r( t ) : console.error( t ), i.manager.itemError( e );

		}

	}, n, r );

}, parse: function ( e ) {

	const t = this.textures; function n( e ) {

		return void 0 === t[ e ] && console.warn( 'THREE.MaterialLoader: Undefined texture', e ), t[ e ];

	}

	const r = new Materials[ e.type ](); if ( void 0 !== e.uuid && ( r.uuid = e.uuid ), void 0 !== e.name && ( r.name = e.name ), void 0 !== e.color && void 0 !== r.color && r.color.setHex( e.color ), void 0 !== e.roughness && ( r.roughness = e.roughness ), void 0 !== e.metalness && ( r.metalness = e.metalness ), void 0 !== e.sheen && ( r.sheen = ( new Color() ).setHex( e.sheen ) ), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex( e.emissive ), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex( e.specular ), void 0 !== e.shininess && ( r.shininess = e.shininess ), void 0 !== e.clearcoat && ( r.clearcoat = e.clearcoat ), void 0 !== e.clearcoatRoughness && ( r.clearcoatRoughness = e.clearcoatRoughness ), void 0 !== e.fog && ( r.fog = e.fog ), void 0 !== e.flatShading && ( r.flatShading = e.flatShading ), void 0 !== e.blending && ( r.blending = e.blending ), void 0 !== e.combine && ( r.combine = e.combine ), void 0 !== e.side && ( r.side = e.side ), void 0 !== e.opacity && ( r.opacity = e.opacity ), void 0 !== e.transparent && ( r.transparent = e.transparent ), void 0 !== e.alphaTest && ( r.alphaTest = e.alphaTest ), void 0 !== e.depthTest && ( r.depthTest = e.depthTest ), void 0 !== e.depthWrite && ( r.depthWrite = e.depthWrite ), void 0 !== e.colorWrite && ( r.colorWrite = e.colorWrite ), void 0 !== e.stencilWrite && ( r.stencilWrite = e.stencilWrite ), void 0 !== e.stencilWriteMask && ( r.stencilWriteMask = e.stencilWriteMask ), void 0 !== e.stencilFunc && ( r.stencilFunc = e.stencilFunc ), void 0 !== e.stencilRef && ( r.stencilRef = e.stencilRef ), void 0 !== e.stencilFuncMask && ( r.stencilFuncMask = e.stencilFuncMask ), void 0 !== e.stencilFail && ( r.stencilFail = e.stencilFail ), void 0 !== e.stencilZFail && ( r.stencilZFail = e.stencilZFail ), void 0 !== e.stencilZPass && ( r.stencilZPass = e.stencilZPass ), void 0 !== e.wireframe && ( r.wireframe = e.wireframe ), void 0 !== e.wireframeLinewidth && ( r.wireframeLinewidth = e.wireframeLinewidth ), void 0 !== e.wireframeLinecap && ( r.wireframeLinecap = e.wireframeLinecap ), void 0 !== e.wireframeLinejoin && ( r.wireframeLinejoin = e.wireframeLinejoin ), void 0 !== e.rotation && ( r.rotation = e.rotation ), 1 !== e.linewidth && ( r.linewidth = e.linewidth ), void 0 !== e.dashSize && ( r.dashSize = e.dashSize ), void 0 !== e.gapSize && ( r.gapSize = e.gapSize ), void 0 !== e.scale && ( r.scale = e.scale ), void 0 !== e.polygonOffset && ( r.polygonOffset = e.polygonOffset ), void 0 !== e.polygonOffsetFactor && ( r.polygonOffsetFactor = e.polygonOffsetFactor ), void 0 !== e.polygonOffsetUnits && ( r.polygonOffsetUnits = e.polygonOffsetUnits ), void 0 !== e.skinning && ( r.skinning = e.skinning ), void 0 !== e.morphTargets && ( r.morphTargets = e.morphTargets ), void 0 !== e.morphNormals && ( r.morphNormals = e.morphNormals ), void 0 !== e.dithering && ( r.dithering = e.dithering ), void 0 !== e.vertexTangents && ( r.vertexTangents = e.vertexTangents ), void 0 !== e.visible && ( r.visible = e.visible ), void 0 !== e.toneMapped && ( r.toneMapped = e.toneMapped ), void 0 !== e.userData && ( r.userData = e.userData ), void 0 !== e.vertexColors && ( 'number' == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors ), void 0 !== e.uniforms ) for ( const t in e.uniforms ) {

		const i = e.uniforms[ t ]; switch ( r.uniforms[ t ] = {}, i.type ) {

			case 't':r.uniforms[ t ].value = n( i.value ); break; case 'c':r.uniforms[ t ].value = ( new Color() ).setHex( i.value ); break; case 'v2':r.uniforms[ t ].value = ( new Vector2() ).fromArray( i.value ); break; case 'v3':r.uniforms[ t ].value = ( new Vector3() ).fromArray( i.value ); break; case 'v4':r.uniforms[ t ].value = ( new Vector4() ).fromArray( i.value ); break; case 'm3':r.uniforms[ t ].value = ( new Matrix3() ).fromArray( i.value ); break; case 'm4':r.uniforms[ t ].value = ( new Matrix4() ).fromArray( i.value ); break; default:r.uniforms[ t ].value = i.value;

		}

	}

	if ( void 0 !== e.defines && ( r.defines = e.defines ), void 0 !== e.vertexShader && ( r.vertexShader = e.vertexShader ), void 0 !== e.fragmentShader && ( r.fragmentShader = e.fragmentShader ), void 0 !== e.extensions ) for ( const t in e.extensions )r.extensions[ t ] = e.extensions[ t ]; if ( void 0 !== e.shading && ( r.flatShading = 1 === e.shading ), void 0 !== e.size && ( r.size = e.size ), void 0 !== e.sizeAttenuation && ( r.sizeAttenuation = e.sizeAttenuation ), void 0 !== e.map && ( r.map = n( e.map ) ), void 0 !== e.matcap && ( r.matcap = n( e.matcap ) ), void 0 !== e.alphaMap && ( r.alphaMap = n( e.alphaMap ) ), void 0 !== e.bumpMap && ( r.bumpMap = n( e.bumpMap ) ), void 0 !== e.bumpScale && ( r.bumpScale = e.bumpScale ), void 0 !== e.normalMap && ( r.normalMap = n( e.normalMap ) ), void 0 !== e.normalMapType && ( r.normalMapType = e.normalMapType ), void 0 !== e.normalScale ) {

		let t = e.normalScale; ! 1 === Array.isArray( t ) && ( t = [ t, t ] ), r.normalScale = ( new Vector2() ).fromArray( t );

	}

	return void 0 !== e.displacementMap && ( r.displacementMap = n( e.displacementMap ) ), void 0 !== e.displacementScale && ( r.displacementScale = e.displacementScale ), void 0 !== e.displacementBias && ( r.displacementBias = e.displacementBias ), void 0 !== e.roughnessMap && ( r.roughnessMap = n( e.roughnessMap ) ), void 0 !== e.metalnessMap && ( r.metalnessMap = n( e.metalnessMap ) ), void 0 !== e.emissiveMap && ( r.emissiveMap = n( e.emissiveMap ) ), void 0 !== e.emissiveIntensity && ( r.emissiveIntensity = e.emissiveIntensity ), void 0 !== e.specularMap && ( r.specularMap = n( e.specularMap ) ), void 0 !== e.envMap && ( r.envMap = n( e.envMap ) ), void 0 !== e.envMapIntensity && ( r.envMapIntensity = e.envMapIntensity ), void 0 !== e.reflectivity && ( r.reflectivity = e.reflectivity ), void 0 !== e.refractionRatio && ( r.refractionRatio = e.refractionRatio ), void 0 !== e.lightMap && ( r.lightMap = n( e.lightMap ) ), void 0 !== e.lightMapIntensity && ( r.lightMapIntensity = e.lightMapIntensity ), void 0 !== e.aoMap && ( r.aoMap = n( e.aoMap ) ), void 0 !== e.aoMapIntensity && ( r.aoMapIntensity = e.aoMapIntensity ), void 0 !== e.gradientMap && ( r.gradientMap = n( e.gradientMap ) ), void 0 !== e.clearcoatMap && ( r.clearcoatMap = n( e.clearcoatMap ) ), void 0 !== e.clearcoatRoughnessMap && ( r.clearcoatRoughnessMap = n( e.clearcoatRoughnessMap ) ), void 0 !== e.clearcoatNormalMap && ( r.clearcoatNormalMap = n( e.clearcoatNormalMap ) ), void 0 !== e.clearcoatNormalScale && ( r.clearcoatNormalScale = ( new Vector2() ).fromArray( e.clearcoatNormalScale ) ), void 0 !== e.transmission && ( r.transmission = e.transmission ), void 0 !== e.transmissionMap && ( r.transmissionMap = n( e.transmissionMap ) ), r;

}, setTextures: function ( e ) {

	return this.textures = e, this;

} } ); const LoaderUtils = { decodeText: function ( e ) {

	if ( 'undefined' != typeof TextDecoder ) return ( new TextDecoder() ).decode( e ); let t = ''; for ( let n = 0, r = e.length; n < r; n ++ )t += String.fromCharCode( e[ n ] ); try {

		return decodeURIComponent( escape( t ) );

	} catch ( e ) {

		return t;

	}

}, extractUrlBase: function ( e ) {

	const t = e.lastIndexOf( '/' ); return - 1 === t ? './' : e.substr( 0, t + 1 );

} }; function InstancedBufferGeometry() {

	BufferGeometry.call( this ), this.type = 'InstancedBufferGeometry', this.instanceCount = 1 / 0;

}

function InstancedBufferAttribute( e, t, n, r ) {

	'number' == typeof n && ( r = n, n = ! 1, console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' ) ), BufferAttribute.call( this, e, t, n ), this.meshPerAttribute = r || 1;

}

function BufferGeometryLoader( e ) {

	Loader.call( this, e );

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), { constructor: InstancedBufferGeometry, isInstancedBufferGeometry: ! 0, copy: function ( e ) {

	return BufferGeometry.prototype.copy.call( this, e ), this.instanceCount = e.instanceCount, this;

}, clone: function () {

	return ( new this.constructor() ).copy( this );

}, toJSON: function () {

	const e = BufferGeometry.prototype.toJSON.call( this ); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = ! 0, e;

} } ), InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), { constructor: InstancedBufferAttribute, isInstancedBufferAttribute: ! 0, copy: function ( e ) {

	return BufferAttribute.prototype.copy.call( this, e ), this.meshPerAttribute = e.meshPerAttribute, this;

}, toJSON: function () {

	const e = BufferAttribute.prototype.toJSON.call( this ); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = ! 0, e;

} } ), BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: BufferGeometryLoader, load: function ( e, t, n, r ) {

	const i = this, o = new FileLoader( i.manager ); o.setPath( i.path ), o.setRequestHeader( i.requestHeader ), o.setWithCredentials( i.withCredentials ), o.load( e, function ( n ) {

		try {

			t( i.parse( JSON.parse( n ) ) );

		} catch ( t ) {

			r ? r( t ) : console.error( t ), i.manager.itemError( e );

		}

	}, n, r );

}, parse: function ( e ) {

	const t = {}, n = {}; function r( e, r ) {

		if ( void 0 !== t[ r ] ) return t[ r ]; const i = e.interleavedBuffers[ r ], o = function ( e, t ) {

				if ( void 0 !== n[ t ] ) return n[ t ]; const r = e.arrayBuffers[ t ], i = new Uint32Array( r ).buffer; return n[ t ] = i, i;

			}( e, i.buffer ), a = new InterleavedBuffer( getTypedArray( i.type, o ), i.stride ); return a.uuid = i.uuid, t[ r ] = a, a;

	}

	const i = e.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry(), o = e.data.index; if ( void 0 !== o ) {

		const e = getTypedArray( o.type, o.array ); i.setIndex( new BufferAttribute( e, 1 ) );

	}

	const a = e.data.attributes; for ( const t in a ) {

		const n = a[ t ]; let o; if ( n.isInterleavedBufferAttribute ) {

			o = new InterleavedBufferAttribute( r( e.data, n.data ), n.itemSize, n.offset, n.normalized );

		} else {

			const e = getTypedArray( n.type, n.array ); o = new ( n.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute )( e, n.itemSize, n.normalized );

		}

		void 0 !== n.name && ( o.name = n.name ), i.setAttribute( t, o );

	}

	const s = e.data.morphAttributes; if ( s ) for ( const t in s ) {

		const n = s[ t ], o = []; for ( let t = 0, i = n.length; t < i; t ++ ) {

			const i = n[ t ]; let a; if ( i.isInterleavedBufferAttribute ) {

				a = new InterleavedBufferAttribute( r( e.data, i.data ), i.itemSize, i.offset, i.normalized );

			} else {

				a = new BufferAttribute( getTypedArray( i.type, i.array ), i.itemSize, i.normalized );

			}

			void 0 !== i.name && ( a.name = i.name ), o.push( a );

		}

		i.morphAttributes[ t ] = o;

	}

	e.data.morphTargetsRelative && ( i.morphTargetsRelative = ! 0 ); const c = e.data.groups || e.data.drawcalls || e.data.offsets; if ( void 0 !== c ) for ( let e = 0, t = c.length; e !== t; ++ e ) {

		const t = c[ e ]; i.addGroup( t.start, t.count, t.materialIndex );

	}

	const l = e.data.boundingSphere; if ( void 0 !== l ) {

		const e = new Vector3(); void 0 !== l.center && e.fromArray( l.center ), i.boundingSphere = new Sphere( e, l.radius );

	}

	return e.name && ( i.name = e.name ), e.userData && ( i.userData = e.userData ), i;

} } ); class ObjectLoader extends Loader {

	constructor( e ) {

		super( e );

	}load( e, t, n, r ) {

		const i = this, o = '' === this.path ? LoaderUtils.extractUrlBase( e ) : this.path; this.resourcePath = this.resourcePath || o; const a = new FileLoader( this.manager ); a.setPath( this.path ), a.setRequestHeader( this.requestHeader ), a.setWithCredentials( this.withCredentials ), a.load( e, function ( n ) {

			let o = null; try {

				o = JSON.parse( n );

			} catch ( t ) {

				return void 0 !== r && r( t ), void console.error( "THREE:ObjectLoader: Can't parse " + e + '.', t.message );

			}

			const a = o.metadata; void 0 !== a && void 0 !== a.type && 'geometry' !== a.type.toLowerCase() ? i.parse( o, t ) : console.error( "THREE.ObjectLoader: Can't load " + e );

		}, n, r );

	}parse( e, t ) {

		const n = this.parseAnimations( e.animations ), r = this.parseShapes( e.shapes ), i = this.parseGeometries( e.geometries, r ), o = this.parseImages( e.images, function () {

				void 0 !== t && t( c );

			} ), a = this.parseTextures( e.textures, o ), s = this.parseMaterials( e.materials, a ), c = this.parseObject( e.object, i, s, n ), l = this.parseSkeletons( e.skeletons, c ); if ( this.bindSkeletons( c, l ), void 0 !== t ) {

			let e = ! 1; for ( const t in o ) if ( o[ t ] instanceof HTMLImageElement ) {

				e = ! 0; break;

			}

			! 1 === e && t( c );

		}

		return c;

	}parseShapes( e ) {

		const t = {}; if ( void 0 !== e ) for ( let n = 0, r = e.length; n < r; n ++ ) {

			const r = ( new Shape() ).fromJSON( e[ n ] ); t[ r.uuid ] = r;

		}

		return t;

	}parseSkeletons( e, t ) {

		const n = {}, r = {}; if ( t.traverse( function ( e ) {

			e.isBone && ( r[ e.uuid ] = e );

		} ), void 0 !== e ) for ( let t = 0, i = e.length; t < i; t ++ ) {

			const i = ( new Skeleton() ).fromJSON( e[ t ], r ); n[ i.uuid ] = i;

		}

		return n;

	}parseGeometries( e, t ) {

		const n = {}; let r; if ( void 0 !== e ) {

			const i = new BufferGeometryLoader(); for ( let o = 0, a = e.length; o < a; o ++ ) {

				let a; const s = e[ o ]; switch ( s.type ) {

					case 'PlaneGeometry':case 'PlaneBufferGeometry':a = new Geometries[ s.type ]( s.width, s.height, s.widthSegments, s.heightSegments ); break; case 'BoxGeometry':case 'BoxBufferGeometry':case 'CubeGeometry':a = new Geometries[ s.type ]( s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments ); break; case 'CircleGeometry':case 'CircleBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.segments, s.thetaStart, s.thetaLength ); break; case 'CylinderGeometry':case 'CylinderBufferGeometry':a = new Geometries[ s.type ]( s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength ); break; case 'ConeGeometry':case 'ConeBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength ); break; case 'SphereGeometry':case 'SphereBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength ); break; case 'DodecahedronGeometry':case 'DodecahedronBufferGeometry':case 'IcosahedronGeometry':case 'IcosahedronBufferGeometry':case 'OctahedronGeometry':case 'OctahedronBufferGeometry':case 'TetrahedronGeometry':case 'TetrahedronBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.detail ); break; case 'RingGeometry':case 'RingBufferGeometry':a = new Geometries[ s.type ]( s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength ); break; case 'TorusGeometry':case 'TorusBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc ); break; case 'TorusKnotGeometry':case 'TorusKnotBufferGeometry':a = new Geometries[ s.type ]( s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q ); break; case 'TubeGeometry':case 'TubeBufferGeometry':a = new Geometries[ s.type ]( ( new Curves[ s.path.type ]() ).fromJSON( s.path ), s.tubularSegments, s.radius, s.radialSegments, s.closed ); break; case 'LatheGeometry':case 'LatheBufferGeometry':a = new Geometries[ s.type ]( s.points, s.segments, s.phiStart, s.phiLength ); break; case 'PolyhedronGeometry':case 'PolyhedronBufferGeometry':a = new Geometries[ s.type ]( s.vertices, s.indices, s.radius, s.details ); break; case 'ShapeGeometry':case 'ShapeBufferGeometry':r = []; for ( let e = 0, n = s.shapes.length; e < n; e ++ ) {

						const n = t[ s.shapes[ e ] ]; r.push( n );

					}

						a = new Geometries[ s.type ]( r, s.curveSegments ); break; case 'ExtrudeGeometry':case 'ExtrudeBufferGeometry':r = []; for ( let e = 0, n = s.shapes.length; e < n; e ++ ) {

						const n = t[ s.shapes[ e ] ]; r.push( n );

					}

						const e = s.options.extrudePath; void 0 !== e && ( s.options.extrudePath = ( new Curves[ e.type ]() ).fromJSON( e ) ), a = new Geometries[ s.type ]( r, s.options ); break; case 'BufferGeometry':case 'InstancedBufferGeometry':a = i.parse( s ); break; case 'Geometry':console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' ); break; default:console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"' ); continue;

				}

				a.uuid = s.uuid, void 0 !== s.name && ( a.name = s.name ), ! 0 === a.isBufferGeometry && void 0 !== s.userData && ( a.userData = s.userData ), n[ s.uuid ] = a;

			}

		}

		return n;

	}parseMaterials( e, t ) {

		const n = {}, r = {}; if ( void 0 !== e ) {

			const i = new MaterialLoader(); i.setTextures( t ); for ( let t = 0, o = e.length; t < o; t ++ ) {

				const o = e[ t ]; if ( 'MultiMaterial' === o.type ) {

					const e = []; for ( let t = 0; t < o.materials.length; t ++ ) {

						const r = o.materials[ t ]; void 0 === n[ r.uuid ] && ( n[ r.uuid ] = i.parse( r ) ), e.push( n[ r.uuid ] );

					}

					r[ o.uuid ] = e;

				} else void 0 === n[ o.uuid ] && ( n[ o.uuid ] = i.parse( o ) ), r[ o.uuid ] = n[ o.uuid ];

			}

		}

		return r;

	}parseAnimations( e ) {

		const t = {}; if ( void 0 !== e ) for ( let n = 0; n < e.length; n ++ ) {

			const r = e[ n ], i = AnimationClip.parse( r ); t[ i.uuid ] = i;

		}

		return t;

	}parseImages( e, t ) {

		const n = this, r = {}; let i; function o( e ) {

			if ( 'string' == typeof e ) {

				const t = e, r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( t ) ? t : n.resourcePath + t; return t = r, n.manager.itemStart( t ), i.load( t, function () {

					n.manager.itemEnd( t );

				}, void 0, function () {

					n.manager.itemError( t ), n.manager.itemEnd( t );

				} );

			}

			return e.data ? { data: getTypedArray( e.type, e.data ), width: e.width, height: e.height } : null;

		}

		if ( void 0 !== e && e.length > 0 ) {

			const n = new LoadingManager( t ); ( i = new ImageLoader( n ) ).setCrossOrigin( this.crossOrigin ); for ( let t = 0, n = e.length; t < n; t ++ ) {

				const n = e[ t ], i = n.url; if ( Array.isArray( i ) ) {

					r[ n.uuid ] = []; for ( let e = 0, t = i.length; e < t; e ++ ) {

						const t = o( i[ e ] ); null !== t && ( t instanceof HTMLImageElement ? r[ n.uuid ].push( t ) : r[ n.uuid ].push( new DataTexture( t.data, t.width, t.height ) ) );

					}

				} else {

					const e = o( n.url ); null !== e && ( r[ n.uuid ] = e );

				}

			}

		}

		return r;

	}parseTextures( e, t ) {

		function n( e, t ) {

			return 'number' == typeof e ? e : ( console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', e ), t[ e ] );

		}

		const r = {}; if ( void 0 !== e ) for ( let i = 0, o = e.length; i < o; i ++ ) {

			const o = e[ i ]; let a; void 0 === o.image && console.warn( 'THREE.ObjectLoader: No "image" specified for', o.uuid ), void 0 === t[ o.image ] && console.warn( 'THREE.ObjectLoader: Undefined image', o.image ); const s = t[ o.image ]; Array.isArray( s ) ? ( a = new CubeTexture( s ), 6 === s.length && ( a.needsUpdate = ! 0 ) ) : ( a = s && s.data ? new DataTexture( s.data, s.width, s.height ) : new Texture( s ), s && ( a.needsUpdate = ! 0 ) ), a.uuid = o.uuid, void 0 !== o.name && ( a.name = o.name ), void 0 !== o.mapping && ( a.mapping = n( o.mapping, TEXTURE_MAPPING ) ), void 0 !== o.offset && a.offset.fromArray( o.offset ), void 0 !== o.repeat && a.repeat.fromArray( o.repeat ), void 0 !== o.center && a.center.fromArray( o.center ), void 0 !== o.rotation && ( a.rotation = o.rotation ), void 0 !== o.wrap && ( a.wrapS = n( o.wrap[ 0 ], TEXTURE_WRAPPING ), a.wrapT = n( o.wrap[ 1 ], TEXTURE_WRAPPING ) ), void 0 !== o.format && ( a.format = o.format ), void 0 !== o.type && ( a.type = o.type ), void 0 !== o.encoding && ( a.encoding = o.encoding ), void 0 !== o.minFilter && ( a.minFilter = n( o.minFilter, TEXTURE_FILTER ) ), void 0 !== o.magFilter && ( a.magFilter = n( o.magFilter, TEXTURE_FILTER ) ), void 0 !== o.anisotropy && ( a.anisotropy = o.anisotropy ), void 0 !== o.flipY && ( a.flipY = o.flipY ), void 0 !== o.premultiplyAlpha && ( a.premultiplyAlpha = o.premultiplyAlpha ), void 0 !== o.unpackAlignment && ( a.unpackAlignment = o.unpackAlignment ), r[ o.uuid ] = a;

		}

		return r;

	}parseObject( e, t, n, r ) {

		let i, o, a; function s( e ) {

			return void 0 === t[ e ] && console.warn( 'THREE.ObjectLoader: Undefined geometry', e ), t[ e ];

		}

		function c( e ) {

			if ( void 0 !== e ) {

				if ( Array.isArray( e ) ) {

					const t = []; for ( let r = 0, i = e.length; r < i; r ++ ) {

						const i = e[ r ]; void 0 === n[ i ] && console.warn( 'THREE.ObjectLoader: Undefined material', i ), t.push( n[ i ] );

					}

					return t;

				}

				return void 0 === n[ e ] && console.warn( 'THREE.ObjectLoader: Undefined material', e ), n[ e ];

			}

		}

		switch ( e.type ) {

			case 'Scene':i = new Scene(), void 0 !== e.background && Number.isInteger( e.background ) && ( i.background = new Color( e.background ) ), void 0 !== e.fog && ( 'Fog' === e.fog.type ? i.fog = new Fog( e.fog.color, e.fog.near, e.fog.far ) : 'FogExp2' === e.fog.type && ( i.fog = new FogExp2( e.fog.color, e.fog.density ) ) ); break; case 'PerspectiveCamera':i = new PerspectiveCamera( e.fov, e.aspect, e.near, e.far ), void 0 !== e.focus && ( i.focus = e.focus ), void 0 !== e.zoom && ( i.zoom = e.zoom ), void 0 !== e.filmGauge && ( i.filmGauge = e.filmGauge ), void 0 !== e.filmOffset && ( i.filmOffset = e.filmOffset ), void 0 !== e.view && ( i.view = Object.assign( {}, e.view ) ); break; case 'OrthographicCamera':i = new OrthographicCamera( e.left, e.right, e.top, e.bottom, e.near, e.far ), void 0 !== e.zoom && ( i.zoom = e.zoom ), void 0 !== e.view && ( i.view = Object.assign( {}, e.view ) ); break; case 'AmbientLight':i = new AmbientLight( e.color, e.intensity ); break; case 'DirectionalLight':i = new DirectionalLight( e.color, e.intensity ); break; case 'PointLight':i = new PointLight( e.color, e.intensity, e.distance, e.decay ); break; case 'RectAreaLight':i = new RectAreaLight( e.color, e.intensity, e.width, e.height ); break; case 'SpotLight':i = new SpotLight( e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay ); break; case 'HemisphereLight':i = new HemisphereLight( e.color, e.groundColor, e.intensity ); break; case 'LightProbe':i = ( new LightProbe() ).fromJSON( e ); break; case 'SkinnedMesh':i = new SkinnedMesh( o = s( e.geometry ), a = c( e.material ) ), void 0 !== e.bindMode && ( i.bindMode = e.bindMode ), void 0 !== e.bindMatrix && i.bindMatrix.fromArray( e.bindMatrix ), void 0 !== e.skeleton && ( i.skeleton = e.skeleton ); break; case 'Mesh':i = new Mesh( o = s( e.geometry ), a = c( e.material ) ); break; case 'InstancedMesh':o = s( e.geometry ), a = c( e.material ); const t = e.count, n = e.instanceMatrix; ( i = new InstancedMesh( o, a, t ) ).instanceMatrix = new BufferAttribute( new Float32Array( n.array ), 16 ); break; case 'LOD':i = new LOD(); break; case 'Line':i = new Line( s( e.geometry ), c( e.material ) ); break; case 'LineLoop':i = new LineLoop( s( e.geometry ), c( e.material ) ); break; case 'LineSegments':i = new LineSegments( s( e.geometry ), c( e.material ) ); break; case 'PointCloud':case 'Points':i = new Points( s( e.geometry ), c( e.material ) ); break; case 'Sprite':i = new Sprite( c( e.material ) ); break; case 'Group':i = new Group(); break; case 'Bone':i = new Bone(); break; default:i = new Object3D();

		}

		if ( i.uuid = e.uuid, void 0 !== e.name && ( i.name = e.name ), void 0 !== e.matrix ? ( i.matrix.fromArray( e.matrix ), void 0 !== e.matrixAutoUpdate && ( i.matrixAutoUpdate = e.matrixAutoUpdate ), i.matrixAutoUpdate && i.matrix.decompose( i.position, i.quaternion, i.scale ) ) : ( void 0 !== e.position && i.position.fromArray( e.position ), void 0 !== e.rotation && i.rotation.fromArray( e.rotation ), void 0 !== e.quaternion && i.quaternion.fromArray( e.quaternion ), void 0 !== e.scale && i.scale.fromArray( e.scale ) ), void 0 !== e.castShadow && ( i.castShadow = e.castShadow ), void 0 !== e.receiveShadow && ( i.receiveShadow = e.receiveShadow ), e.shadow && ( void 0 !== e.shadow.bias && ( i.shadow.bias = e.shadow.bias ), void 0 !== e.shadow.normalBias && ( i.shadow.normalBias = e.shadow.normalBias ), void 0 !== e.shadow.radius && ( i.shadow.radius = e.shadow.radius ), void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray( e.shadow.mapSize ), void 0 !== e.shadow.camera && ( i.shadow.camera = this.parseObject( e.shadow.camera ) ) ), void 0 !== e.visible && ( i.visible = e.visible ), void 0 !== e.frustumCulled && ( i.frustumCulled = e.frustumCulled ), void 0 !== e.renderOrder && ( i.renderOrder = e.renderOrder ), void 0 !== e.userData && ( i.userData = e.userData ), void 0 !== e.layers && ( i.layers.mask = e.layers ), void 0 !== e.children ) {

			const o = e.children; for ( let e = 0; e < o.length; e ++ )i.add( this.parseObject( o[ e ], t, n, r ) );

		}

		if ( void 0 !== e.animations ) {

			const t = e.animations; for ( let e = 0; e < t.length; e ++ ) {

				const n = t[ e ]; i.animations.push( r[ n ] );

			}

		}

		if ( 'LOD' === e.type ) {

			void 0 !== e.autoUpdate && ( i.autoUpdate = e.autoUpdate ); const t = e.levels; for ( let e = 0; e < t.length; e ++ ) {

				const n = t[ e ], r = i.getObjectByProperty( 'uuid', n.object ); void 0 !== r && i.addLevel( r, n.distance );

			}

		}

		return i;

	}bindSkeletons( e, t ) {

		0 !== Object.keys( t ).length && e.traverse( function ( e ) {

			if ( ! 0 === e.isSkinnedMesh && void 0 !== e.skeleton ) {

				const n = t[ e.skeleton ]; void 0 === n ? console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', e.skeleton ) : e.bind( n, e.bindMatrix );

			}

		} );

	}setTexturePath( e ) {

		return console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' ), this.setResourcePath( e );

	}

} const TEXTURE_MAPPING = { UVMapping: 300, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping }, TEXTURE_WRAPPING = { RepeatWrapping: RepeatWrapping, ClampToEdgeWrapping: ClampToEdgeWrapping, MirroredRepeatWrapping: MirroredRepeatWrapping }, TEXTURE_FILTER = { NearestFilter: NearestFilter, NearestMipmapNearestFilter: NearestMipmapNearestFilter, NearestMipmapLinearFilter: NearestMipmapLinearFilter, LinearFilter: LinearFilter, LinearMipmapNearestFilter: LinearMipmapNearestFilter, LinearMipmapLinearFilter: LinearMipmapLinearFilter }; function ImageBitmapLoader( e ) {

	'undefined' == typeof createImageBitmap && console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' ), 'undefined' == typeof fetch && console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' ), Loader.call( this, e ), this.options = { premultiplyAlpha: 'none' };

}

function ShapePath() {

	this.type = 'ShapePath', this.color = new Color(), this.subPaths = [], this.currentPath = null;

}

function Font( e ) {

	this.type = 'Font', this.data = e;

}

function createPaths( e, t, n ) {

	const r = Array.from ? Array.from( e ) : String( e ).split( '' ), i = t / n.resolution, o = ( n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness ) * i, a = []; let s = 0, c = 0; for ( let e = 0; e < r.length; e ++ ) {

		const t = r[ e ]; if ( '\n' === t )s = 0, c -= o; else {

			const e = createPath( t, i, s, c, n ); s += e.offsetX, a.push( e.path );

		}

	}

	return a;

}

function createPath( e, t, n, r, i ) {

	const o = i.glyphs[ e ] || i.glyphs[ '?' ]; if ( ! o ) return void console.error( 'THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + '.' ); const a = new ShapePath(); let s, c, l, h, u, d, p, m; if ( o.o ) {

		const e = o._cachedOutline || ( o._cachedOutline = o.o.split( ' ' ) ); for ( let i = 0, o = e.length; i < o; ) {

			switch ( e[ i ++ ] ) {

				case 'm':s = e[ i ++ ] * t + n, c = e[ i ++ ] * t + r, a.moveTo( s, c ); break; case 'l':s = e[ i ++ ] * t + n, c = e[ i ++ ] * t + r, a.lineTo( s, c ); break; case 'q':l = e[ i ++ ] * t + n, h = e[ i ++ ] * t + r, u = e[ i ++ ] * t + n, d = e[ i ++ ] * t + r, a.quadraticCurveTo( u, d, l, h ); break; case 'b':l = e[ i ++ ] * t + n, h = e[ i ++ ] * t + r, u = e[ i ++ ] * t + n, d = e[ i ++ ] * t + r, p = e[ i ++ ] * t + n, m = e[ i ++ ] * t + r, a.bezierCurveTo( u, d, p, m, l, h );

			}

		}

	}

	return { offsetX: o.ha * t, path: a };

}

function FontLoader( e ) {

	Loader.call( this, e );

}

let _context; ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: ImageBitmapLoader, isImageBitmapLoader: ! 0, setOptions: function ( e ) {

	return this.options = e, this;

}, load: function ( e, t, n, r ) {

	void 0 === e && ( e = '' ), void 0 !== this.path && ( e = this.path + e ), e = this.manager.resolveURL( e ); const i = this, o = Cache.get( e ); if ( void 0 !== o ) return i.manager.itemStart( e ), setTimeout( function () {

		t && t( o ), i.manager.itemEnd( e );

	}, 0 ), o; const a = {}; a.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include', fetch( e, a ).then( function ( e ) {

		return e.blob();

	} ).then( function ( e ) {

		return createImageBitmap( e, i.options );

	} ).then( function ( n ) {

		Cache.add( e, n ), t && t( n ), i.manager.itemEnd( e );

	} ).catch( function ( t ) {

		r && r( t ), i.manager.itemError( e ), i.manager.itemEnd( e );

	} ), i.manager.itemStart( e );

} } ), Object.assign( ShapePath.prototype, { moveTo: function ( e, t ) {

	return this.currentPath = new Path(), this.subPaths.push( this.currentPath ), this.currentPath.moveTo( e, t ), this;

}, lineTo: function ( e, t ) {

	return this.currentPath.lineTo( e, t ), this;

}, quadraticCurveTo: function ( e, t, n, r ) {

	return this.currentPath.quadraticCurveTo( e, t, n, r ), this;

}, bezierCurveTo: function ( e, t, n, r, i, o ) {

	return this.currentPath.bezierCurveTo( e, t, n, r, i, o ), this;

}, splineThru: function ( e ) {

	return this.currentPath.splineThru( e ), this;

}, toShapes: function ( e, t ) {

	function n( e ) {

		const t = []; for ( let n = 0, r = e.length; n < r; n ++ ) {

			const r = e[ n ], i = new Shape(); i.curves = r.curves, t.push( i );

		}

		return t;

	}

	function r( e, t ) {

		const n = t.length; let r = ! 1; for ( let i = n - 1, o = 0; o < n; i = o ++ ) {

			let n = t[ i ], a = t[ o ], s = a.x - n.x, c = a.y - n.y; if ( Math.abs( c ) > Number.EPSILON ) {

				if ( c < 0 && ( n = t[ o ], s = - s, a = t[ i ], c = - c ), e.y < n.y || e.y > a.y ) continue; if ( e.y === n.y ) {

					if ( e.x === n.x ) return ! 0;

				} else {

					const t = c * ( e.x - n.x ) - s * ( e.y - n.y ); if ( 0 === t ) return ! 0; if ( t < 0 ) continue; r = ! r;

				}

			} else {

				if ( e.y !== n.y ) continue; if ( a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x ) return ! 0;

			}

		}

		return r;

	}

	const i = ShapeUtils.isClockWise, o = this.subPaths; if ( 0 === o.length ) return []; if ( ! 0 === t ) return n( o ); let a, s, c; const l = []; if ( 1 === o.length ) return s = o[ 0 ], ( c = new Shape() ).curves = s.curves, l.push( c ), l; let h = ! i( o[ 0 ].getPoints() ); h = e ? ! h : h; const u = [], d = []; let p, m, f = [], g = 0; d[ g ] = void 0, f[ g ] = []; for ( let t = 0, n = o.length; t < n; t ++ )a = i( p = ( s = o[ t ] ).getPoints() ), ( a = e ? ! a : a ) ? ( ! h && d[ g ] && g ++, d[ g ] = { s: new Shape(), p: p }, d[ g ].s.curves = s.curves, h && g ++, f[ g ] = [] ) : f[ g ].push( { h: s, p: p[ 0 ] } ); if ( ! d[ 0 ] ) return n( o ); if ( d.length > 1 ) {

		let e = ! 1; const t = []; for ( let e = 0, t = d.length; e < t; e ++ )u[ e ] = []; for ( let n = 0, i = d.length; n < i; n ++ ) {

			const i = f[ n ]; for ( let o = 0; o < i.length; o ++ ) {

				const a = i[ o ]; let s = ! 0; for ( let i = 0; i < d.length; i ++ )r( a.p, d[ i ].p ) && ( n !== i && t.push( { froms: n, tos: i, hole: o } ), s ? ( s = ! 1, u[ i ].push( a ) ) : e = ! 0 ); s && u[ n ].push( a );

			}

		}

		t.length > 0 && ( e || ( f = u ) );

	}

	for ( let e = 0, t = d.length; e < t; e ++ ) {

		c = d[ e ].s, l.push( c ); for ( let t = 0, n = ( m = f[ e ] ).length; t < n; t ++ )c.holes.push( m[ t ].h );

	}

	return l;

} } ), Object.assign( Font.prototype, { isFont: ! 0, generateShapes: function ( e, t = 100 ) {

	const n = [], r = createPaths( e, t, this.data ); for ( let e = 0, t = r.length; e < t; e ++ )Array.prototype.push.apply( n, r[ e ].toShapes() ); return n;

} } ), FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: FontLoader, load: function ( e, t, n, r ) {

	const i = this, o = new FileLoader( this.manager ); o.setPath( this.path ), o.setRequestHeader( this.requestHeader ), o.setWithCredentials( i.withCredentials ), o.load( e, function ( e ) {

		let n; try {

			n = JSON.parse( e );

		} catch ( t ) {

			console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' ), n = JSON.parse( e.substring( 65, e.length - 2 ) );

		}

		const r = i.parse( n ); t && t( r );

	}, n, r );

}, parse: function ( e ) {

	return new Font( e );

} } ); const AudioContext = { getContext: function () {

	return void 0 === _context && ( _context = new ( window.AudioContext || window.webkitAudioContext )() ), _context;

}, setContext: function ( e ) {

	_context = e;

} }; function AudioLoader( e ) {

	Loader.call( this, e );

}

function HemisphereLightProbe( e, t, n ) {

	LightProbe.call( this, void 0, n ); const r = ( new Color() ).set( e ), i = ( new Color() ).set( t ), o = new Vector3( r.r, r.g, r.b ), a = new Vector3( i.r, i.g, i.b ), s = Math.sqrt( Math.PI ), c = s * Math.sqrt( .75 ); this.sh.coefficients[ 0 ].copy( o ).add( a ).multiplyScalar( s ), this.sh.coefficients[ 1 ].copy( o ).sub( a ).multiplyScalar( c );

}

function AmbientLightProbe( e, t ) {

	LightProbe.call( this, void 0, t ); const n = ( new Color() ).set( e ); this.sh.coefficients[ 0 ].set( n.r, n.g, n.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

}

AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), { constructor: AudioLoader, load: function ( e, t, n, r ) {

	const i = this, o = new FileLoader( i.manager ); o.setResponseType( 'arraybuffer' ), o.setPath( i.path ), o.setRequestHeader( i.requestHeader ), o.setWithCredentials( i.withCredentials ), o.load( e, function ( n ) {

		try {

			const o = n.slice( 0 ); AudioContext.getContext().decodeAudioData( o, function ( e ) {

				t( e );

			} );

		} catch ( t ) {

			r ? r( t ) : console.error( t ), i.manager.itemError( e );

		}

	}, n, r );

} } ), HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), { constructor: HemisphereLightProbe, isHemisphereLightProbe: ! 0, copy: function ( e ) {

	return LightProbe.prototype.copy.call( this, e ), this;

}, toJSON: function ( e ) {

	return LightProbe.prototype.toJSON.call( this, e );

} } ), AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), { constructor: AmbientLightProbe, isAmbientLightProbe: ! 0, copy: function ( e ) {

	return LightProbe.prototype.copy.call( this, e ), this;

}, toJSON: function ( e ) {

	return LightProbe.prototype.toJSON.call( this, e );

} } ); const _eyeRight = new Matrix4(), _eyeLeft = new Matrix4(); function StereoCamera() {

	this.type = 'StereoCamera', this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable( 1 ), this.cameraL.matrixAutoUpdate = ! 1, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable( 2 ), this.cameraR.matrixAutoUpdate = ! 1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };

}

Object.assign( StereoCamera.prototype, { update: function ( e ) {

	const t = this._cache; if ( t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep ) {

		t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; const n = e.projectionMatrix.clone(), r = t.eyeSep / 2, i = r * t.near / t.focus, o = t.near * Math.tan( MathUtils.DEG2RAD * t.fov * .5 ) / t.zoom; let a, s; _eyeLeft.elements[ 12 ] = - r, _eyeRight.elements[ 12 ] = r, a = - o * t.aspect + i, s = o * t.aspect + i, n.elements[ 0 ] = 2 * t.near / ( s - a ), n.elements[ 8 ] = ( s + a ) / ( s - a ), this.cameraL.projectionMatrix.copy( n ), a = - o * t.aspect - i, s = o * t.aspect - i, n.elements[ 0 ] = 2 * t.near / ( s - a ), n.elements[ 8 ] = ( s + a ) / ( s - a ), this.cameraR.projectionMatrix.copy( n );

	}

	this.cameraL.matrixWorld.copy( e.matrixWorld ).multiply( _eyeLeft ), this.cameraR.matrixWorld.copy( e.matrixWorld ).multiply( _eyeRight );

} } ); class Clock {

	constructor( e ) {

		this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = ! 1;

	}start() {

		this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = ! 0;

	}stop() {

		this.getElapsedTime(), this.running = ! 1, this.autoStart = ! 1;

	}getElapsedTime() {

		return this.getDelta(), this.elapsedTime;

	}getDelta() {

		let e = 0; if ( this.autoStart && ! this.running ) return this.start(), 0; if ( this.running ) {

			const t = now(); e = ( t - this.oldTime ) / 1e3, this.oldTime = t, this.elapsedTime += e;

		}

		return e;

	}

} function now() {

	return ( 'undefined' == typeof performance ? Date : performance ).now();

}

const _position$2 = new Vector3(), _quaternion$3 = new Quaternion(), _scale$1 = new Vector3(), _orientation = new Vector3(); class AudioListener extends Object3D {

	constructor() {

		super(), this.type = 'AudioListener', this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect( this.context.destination ), this.filter = null, this.timeDelta = 0, this._clock = new Clock();

	}getInput() {

		return this.gain;

	}removeFilter() {

		return null !== this.filter && ( this.gain.disconnect( this.filter ), this.filter.disconnect( this.context.destination ), this.gain.connect( this.context.destination ), this.filter = null ), this;

	}getFilter() {

		return this.filter;

	}setFilter( e ) {

		return null !== this.filter ? ( this.gain.disconnect( this.filter ), this.filter.disconnect( this.context.destination ) ) : this.gain.disconnect( this.context.destination ), this.filter = e, this.gain.connect( this.filter ), this.filter.connect( this.context.destination ), this;

	}getMasterVolume() {

		return this.gain.gain.value;

	}setMasterVolume( e ) {

		return this.gain.gain.setTargetAtTime( e, this.context.currentTime, .01 ), this;

	}updateMatrixWorld( e ) {

		super.updateMatrixWorld( e ); const t = this.context.listener, n = this.up; if ( this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 ), _orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 ), t.positionX ) {

			const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime( _position$2.x, e ), t.positionY.linearRampToValueAtTime( _position$2.y, e ), t.positionZ.linearRampToValueAtTime( _position$2.z, e ), t.forwardX.linearRampToValueAtTime( _orientation.x, e ), t.forwardY.linearRampToValueAtTime( _orientation.y, e ), t.forwardZ.linearRampToValueAtTime( _orientation.z, e ), t.upX.linearRampToValueAtTime( n.x, e ), t.upY.linearRampToValueAtTime( n.y, e ), t.upZ.linearRampToValueAtTime( n.z, e );

		} else t.setPosition( _position$2.x, _position$2.y, _position$2.z ), t.setOrientation( _orientation.x, _orientation.y, _orientation.z, n.x, n.y, n.z );

	}

} class Audio extends Object3D {

	constructor( e ) {

		super(), this.type = 'Audio', this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect( e.getInput() ), this.autoplay = ! 1, this.buffer = null, this.detune = 0, this.loop = ! 1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = ! 1, this.hasPlaybackControl = ! 0, this.source = null, this.sourceType = 'empty', this._startedAt = 0, this._progress = 0, this._connected = ! 1, this.filters = [];

	}getOutput() {

		return this.gain;

	}setNodeSource( e ) {

		return this.hasPlaybackControl = ! 1, this.sourceType = 'audioNode', this.source = e, this.connect(), this;

	}setMediaElementSource( e ) {

		return this.hasPlaybackControl = ! 1, this.sourceType = 'mediaNode', this.source = this.context.createMediaElementSource( e ), this.connect(), this;

	}setMediaStreamSource( e ) {

		return this.hasPlaybackControl = ! 1, this.sourceType = 'mediaStreamNode', this.source = this.context.createMediaStreamSource( e ), this.connect(), this;

	}setBuffer( e ) {

		return this.buffer = e, this.sourceType = 'buffer', this.autoplay && this.play(), this;

	}play( e = 0 ) {

		if ( ! 0 === this.isPlaying ) return void console.warn( 'THREE.Audio: Audio is already playing.' ); if ( ! 1 === this.hasPlaybackControl ) return void console.warn( 'THREE.Audio: this Audio has no playback control.' ); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind( this ), t.start( this._startedAt, this._progress + this.offset, this.duration ), this.isPlaying = ! 0, this.source = t, this.setDetune( this.detune ), this.setPlaybackRate( this.playbackRate ), this.connect();

	}pause() {

		if ( ! 1 !== this.hasPlaybackControl ) return ! 0 === this.isPlaying && ( this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate, ! 0 === this.loop && ( this._progress = this._progress % ( this.duration || this.buffer.duration ) ), this.source.stop(), this.source.onended = null, this.isPlaying = ! 1 ), this; console.warn( 'THREE.Audio: this Audio has no playback control.' );

	}stop() {

		if ( ! 1 !== this.hasPlaybackControl ) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = ! 1, this; console.warn( 'THREE.Audio: this Audio has no playback control.' );

	}connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] ); for ( let e = 1, t = this.filters.length; e < t; e ++ ) this.filters[ e - 1 ].connect( this.filters[ e ] ); this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else this.source.connect( this.getOutput() ); return this._connected = ! 0, this;

	}disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] ); for ( let e = 1, t = this.filters.length; e < t; e ++ ) this.filters[ e - 1 ].disconnect( this.filters[ e ] ); this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else this.source.disconnect( this.getOutput() ); return this._connected = ! 1, this;

	}getFilters() {

		return this.filters;

	}setFilters( e ) {

		return e || ( e = [] ), ! 0 === this._connected ? ( this.disconnect(), this.filters = e.slice(), this.connect() ) : this.filters = e.slice(), this;

	}setDetune( e ) {

		if ( this.detune = e, void 0 !== this.source.detune ) return ! 0 === this.isPlaying && this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, .01 ), this;

	}getDetune() {

		return this.detune;

	}getFilter() {

		return this.getFilters()[ 0 ];

	}setFilter( e ) {

		return this.setFilters( e ? [ e ] : [] );

	}setPlaybackRate( e ) {

		if ( ! 1 !== this.hasPlaybackControl ) return this.playbackRate = e, ! 0 === this.isPlaying && this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, .01 ), this; console.warn( 'THREE.Audio: this Audio has no playback control.' );

	}getPlaybackRate() {

		return this.playbackRate;

	}onEnded() {

		this.isPlaying = ! 1;

	}getLoop() {

		return ! 1 === this.hasPlaybackControl ? ( console.warn( 'THREE.Audio: this Audio has no playback control.' ), ! 1 ) : this.loop;

	}setLoop( e ) {

		if ( ! 1 !== this.hasPlaybackControl ) return this.loop = e, ! 0 === this.isPlaying && ( this.source.loop = this.loop ), this; console.warn( 'THREE.Audio: this Audio has no playback control.' );

	}setLoopStart( e ) {

		return this.loopStart = e, this;

	}setLoopEnd( e ) {

		return this.loopEnd = e, this;

	}getVolume() {

		return this.gain.gain.value;

	}setVolume( e ) {

		return this.gain.gain.setTargetAtTime( e, this.context.currentTime, .01 ), this;

	}

} const _position$3 = new Vector3(), _quaternion$4 = new Quaternion(), _scale$2 = new Vector3(), _orientation$1 = new Vector3(); class PositionalAudio extends Audio {

	constructor( e ) {

		super( e ), this.panner = this.context.createPanner(), this.panner.panningModel = 'HRTF', this.panner.connect( this.gain );

	}getOutput() {

		return this.panner;

	}getRefDistance() {

		return this.panner.refDistance;

	}setRefDistance( e ) {

		return this.panner.refDistance = e, this;

	}getRolloffFactor() {

		return this.panner.rolloffFactor;

	}setRolloffFactor( e ) {

		return this.panner.rolloffFactor = e, this;

	}getDistanceModel() {

		return this.panner.distanceModel;

	}setDistanceModel( e ) {

		return this.panner.distanceModel = e, this;

	}getMaxDistance() {

		return this.panner.maxDistance;

	}setMaxDistance( e ) {

		return this.panner.maxDistance = e, this;

	}setDirectionalCone( e, t, n ) {

		return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;

	}updateMatrixWorld( e ) {

		if ( super.updateMatrixWorld( e ), ! 0 === this.hasPlaybackControl && ! 1 === this.isPlaying ) return; this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 ), _orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 ); const t = this.panner; if ( t.positionX ) {

			const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime( _position$3.x, e ), t.positionY.linearRampToValueAtTime( _position$3.y, e ), t.positionZ.linearRampToValueAtTime( _position$3.z, e ), t.orientationX.linearRampToValueAtTime( _orientation$1.x, e ), t.orientationY.linearRampToValueAtTime( _orientation$1.y, e ), t.orientationZ.linearRampToValueAtTime( _orientation$1.z, e );

		} else t.setPosition( _position$3.x, _position$3.y, _position$3.z ), t.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

	}

} class AudioAnalyser {

	constructor( e, t = 2048 ) {

		this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array( this.analyser.frequencyBinCount ), e.getOutput().connect( this.analyser );

	}getFrequencyData() {

		return this.analyser.getByteFrequencyData( this.data ), this.data;

	}getAverageFrequency() {

		let e = 0; const t = this.getFrequencyData(); for ( let n = 0; n < t.length; n ++ )e += t[ n ]; return e / t.length;

	}

} function PropertyMixer( e, t, n ) {

	let r, i, o; switch ( this.binding = e, this.valueSize = n, t ) {

		case 'quaternion':r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array( 6 * n ), this._workIndex = 5; break; case 'string':case 'bool':r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array( 5 * n ); break; default:r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array( 5 * n );

	}

	this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, { accumulate: function ( e, t ) {

	const n = this.buffer, r = this.valueSize, i = e * r + r; let o = this.cumulativeWeight; if ( 0 === o ) {

		for ( let e = 0; e !== r; ++ e )n[ i + e ] = n[ e ]; o = t;

	} else {

		const e = t / ( o += t ); this._mixBufferRegion( n, i, 0, e, r );

	}

	this.cumulativeWeight = o;

}, accumulateAdditive: function ( e ) {

	const t = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive( t, r, 0, e, n ), this.cumulativeWeightAdditive += e;

}, apply: function ( e ) {

	const t = this.valueSize, n = this.buffer, r = e * t + t, i = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if ( this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1 ) {

		const e = t * this._origIndex; this._mixBufferRegion( n, r, e, 1 - i, t );

	}

	o > 0 && this._mixBufferRegionAdditive( n, r, this._addIndex * t, 1, t ); for ( let e = t, i = t + t; e !== i; ++ e ) if ( n[ e ] !== n[ e + t ] ) {

		a.setValue( n, r ); break;

	}

}, saveOriginalState: function () {

	const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex; e.getValue( t, r ); for ( let e = n, i = r; e !== i; ++ e )t[ e ] = t[ r + e % n ]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;

}, restoreOriginalState: function () {

	const e = 3 * this.valueSize; this.binding.setValue( this.buffer, e );

}, _setAdditiveIdentityNumeric: function () {

	const e = this._addIndex * this.valueSize, t = e + this.valueSize; for ( let n = e; n < t; n ++ ) this.buffer[ n ] = 0;

}, _setAdditiveIdentityQuaternion: function () {

	this._setAdditiveIdentityNumeric(), this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

}, _setAdditiveIdentityOther: function () {

	const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for ( let n = 0; n < this.valueSize; n ++ ) this.buffer[ t + n ] = this.buffer[ e + n ];

}, _select: function ( e, t, n, r, i ) {

	if ( r >= .5 ) for ( let r = 0; r !== i; ++ r )e[ t + r ] = e[ n + r ];

}, _slerp: function ( e, t, n, r ) {

	Quaternion.slerpFlat( e, t, e, t, e, n, r );

}, _slerpAdditive: function ( e, t, n, r, i ) {

	const o = this._workIndex * i; Quaternion.multiplyQuaternionsFlat( e, o, e, t, e, n ), Quaternion.slerpFlat( e, t, e, t, e, o, r );

}, _lerp: function ( e, t, n, r, i ) {

	const o = 1 - r; for ( let a = 0; a !== i; ++ a ) {

		const i = t + a; e[ i ] = e[ i ] * o + e[ n + a ] * r;

	}

}, _lerpAdditive: function ( e, t, n, r, i ) {

	for ( let o = 0; o !== i; ++ o ) {

		const i = t + o; e[ i ] = e[ i ] + e[ n + o ] * r;

	}

} } ); const _reservedRe = new RegExp( '[\\[\\]\\.:\\/]', 'g' ), _wordChar = '[^\\[\\]\\.:\\/]', _wordCharOrDot = '[^' + '\\[\\]\\.:\\/'.replace( '\\.', '' ) + ']', _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar ), _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot ), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar ), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar ), _trackRe = new RegExp( '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$' ), _supportedObjectNames = [ 'material', 'materials', 'bones' ]; function Composite( e, t, n ) {

	const r = n || PropertyBinding.parseTrackName( t ); this._targetGroup = e, this._bindings = e.subscribe_( t, r );

}

function PropertyBinding( e, t, n ) {

	this.path = t, this.parsedPath = n || PropertyBinding.parseTrackName( t ), this.node = PropertyBinding.findNode( e, this.parsedPath.nodeName ) || e, this.rootNode = e;

}

function AnimationObjectGroup() {

	this.uuid = MathUtils.generateUUID(), this._objects = Array.prototype.slice.call( arguments ), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for ( let t = 0, n = arguments.length; t !== n; ++ t )e[ arguments[ t ].uuid ] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() {

		return t._objects.length;

	}, get inUse() {

		return this.total - t.nCachedObjects_;

	} }, get bindingsPerObject() {

		return t._bindings.length;

	} };

}

Object.assign( Composite.prototype, { getValue: function ( e, t ) {

	this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[ n ]; void 0 !== r && r.getValue( e, t );

}, setValue: function ( e, t ) {

	const n = this._bindings; for ( let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++ r )n[ r ].setValue( e, t );

}, bind: function () {

	const e = this._bindings; for ( let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++ t )e[ t ].bind();

}, unbind: function () {

	const e = this._bindings; for ( let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++ t )e[ t ].unbind();

} } ), Object.assign( PropertyBinding, { Composite: Composite, create: function ( e, t, n ) {

	return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite( e, t, n ) : new PropertyBinding( e, t, n );

}, sanitizeNodeName: function ( e ) {

	return e.replace( /\s/g, '_' ).replace( _reservedRe, '' );

}, parseTrackName: function ( e ) {

	const t = _trackRe.exec( e ); if ( ! t ) throw new Error( 'PropertyBinding: Cannot parse trackName: ' + e ); const n = { nodeName: t[ 2 ], objectName: t[ 3 ], objectIndex: t[ 4 ], propertyName: t[ 5 ], propertyIndex: t[ 6 ] }, r = n.nodeName && n.nodeName.lastIndexOf( '.' ); if ( void 0 !== r && - 1 !== r ) {

		const e = n.nodeName.substring( r + 1 ); - 1 !== _supportedObjectNames.indexOf( e ) && ( n.nodeName = n.nodeName.substring( 0, r ), n.objectName = e );

	}

	if ( null === n.propertyName || 0 === n.propertyName.length ) throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + e ); return n;

}, findNode: function ( e, t ) {

	if ( ! t || '' === t || '.' === t || - 1 === t || t === e.name || t === e.uuid ) return e; if ( e.skeleton ) {

		const n = e.skeleton.getBoneByName( t ); if ( void 0 !== n ) return n;

	}

	if ( e.children ) {

		const n = function ( e ) {

				for ( let r = 0; r < e.length; r ++ ) {

					const i = e[ r ]; if ( i.name === t || i.uuid === t ) return i; const o = n( i.children ); if ( o ) return o;

				}

				return null;

			}, r = n( e.children ); if ( r ) return r;

	}

	return null;

} } ), Object.assign( PropertyBinding.prototype, { _getValue_unavailable: function () {}, _setValue_unavailable: function () {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [ function ( e, t ) {

	e[ t ] = this.node[ this.propertyName ];

}, function ( e, t ) {

	const n = this.resolvedProperty; for ( let r = 0, i = n.length; r !== i; ++ r )e[ t ++ ] = n[ r ];

}, function ( e, t ) {

	e[ t ] = this.resolvedProperty[ this.propertyIndex ];

}, function ( e, t ) {

	this.resolvedProperty.toArray( e, t );

} ], SetterByBindingTypeAndVersioning: [[ function ( e, t ) {

	this.targetObject[ this.propertyName ] = e[ t ];

}, function ( e, t ) {

	this.targetObject[ this.propertyName ] = e[ t ], this.targetObject.needsUpdate = ! 0;

}, function ( e, t ) {

	this.targetObject[ this.propertyName ] = e[ t ], this.targetObject.matrixWorldNeedsUpdate = ! 0;

} ], [ function ( e, t ) {

	const n = this.resolvedProperty; for ( let r = 0, i = n.length; r !== i; ++ r )n[ r ] = e[ t ++ ];

}, function ( e, t ) {

	const n = this.resolvedProperty; for ( let r = 0, i = n.length; r !== i; ++ r )n[ r ] = e[ t ++ ]; this.targetObject.needsUpdate = ! 0;

}, function ( e, t ) {

	const n = this.resolvedProperty; for ( let r = 0, i = n.length; r !== i; ++ r )n[ r ] = e[ t ++ ]; this.targetObject.matrixWorldNeedsUpdate = ! 0;

} ], [ function ( e, t ) {

	this.resolvedProperty[ this.propertyIndex ] = e[ t ];

}, function ( e, t ) {

	this.resolvedProperty[ this.propertyIndex ] = e[ t ], this.targetObject.needsUpdate = ! 0;

}, function ( e, t ) {

	this.resolvedProperty[ this.propertyIndex ] = e[ t ], this.targetObject.matrixWorldNeedsUpdate = ! 0;

} ], [ function ( e, t ) {

	this.resolvedProperty.fromArray( e, t );

}, function ( e, t ) {

	this.resolvedProperty.fromArray( e, t ), this.targetObject.needsUpdate = ! 0;

}, function ( e, t ) {

	this.resolvedProperty.fromArray( e, t ), this.targetObject.matrixWorldNeedsUpdate = ! 0;

} ]], getValue: function ( e, t ) {

	this.bind(), this.getValue( e, t );

}, setValue: function ( e, t ) {

	this.bind(), this.setValue( e, t );

}, bind: function () {

	let e = this.node; const t = this.parsedPath, n = t.objectName, r = t.propertyName; let i = t.propertyIndex; if ( e || ( e = PropertyBinding.findNode( this.rootNode, t.nodeName ) || this.rootNode, this.node = e ), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, ! e ) return void console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + " but it wasn't found." ); if ( n ) {

		let r = t.objectIndex; switch ( n ) {

			case 'materials':if ( ! e.material ) return void console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this ); if ( ! e.material.materials ) return void console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this ); e = e.material.materials; break; case 'bones':if ( ! e.skeleton ) return void console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this ); e = e.skeleton.bones; for ( let t = 0; t < e.length; t ++ ) if ( e[ t ].name === r ) {

				r = t; break;

			}

				break; default:if ( void 0 === e[ n ] ) return void console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this ); e = e[ n ];

		}

		if ( void 0 !== r ) {

			if ( void 0 === e[ r ] ) return void console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, e ); e = e[ r ];

		}

	}

	const o = e[ r ]; if ( void 0 === o ) {

		const n = t.nodeName; return void console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + n + '.' + r + " but it wasn't found.", e );

	}

	let a = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && ( a = this.Versioning.MatrixWorldNeedsUpdate ); let s = this.BindingType.Direct; if ( void 0 !== i ) {

		if ( 'morphTargetInfluences' === r ) {

			if ( ! e.geometry ) return void console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this ); if ( ! e.geometry.isBufferGeometry ) return void console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this ); if ( ! e.geometry.morphAttributes ) return void console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this ); void 0 !== e.morphTargetDictionary[ i ] && ( i = e.morphTargetDictionary[ i ] );

		}

		s = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i;

	} else void 0 !== o.fromArray && void 0 !== o.toArray ? ( s = this.BindingType.HasFromToArray, this.resolvedProperty = o ) : Array.isArray( o ) ? ( s = this.BindingType.EntireArray, this.resolvedProperty = o ) : this.propertyName = r; this.getValue = this.GetterByBindingType[ s ], this.setValue = this.SetterByBindingTypeAndVersioning[ s ][ a ];

}, unbind: function () {

	this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;

} } ), Object.assign( PropertyBinding.prototype, { _getValue_unbound: PropertyBinding.prototype.getValue, _setValue_unbound: PropertyBinding.prototype.setValue } ), Object.assign( AnimationObjectGroup.prototype, { isAnimationObjectGroup: ! 0, add: function () {

	const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, o = i.length; let a = void 0, s = e.length, c = this.nCachedObjects_; for ( let l = 0, h = arguments.length; l !== h; ++ l ) {

		const h = arguments[ l ], u = h.uuid; let d = t[ u ]; if ( void 0 === d ) {

			d = s ++, t[ u ] = d, e.push( h ); for ( let e = 0, t = o; e !== t; ++ e )i[ e ].push( new PropertyBinding( h, n[ e ], r[ e ] ) );

		} else if ( d < c ) {

			a = e[ d ]; const s = -- c, l = e[ s ]; t[ l.uuid ] = d, e[ d ] = l, t[ u ] = s, e[ s ] = h; for ( let e = 0, t = o; e !== t; ++ e ) {

				const t = i[ e ], o = t[ s ]; let a = t[ d ]; t[ d ] = o, void 0 === a && ( a = new PropertyBinding( h, n[ e ], r[ e ] ) ), t[ s ] = a;

			}

		} else e[ d ] !== a && console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

	}

	this.nCachedObjects_ = c;

}, remove: function () {

	const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_; for ( let o = 0, a = arguments.length; o !== a; ++ o ) {

		const a = arguments[ o ], s = a.uuid, c = t[ s ]; if ( void 0 !== c && c >= i ) {

			const o = i ++, l = e[ o ]; t[ l.uuid ] = c, e[ c ] = l, t[ s ] = o, e[ o ] = a; for ( let e = 0, t = r; e !== t; ++ e ) {

				const t = n[ e ], r = t[ o ], i = t[ c ]; t[ c ] = r, t[ o ] = i;

			}

		}

	}

	this.nCachedObjects_ = i;

}, uncache: function () {

	const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_, o = e.length; for ( let a = 0, s = arguments.length; a !== s; ++ a ) {

		const s = arguments[ a ].uuid, c = t[ s ]; if ( void 0 !== c ) if ( delete t[ s ], c < i ) {

			const a = -- i, s = e[ a ], l = -- o, h = e[ l ]; t[ s.uuid ] = c, e[ c ] = s, t[ h.uuid ] = a, e[ a ] = h, e.pop(); for ( let e = 0, t = r; e !== t; ++ e ) {

				const t = n[ e ], r = t[ a ], i = t[ l ]; t[ c ] = r, t[ a ] = i, t.pop();

			}

		} else {

			const i = -- o, a = e[ i ]; i > 0 && ( t[ a.uuid ] = c ), e[ c ] = a, e.pop(); for ( let e = 0, t = r; e !== t; ++ e ) {

				const t = n[ e ]; t[ c ] = t[ i ], t.pop();

			}

		}

	}

	this.nCachedObjects_ = i;

}, subscribe_: function ( e, t ) {

	const n = this._bindingsIndicesByPath; let r = n[ e ]; const i = this._bindings; if ( void 0 !== r ) return i[ r ]; const o = this._paths, a = this._parsedPaths, s = this._objects, c = s.length, l = this.nCachedObjects_, h = new Array( c ); r = i.length, n[ e ] = r, o.push( e ), a.push( t ), i.push( h ); for ( let n = l, r = s.length; n !== r; ++ n ) {

		const r = s[ n ]; h[ n ] = new PropertyBinding( r, e, t );

	}

	return h;

}, unsubscribe_: function ( e ) {

	const t = this._bindingsIndicesByPath, n = t[ e ]; if ( void 0 !== n ) {

		const r = this._paths, i = this._parsedPaths, o = this._bindings, a = o.length - 1, s = o[ a ]; t[ e[ a ] ] = n, o[ n ] = s, o.pop(), i[ n ] = i[ a ], i.pop(), r[ n ] = r[ a ], r.pop();

	}

} } ); class AnimationAction {

	constructor( e, t, n = null, r = t.blendMode ) {

		this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r; const i = t.tracks, o = i.length, a = new Array( o ), s = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for ( let e = 0; e !== o; ++ e ) {

			const t = i[ e ].createInterpolant( null ); a[ e ] = t, t.settings = s;

		}

		this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array( o ), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = - 1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = ! 1, this.enabled = ! 0, this.clampWhenFinished = ! 1, this.zeroSlopeAtStart = ! 0, this.zeroSlopeAtEnd = ! 0;

	}play() {

		return this._mixer._activateAction( this ), this;

	}stop() {

		return this._mixer._deactivateAction( this ), this.reset();

	}reset() {

		return this.paused = ! 1, this.enabled = ! 0, this.time = 0, this._loopCount = - 1, this._startTime = null, this.stopFading().stopWarping();

	}isRunning() {

		return this.enabled && ! this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction( this );

	}isScheduled() {

		return this._mixer._isActiveAction( this );

	}startAt( e ) {

		return this._startTime = e, this;

	}setLoop( e, t ) {

		return this.loop = e, this.repetitions = t, this;

	}setEffectiveWeight( e ) {

		return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();

	}getEffectiveWeight() {

		return this._effectiveWeight;

	}fadeIn( e ) {

		return this._scheduleFading( e, 0, 1 );

	}fadeOut( e ) {

		return this._scheduleFading( e, 1, 0 );

	}crossFadeFrom( e, t, n ) {

		if ( e.fadeOut( t ), this.fadeIn( t ), n ) {

			const n = this._clip.duration, r = e._clip.duration, i = r / n, o = n / r; e.warp( 1, i, t ), this.warp( o, 1, t );

		}

		return this;

	}crossFadeTo( e, t, n ) {

		return e.crossFadeFrom( this, t, n );

	}stopFading() {

		const e = this._weightInterpolant; return null !== e && ( this._weightInterpolant = null, this._mixer._takeBackControlInterpolant( e ) ), this;

	}setEffectiveTimeScale( e ) {

		return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();

	}getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}setDuration( e ) {

		return this.timeScale = this._clip.duration / e, this.stopWarping();

	}syncWith( e ) {

		return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();

	}halt( e ) {

		return this.warp( this._effectiveTimeScale, 0, e );

	}warp( e, t, n ) {

		const r = this._mixer, i = r.time, o = this.timeScale; let a = this._timeScaleInterpolant; null === a && ( a = r._lendControlInterpolant(), this._timeScaleInterpolant = a ); const s = a.parameterPositions, c = a.sampleValues; return s[ 0 ] = i, s[ 1 ] = i + n, c[ 0 ] = e / o, c[ 1 ] = t / o, this;

	}stopWarping() {

		const e = this._timeScaleInterpolant; return null !== e && ( this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant( e ) ), this;

	}getMixer() {

		return this._mixer;

	}getClip() {

		return this._clip;

	}getRoot() {

		return this._localRoot || this._mixer._root;

	}_update( e, t, n, r ) {

		if ( ! this.enabled ) return void this._updateWeight( e ); const i = this._startTime; if ( null !== i ) {

			const r = ( e - i ) * n; if ( r < 0 || 0 === n ) return; this._startTime = null, t = n * r;

		}

		t *= this._updateTimeScale( e ); const o = this._updateTime( t ), a = this._updateWeight( e ); if ( a > 0 ) {

			const e = this._interpolants, t = this._propertyBindings; switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:for ( let n = 0, r = e.length; n !== r; ++ n )e[ n ].evaluate( o ), t[ n ].accumulateAdditive( a ); break; case NormalAnimationBlendMode:default:for ( let n = 0, i = e.length; n !== i; ++ n )e[ n ].evaluate( o ), t[ n ].accumulate( r, a );

			}

		}

	}_updateWeight( e ) {

		let t = 0; if ( this.enabled ) {

			t = this.weight; const n = this._weightInterpolant; if ( null !== n ) {

				const r = n.evaluate( e )[ 0 ]; t *= r, e > n.parameterPositions[ 1 ] && ( this.stopFading(), 0 === r && ( this.enabled = ! 1 ) );

			}

		}

		return this._effectiveWeight = t, t;

	}_updateTimeScale( e ) {

		let t = 0; if ( ! this.paused ) {

			t = this.timeScale; const n = this._timeScaleInterpolant; if ( null !== n ) {

				t *= n.evaluate( e )[ 0 ], e > n.parameterPositions[ 1 ] && ( this.stopWarping(), 0 === t ? this.paused = ! 0 : this.timeScale = t );

			}

		}

		return this._effectiveTimeScale = t, t;

	}_updateTime( e ) {

		const t = this._clip.duration, n = this.loop; let r = this.time + e, i = this._loopCount; const o = n === LoopPingPong; if ( 0 === e ) return - 1 === i ? r : o && 1 == ( 1 & i ) ? t - r : r; if ( n === LoopOnce ) {

			- 1 === i && ( this._loopCount = 0, this._setEndings( ! 0, ! 0, ! 1 ) ); e: {

				if ( r >= t )r = t; else {

					if ( ! ( r < 0 ) ) {

						this.time = r; break e;

					}

					r = 0;

				}

				this.clampWhenFinished ? this.paused = ! 0 : this.enabled = ! 1, this.time = r, this._mixer.dispatchEvent( { type: 'finished', action: this, direction: e < 0 ? - 1 : 1 } );

			}

		} else {

			if ( - 1 === i && ( e >= 0 ? ( i = 0, this._setEndings( ! 0, 0 === this.repetitions, o ) ) : this._setEndings( 0 === this.repetitions, ! 0, o ) ), r >= t || r < 0 ) {

				const n = Math.floor( r / t ); r -= t * n, i += Math.abs( n ); const a = this.repetitions - i; if ( a <= 0 ) this.clampWhenFinished ? this.paused = ! 0 : this.enabled = ! 1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent( { type: 'finished', action: this, direction: e > 0 ? 1 : - 1 } ); else {

					if ( 1 === a ) {

						const t = e < 0; this._setEndings( t, ! t, o );

					} else this._setEndings( ! 1, ! 1, o ); this._loopCount = i, this.time = r, this._mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: n } );

				}

			} else this.time = r; if ( o && 1 == ( 1 & i ) ) return t - r;

		}

		return r;

	}_setEndings( e, t, n ) {

		const r = this._interpolantSettings; n ? ( r.endingStart = ZeroSlopeEnding, r.endingEnd = ZeroSlopeEnding ) : ( r.endingStart = e ? this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding, r.endingEnd = t ? this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding );

	}_scheduleFading( e, t, n ) {

		const r = this._mixer, i = r.time; let o = this._weightInterpolant; null === o && ( o = r._lendControlInterpolant(), this._weightInterpolant = o ); const a = o.parameterPositions, s = o.sampleValues; return a[ 0 ] = i, s[ 0 ] = t, a[ 1 ] = i + e, s[ 1 ] = n, this;

	}

} function AnimationMixer( e ) {

	this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;

}

AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: AnimationMixer, _bindAction: function ( e, t ) {

	const n = e._localRoot || this._root, r = e._clip.tracks, i = r.length, o = e._propertyBindings, a = e._interpolants, s = n.uuid, c = this._bindingsByRootAndName; let l = c[ s ]; void 0 === l && ( l = {}, c[ s ] = l ); for ( let e = 0; e !== i; ++ e ) {

		const i = r[ e ], c = i.name; let h = l[ c ]; if ( void 0 !== h )o[ e ] = h; else {

			if ( void 0 !== ( h = o[ e ] ) ) {

				null === h._cacheIndex && ( ++ h.referenceCount, this._addInactiveBinding( h, s, c ) ); continue;

			}

			const r = t && t._propertyBindings[ e ].binding.parsedPath; ++ ( h = new PropertyMixer( PropertyBinding.create( n, c, r ), i.ValueTypeName, i.getValueSize() ) ).referenceCount, this._addInactiveBinding( h, s, c ), o[ e ] = h;

		}

		a[ e ].resultBuffer = h.buffer;

	}

}, _activateAction: function ( e ) {

	if ( ! this._isActiveAction( e ) ) {

		if ( null === e._cacheIndex ) {

			const t = ( e._localRoot || this._root ).uuid, n = e._clip.uuid, r = this._actionsByClip[ n ]; this._bindAction( e, r && r.knownActions[ 0 ] ), this._addInactiveAction( e, n, t );

		}

		const t = e._propertyBindings; for ( let e = 0, n = t.length; e !== n; ++ e ) {

			const n = t[ e ]; 0 == n.useCount ++ && ( this._lendBinding( n ), n.saveOriginalState() );

		}

		this._lendAction( e );

	}

}, _deactivateAction: function ( e ) {

	if ( this._isActiveAction( e ) ) {

		const t = e._propertyBindings; for ( let e = 0, n = t.length; e !== n; ++ e ) {

			const n = t[ e ]; 0 == -- n.useCount && ( n.restoreOriginalState(), this._takeBackBinding( n ) );

		}

		this._takeBackAction( e );

	}

}, _initMemoryManager: function () {

	this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() {

		return e._actions.length;

	}, get inUse() {

		return e._nActiveActions;

	} }, bindings: { get total() {

		return e._bindings.length;

	}, get inUse() {

		return e._nActiveBindings;

	} }, controlInterpolants: { get total() {

		return e._controlInterpolants.length;

	}, get inUse() {

		return e._nActiveControlInterpolants;

	} } };

}, _isActiveAction: function ( e ) {

	const t = e._cacheIndex; return null !== t && t < this._nActiveActions;

}, _addInactiveAction: function ( e, t, n ) {

	const r = this._actions, i = this._actionsByClip; let o = i[ t ]; if ( void 0 === o )o = { knownActions: [ e ], actionByRoot: {} }, e._byClipCacheIndex = 0, i[ t ] = o; else {

		const t = o.knownActions; e._byClipCacheIndex = t.length, t.push( e );

	}

	e._cacheIndex = r.length, r.push( e ), o.actionByRoot[ n ] = e;

}, _removeInactiveAction: function ( e ) {

	const t = this._actions, n = t[ t.length - 1 ], r = e._cacheIndex; n._cacheIndex = r, t[ r ] = n, t.pop(), e._cacheIndex = null; const i = e._clip.uuid, o = this._actionsByClip, a = o[ i ], s = a.knownActions, c = s[ s.length - 1 ], l = e._byClipCacheIndex; c._byClipCacheIndex = l, s[ l ] = c, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[ ( e._localRoot || this._root ).uuid ], 0 === s.length && delete o[ i ], this._removeInactiveBindingsForAction( e );

}, _removeInactiveBindingsForAction: function ( e ) {

	const t = e._propertyBindings; for ( let e = 0, n = t.length; e !== n; ++ e ) {

		const n = t[ e ]; 0 == -- n.referenceCount && this._removeInactiveBinding( n );

	}

}, _lendAction: function ( e ) {

	const t = this._actions, n = e._cacheIndex, r = this._nActiveActions ++, i = t[ r ]; e._cacheIndex = r, t[ r ] = e, i._cacheIndex = n, t[ n ] = i;

}, _takeBackAction: function ( e ) {

	const t = this._actions, n = e._cacheIndex, r = -- this._nActiveActions, i = t[ r ]; e._cacheIndex = r, t[ r ] = e, i._cacheIndex = n, t[ n ] = i;

}, _addInactiveBinding: function ( e, t, n ) {

	const r = this._bindingsByRootAndName, i = this._bindings; let o = r[ t ]; void 0 === o && ( o = {}, r[ t ] = o ), o[ n ] = e, e._cacheIndex = i.length, i.push( e );

}, _removeInactiveBinding: function ( e ) {

	const t = this._bindings, n = e.binding, r = n.rootNode.uuid, i = n.path, o = this._bindingsByRootAndName, a = o[ r ], s = t[ t.length - 1 ], c = e._cacheIndex; s._cacheIndex = c, t[ c ] = s, t.pop(), delete a[ i ], 0 === Object.keys( a ).length && delete o[ r ];

}, _lendBinding: function ( e ) {

	const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings ++, i = t[ r ]; e._cacheIndex = r, t[ r ] = e, i._cacheIndex = n, t[ n ] = i;

}, _takeBackBinding: function ( e ) {

	const t = this._bindings, n = e._cacheIndex, r = -- this._nActiveBindings, i = t[ r ]; e._cacheIndex = r, t[ r ] = e, i._cacheIndex = n, t[ n ] = i;

}, _lendControlInterpolant: function () {

	const e = this._controlInterpolants, t = this._nActiveControlInterpolants ++; let n = e[ t ]; return void 0 === n && ( ( n = new LinearInterpolant( new Float32Array( 2 ), new Float32Array( 2 ), 1, this._controlInterpolantsResultBuffer ) ).__cacheIndex = t, e[ t ] = n ), n;

}, _takeBackControlInterpolant: function ( e ) {

	const t = this._controlInterpolants, n = e.__cacheIndex, r = -- this._nActiveControlInterpolants, i = t[ r ]; e.__cacheIndex = r, t[ r ] = e, i.__cacheIndex = n, t[ n ] = i;

}, _controlInterpolantsResultBuffer: new Float32Array( 1 ), clipAction: function ( e, t, n ) {

	const r = t || this._root, i = r.uuid; let o = 'string' == typeof e ? AnimationClip.findByName( r, e ) : e; const a = null !== o ? o.uuid : e, s = this._actionsByClip[ a ]; let c = null; if ( void 0 === n && ( n = null !== o ? o.blendMode : NormalAnimationBlendMode ), void 0 !== s ) {

		const e = s.actionByRoot[ i ]; if ( void 0 !== e && e.blendMode === n ) return e; c = s.knownActions[ 0 ], null === o && ( o = c._clip );

	}

	if ( null === o ) return null; const l = new AnimationAction( this, o, t, n ); return this._bindAction( l, c ), this._addInactiveAction( l, a, i ), l;

}, existingAction: function ( e, t ) {

	const n = t || this._root, r = n.uuid, i = 'string' == typeof e ? AnimationClip.findByName( n, e ) : e, o = i ? i.uuid : e, a = this._actionsByClip[ o ]; return void 0 !== a && a.actionByRoot[ r ] || null;

}, stopAllAction: function () {

	const e = this._actions; for ( let t = this._nActiveActions - 1; t >= 0; -- t )e[ t ].stop(); return this;

}, update: function ( e ) {

	e *= this.timeScale; const t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign( e ), o = this._accuIndex ^= 1; for ( let a = 0; a !== n; ++ a ) {

		t[ a ]._update( r, e, i, o );

	}

	const a = this._bindings, s = this._nActiveBindings; for ( let e = 0; e !== s; ++ e )a[ e ].apply( o ); return this;

}, setTime: function ( e ) {

	this.time = 0; for ( let e = 0; e < this._actions.length; e ++ ) this._actions[ e ].time = 0; return this.update( e );

}, getRoot: function () {

	return this._root;

}, uncacheClip: function ( e ) {

	const t = this._actions, n = e.uuid, r = this._actionsByClip, i = r[ n ]; if ( void 0 !== i ) {

		const e = i.knownActions; for ( let n = 0, r = e.length; n !== r; ++ n ) {

			const r = e[ n ]; this._deactivateAction( r ); const i = r._cacheIndex, o = t[ t.length - 1 ]; r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = i, t[ i ] = o, t.pop(), this._removeInactiveBindingsForAction( r );

		}

		delete r[ n ];

	}

}, uncacheRoot: function ( e ) {

	const t = e.uuid, n = this._actionsByClip; for ( const e in n ) {

		const r = n[ e ].actionByRoot[ t ]; void 0 !== r && ( this._deactivateAction( r ), this._removeInactiveAction( r ) );

	}

	const r = this._bindingsByRootAndName[ t ]; if ( void 0 !== r ) for ( const e in r ) {

		const t = r[ e ]; t.restoreOriginalState(), this._removeInactiveBinding( t );

	}

}, uncacheAction: function ( e, t ) {

	const n = this.existingAction( e, t ); null !== n && ( this._deactivateAction( n ), this._removeInactiveAction( n ) );

} } ); class Uniform {

	constructor( e ) {

		'string' == typeof e && ( console.warn( 'THREE.Uniform: Type parameter is no longer needed.' ), e = arguments[ 1 ] ), this.value = e;

	}clone() {

		return new Uniform( void 0 === this.value.clone ? this.value : this.value.clone() );

	}

} function InstancedInterleavedBuffer( e, t, n ) {

	InterleavedBuffer.call( this, e, t ), this.meshPerAttribute = n || 1;

}

function GLBufferAttribute( e, t, n, r, i ) {

	this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0;

}

function Raycaster( e, t, n, r ) {

	this.ray = new Ray( e, t ), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new Layers(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties( this.params, { PointCloud: { get: function () {

		return console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' ), this.Points;

	} } } );

}

function ascSort( e, t ) {

	return e.distance - t.distance;

}

function intersectObject( e, t, n, r ) {

	if ( e.layers.test( t.layers ) && e.raycast( t, n ), ! 0 === r ) {

		const r = e.children; for ( let e = 0, i = r.length; e < i; e ++ )intersectObject( r[ e ], t, n, ! 0 );

	}

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), { constructor: InstancedInterleavedBuffer, isInstancedInterleavedBuffer: ! 0, copy: function ( e ) {

	return InterleavedBuffer.prototype.copy.call( this, e ), this.meshPerAttribute = e.meshPerAttribute, this;

}, clone: function ( e ) {

	const t = InterleavedBuffer.prototype.clone.call( this, e ); return t.meshPerAttribute = this.meshPerAttribute, t;

}, toJSON: function ( e ) {

	const t = InterleavedBuffer.prototype.toJSON.call( this, e ); return t.isInstancedInterleavedBuffer = ! 0, t.meshPerAttribute = this.meshPerAttribute, t;

} } ), Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', { set: function ( e ) {

	! 0 === e && this.version ++;

} } ), Object.assign( GLBufferAttribute.prototype, { isGLBufferAttribute: ! 0, setBuffer: function ( e ) {

	return this.buffer = e, this;

}, setType: function ( e, t ) {

	return this.type = e, this.elementSize = t, this;

}, setItemSize: function ( e ) {

	return this.itemSize = e, this;

}, setCount: function ( e ) {

	return this.count = e, this;

} } ), Object.assign( Raycaster.prototype, { set: function ( e, t ) {

	this.ray.set( e, t );

}, setFromCamera: function ( e, t ) {

	t && t.isPerspectiveCamera ? ( this.ray.origin.setFromMatrixPosition( t.matrixWorld ), this.ray.direction.set( e.x, e.y, .5 ).unproject( t ).sub( this.ray.origin ).normalize(), this.camera = t ) : t && t.isOrthographicCamera ? ( this.ray.origin.set( e.x, e.y, ( t.near + t.far ) / ( t.near - t.far ) ).unproject( t ), this.ray.direction.set( 0, 0, - 1 ).transformDirection( t.matrixWorld ), this.camera = t ) : console.error( 'THREE.Raycaster: Unsupported camera type: ' + t.type );

}, intersectObject: function ( e, t, n ) {

	const r = n || []; return intersectObject( e, this, r, t ), r.sort( ascSort ), r;

}, intersectObjects: function ( e, t, n ) {

	const r = n || []; if ( ! 1 === Array.isArray( e ) ) return console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' ), r; for ( let n = 0, i = e.length; n < i; n ++ )intersectObject( e[ n ], this, r, t ); return r.sort( ascSort ), r;

} } ); class Spherical {

	constructor( e = 1, t = 0, n = 0 ) {

		return this.radius = e, this.phi = t, this.theta = n, this;

	}set( e, t, n ) {

		return this.radius = e, this.phi = t, this.theta = n, this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;

	}makeSafe() {

		return this.phi = Math.max( 1e-6, Math.min( Math.PI - 1e-6, this.phi ) ), this;

	}setFromVector3( e ) {

		return this.setFromCartesianCoords( e.x, e.y, e.z );

	}setFromCartesianCoords( e, t, n ) {

		return this.radius = Math.sqrt( e * e + t * t + n * n ), 0 === this.radius ? ( this.theta = 0, this.phi = 0 ) : ( this.theta = Math.atan2( e, n ), this.phi = Math.acos( MathUtils.clamp( t / this.radius, - 1, 1 ) ) ), this;

	}

} class Cylindrical {

	constructor( e, t, n ) {

		return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this;

	}set( e, t, n ) {

		return this.radius = e, this.theta = t, this.y = n, this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;

	}setFromVector3( e ) {

		return this.setFromCartesianCoords( e.x, e.y, e.z );

	}setFromCartesianCoords( e, t, n ) {

		return this.radius = Math.sqrt( e * e + n * n ), this.theta = Math.atan2( e, n ), this.y = t, this;

	}

} const _vector$8 = new Vector2(); class Box2 {

	constructor( e, t ) {

		Object.defineProperty( this, 'isBox2', { value: ! 0 } ), this.min = void 0 !== e ? e : new Vector2( 1 / 0, 1 / 0 ), this.max = void 0 !== t ? t : new Vector2( - 1 / 0, - 1 / 0 );

	}set( e, t ) {

		return this.min.copy( e ), this.max.copy( t ), this;

	}setFromPoints( e ) {

		this.makeEmpty(); for ( let t = 0, n = e.length; t < n; t ++ ) this.expandByPoint( e[ t ] ); return this;

	}setFromCenterAndSize( e, t ) {

		const n = _vector$8.copy( t ).multiplyScalar( .5 ); return this.min.copy( e ).sub( n ), this.max.copy( e ).add( n ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.min.copy( e.min ), this.max.copy( e.max ), this;

	}makeEmpty() {

		return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = - 1 / 0, this;

	}isEmpty() {

		return this.max.x < this.min.x || this.max.y < this.min.y;

	}getCenter( e ) {

		return void 0 === e && ( console.warn( 'THREE.Box2: .getCenter() target is now required' ), e = new Vector2() ), this.isEmpty() ? e.set( 0, 0 ) : e.addVectors( this.min, this.max ).multiplyScalar( .5 );

	}getSize( e ) {

		return void 0 === e && ( console.warn( 'THREE.Box2: .getSize() target is now required' ), e = new Vector2() ), this.isEmpty() ? e.set( 0, 0 ) : e.subVectors( this.max, this.min );

	}expandByPoint( e ) {

		return this.min.min( e ), this.max.max( e ), this;

	}expandByVector( e ) {

		return this.min.sub( e ), this.max.add( e ), this;

	}expandByScalar( e ) {

		return this.min.addScalar( - e ), this.max.addScalar( e ), this;

	}containsPoint( e ) {

		return ! ( e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y );

	}containsBox( e ) {

		return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;

	}getParameter( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Box2: .getParameter() target is now required' ), t = new Vector2() ), t.set( ( e.x - this.min.x ) / ( this.max.x - this.min.x ), ( e.y - this.min.y ) / ( this.max.y - this.min.y ) );

	}intersectsBox( e ) {

		return ! ( e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y );

	}clampPoint( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Box2: .clampPoint() target is now required' ), t = new Vector2() ), t.copy( e ).clamp( this.min, this.max );

	}distanceToPoint( e ) {

		return _vector$8.copy( e ).clamp( this.min, this.max ).sub( e ).length();

	}intersect( e ) {

		return this.min.max( e.min ), this.max.min( e.max ), this;

	}union( e ) {

		return this.min.min( e.min ), this.max.max( e.max ), this;

	}translate( e ) {

		return this.min.add( e ), this.max.add( e ), this;

	}equals( e ) {

		return e.min.equals( this.min ) && e.max.equals( this.max );

	}

} const _startP = new Vector3(), _startEnd = new Vector3(); class Line3 {

	constructor( e, t ) {

		this.start = void 0 !== e ? e : new Vector3(), this.end = void 0 !== t ? t : new Vector3();

	}set( e, t ) {

		return this.start.copy( e ), this.end.copy( t ), this;

	}clone() {

		return ( new this.constructor() ).copy( this );

	}copy( e ) {

		return this.start.copy( e.start ), this.end.copy( e.end ), this;

	}getCenter( e ) {

		return void 0 === e && ( console.warn( 'THREE.Line3: .getCenter() target is now required' ), e = new Vector3() ), e.addVectors( this.start, this.end ).multiplyScalar( .5 );

	}delta( e ) {

		return void 0 === e && ( console.warn( 'THREE.Line3: .delta() target is now required' ), e = new Vector3() ), e.subVectors( this.end, this.start );

	}distanceSq() {

		return this.start.distanceToSquared( this.end );

	}distance() {

		return this.start.distanceTo( this.end );

	}at( e, t ) {

		return void 0 === t && ( console.warn( 'THREE.Line3: .at() target is now required' ), t = new Vector3() ), this.delta( t ).multiplyScalar( e ).add( this.start );

	}closestPointToPointParameter( e, t ) {

		_startP.subVectors( e, this.start ), _startEnd.subVectors( this.end, this.start ); const n = _startEnd.dot( _startEnd ); let r = _startEnd.dot( _startP ) / n; return t && ( r = MathUtils.clamp( r, 0, 1 ) ), r;

	}closestPointToPoint( e, t, n ) {

		const r = this.closestPointToPointParameter( e, t ); return void 0 === n && ( console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' ), n = new Vector3() ), this.delta( n ).multiplyScalar( r ).add( this.start );

	}applyMatrix4( e ) {

		return this.start.applyMatrix4( e ), this.end.applyMatrix4( e ), this;

	}equals( e ) {

		return e.start.equals( this.start ) && e.end.equals( this.end );

	}

} function ImmediateRenderObject( e ) {

	Object3D.call( this ), this.material = e, this.render = function () {}, this.hasPositions = ! 1, this.hasNormals = ! 1, this.hasColors = ! 1, this.hasUvs = ! 1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype ), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject, ImmediateRenderObject.prototype.isImmediateRenderObject = ! 0; const _vector$9 = new Vector3(); class SpotLightHelper extends Object3D {

	constructor( e, t ) {

		super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = ! 1, this.color = t; const n = new BufferGeometry(), r = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, - 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, - 1, 1 ]; for ( let e = 0, t = 1, n = 32; e < n; e ++, t ++ ) {

			const i = e / n * Math.PI * 2, o = t / n * Math.PI * 2; r.push( Math.cos( i ), Math.sin( i ), 1, Math.cos( o ), Math.sin( o ), 1 );

		}

		n.setAttribute( 'position', new Float32BufferAttribute( r, 3 ) ); const i = new LineBasicMaterial( { fog: ! 1, toneMapped: ! 1 } ); this.cone = new LineSegments( n, i ), this.add( this.cone ), this.update();

	}dispose() {

		this.cone.geometry.dispose(), this.cone.material.dispose();

	}update() {

		this.light.updateMatrixWorld(); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan( this.light.angle ); this.cone.scale.set( t, t, e ), _vector$9.setFromMatrixPosition( this.light.target.matrixWorld ), this.cone.lookAt( _vector$9 ), void 0 !== this.color ? this.cone.material.color.set( this.color ) : this.cone.material.color.copy( this.light.color );

	}

} const _vector$a = new Vector3(), _boneMatrix = new Matrix4(), _matrixWorldInv = new Matrix4(); class SkeletonHelper extends LineSegments {

	constructor( e ) {

		const t = getBoneList( e ), n = new BufferGeometry(), r = [], i = [], o = new Color( 0, 0, 1 ), a = new Color( 0, 1, 0 ); for ( let e = 0; e < t.length; e ++ ) {

			const n = t[ e ]; n.parent && n.parent.isBone && ( r.push( 0, 0, 0 ), r.push( 0, 0, 0 ), i.push( o.r, o.g, o.b ), i.push( a.r, a.g, a.b ) );

		}

		n.setAttribute( 'position', new Float32BufferAttribute( r, 3 ) ), n.setAttribute( 'color', new Float32BufferAttribute( i, 3 ) ), super( n, new LineBasicMaterial( { vertexColors: ! 0, depthTest: ! 1, depthWrite: ! 1, toneMapped: ! 1, transparent: ! 0 } ) ), this.type = 'SkeletonHelper', this.isSkeletonHelper = ! 0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = ! 1;

	}updateMatrixWorld( e ) {

		const t = this.bones, n = this.geometry, r = n.getAttribute( 'position' ); _matrixWorldInv.copy( this.root.matrixWorld ).invert(); for ( let e = 0, n = 0; e < t.length; e ++ ) {

			const i = t[ e ]; i.parent && i.parent.isBone && ( _boneMatrix.multiplyMatrices( _matrixWorldInv, i.matrixWorld ), _vector$a.setFromMatrixPosition( _boneMatrix ), r.setXYZ( n, _vector$a.x, _vector$a.y, _vector$a.z ), _boneMatrix.multiplyMatrices( _matrixWorldInv, i.parent.matrixWorld ), _vector$a.setFromMatrixPosition( _boneMatrix ), r.setXYZ( n + 1, _vector$a.x, _vector$a.y, _vector$a.z ), n += 2 );

		}

		n.getAttribute( 'position' ).needsUpdate = ! 0, super.updateMatrixWorld( e );

	}

} function getBoneList( e ) {

	const t = []; e && e.isBone && t.push( e ); for ( let n = 0; n < e.children.length; n ++ )t.push.apply( t, getBoneList( e.children[ n ] ) ); return t;

}

class PointLightHelper extends Mesh {

	constructor( e, t, n ) {

		super( new SphereBufferGeometry( t, 4, 2 ), new MeshBasicMaterial( { wireframe: ! 0, fog: ! 1, toneMapped: ! 1 } ) ), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = 'PointLightHelper', this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = ! 1, this.update();

	}dispose() {

		this.geometry.dispose(), this.material.dispose();

	}update() {

		void 0 !== this.color ? this.material.color.set( this.color ) : this.material.color.copy( this.light.color );

	}

} const _vector$b = new Vector3(), _color1 = new Color(), _color2 = new Color(); class HemisphereLightHelper extends Object3D {

	constructor( e, t, n ) {

		super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = ! 1, this.color = n; const r = new OctahedronBufferGeometry( t ); r.rotateY( .5 * Math.PI ), this.material = new MeshBasicMaterial( { wireframe: ! 0, fog: ! 1, toneMapped: ! 1 } ), void 0 === this.color && ( this.material.vertexColors = ! 0 ); const i = r.getAttribute( 'position' ), o = new Float32Array( 3 * i.count ); r.setAttribute( 'color', new BufferAttribute( o, 3 ) ), this.add( new Mesh( r, this.material ) ), this.update();

	}dispose() {

		this.children[ 0 ].geometry.dispose(), this.children[ 0 ].material.dispose();

	}update() {

		const e = this.children[ 0 ]; if ( void 0 !== this.color ) this.material.color.set( this.color ); else {

			const t = e.geometry.getAttribute( 'color' ); _color1.copy( this.light.color ), _color2.copy( this.light.groundColor ); for ( let e = 0, n = t.count; e < n; e ++ ) {

				const r = e < n / 2 ? _color1 : _color2; t.setXYZ( e, r.r, r.g, r.b );

			}

			t.needsUpdate = ! 0;

		}

		e.lookAt( _vector$b.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

} class GridHelper extends LineSegments {

	constructor( e = 10, t = 10, n = 4473924, r = 8947848 ) {

		n = new Color( n ), r = new Color( r ); const i = t / 2, o = e / t, a = e / 2, s = [], c = []; for ( let e = 0, l = 0, h = - a; e <= t; e ++, h += o ) {

			s.push( - a, 0, h, a, 0, h ), s.push( h, 0, - a, h, 0, a ); const t = e === i ? n : r; t.toArray( c, l ), l += 3, t.toArray( c, l ), l += 3, t.toArray( c, l ), l += 3, t.toArray( c, l ), l += 3;

		}

		const l = new BufferGeometry(); l.setAttribute( 'position', new Float32BufferAttribute( s, 3 ) ), l.setAttribute( 'color', new Float32BufferAttribute( c, 3 ) ), super( l, new LineBasicMaterial( { vertexColors: ! 0, toneMapped: ! 1 } ) ), this.type = 'GridHelper';

	}

} class PolarGridHelper extends LineSegments {

	constructor( e = 10, t = 16, n = 8, r = 64, i = 4473924, o = 8947848 ) {

		i = new Color( i ), o = new Color( o ); const a = [], s = []; for ( let n = 0; n <= t; n ++ ) {

			const r = n / t * ( 2 * Math.PI ), c = Math.sin( r ) * e, l = Math.cos( r ) * e; a.push( 0, 0, 0 ), a.push( c, 0, l ); const h = 1 & n ? i : o; s.push( h.r, h.g, h.b ), s.push( h.r, h.g, h.b );

		}

		for ( let t = 0; t <= n; t ++ ) {

			const c = 1 & t ? i : o, l = e - e / n * t; for ( let e = 0; e < r; e ++ ) {

				let t = e / r * ( 2 * Math.PI ), n = Math.sin( t ) * l, i = Math.cos( t ) * l; a.push( n, 0, i ), s.push( c.r, c.g, c.b ), t = ( e + 1 ) / r * ( 2 * Math.PI ), n = Math.sin( t ) * l, i = Math.cos( t ) * l, a.push( n, 0, i ), s.push( c.r, c.g, c.b );

			}

		}

		const c = new BufferGeometry(); c.setAttribute( 'position', new Float32BufferAttribute( a, 3 ) ), c.setAttribute( 'color', new Float32BufferAttribute( s, 3 ) ), super( c, new LineBasicMaterial( { vertexColors: ! 0, toneMapped: ! 1 } ) ), this.type = 'PolarGridHelper';

	}

} const _v1$6 = new Vector3(), _v2$3 = new Vector3(), _v3$1 = new Vector3(); class DirectionalLightHelper extends Object3D {

	constructor( e, t, n ) {

		super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = ! 1, this.color = n, void 0 === t && ( t = 1 ); let r = new BufferGeometry(); r.setAttribute( 'position', new Float32BufferAttribute( [ - t, t, 0, t, t, 0, t, - t, 0, - t, - t, 0, - t, t, 0 ], 3 ) ); const i = new LineBasicMaterial( { fog: ! 1, toneMapped: ! 1 } ); this.lightPlane = new Line( r, i ), this.add( this.lightPlane ), ( r = new BufferGeometry() ).setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) ), this.targetLine = new Line( r, i ), this.add( this.targetLine ), this.update();

	}dispose() {

		this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();

	}update() {

		_v1$6.setFromMatrixPosition( this.light.matrixWorld ), _v2$3.setFromMatrixPosition( this.light.target.matrixWorld ), _v3$1.subVectors( _v2$3, _v1$6 ), this.lightPlane.lookAt( _v2$3 ), void 0 !== this.color ? ( this.lightPlane.material.color.set( this.color ), this.targetLine.material.color.set( this.color ) ) : ( this.lightPlane.material.color.copy( this.light.color ), this.targetLine.material.color.copy( this.light.color ) ), this.targetLine.lookAt( _v2$3 ), this.targetLine.scale.z = _v3$1.length();

	}

} const _vector$c = new Vector3(), _camera = new Camera(); class CameraHelper extends LineSegments {

	constructor( e ) {

		const t = new BufferGeometry(), n = new LineBasicMaterial( { color: 16777215, vertexColors: ! 0, toneMapped: ! 1 } ), r = [], i = [], o = {}, a = new Color( 16755200 ), s = new Color( 16711680 ), c = new Color( 43775 ), l = new Color( 16777215 ), h = new Color( 3355443 ); function u( e, t, n ) {

			d( e, n ), d( t, n );

		}

		function d( e, t ) {

			r.push( 0, 0, 0 ), i.push( t.r, t.g, t.b ), void 0 === o[ e ] && ( o[ e ] = [] ), o[ e ].push( r.length / 3 - 1 );

		}

		u( 'n1', 'n2', a ), u( 'n2', 'n4', a ), u( 'n4', 'n3', a ), u( 'n3', 'n1', a ), u( 'f1', 'f2', a ), u( 'f2', 'f4', a ), u( 'f4', 'f3', a ), u( 'f3', 'f1', a ), u( 'n1', 'f1', a ), u( 'n2', 'f2', a ), u( 'n3', 'f3', a ), u( 'n4', 'f4', a ), u( 'p', 'n1', s ), u( 'p', 'n2', s ), u( 'p', 'n3', s ), u( 'p', 'n4', s ), u( 'u1', 'u2', c ), u( 'u2', 'u3', c ), u( 'u3', 'u1', c ), u( 'c', 't', l ), u( 'p', 'c', h ), u( 'cn1', 'cn2', h ), u( 'cn3', 'cn4', h ), u( 'cf1', 'cf2', h ), u( 'cf3', 'cf4', h ), t.setAttribute( 'position', new Float32BufferAttribute( r, 3 ) ), t.setAttribute( 'color', new Float32BufferAttribute( i, 3 ) ), super( t, n ), this.type = 'CameraHelper', this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = ! 1, this.pointMap = o, this.update();

	}update() {

		const e = this.geometry, t = this.pointMap; _camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse ), setPoint( 'c', t, e, _camera, 0, 0, - 1 ), setPoint( 't', t, e, _camera, 0, 0, 1 ), setPoint( 'n1', t, e, _camera, - 1, - 1, - 1 ), setPoint( 'n2', t, e, _camera, 1, - 1, - 1 ), setPoint( 'n3', t, e, _camera, - 1, 1, - 1 ), setPoint( 'n4', t, e, _camera, 1, 1, - 1 ), setPoint( 'f1', t, e, _camera, - 1, - 1, 1 ), setPoint( 'f2', t, e, _camera, 1, - 1, 1 ), setPoint( 'f3', t, e, _camera, - 1, 1, 1 ), setPoint( 'f4', t, e, _camera, 1, 1, 1 ), setPoint( 'u1', t, e, _camera, .7, 1.1, - 1 ), setPoint( 'u2', t, e, _camera, - .7, 1.1, - 1 ), setPoint( 'u3', t, e, _camera, 0, 2, - 1 ), setPoint( 'cf1', t, e, _camera, - 1, 0, 1 ), setPoint( 'cf2', t, e, _camera, 1, 0, 1 ), setPoint( 'cf3', t, e, _camera, 0, - 1, 1 ), setPoint( 'cf4', t, e, _camera, 0, 1, 1 ), setPoint( 'cn1', t, e, _camera, - 1, 0, - 1 ), setPoint( 'cn2', t, e, _camera, 1, 0, - 1 ), setPoint( 'cn3', t, e, _camera, 0, - 1, - 1 ), setPoint( 'cn4', t, e, _camera, 0, 1, - 1 ), e.getAttribute( 'position' ).needsUpdate = ! 0;

	}

} function setPoint( e, t, n, r, i, o, a ) {

	_vector$c.set( i, o, a ).unproject( r ); const s = t[ e ]; if ( void 0 !== s ) {

		const e = n.getAttribute( 'position' ); for ( let t = 0, n = s.length; t < n; t ++ )e.setXYZ( s[ t ], _vector$c.x, _vector$c.y, _vector$c.z );

	}

}

const _box$3 = new Box3(); class BoxHelper extends LineSegments {

	constructor( e, t = 16776960 ) {

		const n = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] ), r = new Float32Array( 24 ), i = new BufferGeometry(); i.setIndex( new BufferAttribute( n, 1 ) ), i.setAttribute( 'position', new BufferAttribute( r, 3 ) ), super( i, new LineBasicMaterial( { color: t, toneMapped: ! 1 } ) ), this.object = e, this.type = 'BoxHelper', this.matrixAutoUpdate = ! 1, this.update();

	}update( e ) {

		if ( void 0 !== e && console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' ), void 0 !== this.object && _box$3.setFromObject( this.object ), _box$3.isEmpty() ) return; const t = _box$3.min, n = _box$3.max, r = this.geometry.attributes.position, i = r.array; i[ 0 ] = n.x, i[ 1 ] = n.y, i[ 2 ] = n.z, i[ 3 ] = t.x, i[ 4 ] = n.y, i[ 5 ] = n.z, i[ 6 ] = t.x, i[ 7 ] = t.y, i[ 8 ] = n.z, i[ 9 ] = n.x, i[ 10 ] = t.y, i[ 11 ] = n.z, i[ 12 ] = n.x, i[ 13 ] = n.y, i[ 14 ] = t.z, i[ 15 ] = t.x, i[ 16 ] = n.y, i[ 17 ] = t.z, i[ 18 ] = t.x, i[ 19 ] = t.y, i[ 20 ] = t.z, i[ 21 ] = n.x, i[ 22 ] = t.y, i[ 23 ] = t.z, r.needsUpdate = ! 0, this.geometry.computeBoundingSphere();

	}setFromObject( e ) {

		return this.object = e, this.update(), this;

	}copy( e ) {

		return LineSegments.prototype.copy.call( this, e ), this.object = e.object, this;

	}

} class Box3Helper extends LineSegments {

	constructor( e, t = 16776960 ) {

		const n = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] ), r = new BufferGeometry(); r.setIndex( new BufferAttribute( n, 1 ) ), r.setAttribute( 'position', new Float32BufferAttribute( [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ], 3 ) ), super( r, new LineBasicMaterial( { color: t, toneMapped: ! 1 } ) ), this.box = e, this.type = 'Box3Helper', this.geometry.computeBoundingSphere();

	}updateMatrixWorld( e ) {

		const t = this.box; t.isEmpty() || ( t.getCenter( this.position ), t.getSize( this.scale ), this.scale.multiplyScalar( .5 ), super.updateMatrixWorld( e ) );

	}

} class PlaneHelper extends Line {

	constructor( e, t = 1, n = 16776960 ) {

		const r = n, i = new BufferGeometry(); i.setAttribute( 'position', new Float32BufferAttribute( [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ], 3 ) ), i.computeBoundingSphere(), super( i, new LineBasicMaterial( { color: r, toneMapped: ! 1 } ) ), this.type = 'PlaneHelper', this.plane = e, this.size = t; const o = new BufferGeometry(); o.setAttribute( 'position', new Float32BufferAttribute( [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ], 3 ) ), o.computeBoundingSphere(), this.add( new Mesh( o, new MeshBasicMaterial( { color: r, opacity: .2, transparent: ! 0, depthWrite: ! 1, toneMapped: ! 1 } ) ) );

	}updateMatrixWorld( e ) {

		let t = - this.plane.constant; Math.abs( t ) < 1e-8 && ( t = 1e-8 ), this.scale.set( .5 * this.size, .5 * this.size, t ), this.children[ 0 ].material.side = t < 0 ? BackSide : FrontSide, this.lookAt( this.plane.normal ), super.updateMatrixWorld( e );

	}

} const _axis = new Vector3(); let _lineGeometry, _coneGeometry; class ArrowHelper extends Object3D {

	constructor( e, t, n, r, i, o ) {

		super(), this.type = 'ArrowHelper', void 0 === e && ( e = new Vector3( 0, 0, 1 ) ), void 0 === t && ( t = new Vector3( 0, 0, 0 ) ), void 0 === n && ( n = 1 ), void 0 === r && ( r = 16776960 ), void 0 === i && ( i = .2 * n ), void 0 === o && ( o = .2 * i ), void 0 === _lineGeometry && ( ( _lineGeometry = new BufferGeometry() ).setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) ), ( _coneGeometry = new CylinderBufferGeometry( 0, .5, 1, 5, 1 ) ).translate( 0, - .5, 0 ) ), this.position.copy( t ), this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: r, toneMapped: ! 1 } ) ), this.line.matrixAutoUpdate = ! 1, this.add( this.line ), this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: r, toneMapped: ! 1 } ) ), this.cone.matrixAutoUpdate = ! 1, this.add( this.cone ), this.setDirection( e ), this.setLength( n, i, o );

	}setDirection( e ) {

		if ( e.y > .99999 ) this.quaternion.set( 0, 0, 0, 1 ); else if ( e.y < - .99999 ) this.quaternion.set( 1, 0, 0, 0 ); else {

			_axis.set( e.z, 0, - e.x ).normalize(); const t = Math.acos( e.y ); this.quaternion.setFromAxisAngle( _axis, t );

		}

	}setLength( e, t, n ) {

		void 0 === t && ( t = .2 * e ), void 0 === n && ( n = .2 * t ), this.line.scale.set( 1, Math.max( 1e-4, e - t ), 1 ), this.line.updateMatrix(), this.cone.scale.set( n, t, n ), this.cone.position.y = e, this.cone.updateMatrix();

	}setColor( e ) {

		this.line.material.color.set( e ), this.cone.material.color.set( e );

	}copy( e ) {

		return super.copy( e, ! 1 ), this.line.copy( e.line ), this.cone.copy( e.cone ), this;

	}

} class AxesHelper extends LineSegments {

	constructor( e = 1 ) {

		const t = [ 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e ], n = new BufferGeometry(); n.setAttribute( 'position', new Float32BufferAttribute( t, 3 ) ), n.setAttribute( 'color', new Float32BufferAttribute( [ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ], 3 ) ), super( n, new LineBasicMaterial( { vertexColors: ! 0, toneMapped: ! 1 } ) ), this.type = 'AxesHelper';

	}

} const _floatView = new Float32Array( 1 ), _int32View = new Int32Array( _floatView.buffer ), DataUtils = { toHalfFloat: function ( e ) {

		_floatView[ 0 ] = e; const t = _int32View[ 0 ]; let n = t >> 16 & 32768, r = t >> 12 & 2047; const i = t >> 23 & 255; return i < 103 ? n : i > 142 ? ( n |= 31744, n |= ( 255 == i ? 0 : 1 ) && 8388607 & t ) : i < 113 ? n |= ( ( r |= 2048 ) >> 114 - i ) + ( r >> 113 - i & 1 ) : ( n |= i - 112 << 10 | r >> 1, n += 1 & r );

	} }, LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow( 2, LOD_MAX ), EXTRA_LOD_SIGMA = [ .125, .215, .35, .446, .526, .582 ], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = { [ LinearEncoding ]: 0, [ sRGBEncoding ]: 1, [ RGBEEncoding ]: 2, [ RGBM7Encoding ]: 3, [ RGBM16Encoding ]: 4, [ RGBDEncoding ]: 5, [ GammaEncoding ]: 6 }, _flatCamera = new OrthographicCamera(), { _lodPlanes: _lodPlanes, _sizeLods: _sizeLods, _sigmas: _sigmas } = _createPlanes(), _clearColor = new Color(); let _oldTarget = null; const PHI = ( 1 + Math.sqrt( 5 ) ) / 2, INV_PHI = 1 / PHI, _axisDirections = [ new Vector3( 1, 1, 1 ), new Vector3( - 1, 1, 1 ), new Vector3( 1, 1, - 1 ), new Vector3( - 1, 1, - 1 ), new Vector3( 0, PHI, INV_PHI ), new Vector3( 0, PHI, - INV_PHI ), new Vector3( INV_PHI, 0, PHI ), new Vector3( - INV_PHI, 0, PHI ), new Vector3( PHI, INV_PHI, 0 ), new Vector3( - PHI, INV_PHI, 0 ) ]; class PMREMGenerator {

	constructor( e ) {

		this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader( MAX_SAMPLES ), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial( this._blurMaterial );

	}fromScene( e, t = 0, n = .1, r = 100 ) {

		_oldTarget = this._renderer.getRenderTarget(); const i = this._allocateTargets(); return this._sceneToCubeUV( e, n, r, i ), t > 0 && this._blur( i, 0, 0, t ), this._applyPMREM( i ), this._cleanup( i ), i;

	}fromEquirectangular( e ) {

		return this._fromTexture( e );

	}fromCubemap( e ) {

		return this._fromTexture( e );

	}compileCubemapShader() {

		null === this._cubemapShader && ( this._cubemapShader = _getCubemapShader(), this._compileMaterial( this._cubemapShader ) );

	}compileEquirectangularShader() {

		null === this._equirectShader && ( this._equirectShader = _getEquirectShader(), this._compileMaterial( this._equirectShader ) );

	}dispose() {

		this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for ( let e = 0; e < _lodPlanes.length; e ++ )_lodPlanes[ e ].dispose();

	}_cleanup( e ) {

		this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget( _oldTarget ), e.scissorTest = ! 1, _setViewport( e, 0, 0, e.width, e.height );

	}_fromTexture( e ) {

		_oldTarget = this._renderer.getRenderTarget(); const t = this._allocateTargets( e ); return this._textureToCubeUV( e, t ), this._applyPMREM( t ), this._cleanup( t ), t;

	}_allocateTargets( e ) {

		const t = { magFilter: NearestFilter, minFilter: NearestFilter, generateMipmaps: ! 1, type: UnsignedByteType, format: RGBEFormat, encoding: _isLDR( e ) ? e.encoding : RGBEEncoding, depthBuffer: ! 1 }, n = _createRenderTarget( t ); return n.depthBuffer = ! e, this._pingPongRenderTarget = _createRenderTarget( t ), n;

	}_compileMaterial( e ) {

		const t = new Mesh( _lodPlanes[ 0 ], e ); this._renderer.compile( t, _flatCamera );

	}_sceneToCubeUV( e, t, n, r ) {

		const i = new PerspectiveCamera( 90, 1, t, n ), o = [ 1, - 1, 1, 1, 1, 1 ], a = [ 1, 1, 1, - 1, - 1, - 1 ], s = this._renderer, c = s.outputEncoding, l = s.toneMapping; s.getClearColor( _clearColor ); const h = s.getClearAlpha(); s.toneMapping = NoToneMapping, s.outputEncoding = LinearEncoding; let u = e.background; if ( u && u.isColor ) {

			u.convertSRGBToLinear(); const t = Math.max( u.r, u.g, u.b ), n = Math.min( Math.max( Math.ceil( Math.log2( t ) ), - 128 ), 127 ); u = u.multiplyScalar( Math.pow( 2, - n ) ); const r = ( n + 128 ) / 255; s.setClearColor( u, r ), e.background = null;

		}

		for ( let t = 0; t < 6; t ++ ) {

			const n = t % 3; 0 == n ? ( i.up.set( 0, o[ t ], 0 ), i.lookAt( a[ t ], 0, 0 ) ) : 1 == n ? ( i.up.set( 0, 0, o[ t ] ), i.lookAt( 0, a[ t ], 0 ) ) : ( i.up.set( 0, o[ t ], 0 ), i.lookAt( 0, 0, a[ t ] ) ), _setViewport( r, n * SIZE_MAX, t > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX ), s.setRenderTarget( r ), s.render( e, i );

		}

		s.toneMapping = l, s.outputEncoding = c, s.setClearColor( _clearColor, h );

	}_textureToCubeUV( e, t ) {

		const n = this._renderer; e.isCubeTexture ? null == this._cubemapShader && ( this._cubemapShader = _getCubemapShader() ) : null == this._equirectShader && ( this._equirectShader = _getEquirectShader() ); const r = e.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new Mesh( _lodPlanes[ 0 ], r ), o = r.uniforms; o.envMap.value = e, e.isCubeTexture || o.texelSize.value.set( 1 / e.image.width, 1 / e.image.height ), o.inputEncoding.value = ENCODINGS[ e.encoding ], o.outputEncoding.value = ENCODINGS[ t.texture.encoding ], _setViewport( t, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX ), n.setRenderTarget( t ), n.render( i, _flatCamera );

	}_applyPMREM( e ) {

		const t = this._renderer, n = t.autoClear; t.autoClear = ! 1; for ( let t = 1; t < TOTAL_LODS; t ++ ) {

			const n = Math.sqrt( _sigmas[ t ] * _sigmas[ t ] - _sigmas[ t - 1 ] * _sigmas[ t - 1 ] ), r = _axisDirections[ ( t - 1 ) % _axisDirections.length ]; this._blur( e, t - 1, t, n, r );

		}

		t.autoClear = n;

	}_blur( e, t, n, r, i ) {

		const o = this._pingPongRenderTarget; this._halfBlur( e, o, t, n, r, 'latitudinal', i ), this._halfBlur( o, e, n, n, r, 'longitudinal', i );

	}_halfBlur( e, t, n, r, i, o, a ) {

		const s = this._renderer, c = this._blurMaterial; 'latitudinal' !== o && 'longitudinal' !== o && console.error( 'blur direction must be either latitudinal or longitudinal!' ); const l = new Mesh( _lodPlanes[ r ], c ), h = c.uniforms, u = _sizeLods[ n ] - 1, d = isFinite( i ) ? Math.PI / ( 2 * u ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 ), p = i / d, m = isFinite( i ) ? 1 + Math.floor( 3 * p ) : MAX_SAMPLES; m > MAX_SAMPLES && console.warn( `sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${MAX_SAMPLES}` ); const f = []; let g = 0; for ( let e = 0; e < MAX_SAMPLES; ++ e ) {

			const t = e / p, n = Math.exp( - t * t / 2 ); f.push( n ), 0 == e ? g += n : e < m && ( g += 2 * n );

		}

		for ( let e = 0; e < f.length; e ++ )f[ e ] = f[ e ] / g; h.envMap.value = e.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = 'latitudinal' === o, a && ( h.poleAxis.value = a ), h.dTheta.value = d, h.mipInt.value = LOD_MAX - n, h.inputEncoding.value = ENCODINGS[ e.texture.encoding ], h.outputEncoding.value = ENCODINGS[ e.texture.encoding ]; const v = _sizeLods[ r ]; _setViewport( t, 3 * Math.max( 0, SIZE_MAX - 2 * v ), ( 0 === r ? 0 : 2 * SIZE_MAX ) + 2 * v * ( r > LOD_MAX - LOD_MIN ? r - LOD_MAX + LOD_MIN : 0 ), 3 * v, 2 * v ), s.setRenderTarget( t ), s.render( l, _flatCamera );

	}

} function _isLDR( e ) {

	return void 0 !== e && e.type === UnsignedByteType && ( e.encoding === LinearEncoding || e.encoding === sRGBEncoding || e.encoding === GammaEncoding );

}

function _createPlanes() {

	const e = [], t = [], n = []; let r = LOD_MAX; for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const o = Math.pow( 2, r ); t.push( o ); let a = 1 / o; i > LOD_MAX - LOD_MIN ? a = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ] : 0 == i && ( a = 0 ), n.push( a ); const s = 1 / ( o - 1 ), c = - s / 2, l = 1 + s / 2, h = [ c, c, l, c, l, l, c, c, l, l, c, l ], u = 6, d = 6, p = 3, m = 2, f = 1, g = new Float32Array( p * d * u ), v = new Float32Array( m * d * u ), y = new Float32Array( f * d * u ); for ( let e = 0; e < u; e ++ ) {

			const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : - 1, r = [ t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0 ]; g.set( r, p * d * e ), v.set( h, m * d * e ); const i = [ e, e, e, e, e, e ]; y.set( i, f * d * e );

		}

		const _ = new BufferGeometry(); _.setAttribute( 'position', new BufferAttribute( g, p ) ), _.setAttribute( 'uv', new BufferAttribute( v, m ) ), _.setAttribute( 'faceIndex', new BufferAttribute( y, f ) ), e.push( _ ), r > LOD_MIN && r --;

	}

	return { _lodPlanes: e, _sizeLods: t, _sigmas: n };

}

function _createRenderTarget( e ) {

	const t = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, e ); return t.texture.mapping = CubeUVReflectionMapping, t.texture.name = 'PMREM.cubeUv', t.scissorTest = ! 0, t;

}

function _setViewport( e, t, n, r, i ) {

	e.viewport.set( t, n, r, i ), e.scissor.set( t, n, r, i );

}

function _getBlurShader( e ) {

	return new RawShaderMaterial( { name: 'SphericalGaussianBlur', defines: { n: e }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: new Float32Array( e ) }, latitudinal: { value: ! 1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: new Vector3( 0, 1, 0 ) }, inputEncoding: { value: ENCODINGS[ LinearEncoding ] }, outputEncoding: { value: ENCODINGS[ LinearEncoding ] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: NoBlending, depthTest: ! 1, depthWrite: ! 1 } );

}

function _getEquirectShader() {

	return new RawShaderMaterial( { name: 'EquirectangularToCubeUV', uniforms: { envMap: { value: null }, texelSize: { value: new Vector2( 1, 1 ) }, inputEncoding: { value: ENCODINGS[ LinearEncoding ] }, outputEncoding: { value: ENCODINGS[ LinearEncoding ] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: NoBlending, depthTest: ! 1, depthWrite: ! 1 } );

}

function _getCubemapShader() {

	return new RawShaderMaterial( { name: 'CubemapToCubeUV', uniforms: { envMap: { value: null }, inputEncoding: { value: ENCODINGS[ LinearEncoding ] }, outputEncoding: { value: ENCODINGS[ LinearEncoding ] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: NoBlending, depthTest: ! 1, depthWrite: ! 1 } );

}

function _getCommonVertexShader() {

	return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t';

}

function _getEncodings() {

	return '\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t';

}

function Face4( e, t, n, r, i, o, a ) {

	return console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' ), new Face3( e, t, n, i, o, a );

}

const LineStrip = 0, LinePieces = 1, NoColors = 0, FaceColors = 1, VertexColors = 2; function MeshFaceMaterial( e ) {

	return console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' ), e;

}

function MultiMaterial( e = [] ) {

	return console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' ), e.isMultiMaterial = ! 0, e.materials = e, e.clone = function () {

		return e.slice();

	}, e;

}

function PointCloud( e, t ) {

	return console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' ), new Points( e, t );

}

function Particle( e ) {

	return console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' ), new Sprite( e );

}

function ParticleSystem( e, t ) {

	return console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' ), new Points( e, t );

}

function PointCloudMaterial( e ) {

	return console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' ), new PointsMaterial( e );

}

function ParticleBasicMaterial( e ) {

	return console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' ), new PointsMaterial( e );

}

function ParticleSystemMaterial( e ) {

	return console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' ), new PointsMaterial( e );

}

function Vertex( e, t, n ) {

	return console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' ), new Vector3( e, t, n );

}

function DynamicBufferAttribute( e, t ) {

	return console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' ), new BufferAttribute( e, t ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( e, t ) {

	return console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' ), new Int8BufferAttribute( e, t );

}

function Uint8Attribute( e, t ) {

	return console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' ), new Uint8BufferAttribute( e, t );

}

function Uint8ClampedAttribute( e, t ) {

	return console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' ), new Uint8ClampedBufferAttribute( e, t );

}

function Int16Attribute( e, t ) {

	return console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' ), new Int16BufferAttribute( e, t );

}

function Uint16Attribute( e, t ) {

	return console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' ), new Uint16BufferAttribute( e, t );

}

function Int32Attribute( e, t ) {

	return console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' ), new Int32BufferAttribute( e, t );

}

function Uint32Attribute( e, t ) {

	return console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' ), new Uint32BufferAttribute( e, t );

}

function Float32Attribute( e, t ) {

	return console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' ), new Float32BufferAttribute( e, t );

}

function Float64Attribute( e, t ) {

	return console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' ), new Float64BufferAttribute( e, t );

}

function ClosedSplineCurve3( e ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' ), CatmullRomCurve3.call( this, e ), this.type = 'catmullrom', this.closed = ! 0;

}

function SplineCurve3( e ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' ), CatmullRomCurve3.call( this, e ), this.type = 'catmullrom';

}

function Spline( e ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' ), CatmullRomCurve3.call( this, e ), this.type = 'catmullrom';

}

function AxisHelper( e ) {

	return console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' ), new AxesHelper( e );

}

function BoundingBoxHelper( e, t ) {

	return console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' ), new BoxHelper( e, t );

}

function EdgesHelper( e, t ) {

	return console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' ), new LineSegments( new EdgesGeometry( e.geometry ), new LineBasicMaterial( { color: void 0 !== t ? t : 16777215 } ) );

}

function WireframeHelper( e, t ) {

	return console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' ), new LineSegments( new WireframeGeometry( e.geometry ), new LineBasicMaterial( { color: void 0 !== t ? t : 16777215 } ) );

}

function XHRLoader( e ) {

	return console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' ), new FileLoader( e );

}

function BinaryTextureLoader( e ) {

	return console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' ), new DataTextureLoader( e );

}

function WebGLRenderTargetCube( e, t, n ) {

	return console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' ), new WebGLCubeRenderTarget( e, n );

}

Curve.create = function ( e, t ) {

	return console.log( 'THREE.Curve.create() has been deprecated' ), e.prototype = Object.create( Curve.prototype ), e.prototype.constructor = e, e.prototype.getPoint = t, e;

}, Object.assign( CurvePath.prototype, { createPointsGeometry: function ( e ) {

	console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' ); const t = this.getPoints( e ); return this.createGeometry( t );

}, createSpacedPointsGeometry: function ( e ) {

	console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' ); const t = this.getSpacedPoints( e ); return this.createGeometry( t );

}, createGeometry: function ( e ) {

	console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' ); const t = new Geometry(); for ( let n = 0, r = e.length; n < r; n ++ ) {

		const r = e[ n ]; t.vertices.push( new Vector3( r.x, r.y, r.z || 0 ) );

	}

	return t;

} } ), Object.assign( Path.prototype, { fromPoints: function ( e ) {

	return console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' ), this.setFromPoints( e );

} } ), ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype ), SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype ), Spline.prototype = Object.create( CatmullRomCurve3.prototype ), Object.assign( Spline.prototype, { initFromArray: function () {

	console.error( 'THREE.Spline: .initFromArray() has been removed.' );

}, getControlPointsArray: function () {

	console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

}, reparametrizeByArcLength: function () {

	console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

} } ), GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

}, SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

}, Object.assign( Loader.prototype, { extractUrlBase: function ( e ) {

	return console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' ), LoaderUtils.extractUrlBase( e );

} } ), Loader.Handlers = { add: function () {

	console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

}, get: function () {

	console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

} }, Object.assign( Box2.prototype, { center: function ( e ) {

	return console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' ), this.getCenter( e );

}, empty: function () {

	return console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' ), this.isEmpty();

}, isIntersectionBox: function ( e ) {

	return console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' ), this.intersectsBox( e );

}, size: function ( e ) {

	return console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' ), this.getSize( e );

} } ), Object.assign( Box3.prototype, { center: function ( e ) {

	return console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' ), this.getCenter( e );

}, empty: function () {

	return console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' ), this.isEmpty();

}, isIntersectionBox: function ( e ) {

	return console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' ), this.intersectsBox( e );

}, isIntersectionSphere: function ( e ) {

	return console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' ), this.intersectsSphere( e );

}, size: function ( e ) {

	return console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' ), this.getSize( e );

} } ), Object.assign( Sphere.prototype, { empty: function () {

	return console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' ), this.isEmpty();

} } ), Frustum.prototype.setFromMatrix = function ( e ) {

	return console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' ), this.setFromProjectionMatrix( e );

}, Line3.prototype.center = function ( e ) {

	return console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' ), this.getCenter( e );

}, Object.assign( MathUtils, { random16: function () {

	return console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' ), Math.random();

}, nearestPowerOfTwo: function ( e ) {

	return console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' ), MathUtils.floorPowerOfTwo( e );

}, nextPowerOfTwo: function ( e ) {

	return console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' ), MathUtils.ceilPowerOfTwo( e );

} } ), Object.assign( Matrix3.prototype, { flattenToArrayOffset: function ( e, t ) {

	return console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' ), this.toArray( e, t );

}, multiplyVector3: function ( e ) {

	return console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' ), e.applyMatrix3( this );

}, multiplyVector3Array: function () {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

}, applyToBufferAttribute: function ( e ) {

	return console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' ), e.applyMatrix3( this );

}, applyToVector3Array: function () {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

}, getInverse: function ( e ) {

	return console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' ), this.copy( e ).invert();

} } ), Object.assign( Matrix4.prototype, { extractPosition: function ( e ) {

	return console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' ), this.copyPosition( e );

}, flattenToArrayOffset: function ( e, t ) {

	return console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' ), this.toArray( e, t );

}, getPosition: function () {

	return console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' ), ( new Vector3() ).setFromMatrixColumn( this, 3 );

}, setRotationFromQuaternion: function ( e ) {

	return console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' ), this.makeRotationFromQuaternion( e );

}, multiplyToArray: function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

}, multiplyVector3: function ( e ) {

	return console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' ), e.applyMatrix4( this );

}, multiplyVector4: function ( e ) {

	return console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' ), e.applyMatrix4( this );

}, multiplyVector3Array: function () {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

}, rotateAxis: function ( e ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' ), e.transformDirection( this );

}, crossVector: function ( e ) {

	return console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' ), e.applyMatrix4( this );

}, translate: function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

}, rotateX: function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

}, rotateY: function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

}, rotateZ: function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

}, rotateByAxis: function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

}, applyToBufferAttribute: function ( e ) {

	return console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' ), e.applyMatrix4( this );

}, applyToVector3Array: function () {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

}, makeFrustum: function ( e, t, n, r, i, o ) {

	return console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' ), this.makePerspective( e, t, r, n, i, o );

}, getInverse: function ( e ) {

	return console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' ), this.copy( e ).invert();

} } ), Plane.prototype.isIntersectionLine = function ( e ) {

	return console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' ), this.intersectsLine( e );

}, Object.assign( Quaternion.prototype, { multiplyVector3: function ( e ) {

	return console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' ), e.applyQuaternion( this );

}, inverse: function () {

	return console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' ), this.invert();

} } ), Object.assign( Ray.prototype, { isIntersectionBox: function ( e ) {

	return console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' ), this.intersectsBox( e );

}, isIntersectionPlane: function ( e ) {

	return console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' ), this.intersectsPlane( e );

}, isIntersectionSphere: function ( e ) {

	return console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' ), this.intersectsSphere( e );

} } ), Object.assign( Triangle.prototype, { area: function () {

	return console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' ), this.getArea();

}, barycoordFromPoint: function ( e, t ) {

	return console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' ), this.getBarycoord( e, t );

}, midpoint: function ( e ) {

	return console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' ), this.getMidpoint( e );

}, normal: function ( e ) {

	return console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' ), this.getNormal( e );

}, plane: function ( e ) {

	return console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' ), this.getPlane( e );

} } ), Object.assign( Triangle, { barycoordFromPoint: function ( e, t, n, r, i ) {

	return console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' ), Triangle.getBarycoord( e, t, n, r, i );

}, normal: function ( e, t, n, r ) {

	return console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' ), Triangle.getNormal( e, t, n, r );

} } ), Object.assign( Shape.prototype, { extractAllPoints: function ( e ) {

	return console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' ), this.extractPoints( e );

}, extrude: function ( e ) {

	return console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' ), new ExtrudeGeometry( this, e );

}, makeGeometry: function ( e ) {

	return console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' ), new ShapeGeometry( this, e );

} } ), Object.assign( Vector2.prototype, { fromAttribute: function ( e, t, n ) {

	return console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' ), this.fromBufferAttribute( e, t, n );

}, distanceToManhattan: function ( e ) {

	return console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' ), this.manhattanDistanceTo( e );

}, lengthManhattan: function () {

	return console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' ), this.manhattanLength();

} } ), Object.assign( Vector3.prototype, { setEulerFromRotationMatrix: function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

}, setEulerFromQuaternion: function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

}, getPositionFromMatrix: function ( e ) {

	return console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' ), this.setFromMatrixPosition( e );

}, getScaleFromMatrix: function ( e ) {

	return console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' ), this.setFromMatrixScale( e );

}, getColumnFromMatrix: function ( e, t ) {

	return console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' ), this.setFromMatrixColumn( t, e );

}, applyProjection: function ( e ) {

	return console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' ), this.applyMatrix4( e );

}, fromAttribute: function ( e, t, n ) {

	return console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' ), this.fromBufferAttribute( e, t, n );

}, distanceToManhattan: function ( e ) {

	return console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' ), this.manhattanDistanceTo( e );

}, lengthManhattan: function () {

	return console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' ), this.manhattanLength();

} } ), Object.assign( Vector4.prototype, { fromAttribute: function ( e, t, n ) {

	return console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' ), this.fromBufferAttribute( e, t, n );

}, lengthManhattan: function () {

	return console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' ), this.manhattanLength();

} } ), Object.assign( Geometry.prototype, { computeTangents: function () {

	console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

}, computeLineDistances: function () {

	console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

}, applyMatrix: function ( e ) {

	return console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' ), this.applyMatrix4( e );

} } ), Object.assign( Object3D.prototype, { getChildByName: function ( e ) {

	return console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' ), this.getObjectByName( e );

}, renderDepth: function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

}, translate: function ( e, t ) {

	return console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' ), this.translateOnAxis( t, e );

}, getWorldRotation: function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

}, applyMatrix: function ( e ) {

	return console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' ), this.applyMatrix4( e );

} } ), Object.defineProperties( Object3D.prototype, { eulerOrder: { get: function () {

	return console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' ), this.rotation.order;

}, set: function ( e ) {

	console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' ), this.rotation.order = e;

} }, useQuaternion: { get: function () {

	console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

}, set: function () {

	console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

} } } ), Object.assign( Mesh.prototype, { setDrawMode: function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

} } ), Object.defineProperties( Mesh.prototype, { drawMode: { get: function () {

	return console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' ), 0;

}, set: function () {

	console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

} } } ), Object.defineProperties( LOD.prototype, { objects: { get: function () {

	return console.warn( 'THREE.LOD: .objects has been renamed to .levels.' ), this.levels;

} } } ), Object.defineProperty( Skeleton.prototype, 'useVertexTexture', { get: function () {

	console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

}, set: function () {

	console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

} } ), SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

}, Object.defineProperty( Curve.prototype, '__arcLengthDivisions', { get: function () {

	return console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' ), this.arcLengthDivisions;

}, set: function ( e ) {

	console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' ), this.arcLengthDivisions = e;

} } ), PerspectiveCamera.prototype.setLens = function ( e, t ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.' ), void 0 !== t && ( this.filmGauge = t ), this.setFocalLength( e );

}, Object.defineProperties( Light.prototype, { onlyShadow: { set: function () {

	console.warn( 'THREE.Light: .onlyShadow has been removed.' );

} }, shadowCameraFov: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' ), this.shadow.camera.fov = e;

} }, shadowCameraLeft: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' ), this.shadow.camera.left = e;

} }, shadowCameraRight: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' ), this.shadow.camera.right = e;

} }, shadowCameraTop: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' ), this.shadow.camera.top = e;

} }, shadowCameraBottom: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' ), this.shadow.camera.bottom = e;

} }, shadowCameraNear: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' ), this.shadow.camera.near = e;

} }, shadowCameraFar: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' ), this.shadow.camera.far = e;

} }, shadowCameraVisible: { set: function () {

	console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

} }, shadowBias: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' ), this.shadow.bias = e;

} }, shadowDarkness: { set: function () {

	console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

} }, shadowMapWidth: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' ), this.shadow.mapSize.width = e;

} }, shadowMapHeight: { set: function ( e ) {

	console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' ), this.shadow.mapSize.height = e;

} } } ), Object.defineProperties( BufferAttribute.prototype, { length: { get: function () {

	return console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' ), this.array.length;

} }, dynamic: { get: function () {

	return console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' ), this.usage === DynamicDrawUsage;

}, set: function () {

	console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' ), this.setUsage( DynamicDrawUsage );

} } } ), Object.assign( BufferAttribute.prototype, { setDynamic: function ( e ) {

	return console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' ), this.setUsage( ! 0 === e ? DynamicDrawUsage : StaticDrawUsage ), this;

}, copyIndicesArray: function () {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

}, setArray: function () {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

} } ), Object.assign( BufferGeometry.prototype, { addIndex: function ( e ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' ), this.setIndex( e );

}, addAttribute: function ( e, t ) {

	return console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' ), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? 'index' === e ? ( console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' ), this.setIndex( t ), this ) : this.setAttribute( e, t ) : ( console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' ), this.setAttribute( e, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) ) );

}, addDrawCall: function ( e, t, n ) {

	void 0 !== n && console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' ), console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' ), this.addGroup( e, t );

}, clearDrawCalls: function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' ), this.clearGroups();

}, computeTangents: function () {

	console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

}, computeOffsets: function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

}, removeAttribute: function ( e ) {

	return console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' ), this.deleteAttribute( e );

}, applyMatrix: function ( e ) {

	return console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' ), this.applyMatrix4( e );

} } ), Object.defineProperties( BufferGeometry.prototype, { drawcalls: { get: function () {

	return console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' ), this.groups;

} }, offsets: { get: function () {

	return console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' ), this.groups;

} } } ), Object.defineProperties( InstancedBufferGeometry.prototype, { maxInstancedCount: { get: function () {

	return console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' ), this.instanceCount;

}, set: function ( e ) {

	console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' ), this.instanceCount = e;

} } } ), Object.defineProperties( Raycaster.prototype, { linePrecision: { get: function () {

	return console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' ), this.params.Line.threshold;

}, set: function ( e ) {

	console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' ), this.params.Line.threshold = e;

} } } ), Object.defineProperties( InterleavedBuffer.prototype, { dynamic: { get: function () {

	return console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' ), this.usage === DynamicDrawUsage;

}, set: function ( e ) {

	console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' ), this.setUsage( e );

} } } ), Object.assign( InterleavedBuffer.prototype, { setDynamic: function ( e ) {

	return console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' ), this.setUsage( ! 0 === e ? DynamicDrawUsage : StaticDrawUsage ), this;

}, setArray: function () {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

} } ), Object.assign( ExtrudeBufferGeometry.prototype, { getArrays: function () {

	console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

}, addShapeList: function () {

	console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

}, addShape: function () {

	console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

} } ), Object.assign( Scene.prototype, { dispose: function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

} } ), Object.defineProperties( Uniform.prototype, { dynamic: { set: function () {

	console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

} }, onUpdate: { value: function () {

	return console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' ), this;

} } } ), Object.defineProperties( Material.prototype, { wrapAround: { get: function () {

	console.warn( 'THREE.Material: .wrapAround has been removed.' );

}, set: function () {

	console.warn( 'THREE.Material: .wrapAround has been removed.' );

} }, overdraw: { get: function () {

	console.warn( 'THREE.Material: .overdraw has been removed.' );

}, set: function () {

	console.warn( 'THREE.Material: .overdraw has been removed.' );

} }, wrapRGB: { get: function () {

	return console.warn( 'THREE.Material: .wrapRGB has been removed.' ), new Color();

} }, shading: { get: function () {

	console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

}, set: function ( e ) {

	console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' ), this.flatShading = 1 === e;

} }, stencilMask: { get: function () {

	return console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' ), this.stencilFuncMask;

}, set: function ( e ) {

	console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' ), this.stencilFuncMask = e;

} } } ), Object.defineProperties( MeshPhongMaterial.prototype, { metal: { get: function () {

	return console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' ), ! 1;

}, set: function () {

	console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

} } } ), Object.defineProperties( MeshPhysicalMaterial.prototype, { transparency: { get: function () {

	return console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' ), this.transmission;

}, set: function ( e ) {

	console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' ), this.transmission = e;

} } } ), Object.defineProperties( ShaderMaterial.prototype, { derivatives: { get: function () {

	return console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' ), this.extensions.derivatives;

}, set: function ( e ) {

	console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' ), this.extensions.derivatives = e;

} } } ), Object.assign( WebGLRenderer.prototype, { clearTarget: function ( e, t, n, r ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' ), this.setRenderTarget( e ), this.clear( t, n, r );

}, animate: function ( e ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' ), this.setAnimationLoop( e );

}, getCurrentRenderTarget: function () {

	return console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' ), this.getRenderTarget();

}, getMaxAnisotropy: function () {

	return console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' ), this.capabilities.getMaxAnisotropy();

}, getPrecision: function () {

	return console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' ), this.capabilities.precision;

}, resetGLState: function () {

	return console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' ), this.state.reset();

}, supportsFloatTextures: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )." ), this.extensions.get( 'OES_texture_float' );

}, supportsHalfFloatTextures: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )." ), this.extensions.get( 'OES_texture_half_float' );

}, supportsStandardDerivatives: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )." ), this.extensions.get( 'OES_standard_derivatives' );

}, supportsCompressedTextureS3TC: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )." ), this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

}, supportsCompressedTexturePVRTC: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )." ), this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

}, supportsBlendMinMax: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )." ), this.extensions.get( 'EXT_blend_minmax' );

}, supportsVertexTextures: function () {

	return console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' ), this.capabilities.vertexTextures;

}, supportsInstancedArrays: function () {

	return console.warn( "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )." ), this.extensions.get( 'ANGLE_instanced_arrays' );

}, enableScissorTest: function ( e ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' ), this.setScissorTest( e );

}, initMaterial: function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

}, addPrePlugin: function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

}, addPostPlugin: function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

}, updateShadowMap: function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

}, setFaceCulling: function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

}, allocTextureUnit: function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

}, setTexture: function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

}, setTexture2D: function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

}, setTextureCube: function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

}, getActiveMipMapLevel: function () {

	return console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' ), this.getActiveMipmapLevel();

} } ), Object.defineProperties( WebGLRenderer.prototype, { shadowMapEnabled: { get: function () {

	return this.shadowMap.enabled;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' ), this.shadowMap.enabled = e;

} }, shadowMapType: { get: function () {

	return this.shadowMap.type;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' ), this.shadowMap.type = e;

} }, shadowMapCullFace: { get: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

} }, context: { get: function () {

	return console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' ), this.getContext();

} }, vr: { get: function () {

	return console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' ), this.xr;

} }, gammaInput: { get: function () {

	return console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' ), ! 1;

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

} }, gammaOutput: { get: function () {

	return console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' ), ! 1;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' ), this.outputEncoding = ! 0 === e ? sRGBEncoding : LinearEncoding;

} }, toneMappingWhitePoint: { get: function () {

	return console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' ), 1;

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

} } } ), Object.defineProperties( WebGLShadowMap.prototype, { cullFace: { get: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

} }, renderReverseSided: { get: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

} }, renderSingleSided: { get: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

}, set: function () {

	console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

} } } ), Object.defineProperties( WebGLRenderTarget.prototype, { wrapS: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' ), this.texture.wrapS;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' ), this.texture.wrapS = e;

} }, wrapT: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' ), this.texture.wrapT;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' ), this.texture.wrapT = e;

} }, magFilter: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' ), this.texture.magFilter;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' ), this.texture.magFilter = e;

} }, minFilter: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' ), this.texture.minFilter;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' ), this.texture.minFilter = e;

} }, anisotropy: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' ), this.texture.anisotropy;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' ), this.texture.anisotropy = e;

} }, offset: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' ), this.texture.offset;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' ), this.texture.offset = e;

} }, repeat: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' ), this.texture.repeat;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' ), this.texture.repeat = e;

} }, format: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' ), this.texture.format;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' ), this.texture.format = e;

} }, type: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' ), this.texture.type;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' ), this.texture.type = e;

} }, generateMipmaps: { get: function () {

	return console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' ), this.texture.generateMipmaps;

}, set: function ( e ) {

	console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' ), this.texture.generateMipmaps = e;

} } } ), Object.defineProperties( Audio.prototype, { load: { value: function ( e ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' ); const t = this; return ( new AudioLoader() ).load( e, function ( e ) {

		t.setBuffer( e );

	} ), this;

} }, startTime: { set: function () {

	console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

} } } ), AudioAnalyser.prototype.getData = function () {

	return console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' ), this.getFrequencyData();

}, CubeCamera.prototype.updateCubeMap = function ( e, t ) {

	return console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' ), this.update( e, t );

}, CubeCamera.prototype.clear = function ( e, t, n, r ) {

	return console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' ), this.renderTarget.clear( e, t, n, r );

};

const GeometryUtils = { merge: function ( e, t, n ) {

	let r; console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' ), t.isMesh && ( t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry ), e.merge( t, r, n );

}, center: function ( e ) {

	return console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' ), e.center();

} }; function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

ImageUtils.crossOrigin = void 0, ImageUtils.loadTexture = function ( e, t, n, r ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' ); const i = new TextureLoader(); i.setCrossOrigin( this.crossOrigin ); const o = i.load( e, n, void 0, r ); return t && ( o.mapping = t ), o;

}, ImageUtils.loadTextureCube = function ( e, t, n, r ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' ); const i = new CubeTextureLoader(); i.setCrossOrigin( this.crossOrigin ); const o = i.load( e, n, void 0, r ); return t && ( o.mapping = t ), o;

}, ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

}, ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

const SceneUtils = { createMultiMaterialObject: function () {

	console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

}, detach: function () {

	console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

}, attach: function () {

	console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

} }; function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: { revision: '124dev' } } ) );

var S = {}; ! function ( t ) {

	function i( t ) {

		this.Cc = - 1, this.ha = new xt(), this.pa = new xt(), this.a = new xt(); var i = t.position; this.ha.v = i.x, this.ha.A = i.y, this.ha.B = i.z, i = t.rotation, this.ha.o = i.e00, this.ha.f = i.e01, this.ha.h = i.e02, this.ha.i = i.e10, this.ha.m = i.e11, this.ha.j = i.e12, this.ha.l = i.e20, this.ha.g = i.e21, this.ha.s = i.e22; i = this.pa; var s = this.ha; i.v = s.v, i.A = s.A, i.B = s.B, i.o = s.o, i.f = s.f, i.h = s.h, i.i = s.i, i.m = s.m, i.j = s.j, i.l = s.l, i.g = s.g, i.s = s.s, i = this.a, s = this.ha, i.v = s.v, i.A = s.A, i.B = s.B, i.o = s.o, i.f = s.f, i.h = s.h, i.i = s.i, i.m = s.m, i.j = s.j, i.l = s.l, i.g = s.g, i.s = s.s, this.hk = t.restitution, this.Xj = t.friction, this.Dk = t.density, this.Kb = t.geometry, this.Tj = t.collisionGroup, this.Uj = t.collisionMask, this.yd = t.contactCallback, this.u = new Et(), this.tb = null, this.rc = new dt();

	}

	function s() {}

	function h( t ) {

		this.Fi = this.Dc = this.ia = this.M = null, this.zg = 0, this.kc = this.Ob = null, this.Ae = 0, this.Ze = this.ze = null, this.kh = 0; var i = t.linearVelocity; this.gb = i.x, this.hb = i.y, this.ib = i.z, i = t.angularVelocity, this.kb = i.x, this.lb = i.y, this.mb = i.z, this.Wc = this.Vc = this.Uc = this.$c = this.Zc = this.Yc = 0, this.pa = new xt(), this.a = new xt(), i = t.position, this.pa.v = i.x, this.pa.A = i.y, this.pa.B = i.z, i = t.rotation, this.pa.o = i.e00, this.pa.f = i.e01, this.pa.h = i.e02, this.pa.i = i.e10, this.pa.m = i.e11, this.pa.j = i.e12, this.pa.l = i.e20, this.pa.g = i.e21, this.pa.s = i.e22; i = this.a; var s = this.pa; i.v = s.v, i.A = s.A, i.B = s.B, i.o = s.o, i.f = s.f, i.h = s.h, i.i = s.i, i.m = s.m, i.j = s.j, i.l = s.l, i.g = s.g, i.s = s.s, this.Lb = t.type, this.yb = 0, this.Gb = ! 1, this.Bk = t.autoSleep, this.Y = this.X = this.W = this.V = this.U = this.T = this.S = this.R = this.P = this.yi = this.xi = this.wi = this.vi = this.ui = this.ti = this.si = this.ri = this.pi = this.Za = this.Ya = this.Xa = this.Wa = this.Va = this.Ua = this.Ta = this.Sa = this.Ra = this.Id = this.Hd = this.Gd = this.Fd = this.Ed = this.Dd = this.Cd = this.Bd = this.Ad = this.$a = this.Pc = 0, this.$j = t.linearDamping, this.Qj = t.angularDamping, this.xf = this.wf = this.vf = this.Oh = this.Nh = this.Mh = 0, this.N = new dt( 1, 1, 1 ), this.Nf = ! 1, this.eh = 1, this.oc = null;

	}

	function a() {

		this.mass = 0, this.localInertia = new ft();

	}

	function e( t ) {

		Y.call( this ), this.$ = t, this.info = new R(), this.ac = Array( gt.maxJacobianRows ), t = 0; for ( var i = this.ac.length; t < i; ) {

			var s = t ++; this.ac[ s ] = new f();

		}

	}

	function o( t ) {

		Y.call( this ), this.Ji = t, this.info = new N(), this.ac = Array( gt.maxManifoldPoints ), t = 0; for ( var i = this.ac.length; t < i; ) {

			var s = t ++; this.ac[ s ] = new u();

		}

	}

	function r( t ) {

		this.Ag = t, this.wk = Array( this.Ag ), this.$a = Array( this.Ag ), this.cj = Array( this.Ag ), t = 0; for ( var i = this.Ag; t < i; ) {

			var s = t ++; this.wk[ s ] = Array( this.Ag ), this.$a[ s ] = Array( this.Ag ), this.cj[ s ] = Array( this.Ag ); for ( var h = 0, a = this.Ag; h < a; ) {

				var e = h ++; this.wk[ s ][ e ] = 0, this.$a[ s ][ e ] = 0, this.cj[ s ][ e ] = 0;

			}

		}

		for ( this.ak = 1 << this.Ag, this.Sj = Array( this.ak ), this.Ck = Array( this.ak ), t = 0, i = this.ak; t < i; ) {

			h = ( 15 & ( h = ( 51 & ( h = ( 85 & ( h = s = t ++ ) ) + ( h >> 1 & 85 ) ) ) + ( h >> 2 & 51 ) ) ) + ( h >> 4 & 15 ), a = Array( h ), e = 0; for ( var o = h; e < o; ) {

				var r = e ++; a[ r ] = Array( h ); for ( var n = 0, p = h; n < p; ) {

					var l = n ++; a[ r ][ l ] = 0;

				}

			}

			this.Sj[ s ] = ! 1, this.Ck[ s ] = a;

		}

	}

	function n( t ) {

		Y.call( this ), this.$ = t, this.info = new R(), t = gt.maxJacobianRows, this.ei = new r( t ), this.Se = new l( t ), this.ac = Array( t ); for ( var i = 0, s = this.ac.length; i < s; ) {

			var h = i ++; this.ac[ h ] = new f();

		}

		for ( i = this.Se.Th.length, this.Ml = new p( i ), this.Ki = new p( i ), this.Qg = Array( t ), this.Yh = Array( t ), this.Cf = Array( t ), this.Aj = Array( t ), i = 0; i < t; )s = i ++, this.Qg[ s ] = 0, this.Yh[ s ] = 0, this.Cf[ s ] = 0, this.Aj[ s ] = 0;

	}

	function p( t ) {

		this.n = t, this.sc = Array( t ), this.kf = Array( t ); for ( var i = 0; i < t; ) {

			var s = i ++; this.sc[ s ] = s;

		}

	}

	function l( t ) {

		this.Qn = t, this.jf = 0, this.Th = Array( 1 << t ), this.cf = new c( t );

	}

	function c( t ) {

		this.size = t, this.Sc = 0, this.uh = Array( t ), this.zh = Array( t ), this.ie = 0, this.Mg = Array( t );

	}

	function y( t ) {

		this.uh = Array( t ), this.Mg = Array( t ), this.zh = Array( t ), this.il = Array( t ), this.ie = this.Sc = 0;

	}

	function f() {

		this.Ff = this.mass = this.pd = this.od = this.nd = this.md = this.ld = this.kd = this.vd = this.ud = this.td = this.sd = this.rd = this.qd = 0;

	}

	function u() {

		this.Bm = this.Am = this.zm = this.ym = this.he = this.rk = this.qk = this.pk = this.nk = this.mk = this.lk = this.xl = this.wl = this.vl = this.ul = this.tl = this.sl = this.Jj = this.Ij = this.Hj = this.Gj = this.Fj = this.Ej = this.Dl = this.Cl = this.Bl = this.Al = this.zl = this.yl = this.bg = this.ag = this.$f = this.Zf = this.Yf = this.Xf = this.di = this.ci = this.bi = this.ai = this.$h = this.Zh = 0;

	}

	function b() {}

	function v() {

		O.call( this ), this.localAxis1 = new dt( 1, 0, 0 ), this.localAxis2 = new dt( 1, 0, 0 ), this.springDamper1 = new d(), this.springDamper2 = new d(), this.limitMotor1 = new j(), this.limitMotor2 = new j();

	}

	function g( t ) {

		F.call( this, t, q.UNIVERSAL ); var i = t.localAxis1; this.qa = i.x, this.ra = i.y, this.sa = i.z, i = t.localAxis2, this.Mc = i.x, this.Nc = i.y, this.Oc = i.z, this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ? ( 0 < ( i = this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ) && ( i = 1 / Math.sqrt( i ) ), this.qa *= i, this.ra *= i, this.sa *= i ) : ( this.qa = 1, this.sa = this.ra = 0 ), this.Mc * this.Mc + this.Nc * this.Nc + this.Oc * this.Oc ? ( 0 < ( i = this.Mc * this.Mc + this.Nc * this.Nc + this.Oc * this.Oc ) && ( i = 1 / Math.sqrt( i ) ), this.Mc *= i, this.Nc *= i, this.Oc *= i ) : ( this.Nc = this.Mc = 0, this.Oc = 1 ); var s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d = this.C.a; i = this.D.a; f = d.o * this.qa + d.f * this.ra + d.h * this.sa, u = d.i * this.qa + d.m * this.ra + d.j * this.sa, s = d.l * this.qa + d.g * this.ra + d.s * this.sa, b = i.o * this.Mc + i.f * this.Nc + i.h * this.Oc, ( o = ( v = i.i * this.Mc + i.m * this.Nc + i.j * this.Oc ) * s - ( y = i.l * this.Mc + i.g * this.Nc + i.s * this.Oc ) * u ) * o + ( r = y * f - b * s ) * r + ( n = b * u - v * f ) * n || ( n = s * s, ( o = f * f ) < ( r = u * u ) ? o < n ? ( o = 0, r = s * ( n = 1 / Math.sqrt( r + n ) ), n *= - u ) : ( o = u * ( n = 1 / Math.sqrt( o + r ) ), r = - f * n, n = 0 ) : r < n ? ( o = - s * ( n = 1 / Math.sqrt( n + o ) ), r = 0, n *= f ) : ( o = u * ( n = 1 / Math.sqrt( o + r ) ), r = - f * n, n = 0 ) ), h = u * n - s * r, a = s * o - f * n, e = f * r - u * o, p = r * y - n * v, l = n * b - o * y, c = o * v - r * b, g = d.o * f + d.i * u + d.l * s, x = d.f * f + d.m * u + d.g * s, s = d.h * f + d.j * u + d.s * s, this.qa = g, this.ra = x, this.sa = s, s = d.o * o + d.i * r + d.l * n, f = d.f * o + d.m * r + d.g * n, u = d.h * o + d.j * r + d.s * n, this.Ab = s, this.Bb = f, this.Cb = u, s = d.o * h + d.i * a + d.l * e, f = d.f * h + d.m * a + d.g * e, d = d.h * h + d.j * a + d.s * e, this.lc = s, this.mc = f, this.nc = d, d = i.o * p + i.i * l + i.l * c, h = i.f * p + i.m * l + i.g * c, p = i.h * p + i.j * l + i.s * c, this.nb = d, this.ob = h, this.pb = p, d = i.o * o + i.i * r + i.l * n, p = i.f * o + i.m * r + i.g * n, o = i.h * o + i.j * r + i.s * n, this.gh = d, this.hh = p, this.ih = o, o = i.o * b + i.i * v + i.l * y, r = i.f * b + i.m * v + i.g * y, i = i.h * b + i.j * v + i.s * y, this.Mc = o, this.Nc = r, this.Oc = i, this.Oi = this.Pl = this.Ni = 0, this.Lm = this.Km = this.Jm = ! 1, this.Yk = t.springDamper1.clone(), this.Zk = t.springDamper2.clone(), this.Qk = t.limitMotor1.clone(), this.Rk = t.limitMotor2.clone();

	}

	function x() {

		this.lowerLimit = 1, this.motorForce = this.upperLimit = 0;

	}

	function d() {

		this.dampingRatio = this.frequency = 0, this.useSymplecticEuler = ! 1;

	}

	function z() {

		O.call( this ), this.springDamper = new d();

	}

	function m( t ) {

		F.call( this, t, 0 ), this.Ce = t.springDamper.clone();

	}

	function j() {

		this.lowerLimit = 1, this.motorTorque = this.upperLimit = 0;

	}

	function M() {

		O.call( this ), this.localAxis1 = new dt( 1, 0, 0 ), this.localAxis2 = new dt( 1, 0, 0 ), this.springDamper = new d(), this.limitMotor = new j();

	}

	function A( t ) {

		F.call( this, t, 1 ); var i, s, h, a, e, o, r, n, p = t.localAxis1; this.qa = p.x, this.ra = p.y, this.sa = p.z, p = t.localAxis2, this.nb = p.x, this.ob = p.y, this.pb = p.z, this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ? ( 0 < ( p = this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ) && ( p = 1 / Math.sqrt( p ) ), this.qa *= p, this.ra *= p, this.sa *= p ) : ( this.qa = 1, this.sa = this.ra = 0 ), this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ? ( 0 < ( p = this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ) && ( p = 1 / Math.sqrt( p ) ), this.nb *= p, this.ob *= p, this.pb *= p ) : ( this.nb = 1, this.pb = this.ob = 0 ), - .999999999 > ( s = this.qa * this.nb + this.ra * this.ob + this.sa * this.pb ) ? ( p = this.qa, i = this.ra, e = ( h = this.sa ) * h, ( s = p * p ) < ( a = i * i ) ? s < e ? ( s = 0, h *= a = 1 / Math.sqrt( a + e ), a *= - i ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ) : a < e ? ( s = - h * ( a = 1 / Math.sqrt( e + s ) ), h = 0, a *= p ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ), p = s, i = h, s = a, h = 0 ) : ( p = this.ra * this.pb - this.sa * this.ob, i = this.sa * this.nb - this.qa * this.pb, a = this.qa * this.ob - this.ra * this.nb, p *= s = .5 / ( h = Math.sqrt( .5 * ( 1 + s ) ) ), i *= s, s *= a ), o = i, i = h, n = p * ( c = 2 * p ); var l = o * ( e = 2 * o ); a = s * ( h = 2 * s ), s = p * e, r = o * h, o = p * h; var c = i * c, y = i * e; p = 1 - l - a, i = s - ( e = i * h ), h = o + y, s += e, a = 1 - n - a, e = r - c, o -= y, r += c, n = 1 - n - l; var f = ( l = this.qa ) * l, u = ( c = this.ra ) * c, b = ( y = this.sa ) * y; f < u ? f < b ? ( f = 1 / Math.sqrt( u + b ), this.Ab = 0, this.Bb = y * f, this.Cb = - c * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ) : u < b ? ( f = 1 / Math.sqrt( b + f ), this.Ab = - y * f, this.Bb = 0, this.Cb = l * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ), this.lc = this.ra * this.Cb - this.sa * this.Bb, this.mc = this.sa * this.Ab - this.qa * this.Cb, this.nc = this.qa * this.Bb - this.ra * this.Ab, l = p * this.qa + i * this.ra + h * this.sa, c = s * this.qa + a * this.ra + e * this.sa, y = o * this.qa + r * this.ra + n * this.sa, this.nb = l, this.ob = c, this.pb = y, l = p * this.Ab + i * this.Bb + h * this.Cb, c = s * this.Ab + a * this.Bb + e * this.Cb, y = o * this.Ab + r * this.Bb + n * this.Cb, this.gh = l, this.hh = c, this.ih = y, p = p * this.lc + i * this.mc + h * this.nc, i = s * this.lc + a * this.mc + e * this.nc, h = o * this.lc + r * this.mc + n * this.nc, this.Mc = p, this.Nc = i, this.Oc = h, this.Fe = this.Ee = this.angle = 0, this.da = new I( this ), this.Ce = t.springDamper.clone(), this.Rh = t.limitMotor.clone();

	}

	function w() {

		O.call( this ), this.localTwistAxis1 = new dt( 1, 0, 0 ), this.localTwistAxis2 = new dt( 1, 0, 0 ), this.localSwingAxis1 = new dt( 0, 1, 0 ), this.twistSpringDamper = new d(), this.swingSpringDamper = new d(), this.twistLimitMotor = new j(), this.maxSwingAngle2 = this.maxSwingAngle1 = 3.14159265358979;

	}

	function D( t ) {

		F.call( this, t, q.RAGDOLL ); var i, s, h, a, e = t.localTwistAxis1; if ( this.qa = e.x, this.ra = e.y, this.sa = e.z, e = t.localSwingAxis1, this.Ab = e.x, this.Bb = e.y, this.Cb = e.z, e = t.localTwistAxis2, this.nb = e.x, this.ob = e.y, this.pb = e.z, this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ? ( 0 < ( e = this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ) && ( e = 1 / Math.sqrt( e ) ), this.qa *= e, this.ra *= e, this.sa *= e ) : ( this.qa = 1, this.sa = this.ra = 0 ), this.lc = this.ra * this.Cb - this.sa * this.Bb, this.mc = this.sa * this.Ab - this.qa * this.Cb, this.nc = this.qa * this.Bb - this.ra * this.Ab, this.lc * this.lc + this.mc * this.mc + this.nc * this.nc )0 < ( e = this.lc * this.lc + this.mc * this.mc + this.nc * this.nc ) && ( e = 1 / Math.sqrt( e ) ), this.lc *= e, this.mc *= e, this.nc *= e, this.Ab = this.mc * this.sa - this.nc * this.ra, this.Bb = this.nc * this.qa - this.lc * this.sa, this.Cb = this.lc * this.ra - this.mc * this.qa; else {

			e = this.qa; var o, r = this.ra, n = this.sa, p = r * r, l = n * n; ( o = e * e ) < p ? o < l ? ( o = 1 / Math.sqrt( p + l ), this.Ab = 0, this.Bb = n * o, this.Cb = - r * o ) : ( o = 1 / Math.sqrt( o + p ), this.Ab = r * o, this.Bb = - e * o, this.Cb = 0 ) : p < l ? ( o = 1 / Math.sqrt( l + o ), this.Ab = - n * o, this.Bb = 0, this.Cb = e * o ) : ( o = 1 / Math.sqrt( o + p ), this.Ab = r * o, this.Bb = - e * o, this.Cb = 0 ), this.lc = this.ra * this.Cb - this.sa * this.Bb, this.mc = this.sa * this.Ab - this.qa * this.Cb, this.nc = this.qa * this.Bb - this.ra * this.Ab;

		}

		- .999999999 > ( o = this.qa * this.nb + this.ra * this.ob + this.sa * this.pb ) ? ( e = this.qa, r = this.ra, l = ( n = this.sa ) * n, ( o = e * e ) < ( p = r * r ) ? o < l ? ( o = 0, n *= p = 1 / Math.sqrt( p + l ), p *= - r ) : ( o = r * ( p = 1 / Math.sqrt( o + p ) ), n = - e * p, p = 0 ) : p < l ? ( o = - n * ( p = 1 / Math.sqrt( l + o ) ), n = 0, p *= e ) : ( o = r * ( p = 1 / Math.sqrt( o + p ) ), n = - e * p, p = 0 ), e = o, r = n, o = p, n = 0 ) : ( e = this.ra * this.pb - this.sa * this.ob, r = this.sa * this.nb - this.qa * this.pb, p = this.qa * this.ob - this.ra * this.nb, e *= o = .5 / ( n = Math.sqrt( .5 * ( 1 + o ) ) ), r *= o, o *= p ), h = r; l = o, r = n; o = e * ( c = 2 * e ), p = h * ( s = 2 * h ), i = l * ( n = 2 * l ), l = e * s, a = h * n, h = e * n; var c = r * c, y = r * s; e = 1 - p - i, r = l - ( s = r * n ), n = h + y, l += s, i = 1 - o - i, s = a - c, h -= y, a += c, o = 1 - o - p, p = e * this.qa + r * this.ra + n * this.sa, c = l * this.qa + i * this.ra + s * this.sa, y = h * this.qa + a * this.ra + o * this.sa, this.nb = p, this.ob = c, this.pb = y, p = e * this.Ab + r * this.Bb + n * this.Cb, c = l * this.Ab + i * this.Bb + s * this.Cb, y = h * this.Ab + a * this.Bb + o * this.Cb, this.gh = p, this.hh = c, this.ih = y, e = e * this.lc + r * this.mc + n * this.nc, r = l * this.lc + i * this.mc + s * this.nc, n = h * this.lc + a * this.mc + o * this.nc, this.Mc = e, this.Nc = r, this.Oc = n, this.fl = t.twistSpringDamper.clone(), this.el = t.twistLimitMotor.clone(), this.$k = t.swingSpringDamper.clone(), this.bk = t.maxSwingAngle1, this.ck = t.maxSwingAngle2, this.bk < gt.minRagdollMaxSwingAngle && ( this.bk = gt.minRagdollMaxSwingAngle ), this.ck < gt.minRagdollMaxSwingAngle && ( this.ck = gt.minRagdollMaxSwingAngle ), this.nl = new j(), this.nl.lowerLimit = - 1, this.ii = this.hi = this.gi = this.le = this.ke = this.je = this.Nj = this.tj = this.kj = this.nl.upperLimit = 0;

	}

	function C() {

		O.call( this ), this.localAxis1 = new dt( 1, 0, 0 ), this.localAxis2 = new dt( 1, 0, 0 ), this.limitMotor = new x(), this.springDamper = new d();

	}

	function B( t ) {

		F.call( this, t, q.PRISMATIC ); var i, s, h, a, e, o, r, n, p = t.localAxis1; this.qa = p.x, this.ra = p.y, this.sa = p.z, p = t.localAxis2, this.nb = p.x, this.ob = p.y, this.pb = p.z, this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ? ( 0 < ( p = this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ) && ( p = 1 / Math.sqrt( p ) ), this.qa *= p, this.ra *= p, this.sa *= p ) : ( this.qa = 1, this.sa = this.ra = 0 ), this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ? ( 0 < ( p = this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ) && ( p = 1 / Math.sqrt( p ) ), this.nb *= p, this.ob *= p, this.pb *= p ) : ( this.nb = 1, this.pb = this.ob = 0 ), - .999999999 > ( s = this.qa * this.nb + this.ra * this.ob + this.sa * this.pb ) ? ( p = this.qa, i = this.ra, e = ( h = this.sa ) * h, ( s = p * p ) < ( a = i * i ) ? s < e ? ( s = 0, h *= a = 1 / Math.sqrt( a + e ), a *= - i ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ) : a < e ? ( s = - h * ( a = 1 / Math.sqrt( e + s ) ), h = 0, a *= p ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ), p = s, i = h, s = a, h = 0 ) : ( p = this.ra * this.pb - this.sa * this.ob, i = this.sa * this.nb - this.qa * this.pb, a = this.qa * this.ob - this.ra * this.nb, p *= s = .5 / ( h = Math.sqrt( .5 * ( 1 + s ) ) ), i *= s, s *= a ), o = i, i = h, n = p * ( c = 2 * p ); var l = o * ( e = 2 * o ); a = s * ( h = 2 * s ), s = p * e, r = o * h, o = p * h; var c = i * c, y = i * e; p = 1 - l - a, i = s - ( e = i * h ), h = o + y, s += e, a = 1 - n - a, e = r - c, o -= y, r += c, n = 1 - n - l; var f = ( l = this.qa ) * l, u = ( c = this.ra ) * c, b = ( y = this.sa ) * y; f < u ? f < b ? ( f = 1 / Math.sqrt( u + b ), this.Ab = 0, this.Bb = y * f, this.Cb = - c * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ) : u < b ? ( f = 1 / Math.sqrt( b + f ), this.Ab = - y * f, this.Bb = 0, this.Cb = l * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ), this.lc = this.ra * this.Cb - this.sa * this.Bb, this.mc = this.sa * this.Ab - this.qa * this.Cb, this.nc = this.qa * this.Bb - this.ra * this.Ab, l = p * this.qa + i * this.ra + h * this.sa, c = s * this.qa + a * this.ra + e * this.sa, y = o * this.qa + r * this.ra + n * this.sa, this.nb = l, this.ob = c, this.pb = y, l = p * this.Ab + i * this.Bb + h * this.Cb, c = s * this.Ab + a * this.Bb + e * this.Cb, y = o * this.Ab + r * this.Bb + n * this.Cb, this.gh = l, this.hh = c, this.ih = y, p = p * this.lc + i * this.mc + h * this.nc, i = s * this.lc + a * this.mc + e * this.nc, h = o * this.lc + r * this.mc + n * this.nc, this.Mc = p, this.Nc = i, this.Oc = h, this.da = new I( this ), this.Fe = this.Ee = this.rh = this.Ef = this.Df = this.eg = 0, this.Ce = t.springDamper.clone(), this.Rh = t.limitMotor.clone();

	}

	function q() {}

	function S( t ) {

		this.Pk = t;

	}

	function k() {

		this.ub = this.ad = this.ta = 0;

	}

	function I( t ) {

		this.$ = t, this.oe = this.ne = this.me = this.Sd = this.Rd = this.Qd = this.ed = this.dd = this.cd = 0;

	}

	function T() {

		O.call( this ), this.localAxis1 = new dt( 1, 0, 0 ), this.localAxis2 = new dt( 1, 0, 0 ), this.translationalLimitMotor = new x(), this.translationalSpringDamper = new d(), this.rotationalLimitMotor = new j(), this.rotationalSpringDamper = new d();

	}

	function O() {

		this.rigidBody2 = this.rigidBody1 = null, this.localAnchor1 = new dt(), this.localAnchor2 = new dt(), this.allowCollision = ! 1, this.solverType = gt.defaultJointConstraintSolverType, this.positionCorrectionAlgorithm = gt.defaultJointPositionCorrectionAlgorithm, this.breakTorque = this.breakForce = 0;

	}

	function L( t ) {

		F.call( this, t, 2 ); var i, s, h, a, e, o, r, n, p = t.localAxis1; this.qa = p.x, this.ra = p.y, this.sa = p.z, p = t.localAxis2, this.nb = p.x, this.ob = p.y, this.pb = p.z, this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ? ( 0 < ( p = this.qa * this.qa + this.ra * this.ra + this.sa * this.sa ) && ( p = 1 / Math.sqrt( p ) ), this.qa *= p, this.ra *= p, this.sa *= p ) : ( this.qa = 1, this.sa = this.ra = 0 ), this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ? ( 0 < ( p = this.nb * this.nb + this.ob * this.ob + this.pb * this.pb ) && ( p = 1 / Math.sqrt( p ) ), this.nb *= p, this.ob *= p, this.pb *= p ) : ( this.nb = 1, this.pb = this.ob = 0 ), - .999999999 > ( s = this.qa * this.nb + this.ra * this.ob + this.sa * this.pb ) ? ( p = this.qa, i = this.ra, e = ( h = this.sa ) * h, ( s = p * p ) < ( a = i * i ) ? s < e ? ( s = 0, h *= a = 1 / Math.sqrt( a + e ), a *= - i ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ) : a < e ? ( s = - h * ( a = 1 / Math.sqrt( e + s ) ), h = 0, a *= p ) : ( s = i * ( a = 1 / Math.sqrt( s + a ) ), h = - p * a, a = 0 ), p = s, i = h, s = a, h = 0 ) : ( p = this.ra * this.pb - this.sa * this.ob, i = this.sa * this.nb - this.qa * this.pb, a = this.qa * this.ob - this.ra * this.nb, p *= s = .5 / ( h = Math.sqrt( .5 * ( 1 + s ) ) ), i *= s, s *= a ), o = i, i = h, n = p * ( c = 2 * p ); var l = o * ( e = 2 * o ); a = s * ( h = 2 * s ), s = p * e, r = o * h, o = p * h; var c = i * c, y = i * e; p = 1 - l - a, i = s - ( e = i * h ), h = o + y, s += e, a = 1 - n - a, e = r - c, o -= y, r += c, n = 1 - n - l; var f = ( l = this.qa ) * l, u = ( c = this.ra ) * c, b = ( y = this.sa ) * y; f < u ? f < b ? ( f = 1 / Math.sqrt( u + b ), this.Ab = 0, this.Bb = y * f, this.Cb = - c * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ) : u < b ? ( f = 1 / Math.sqrt( b + f ), this.Ab = - y * f, this.Bb = 0, this.Cb = l * f ) : ( f = 1 / Math.sqrt( f + u ), this.Ab = c * f, this.Bb = - l * f, this.Cb = 0 ), this.lc = this.ra * this.Cb - this.sa * this.Bb, this.mc = this.sa * this.Ab - this.qa * this.Cb, this.nc = this.qa * this.Bb - this.ra * this.Ab, l = p * this.qa + i * this.ra + h * this.sa, c = s * this.qa + a * this.ra + e * this.sa, y = o * this.qa + r * this.ra + n * this.sa, this.nb = l, this.ob = c, this.pb = y, l = p * this.Ab + i * this.Bb + h * this.Cb, c = s * this.Ab + a * this.Bb + e * this.Cb, y = o * this.Ab + r * this.Bb + n * this.Cb, this.gh = l, this.hh = c, this.ih = y, p = p * this.lc + i * this.mc + h * this.nc, i = s * this.lc + a * this.mc + e * this.nc, h = o * this.lc + r * this.mc + n * this.nc, this.Mc = p, this.Nc = i, this.Oc = h, this.Ef = this.Df = this.eg = this.Fe = this.Ee = this.angle = 0, this.da = new I( this ), this.dl = t.translationalSpringDamper.clone(), this.cl = t.translationalLimitMotor.clone(), this.Xk = t.rotationalSpringDamper.clone(), this.Wk = t.rotationalLimitMotor.clone();

	}

	function F( t, i ) {

		switch ( this.rb = new S( this ), this.sb = new S( this ), this.Hc = gt.defaultJointPositionCorrectionAlgorithm, this.Lb = i, this.oc = null, this.C = t.rigidBody1, this.D = t.rigidBody2, this.Ak = t.allowCollision, this.Yi = t.breakForce, this.Zi = t.breakTorque, t.solverType ) {

			case 0:this.jk = new e( this ); break; case 1:this.jk = new n( this );

		}

		for ( i = t.localAnchor1, this.dj = i.x, this.ej = i.y, this.fj = i.z, t = t.localAnchor2, this.gj = t.x, this.hj = t.y, this.ij = t.z, this.Oc = this.Nc = this.Mc = this.ih = this.hh = this.gh = this.pb = this.ob = this.nb = this.nc = this.mc = this.lc = this.Cb = this.Bb = this.Ab = this.sa = this.ra = this.qa = this.Tf = this.Sf = this.Rf = this.Qf = this.Pf = this.Of = this.Xb = this.Wb = this.Vb = this.Ub = this.Tb = this.Sb = 0, this.Pb = Array( gt.maxJacobianRows ), t = 0, i = gt.maxJacobianRows; t < i; ) {

			var s = t ++; this.Pb[ s ] = new k();

		}

	}

	function P() {

		this.Aa = new H(), this.fb = this.motorSpeed = this.Ha = this.Ia = this.Ma = this.Fa = 0, this.ta = null;

	}

	function R() {

		this.Re = this.Qe = null, this.Ka = 0, this.rows = Array( gt.maxJacobianRows ); for ( var t = 0, i = this.rows.length; t < i; ) {

			var s = t ++; this.rows[ s ] = new P();

		}

	}

	function J() {

		this.Ng = new H(), this.Lj = new H(), this.Kj = new H(), this.friction = this.Ma = this.Fa = 0, this.ta = null;

	}

	function N() {

		this.Re = this.Qe = null, this.Ka = 0, this.rows = Array( gt.maxManifoldPoints ); for ( var t = 0, i = this.rows.length; t < i; ) {

			var s = t ++; this.rows[ s ] = new J();

		}

	}

	function H() {

		this.xc = this.ga = this.fa = this.ea = this.ca = this.ba = this.aa = this.Da = this.Ca = this.Ba = this.xa = this.wa = this.va = 0;

	}

	function K( t ) {

		this.Ja = t, this.Gl = 0, this.Hl = Array( gt.maxManifoldPoints ), t = 0; for ( var i = gt.maxManifoldPoints; t < i; ) {

			var s = t ++; this.Hl[ s ] = new G();

		}

	}

	function G() {

		this.Gc = this.Od = this.Nd = this.Md = this.Ld = this.Kd = this.Jd = this.gc = this.fc = this.ec = this.Fb = this.Eb = this.Db = this.sf = this.rf = this.qf = this.pf = this.nf = this.mf = 0, this.ae = new E(), this.lf = this.Pe = ! 1, this.Cc = - 1;

	}

	function V() {

		this.be = this.Xi = this.Wi = this.Vi = this.nj = this.mj = this.lj = this.yg = this.xg = this.wg = 0, this.wc = Array( gt.maxManifoldPoints ); for ( var t = 0, i = gt.maxManifoldPoints; t < i; ) {

			var s = t ++; this.wc[ s ] = new G();

		}

	}

	function E() {

		this.ff = this.ef = this.df = this.ub = this.yc = this.zc = this.bd = 0;

	}

	function U( t ) {

		this.jk = new o( this ), this.Ja = t;

	}

	function W() {}

	function Y() {

		this.D = this.C = null, this.Nf = ! 1;

	}

	function X() {}

	function $() {

		this.position = new dt(), this.normal = new dt(), this.shape = null, this.fraction = 1, this.position.Z(), this.normal.Z(), this.hit = ! 1;

	}

	function Z() {}

	function Q() {}

	function _() {}

	function tt() {

		this.u = new Et(), this.Ql = null;

	}

	function it() {

		this.Mi = new Rt(), this.vj = new xt(), this.eg = new dt(), this.Z = new dt(), this.em = this.xj = null;

	}

	function st() {

		this.Mi = new Rt(), this.vj = new dt(), this.end = new dt(), this.xj = null;

	}

	function ht( t, i ) {

		switch ( null == t && ( t = 2 ), t ) {

			case 1:this.jc = new Zt(); break; case 2:this.jc = new $t();

		}

		this.Kh = new ot( this.jc ), null == i && ( i = new dt( 0, - 9.80665, 0 ) ), this.Fk = new dt( i.x, i.y, i.z ), this.zi = this.Ph = this.Ei = this.uf = null, this.ek = this.Sk = this.zg = this.jj = 0, this.Uk = 10, this.Tk = 5, this.gk = new st(), this.aj = new it(), this.yk = new tt(), this.vg = new et(), this.af = Array( gt.islandInitialConstraintArraySize ), this.ph = Array( gt.islandInitialRigidBodyArraySize ), this.Sh = new at(), this.Ga = new lt(), this.Xl = 0;

	}

	function at() {

		this.invDt = this.dt = 0, this.dtRatio = 1;

	}

	function et() {

		this.Jf = Array( gt.islandInitialRigidBodyArraySize ), this.Kf = Array( gt.islandInitialConstraintArraySize ), this.Eh = Array( gt.islandInitialConstraintArraySize ), this.Dh = Array( gt.islandInitialConstraintArraySize ), this.vh = this.wh = this.If = this.Hf = 0;

	}

	function ot( t ) {

		this.jc = t, this.Xm = new Ft(), this.Bi = 0;

	}

	function rt() {

		this.Qc = this.Zd = this.M = this.ia = null;

	}

	function nt() {

		this.ia = this.M = null, this.rb = new rt(), this.sb = new rt(), this.Lh = this.D = this.C = this.$b = this.Zb = null, this.$i = new qt(), this.Ym = new Lt(), this.ik = this.Zj = ! 1, this.Ja = new V(), this.Zl = new K( this.Ja ), this.Ye = new U( this.Ja ), this.Td = ! 1;

	}

	function pt( t, i, s, h ) {

		null == h && ( h = 1 ), null == s && ( s = 0 ), null == i && ( i = 0 ), null == t && ( t = 0 ), this.x = t, this.y = i, this.z = s, this.w = h, pt.numCreations ++;

	}

	function lt() {

		this.b = Array( 256 ), this.c = 0, this.bb = Array( 256 ), this.eb = 0, this.Lf = Array( 256 ), this.dg = 0, this.Wd = Array( 256 ), this.ee = 0;

	}

	function ct() {}

	function yt( t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b ) {

		null == b && ( b = 1 ), null == u && ( u = 0 ), null == f && ( f = 0 ), null == y && ( y = 0 ), null == c && ( c = 0 ), null == l && ( l = 1 ), null == p && ( p = 0 ), null == n && ( n = 0 ), null == r && ( r = 0 ), null == o && ( o = 0 ), null == e && ( e = 1 ), null == a && ( a = 0 ), null == h && ( h = 0 ), null == s && ( s = 0 ), null == i && ( i = 0 ), null == t && ( t = 1 ), this.e00 = t, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, yt.numCreations ++;

	}

	function ft( t, i, s, h, a, e, o, r, n ) {

		null == n && ( n = 1 ), null == r && ( r = 0 ), null == o && ( o = 0 ), null == e && ( e = 0 ), null == a && ( a = 1 ), null == h && ( h = 0 ), null == s && ( s = 0 ), null == i && ( i = 0 ), null == t && ( t = 1 ), this.e00 = t, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, ft.numCreations ++;

	}

	function ut() {}

	function bt() {}

	function vt() {

		this.Na = Array( 4 ), this.jb = Array( 4 ), this.qb = Array( 4 ), this.uj = Array( 3 ), this.uj[ 0 ] = new dt( 1, 0, 0 ), this.uj[ 1 ] = new dt( 0, 1, 0 ), this.uj[ 2 ] = new dt( 0, 0, 1 ), this.bo = new dt(), this.co = new dt(), this.Vn = new dt(), this.Un = new dt(), this.ao = new xt(); for ( var t = 0; 4 > t; ) {

			var i = t ++; this.Na[ i ] = new dt(), this.jb[ i ] = new dt(), this.qb[ i ] = new dt();

		}

		this.dir = new dt(), this.closest = new dt(), this.closestPoint1 = new dt(), this.closestPoint2 = new dt(), this.Og = new Mt();

	}

	function gt() {}

	function xt() {

		this.B = this.A = this.v = 0, this.o = 1, this.i = this.h = this.f = 0, this.m = 1, this.g = this.l = this.j = 0, this.s = 1;

	}

	function dt( t, i, s ) {

		null == s && ( s = 0 ), null == i && ( i = 0 ), null == t && ( t = 0 ), this.x = t, this.y = i, this.z = s, dt.numCreations ++;

	}

	function zt() {

		this.Il = new dt();

	}

	function mt() {

		this.xd = new dt(), this.jb = new dt(), this.qb = new dt();

	}

	function jt() {

		this.id = ++ jt.Mb, this.ia = this.M = null, this.dk = new dt(), this.bl = this.Wj = 0, this.rj = ! 1, this.zb = Array( 3 ), this.Ge = Array( 3 ), this.We = Array( 3 ), this.fi = new dt(), this.Ai = Array( 3 ), this.Ai[ 0 ] = 1, this.Ai[ 1 ] = 2, this.Ai[ 2 ] = 0;

	}

	function Mt() {

		this.zb = Array( gt.maxEPAVertices ), this.mi = new dt(), this.Ne = 0, this.Rc = this.jd = null, this.lh = 0, this.bf = this.De = null;

	}

	function At() {

		this.Sg = ! 1;

	}

	function wt( t ) {

		this.Sg = t;

	}

	function Dt( t ) {

		this.Sg = t;

	}

	function Ct() {

		this.Sg = ! 1;

	}

	function Bt() {

		this.Sg = ! 1;

	}

	function qt() {}

	function St() {

		this.hc = this.Tc = this.Dj = this.w = 0, this.Bc = Array( 8 ), this.ic = Array( 8 ); for ( var t = 0; 8 > t; ) {

			var i = t ++; this.Bc[ i ] = new kt(), this.ic[ i ] = new kt();

		}

	}

	function kt() {

		this.Qa = this.Pa = this.Oa = this.y = this.x = 0;

	}

	function It() {

		this.Sg = ! 1, this.Dg = new St();

	}

	function Tt( t ) {

		this.Sg = t;

	}

	function Ot() {

		this.position1 = new dt(), this.position2 = new dt(), this.id = this.depth = 0;

	}

	function Lt() {

		this.numPoints = 0, this.normal = new dt(), this.points = Array( gt.maxManifoldPoints ), this.incremental = ! 1; for ( var t = 0, i = gt.maxManifoldPoints; t < i; ) {

			var s = t ++; this.points[ s ] = new Ot();

		}

	}

	function Ft() {

		this.Jb = Array( 8 ); for ( var t = 0; 6 > t; ) {

			var i = t ++; this.Jb[ i ] = Array( 8 );

		}

		t = new Ct(), this.Jb[ 0 ][ 0 ] = new At(), this.Jb[ 0 ][ 1 ] = new Dt( ! 1 ), this.Jb[ 0 ][ 2 ] = t, this.Jb[ 0 ][ 3 ] = t, this.Jb[ 0 ][ 4 ] = new wt( ! 1 ), this.Jb[ 0 ][ 5 ] = t, this.Jb[ 1 ][ 0 ] = new Dt( ! 0 ), this.Jb[ 1 ][ 1 ] = new It(), this.Jb[ 1 ][ 2 ] = t, this.Jb[ 1 ][ 3 ] = t, this.Jb[ 1 ][ 4 ] = t, this.Jb[ 1 ][ 5 ] = t, this.Jb[ 2 ][ 0 ] = t, this.Jb[ 2 ][ 1 ] = t, this.Jb[ 2 ][ 2 ] = t, this.Jb[ 2 ][ 3 ] = t, this.Jb[ 2 ][ 4 ] = t, this.Jb[ 2 ][ 5 ] = t, this.Jb[ 3 ][ 0 ] = t, this.Jb[ 3 ][ 1 ] = t, this.Jb[ 3 ][ 2 ] = t, this.Jb[ 3 ][ 3 ] = t, this.Jb[ 3 ][ 4 ] = t, this.Jb[ 3 ][ 5 ] = t, this.Jb[ 4 ][ 0 ] = new wt( ! 0 ), this.Jb[ 4 ][ 1 ] = t, this.Jb[ 4 ][ 2 ] = t, this.Jb[ 4 ][ 3 ] = t, this.Jb[ 4 ][ 4 ] = new Bt(), this.Jb[ 4 ][ 5 ] = t, this.Jb[ 5 ][ 0 ] = t, this.Jb[ 5 ][ 1 ] = t, this.Jb[ 5 ][ 2 ] = t, this.Jb[ 5 ][ 3 ] = t, this.Jb[ 5 ][ 4 ] = t, this.Jb[ 5 ][ 5 ] = t;

	}

	function Pt( t ) {

		ai.call( this, 0 ), this.Rb = this.ab = t, this.Oe();

	}

	function Rt() {

		this.position = new dt(), this.normal = new dt(), this.fraction = 0;

	}

	function Jt() {}

	function Nt( t, i ) {

		ai.call( this, 2 ), this.ab = t, this.Ib = i, this.Oe();

	}

	function Ht( t ) {

		ai.call( this, 5 ), this.Ne = t.length, this.zb = Array( this.Ne ), this.Bg = Array( this.Ne ); for ( var i = 0, s = this.Ne; i < s; ) {

			var h = i ++; this.zb[ h ] = t[ h ], this.Bg[ h ] = new dt();

		}

		this.$l = ! 0, this.Oe();

	}

	function Kt( t, i ) {

		ai.call( this, 3 ), this.ab = t, this.Ib = i, this.uk = t / Math.sqrt( t * t + 4 * i * i ), this.kk = 2 * i / Math.sqrt( t * t + 4 * i * i ), this.Oe();

	}

	function Gt( t, i ) {

		ai.call( this, 4 ), this.ab = t, this.Ib = i, this.Rb = this.ab, this.Oe();

	}

	function Vt( t ) {

		ai.call( this, 1 ), this.Ke = t.x, this.Le = t.y, this.Me = t.z, this.Gk = t.x, this.Jk = this.Ik = this.Hk = 0, this.Kk = t.y, this.Nk = this.Mk = this.Lk = 0, this.Ok = t.z, this.Oe(), t = t.x < t.y ? t.z < t.x ? t.z : t.x : t.z < t.y ? t.z : t.y, this.Rb > .2 * t && ( this.Rb = .2 * t );

	}

	function Et() {

		this.la = this.ka = this.ja = this.oa = this.na = this.ma = 0;

	}

	function Ut() {

		this.Qb = null, this.fk = 0, this.Gi = new Wt(), this.gf = this.cg = this.Xc = null, this.fi = Array( 1024 );

	}

	function Wt() {

		this.Vl = 0, this.Rj = ! 1;

	}

	function Yt( t, i ) {

		_t.call( this, t, i ), this.Qh = null, this.jh = ! 1;

	}

	function Xt() {

		this.Uf = this.Vf = this.M = null, this.F = Array( 2 ), this.La = 0, this.Ea = null, this.O = 0, this.tb = null, this.I = this.H = this.G = this.L = this.K = this.J = 0;

	}

	function $t() {

		oi.call( this, 2 ), this.Yj = ! 0, this.ge = new Ut(), this.hf = Array( 1024 ), this.Gf = 0;

	}

	function Zt() {

		oi.call( this, 1 ), this.Yj = ! 1;

	}

	function Qt() {

		this.nh = this.mh = null;

	}

	function _t( t, i ) {

		this.userData = t, this.Cc = i, this.M = this.ia = null, this.I = this.H = this.G = this.L = this.K = this.J = 0;

	}

	function ti() {}

	function ii() {}

	function si() {

		ai.call( this, - 1 ), this.min = new dt(), this.max = new dt();

	}

	function hi() {

		ai.call( this, - 1 );

	}

	function ai( t ) {

		ei.call( this, t ), this.Rb = gt.defaultGJKMargin, this.$l = ! 1;

	}

	function ei( t ) {

		this.Lb = t, this.yf = 0;

	}

	function oi( t ) {

		this.Lb = t, this.Ci = 0, this.ce = this.$e = this.Be = null, this.Yj = ! 1, this.oj = 0, this.oh = null, this.Ul = 0, this.Vj = new hi(), this.u = new si(), this.Wf = new xt(), this.Z = new dt(), this.Mi = new Rt();

	}

	function ri( t, i ) {

		function s() {}

		for ( var h in s.prototype = t, t = new s(), i )t[ h ] = i[ h ]; return i.toString !== Object.prototype.toString && ( t.toString = i.toString ), t;

	}

	oi.prototype = { Vh: function () {

		return null;

	}, Wh: function () {}, wd: function () {}, Mb: function ( t, i ) {

		return t.J < i.G && t.G > i.J && t.K < i.H && t.H > i.K && t.L < i.I && t.I > i.L;

	}, Ii: function () {}, ua: function () {

		return this.ce;

	}, Hb: function () {

		return this.Yj;

	}, cb: function () {

		return this.oj;

	}, Vd: function () {}, Bf: function () {}, qh: function () {} }, ei.prototype = { Oe: function () {}, Nb: function () {}, Di: function () {

		return ! 1;

	}, cb: function () {

		return this.Lb;

	}, ua: function () {

		return this.yf;

	}, Vd: function ( t, i, s, h ) {

		var a, e, o, r, n, p, l, c; return a = t.x, e = t.y, t = t.z, o = i.x, r = i.y, i = i.z, a -= s.v, e -= s.A, t -= s.B, o -= s.v, r -= s.A, i -= s.B, !! this.Di( s.o * a + s.i * e + s.l * t, s.f * a + s.m * e + s.g * t, s.h * a + s.j * e + s.s * t, s.o * o + s.i * r + s.l * i, s.f * o + s.m * r + s.g * i, s.h * o + s.j * r + s.s * i, h ) && ( a = ( i = h.position ).x, e = i.y, o = i.z, r = ( i = h.normal ).x, n = i.y, p = i.z, l = s.o * a + s.f * e + s.h * o, c = s.i * a + s.m * e + s.j * o, o = s.l * a + s.g * e + s.s * o, i = s.o * r + s.f * n + s.h * p, t = s.i * r + s.m * n + s.j * p, r = s.l * r + s.g * n + s.s * p, a = l + s.v, e = c + s.A, o += s.B, ( s = h.position ).x = a, s.y = e, s.z = o, ( h = h.normal ).x = i, h.y = t, h.z = r, ! 0 );

	} }, ai.ua = ei, ai.prototype = ri( ei.prototype, { un: function () {

		return this.Rb;

	}, Zn: function ( t ) {

		0 > t && ( t = 0 ), this.Rb = t;

	}, Pd: function () {}, Vd: function ( t, i, s, h ) {

		return this.$l ? vt.cb.Vd( this, s, t, i, h ) : ei.prototype.Vd.call( this, t, i, s, h );

	} } ), hi.ua = ai, hi.prototype = ri( ai.prototype, { za: function ( t, i, s ) {

		var h, a, e, o; this.ln = t, h = s.x, a = s.y, e = s.z, s = i.o * h + i.i * a + i.l * e, o = i.f * h + i.m * a + i.g * e, i = i.h * h + i.j * a + i.s * e, ( h = this.Fl = new dt() ).x = s, h.y = o, h.z = i, this.Rb = t.Rb;

	}, Pd: function ( t, i ) {

		this.ln.Pd( t, i ); var s = this.Fl; if ( 0 < t.x * s.x + t.y * s.y + t.z * s.z ) {

			t = this.Fl; s = i.y + t.y; var h = i.z + t.z; i.x += t.x, i.y = s, i.z = h;

		}

	} } ), si.ua = ai, si.prototype = ri( ai.prototype, { Pd: function ( t, i ) {

		i.x = 0 < t.x ? this.max.x : this.min.x, i.y = 0 < t.y ? this.max.y : this.min.y, i.z = 0 < t.z ? this.max.z : this.min.z;

	} } ), ii.prototype = { process: function () {} }, _t.prototype = { Hb: function () {

		return this.Cc;

	}, ua: function () {

		var t = new Et(); return t.ma = this.J, t.na = this.K, t.oa = this.L, t.ja = this.G, t.ka = this.H, t.la = this.I, t;

	}, cb: function ( t ) {

		t.ma = this.J, t.na = this.K, t.oa = this.L, t.ja = this.G, t.ka = this.H, t.la = this.I;

	} }, Qt.prototype = { ua: function () {

		return this.mh;

	}, cb: function () {

		return this.nh;

	}, Hb: function () {

		return this.M;

	} }, Zt.ua = oi, Zt.prototype = ri( oi.prototype, { Vh: function ( t, i ) {

		return t = new _t( t, this.Ul ++ ), this.Ci ++, null == this.Be ? this.Be = t : ( this.$e.M = t, t.ia = this.$e ), this.$e = t, t.J = i.ma, t.K = i.na, t.L = i.oa, t.G = i.ja, t.H = i.ka, t.I = i.la, t;

	}, Wh: function ( t ) {

		this.Ci --; var i = t.ia, s = t.M; null != i && ( i.M = s ), null != s && ( s.ia = i ), t == this.Be && ( this.Be = this.Be.M ), t == this.$e && ( this.$e = this.$e.ia ), t.M = null, t.ia = null, t.userData = null;

	}, wd: function ( t, i ) {

		t.J = i.ma, t.K = i.na, t.L = i.oa, t.G = i.ja, t.H = i.ka, t.I = i.la;

	}, Ii: function () {

		var t = this.ce; if ( null != t ) {

			for ( ;t.mh = null, t.nh = null, null != ( t = t.M ); );this.ce.M = this.oh, this.oh = this.ce, this.ce = null;

		}

		for ( this.oj = 0, t = this.Be; null != t; ) {

			for ( var i = t.M, s = t.M; null != s; ) {

				var h = s.M; if ( this.oj ++, t.J < s.G && t.G > s.J && t.K < s.H && t.H > s.K && t.L < s.I && t.I > s.L ) {

					var a = this.oh; null != a ? ( this.oh = a.M, a.M = null ) : a = new Qt(), null != this.ce && ( a.M = this.ce ), this.ce = a, a.mh = t, a.nh = s;

				}

				s = h;

			}

			t = i;

		}

	}, Vd: function ( t, i, s ) {

		var h, a, e, o; h = t.x, a = t.y, t = t.z, e = i.x, o = i.y, i = i.z; for ( var r = this.Be; null != r; ) {

			var n = r.M, p = ( D = h ) < ( z = e ) ? D : z, l = ( m = a ) < ( M = o ) ? m : M, c = ( j = t ) < ( w = i ) ? j : w, y = m > M ? m : M, f = j > w ? j : w, u = r.J, b = r.K, v = r.L, g = r.G, x = r.H, d = r.I; if ( u > ( D > z ? D : z ) || g < p || b > y || x < l || v > f || d < c )j = ! 1; else {

				var z, m, j, M = M - m, A = w - j, w = 0 > ( z = z - D ) ? - z : z, D = ( l = .5 * ( g - u ), f = .5 * ( d - v ), D - .5 * ( g + u ) ); 0 < ( 0 > ( v = ( m = m - .5 * ( x + b ) ) * A - ( j = j - .5 * ( d + v ) ) * M ) ? - v : v ) - ( ( c = .5 * ( x - b ) ) * ( y = 0 > A ? - A : A ) + f * ( p = 0 > M ? - M : M ) ) ? j = ! 0 : j = 0 < ( 0 > ( j = j * z - D * A ) ? - j : j ) - ( f * w + l * y ), j ? j = ! 0 : j = 0 < ( 0 > ( j = D * M - m * z ) ? - j : j ) - ( l * p + c * w ), j = ! j;

			}

			j && s.process( r ), r = n;

		}

	}, Bf: function ( t, i, s, h ) {

		for ( var a = this.Be; null != a; ) {

			var e = a.M, o = this.u.min; o.x = a.J, o.y = a.K, o.z = a.L, ( o = this.u.max ).x = a.G, o.y = a.H, o.z = a.I, this.Vj.za( t, i, s ), 0 == ( o = vt.cb ).zj( this.Vj, this.u, i, this.Wf, null, ! 1 ) && 0 >= o.distance && h.process( a ), a = e;

		}

	}, qh: function ( t, i ) {

		for ( var s = this.Be; null != s; ) {

			var h = s.M; t.ma < s.G && t.ja > s.J && t.na < s.H && t.ka > s.K && t.oa < s.I && t.la > s.L && i.process( s ), s = h;

		}

	} } ), $t.ua = oi, $t.prototype = ri( oi.prototype, { sh: function ( t, i ) {

		this.oj ++; var s = 0 == t.O, h = 0 == i.O; t == i ? s || ( this.sh( t.F[ 0 ], i ), this.sh( t.F[ 1 ], i ) ) : t.J < i.G && t.G > i.J && t.K < i.H && t.H > i.K && t.L < i.I && t.I > i.L && ( s && h ? ( t = t.tb, i = i.tb, null != ( s = this.oh ) ? ( this.oh = s.M, s.M = null ) : s = new Qt(), null != this.ce && ( s.M = this.ce ), this.ce = s, s.mh = t, s.nh = i ) : h || t.O > i.O ? ( this.sh( t.F[ 0 ], i ), this.sh( t.F[ 1 ], i ) ) : ( this.sh( i.F[ 0 ], t ), this.sh( i.F[ 1 ], t ) ) );

	}, Jl: function ( t, i, s, h, a, e, o, r ) {

		var n, p = t.J, l = t.K, c = t.L, y = t.G, f = t.H, u = t.I; if ( p > ( i > a ? i : a ) || y < ( i < a ? i : a ) || l > ( s > e ? s : e ) || f < ( s < e ? s : e ) || c > ( h > o ? h : o ) || u < ( h < o ? h : o ) )n = ! 1; else {

			var b = a - i, v = e - s, g = o - h; n = 0 > b ? - b : b; var x = 0 > v ? - v : v, d = 0 > g ? - g : g, z = .5 * ( y - p ), m = .5 * ( f - l ), j = .5 * ( u - c ); p = i - .5 * ( y + p ); 0 < ( 0 > ( u = ( l = s - .5 * ( f + l ) ) * g - ( c = h - .5 * ( u + c ) ) * v ) ? - u : u ) - ( m * d + j * x ) ? d = ! 0 : d = 0 < ( 0 > ( g = c * b - p * g ) ? - g : g ) - ( j * n + z * d ), d ? n = ! 0 : n = 0 < ( 0 > ( b = p * v - l * b ) ? - b : b ) - ( z * x + m * n ), n = ! n;

		}

		n && ( 0 == t.O ? r.process( t.tb ) : ( this.Jl( t.F[ 0 ], i, s, h, a, e, o, r ), this.Jl( t.F[ 1 ], i, s, h, a, e, o, r ) ) );

	}, ml: function ( t, i, s, h, a ) {

		var e = this.u.min; e.x = t.J, e.y = t.K, e.z = t.L, ( e = this.u.max ).x = t.G, e.y = t.H, e.z = t.I, this.Vj.za( i, s, h ), 0 == ( e = vt.cb ).zj( this.Vj, this.u, s, this.Wf, null, ! 1 ) && 0 >= e.distance && ( 0 == t.O ? a.process( t.tb ) : ( this.ml( t.F[ 0 ], i, s, h, a ), this.ml( t.F[ 1 ], i, s, h, a ) ) );

	}, hl: function ( t, i, s ) {

		t.J < i.ja && t.G > i.ma && t.K < i.ka && t.H > i.na && t.L < i.la && t.I > i.oa && ( 0 == t.O ? s.process( t.tb ) : ( this.hl( t.F[ 0 ], i, s ), this.hl( t.F[ 1 ], i, s ) ) );

	}, Vh: function ( t, i ) {

		if ( t = new Yt( t, this.Ul ++ ), this.Ci ++, null == this.Be ? this.Be = t : ( this.$e.M = t, t.ia = this.$e ), this.$e = t, t.J = i.ma, t.K = i.na, t.L = i.oa, t.G = i.ja, t.H = i.ka, t.I = i.la, i = gt.bvhProxyPadding, t.J -= i, t.K -= i, t.L -= i, t.G += i, t.H += i, t.I += i, null != ( h = ( i = this.ge ).Xc ) ? ( i.Xc = h.M, h.M = null ) : h = new Xt(), ( o = h ).tb = t, t.Qh = o, o.J = t.J, o.K = t.K, o.L = t.L, o.G = t.G, o.H = t.H, o.I = t.I, i.fk ++, null == i.cg ? i.cg = o : ( i.gf.Uf = o, o.Vf = i.gf ), i.gf = o, null == i.Qb )i.Qb = o; else {

			for ( var s = i.Qb; 0 < s.O && - 1 != ( h = i.Gi.Sl( s, o ) ); )s = s.F[ h ]; var h, a = s.Ea; if ( null != ( h = i.Xc ) ? ( i.Xc = h.M, h.M = null ) : h = new Xt(), null == a )i.Qb = h; else {

				var e = s.La; a.F[ e ] = h, h.Ea = a, h.La = e;

			}

			for ( a = s.La, h.F[ a ] = s, s.Ea = h, s.La = a, s = 1 ^ s.La, h.F[ s ] = o, o.Ea = h, o.La = s; null != h; ) {

				if ( i.Gi.Rj && ! ( 2 > h.O ) ) {

					var o = h.Ea, r = ( a = h.F[ 0 ], e = h.F[ 1 ], a.O - e.O ); s = h.La; 1 < r ? ( e = a.F[ 0 ], r = a.F[ 1 ], e.O > r.O ? ( a.F[ 1 ] = h, h.Ea = a, h.La = 1, h.F[ 0 ] = r, r.Ea = h, r.La = 0 ) : ( a.F[ 0 ] = h, h.Ea = a, h.La = 0, h.F[ 0 ] = e, e.Ea = h, e.La = 0 ), e = a.F[ 0 ], r = a.F[ 1 ], a.J = e.J < r.J ? e.J : r.J, a.K = e.K < r.K ? e.K : r.K, a.L = e.L < r.L ? e.L : r.L, a.G = e.G > r.G ? e.G : r.G, a.H = e.H > r.H ? e.H : r.H, a.I = e.I > r.I ? e.I : r.I, e = a.F[ 0 ].O, r = a.F[ 1 ].O, a.O = ( e > r ? e : r ) + 1, e = h.F[ 0 ], r = h.F[ 1 ], h.J = e.J < r.J ? e.J : r.J, h.K = e.K < r.K ? e.K : r.K, h.L = e.L < r.L ? e.L : r.L, h.G = e.G > r.G ? e.G : r.G, h.H = e.H > r.H ? e.H : r.H, h.I = e.I > r.I ? e.I : r.I, e = h.F[ 0 ].O, r = h.F[ 1 ].O, h.O = ( e > r ? e : r ) + 1, null != o ? ( o.F[ s ] = a, a.Ea = o, a.La = s ) : ( i.Qb = a, a.Ea = null ), h = a ) : - 1 > r && ( a = e.F[ 0 ], r = e.F[ 1 ], a.O > r.O ? ( e.F[ 1 ] = h, h.Ea = e, h.La = 1, h.F[ 1 ] = r, r.Ea = h, r.La = 1 ) : ( e.F[ 0 ] = h, h.Ea = e, h.La = 0, h.F[ 1 ] = a, a.Ea = h, a.La = 1 ), a = e.F[ 0 ], r = e.F[ 1 ], e.J = a.J < r.J ? a.J : r.J, e.K = a.K < r.K ? a.K : r.K, e.L = a.L < r.L ? a.L : r.L, e.G = a.G > r.G ? a.G : r.G, e.H = a.H > r.H ? a.H : r.H, e.I = a.I > r.I ? a.I : r.I, a = e.F[ 0 ].O, r = e.F[ 1 ].O, e.O = ( a > r ? a : r ) + 1, a = h.F[ 0 ], r = h.F[ 1 ], h.J = a.J < r.J ? a.J : r.J, h.K = a.K < r.K ? a.K : r.K, h.L = a.L < r.L ? a.L : r.L, h.G = a.G > r.G ? a.G : r.G, h.H = a.H > r.H ? a.H : r.H, h.I = a.I > r.I ? a.I : r.I, a = h.F[ 0 ].O, r = h.F[ 1 ].O, h.O = ( a > r ? a : r ) + 1, null != o ? ( o.F[ s ] = e, e.Ea = o, e.La = s ) : ( i.Qb = e, e.Ea = null ), h = e );

				}

				o = h.F[ 0 ].O, s = h.F[ 1 ].O, h.O = ( o > s ? o : s ) + 1, o = h.F[ 0 ], s = h.F[ 1 ], h.J = o.J < s.J ? o.J : s.J, h.K = o.K < s.K ? o.K : s.K, h.L = o.L < s.L ? o.L : s.L, h.G = o.G > s.G ? o.G : s.G, h.H = o.H > s.H ? o.H : s.H, h.I = o.I > s.I ? o.I : s.I, h = h.Ea;

			}

		}

		if ( ! t.jh ) {

			if ( t.jh = ! 0, this.hf.length == this.Gf ) {

				for ( i = Array( this.Gf << 1 ), h = 0, o = this.Gf; h < o; )i[ s = h ++ ] = this.hf[ s ], this.hf[ s ] = null; this.hf = i;

			}

			this.hf[ this.Gf ++ ] = t;

		}

		return t;

	}, Wh: function ( t ) {

		this.Ci --; var i = t.ia, s = t.M; null != i && ( i.M = s ), null != s && ( s.ia = i ), t == this.Be && ( this.Be = this.Be.M ), t == this.$e && ( this.$e = this.$e.ia ), t.M = null, t.ia = null, i = this.ge, s = t.Qh, i.fk --; var h = s.Vf, a = s.Uf; if ( null != h && ( h.Uf = a ), null != a && ( a.Vf = h ), s == i.cg && ( i.cg = i.cg.Uf ), s == i.gf && ( i.gf = i.gf.Vf ), s.Uf = null, s.Vf = null, i.Qb == s )i.Qb = null; else {

			a = ( h = s.Ea ).F[ 1 ^ s.La ]; if ( null == ( n = h.Ea ) )a.Ea = null, a.La = 0, i.Qb = a, h.F[ 0 ] = null, h.F[ 1 ] = null, h.La = 0, h.Ea = null, h.O = 0, h.tb = null, h.M = i.Xc, i.Xc = h; else {

				var e = h.La; for ( n.F[ e ] = a, a.Ea = n, a.La = e, h.F[ 0 ] = null, h.F[ 1 ] = null, h.La = 0, h.Ea = null, h.O = 0, h.tb = null, h.M = i.Xc, i.Xc = h, h = n; null != h; ) {

					if ( i.Gi.Rj && ! ( 2 > h.O ) ) {

						a = h.Ea, e = h.F[ 0 ]; var o = h.F[ 1 ], r = e.O - o.O, n = h.La; 1 < r ? ( o = e.F[ 0 ], r = e.F[ 1 ], o.O > r.O ? ( e.F[ 1 ] = h, h.Ea = e, h.La = 1, h.F[ 0 ] = r, r.Ea = h, r.La = 0 ) : ( e.F[ 0 ] = h, h.Ea = e, h.La = 0, h.F[ 0 ] = o, o.Ea = h, o.La = 0 ), o = e.F[ 0 ], r = e.F[ 1 ], e.J = o.J < r.J ? o.J : r.J, e.K = o.K < r.K ? o.K : r.K, e.L = o.L < r.L ? o.L : r.L, e.G = o.G > r.G ? o.G : r.G, e.H = o.H > r.H ? o.H : r.H, e.I = o.I > r.I ? o.I : r.I, o = e.F[ 0 ].O, r = e.F[ 1 ].O, e.O = ( o > r ? o : r ) + 1, o = h.F[ 0 ], r = h.F[ 1 ], h.J = o.J < r.J ? o.J : r.J, h.K = o.K < r.K ? o.K : r.K, h.L = o.L < r.L ? o.L : r.L, h.G = o.G > r.G ? o.G : r.G, h.H = o.H > r.H ? o.H : r.H, h.I = o.I > r.I ? o.I : r.I, o = h.F[ 0 ].O, r = h.F[ 1 ].O, h.O = ( o > r ? o : r ) + 1, null != a ? ( a.F[ n ] = e, e.Ea = a, e.La = n ) : ( i.Qb = e, e.Ea = null ), h = e ) : - 1 > r && ( e = o.F[ 0 ], r = o.F[ 1 ], e.O > r.O ? ( o.F[ 1 ] = h, h.Ea = o, h.La = 1, h.F[ 1 ] = r, r.Ea = h, r.La = 1 ) : ( o.F[ 0 ] = h, h.Ea = o, h.La = 0, h.F[ 1 ] = e, e.Ea = h, e.La = 1 ), e = o.F[ 0 ], r = o.F[ 1 ], o.J = e.J < r.J ? e.J : r.J, o.K = e.K < r.K ? e.K : r.K, o.L = e.L < r.L ? e.L : r.L, o.G = e.G > r.G ? e.G : r.G, o.H = e.H > r.H ? e.H : r.H, o.I = e.I > r.I ? e.I : r.I, e = o.F[ 0 ].O, r = o.F[ 1 ].O, o.O = ( e > r ? e : r ) + 1, e = h.F[ 0 ], r = h.F[ 1 ], h.J = e.J < r.J ? e.J : r.J, h.K = e.K < r.K ? e.K : r.K, h.L = e.L < r.L ? e.L : r.L, h.G = e.G > r.G ? e.G : r.G, h.H = e.H > r.H ? e.H : r.H, h.I = e.I > r.I ? e.I : r.I, e = h.F[ 0 ].O, r = h.F[ 1 ].O, h.O = ( e > r ? e : r ) + 1, null != a ? ( a.F[ n ] = o, o.Ea = a, o.La = n ) : ( i.Qb = o, o.Ea = null ), h = o );

					}

					a = h.F[ 0 ].O, n = h.F[ 1 ].O, h.O = ( a > n ? a : n ) + 1, a = h.F[ 0 ], n = h.F[ 1 ], h.J = a.J < n.J ? a.J : n.J, h.K = a.K < n.K ? a.K : n.K, h.L = a.L < n.L ? a.L : n.L, h.G = a.G > n.G ? a.G : n.G, h.H = a.H > n.H ? a.H : n.H, h.I = a.I > n.I ? a.I : n.I, h = h.Ea;

				}

			}

		}

		t.Qh = null, s.F[ 0 ] = null, s.F[ 1 ] = null, s.La = 0, s.Ea = null, s.O = 0, s.tb = null, s.M = i.Xc, i.Xc = s, t.userData = null, t.M = null, t.ia = null, t.jh && ( t.jh = ! 1 );

	}, wd: function ( t, i, s ) {

		if ( ! ( t.J <= i.ma && t.G >= i.ja && t.K <= i.na && t.H >= i.ka && t.L <= i.oa && t.I >= i.la ) ) {

			var h; if ( t.J = i.ma, t.K = i.na, t.L = i.oa, t.G = i.ja, t.H = i.ka, t.I = i.la, i = gt.bvhProxyPadding, t.J -= i, t.K -= i, t.L -= i, t.G += i, t.H += i, t.I += i, null != s )i = s.x, h = s.y, s = s.z, t.J += 0 < i ? 0 : i, t.K += 0 < h ? 0 : h, t.L += 0 < s ? 0 : s, t.G += 0 > i ? 0 : i, t.H += 0 > h ? 0 : h, t.I += 0 > s ? 0 : s; if ( ! t.jh ) {

				if ( t.jh = ! 0, this.hf.length == this.Gf ) {

					for ( s = Array( this.Gf << 1 ), i = 0, h = this.Gf; i < h; ) {

						var a = i ++; s[ a ] = this.hf[ a ], this.hf[ a ] = null;

					}

					this.hf = s;

				}

				this.hf[ this.Gf ++ ] = t;

			}

		}

	}, Ii: function () {

		var t = this.ce; if ( null != t ) {

			for ( ;t.mh = null, t.nh = null, null != ( t = t.M ); );this.ce.M = this.oh, this.oh = this.ce, this.ce = null;

		}

		if ( this.oj = 0, ! ( 2 > this.Ci ) ) {

			for ( var i = this.Gf / this.Ci < gt.bvhIncrementalCollisionThreshold, s = 0, h = this.Gf; s < h; ) {

				var a = s ++, e = this.hf[ a ]; if ( e.jh ) {

					var o = this.ge, r = e.Qh; o.fk --; var n = r.Vf, p = r.Uf; if ( null != n && ( n.Uf = p ), null != p && ( p.Vf = n ), r == o.cg && ( o.cg = o.cg.Uf ), r == o.gf && ( o.gf = o.gf.Vf ), r.Uf = null, r.Vf = null, o.Qb == r )o.Qb = null; else {

						var l = r.Ea, c = l.F[ 1 ^ r.La ], y = l.Ea; if ( null == y )c.Ea = null, c.La = 0, o.Qb = c, l.M = null, l.La = 0, l.F[ 0 ] = null, l.F[ 1 ] = null, l.La = 0, l.Ea = null, l.O = 0, l.tb = null, l.M = o.Xc, o.Xc = l; else {

							c.Ea = y; var f = l.La; y.F[ f ] = c, c.Ea = y, c.La = f, l.M = null, l.La = 0, l.F[ 0 ] = null, l.F[ 1 ] = null, l.La = 0, l.Ea = null, l.O = 0, l.tb = null, l.M = o.Xc, o.Xc = l; for ( var u = y; null != u; ) {

								if ( o.Gi.Rj && ! ( 2 > u.O ) ) {

									var b = u.Ea, v = u.F[ 0 ], g = u.F[ 1 ], x = v.O - g.O, d = u.La; if ( 1 < x ) {

										var z = v.F[ 0 ], m = v.F[ 1 ]; if ( z.O > m.O ) {

											v.F[ 1 ] = u, u.Ea = v, u.La = 1, u.F[ 0 ] = m, m.Ea = u, m.La = 0; var j = v.F[ 0 ], M = v.F[ 1 ]; v.J = j.J < M.J ? j.J : M.J, v.K = j.K < M.K ? j.K : M.K, v.L = j.L < M.L ? j.L : M.L, v.G = j.G > M.G ? j.G : M.G, v.H = j.H > M.H ? j.H : M.H, v.I = j.I > M.I ? j.I : M.I; var A = v.F[ 0 ].O, w = v.F[ 1 ].O; v.O = ( A > w ? A : w ) + 1; var D = u.F[ 0 ], C = u.F[ 1 ]; u.J = D.J < C.J ? D.J : C.J, u.K = D.K < C.K ? D.K : C.K, u.L = D.L < C.L ? D.L : C.L, u.G = D.G > C.G ? D.G : C.G, u.H = D.H > C.H ? D.H : C.H, u.I = D.I > C.I ? D.I : C.I; var B = u.F[ 0 ].O, q = u.F[ 1 ].O; u.O = ( B > q ? B : q ) + 1;

										} else {

											v.F[ 0 ] = u, u.Ea = v, u.La = 0, u.F[ 0 ] = z, z.Ea = u, z.La = 0; var S = v.F[ 0 ], k = v.F[ 1 ]; v.J = S.J < k.J ? S.J : k.J, v.K = S.K < k.K ? S.K : k.K, v.L = S.L < k.L ? S.L : k.L, v.G = S.G > k.G ? S.G : k.G, v.H = S.H > k.H ? S.H : k.H, v.I = S.I > k.I ? S.I : k.I; var I = v.F[ 0 ].O, T = v.F[ 1 ].O; v.O = ( I > T ? I : T ) + 1; var O = u.F[ 0 ], L = u.F[ 1 ]; u.J = O.J < L.J ? O.J : L.J, u.K = O.K < L.K ? O.K : L.K, u.L = O.L < L.L ? O.L : L.L, u.G = O.G > L.G ? O.G : L.G, u.H = O.H > L.H ? O.H : L.H, u.I = O.I > L.I ? O.I : L.I; var F = u.F[ 0 ].O, P = u.F[ 1 ].O; u.O = ( F > P ? F : P ) + 1;

										}

										null != b ? ( b.F[ d ] = v, v.Ea = b, v.La = d ) : ( o.Qb = v, v.Ea = null ), u = v;

									} else if ( - 1 > x ) {

										var R = g.F[ 0 ], J = g.F[ 1 ]; if ( R.O > J.O ) {

											g.F[ 1 ] = u, u.Ea = g, u.La = 1, u.F[ 1 ] = J, J.Ea = u, J.La = 1; var N = g.F[ 0 ], H = g.F[ 1 ]; g.J = N.J < H.J ? N.J : H.J, g.K = N.K < H.K ? N.K : H.K, g.L = N.L < H.L ? N.L : H.L, g.G = N.G > H.G ? N.G : H.G, g.H = N.H > H.H ? N.H : H.H, g.I = N.I > H.I ? N.I : H.I; var K = g.F[ 0 ].O, G = g.F[ 1 ].O; g.O = ( K > G ? K : G ) + 1; var V = u.F[ 0 ], E = u.F[ 1 ]; u.J = V.J < E.J ? V.J : E.J, u.K = V.K < E.K ? V.K : E.K, u.L = V.L < E.L ? V.L : E.L, u.G = V.G > E.G ? V.G : E.G, u.H = V.H > E.H ? V.H : E.H, u.I = V.I > E.I ? V.I : E.I; var U = u.F[ 0 ].O, W = u.F[ 1 ].O; u.O = ( U > W ? U : W ) + 1;

										} else {

											g.F[ 0 ] = u, u.Ea = g, u.La = 0, u.F[ 1 ] = R, R.Ea = u, R.La = 1; var Y = g.F[ 0 ], X = g.F[ 1 ]; g.J = Y.J < X.J ? Y.J : X.J, g.K = Y.K < X.K ? Y.K : X.K, g.L = Y.L < X.L ? Y.L : X.L, g.G = Y.G > X.G ? Y.G : X.G, g.H = Y.H > X.H ? Y.H : X.H, g.I = Y.I > X.I ? Y.I : X.I; var $ = g.F[ 0 ].O, Z = g.F[ 1 ].O; g.O = ( $ > Z ? $ : Z ) + 1; var Q = u.F[ 0 ], _ = u.F[ 1 ]; u.J = Q.J < _.J ? Q.J : _.J, u.K = Q.K < _.K ? Q.K : _.K, u.L = Q.L < _.L ? Q.L : _.L, u.G = Q.G > _.G ? Q.G : _.G, u.H = Q.H > _.H ? Q.H : _.H, u.I = Q.I > _.I ? Q.I : _.I; var tt = u.F[ 0 ].O, it = u.F[ 1 ].O; u.O = ( tt > it ? tt : it ) + 1;

										}

										null != b ? ( b.F[ d ] = g, g.Ea = b, g.La = d ) : ( o.Qb = g, g.Ea = null ), u = g;

									}

								}

								var st = u.F[ 0 ].O, ht = u.F[ 1 ].O; u.O = ( st > ht ? st : ht ) + 1; var at = u.F[ 0 ], et = u.F[ 1 ]; u.J = at.J < et.J ? at.J : et.J, u.K = at.K < et.K ? at.K : et.K, u.L = at.L < et.L ? at.L : et.L, u.G = at.G > et.G ? at.G : et.G, u.H = at.H > et.H ? at.H : et.H, u.I = at.I > et.I ? at.I : et.I, u = u.Ea;

							}

						}

					}

					e.Qh = null, r.M = null, r.La = 0, r.F[ 0 ] = null, r.F[ 1 ] = null, r.La = 0, r.Ea = null, r.O = 0, r.tb = null, r.M = o.Xc, o.Xc = r; var ot = this.ge, rt = ot.Xc; null != rt ? ( ot.Xc = rt.M, rt.M = null ) : rt = new Xt(); var nt = rt; if ( nt.tb = e, e.Qh = nt, nt.J = e.J, nt.K = e.K, nt.L = e.L, nt.G = e.G, nt.H = e.H, nt.I = e.I, ot.fk ++, null == ot.cg ? ot.cg = nt : ( ot.gf.Uf = nt, nt.Vf = ot.gf ), ot.gf = nt, null == ot.Qb )ot.Qb = nt; else {

						for ( var pt = ot.Qb; 0 < pt.O; ) {

							var lt = ot.Gi.Sl( pt, nt ); if ( - 1 == lt ) break; pt = pt.F[ lt ];

						}

						var ct = pt.Ea, yt = ot.Xc; null != yt ? ( ot.Xc = yt.M, yt.M = null ) : yt = new Xt(); var ft = yt; if ( null == ct )ot.Qb = ft; else {

							var ut = pt.La; ct.F[ ut ] = ft, ft.Ea = ct, ft.La = ut;

						}

						var bt = pt.La; ft.F[ bt ] = pt, pt.Ea = ft, pt.La = bt; var vt = 1 ^ pt.La; for ( ft.F[ vt ] = nt, nt.Ea = ft, nt.La = vt; null != ft; ) {

							if ( ot.Gi.Rj && ! ( 2 > ft.O ) ) {

								var xt = ft.Ea, dt = ft.F[ 0 ], zt = ft.F[ 1 ], mt = dt.O - zt.O, jt = ft.La; if ( 1 < mt ) {

									var Mt = dt.F[ 0 ], At = dt.F[ 1 ]; if ( Mt.O > At.O ) {

										dt.F[ 1 ] = ft, ft.Ea = dt, ft.La = 1, ft.F[ 0 ] = At, At.Ea = ft, At.La = 0; var wt = dt.F[ 0 ], Dt = dt.F[ 1 ]; dt.J = wt.J < Dt.J ? wt.J : Dt.J, dt.K = wt.K < Dt.K ? wt.K : Dt.K, dt.L = wt.L < Dt.L ? wt.L : Dt.L, dt.G = wt.G > Dt.G ? wt.G : Dt.G, dt.H = wt.H > Dt.H ? wt.H : Dt.H, dt.I = wt.I > Dt.I ? wt.I : Dt.I; var Ct = dt.F[ 0 ].O, Bt = dt.F[ 1 ].O; dt.O = ( Ct > Bt ? Ct : Bt ) + 1; var qt = ft.F[ 0 ], St = ft.F[ 1 ]; ft.J = qt.J < St.J ? qt.J : St.J, ft.K = qt.K < St.K ? qt.K : St.K, ft.L = qt.L < St.L ? qt.L : St.L, ft.G = qt.G > St.G ? qt.G : St.G, ft.H = qt.H > St.H ? qt.H : St.H, ft.I = qt.I > St.I ? qt.I : St.I; var kt = ft.F[ 0 ].O, It = ft.F[ 1 ].O; ft.O = ( kt > It ? kt : It ) + 1;

									} else {

										dt.F[ 0 ] = ft, ft.Ea = dt, ft.La = 0, ft.F[ 0 ] = Mt, Mt.Ea = ft, Mt.La = 0; var Tt = dt.F[ 0 ], Ot = dt.F[ 1 ]; dt.J = Tt.J < Ot.J ? Tt.J : Ot.J, dt.K = Tt.K < Ot.K ? Tt.K : Ot.K, dt.L = Tt.L < Ot.L ? Tt.L : Ot.L, dt.G = Tt.G > Ot.G ? Tt.G : Ot.G, dt.H = Tt.H > Ot.H ? Tt.H : Ot.H, dt.I = Tt.I > Ot.I ? Tt.I : Ot.I; var Lt = dt.F[ 0 ].O, Ft = dt.F[ 1 ].O; dt.O = ( Lt > Ft ? Lt : Ft ) + 1; var Pt = ft.F[ 0 ], Rt = ft.F[ 1 ]; ft.J = Pt.J < Rt.J ? Pt.J : Rt.J, ft.K = Pt.K < Rt.K ? Pt.K : Rt.K, ft.L = Pt.L < Rt.L ? Pt.L : Rt.L, ft.G = Pt.G > Rt.G ? Pt.G : Rt.G, ft.H = Pt.H > Rt.H ? Pt.H : Rt.H, ft.I = Pt.I > Rt.I ? Pt.I : Rt.I; var Jt = ft.F[ 0 ].O, Nt = ft.F[ 1 ].O; ft.O = ( Jt > Nt ? Jt : Nt ) + 1;

									}

									null != xt ? ( xt.F[ jt ] = dt, dt.Ea = xt, dt.La = jt ) : ( ot.Qb = dt, dt.Ea = null ), ft = dt;

								} else if ( - 1 > mt ) {

									var Ht = zt.F[ 0 ], Kt = zt.F[ 1 ]; if ( Ht.O > Kt.O ) {

										zt.F[ 1 ] = ft, ft.Ea = zt, ft.La = 1, ft.F[ 1 ] = Kt, Kt.Ea = ft, Kt.La = 1; var Gt = zt.F[ 0 ], Vt = zt.F[ 1 ]; zt.J = Gt.J < Vt.J ? Gt.J : Vt.J, zt.K = Gt.K < Vt.K ? Gt.K : Vt.K, zt.L = Gt.L < Vt.L ? Gt.L : Vt.L, zt.G = Gt.G > Vt.G ? Gt.G : Vt.G, zt.H = Gt.H > Vt.H ? Gt.H : Vt.H, zt.I = Gt.I > Vt.I ? Gt.I : Vt.I; var Et = zt.F[ 0 ].O, Ut = zt.F[ 1 ].O; zt.O = ( Et > Ut ? Et : Ut ) + 1; var Wt = ft.F[ 0 ], Yt = ft.F[ 1 ]; ft.J = Wt.J < Yt.J ? Wt.J : Yt.J, ft.K = Wt.K < Yt.K ? Wt.K : Yt.K, ft.L = Wt.L < Yt.L ? Wt.L : Yt.L, ft.G = Wt.G > Yt.G ? Wt.G : Yt.G, ft.H = Wt.H > Yt.H ? Wt.H : Yt.H, ft.I = Wt.I > Yt.I ? Wt.I : Yt.I; var $t = ft.F[ 0 ].O, Zt = ft.F[ 1 ].O; ft.O = ( $t > Zt ? $t : Zt ) + 1;

									} else {

										zt.F[ 0 ] = ft, ft.Ea = zt, ft.La = 0, ft.F[ 1 ] = Ht, Ht.Ea = ft, Ht.La = 1; var Qt = zt.F[ 0 ], _t = zt.F[ 1 ]; zt.J = Qt.J < _t.J ? Qt.J : _t.J, zt.K = Qt.K < _t.K ? Qt.K : _t.K, zt.L = Qt.L < _t.L ? Qt.L : _t.L, zt.G = Qt.G > _t.G ? Qt.G : _t.G, zt.H = Qt.H > _t.H ? Qt.H : _t.H, zt.I = Qt.I > _t.I ? Qt.I : _t.I; var ti = zt.F[ 0 ].O, ii = zt.F[ 1 ].O; zt.O = ( ti > ii ? ti : ii ) + 1; var si = ft.F[ 0 ], hi = ft.F[ 1 ]; ft.J = si.J < hi.J ? si.J : hi.J, ft.K = si.K < hi.K ? si.K : hi.K, ft.L = si.L < hi.L ? si.L : hi.L, ft.G = si.G > hi.G ? si.G : hi.G, ft.H = si.H > hi.H ? si.H : hi.H, ft.I = si.I > hi.I ? si.I : hi.I; var ai = ft.F[ 0 ].O, ei = ft.F[ 1 ].O; ft.O = ( ai > ei ? ai : ei ) + 1;

									}

									null != xt ? ( xt.F[ jt ] = zt, zt.Ea = xt, zt.La = jt ) : ( ot.Qb = zt, zt.Ea = null ), ft = zt;

								}

							}

							var oi = ft.F[ 0 ].O, ri = ft.F[ 1 ].O; ft.O = ( oi > ri ? oi : ri ) + 1; var ni = ft.F[ 0 ], pi = ft.F[ 1 ]; ft.J = ni.J < pi.J ? ni.J : pi.J, ft.K = ni.K < pi.K ? ni.K : pi.K, ft.L = ni.L < pi.L ? ni.L : pi.L, ft.G = ni.G > pi.G ? ni.G : pi.G, ft.H = ni.H > pi.H ? ni.H : pi.H, ft.I = ni.I > pi.I ? ni.I : pi.I, ft = ft.Ea;

						}

					}

					i && this.sh( this.ge.Qb, e.Qh ), e.jh = ! 1;

				}

				this.hf[ a ] = null;

			}

			i || this.sh( this.ge.Qb, this.ge.Qb ), this.Gf = 0;

		}

	}, Vd: function ( t, i, s ) {

		null != this.ge.Qb && this.Jl( this.ge.Qb, t.x, t.y, t.z, i.x, i.y, i.z, s );

	}, Bf: function ( t, i, s, h ) {

		null != this.ge.Qb && this.ml( this.ge.Qb, t, i, s, h );

	}, qh: function ( t, i ) {

		null != this.ge.Qb && this.hl( this.ge.Qb, t, i );

	}, Jn: function () {

		return this.ge.cn();

	} } ), Yt.ua = _t, Yt.prototype = ri( _t.prototype, {} ), Wt.prototype = { Sl: function ( t, i ) {

		switch ( this.Vl ) {

			case 0:var s, h, a; s = i.J + i.G, h = i.K + i.H, a = i.L + i.I; var e, o, r = t.F[ 0 ], n = t.F[ 1 ]; return i = r.J + r.G, t = r.K + r.H, r = r.L + r.I, e = n.J + n.G, o = n.K + n.H, n = n.L + n.I, ( i -= s ) * i + ( t -= h ) * t + ( r -= a ) * r < ( e -= s ) * e + ( o -= h ) * o + ( n -= a ) * n ? 0 : 1; case 1:r = t.F[ 0 ], s = t.F[ 1 ], h = t.H - t.K, a = t.I - t.L; var p, l; n = 2 * ( ( t.G - t.J ) * ( h + a ) + h * a ); h = t.J < i.J ? t.J : i.J, p = t.K < i.K ? t.K : i.K, e = t.L < i.L ? t.L : i.L, a = t.G > i.G ? t.G : i.G, l = t.H > i.H ? t.H : i.H, o = t.I > i.I ? t.I : i.I, t = 2 * ( h = 2 * ( ( a - h ) * ( ( t = l - p ) + ( e = o - e ) ) + t * e ) ); var c = 2 * ( h - n ); n = c; return h = r.J < i.J ? r.J : i.J, p = r.K < i.K ? r.K : i.K, e = r.L < i.L ? r.L : i.L, a = r.G > i.G ? r.G : i.G, l = r.H > i.H ? r.H : i.H, o = r.I > i.I ? r.I : i.I, 0 == r.O ? n += 2 * ( ( a - h ) * ( ( r = l - p ) + ( e = o - e ) ) + r * e ) : ( p = l - p, e = o - e, o = r.H - r.K, l = r.I - r.L, n += 2 * ( ( a - h ) * ( p + e ) + p * e ) - 2 * ( ( r.G - r.J ) * ( o + l ) + o * l ) ), r = c, h = s.J < i.J ? s.J : i.J, p = s.K < i.K ? s.K : i.K, e = s.L < i.L ? s.L : i.L, a = s.G > i.G ? s.G : i.G, l = s.H > i.H ? s.H : i.H, o = s.I > i.I ? s.I : i.I, 0 == s.O ? r += 2 * ( ( a - h ) * ( ( s = l - p ) + ( i = o - e ) ) + s * i ) : ( i = l - p, e = o - e, o = s.H - s.K, c = s.I - s.L, r += 2 * ( ( a - h ) * ( i + e ) + i * e ) - 2 * ( ( s.G - s.J ) * ( o + c ) + o * c ) ), t < n ? t < r ? - 1 : 1 : n < r ? 0 : 1; default:return console.log( 'BvhStrategy.hx:37:', 'invalid BVH insertion strategy: ' + this.Vl ), - 1;

		}

	} }, Ut.prototype = { cn: function () {

		return this.pl( this.Qb );

	}, pl: function ( t ) {

		if ( null == t || 0 == t.O ) return 0; var i = t.F[ 0 ].O - t.F[ 1 ].O; return 0 > i && ( i = - i ), i + this.pl( t.F[ 0 ] ) + this.pl( t.F[ 1 ] );

	} }, Et.prototype = { za: function ( t, i ) {

		return this.ma = t.x, this.na = t.y, this.oa = t.z, this.ja = i.x, this.ka = i.y, this.la = i.z, this;

	}, Jc: function () {

		var t = new dt(); return t.x = this.ma, t.y = this.na, t.z = this.oa, t;

	}, Kc: function ( t ) {

		t.x = this.ma, t.y = this.na, t.z = this.oa;

	}, Yd: function ( t ) {

		return this.ma = t.x, this.na = t.y, this.oa = t.z, this;

	}, Ac: function () {

		var t = new dt(); return t.x = this.ja, t.y = this.ka, t.z = this.la, t;

	}, Ec: function ( t ) {

		t.x = this.ja, t.y = this.ka, t.z = this.la;

	}, fd: function ( t ) {

		return this.ja = t.x, this.ka = t.y, this.la = t.z, this;

	}, Hb: function () {

		var t, i, s, h = new dt(); return t = this.ma + this.ja, i = this.na + this.ka, s = this.oa + this.la, h.x = .5 * t, h.y = .5 * i, h.z = .5 * s, h;

	}, Mb: function ( t ) {

		var i, s, h; i = this.ma + this.ja, s = this.na + this.ka, h = this.oa + this.la, t.x = .5 * i, t.y = .5 * s, t.z = .5 * h;

	}, pc: function () {

		var t, i, s, h = new dt(); return t = this.ja - this.ma, i = this.ka - this.na, s = this.la - this.oa, h.x = .5 * t, h.y = .5 * i, h.z = .5 * s, h;

	}, qc: function ( t ) {

		var i, s, h; i = this.ja - this.ma, s = this.ka - this.na, h = this.la - this.oa, t.x = .5 * i, t.y = .5 * s, t.z = .5 * h;

	}, ua: function ( t ) {

		return this.ma = this.ma < t.ma ? this.ma : t.ma, this.na = this.na < t.na ? this.na : t.na, this.oa = this.oa < t.oa ? this.oa : t.oa, this.ja = this.ja > t.ja ? this.ja : t.ja, this.ka = this.ka > t.ka ? this.ka : t.ka, this.la = this.la > t.la ? this.la : t.la, this;

	}, cb: function ( t ) {

		var i = new Et(); return i.ma = this.ma < t.ma ? this.ma : t.ma, i.na = this.na < t.na ? this.na : t.na, i.oa = this.oa < t.oa ? this.oa : t.oa, i.ja = this.ja > t.ja ? this.ja : t.ja, i.ka = this.ka > t.ka ? this.ka : t.ka, i.la = this.la > t.la ? this.la : t.la, i;

	}, Lc: function ( t ) {

		return this.ma < t.ja && this.ja > t.ma && this.na < t.ka && this.ka > t.na && this.oa < t.la && this.la > t.oa;

	}, uc: function ( t ) {

		var i = new Et(); return i.ma = this.ma > t.ma ? this.ma : t.ma, i.na = this.na > t.na ? this.na : t.na, i.oa = this.oa > t.oa ? this.oa : t.oa, i.ja = this.ja < t.ja ? this.ja : t.ja, i.ka = this.ka < t.ka ? this.ka : t.ka, i.la = this.la < t.la ? this.la : t.la, i;

	}, vc: function ( t, i ) {

		i.ma = this.ma > t.ma ? this.ma : t.ma, i.na = this.na > t.na ? this.na : t.na, i.oa = this.oa > t.oa ? this.oa : t.oa, i.ja = this.ja < t.ja ? this.ja : t.ja, i.ka = this.ka < t.ka ? this.ka : t.ka, i.la = this.la < t.la ? this.la : t.la;

	}, de: function ( t ) {

		return this.ma = t.ma, this.na = t.na, this.oa = t.oa, this.ja = t.ja, this.ka = t.ka, this.la = t.la, this;

	}, clone: function () {

		var t = new Et(); return t.ma = this.ma, t.na = this.na, t.oa = this.oa, t.ja = this.ja, t.ka = this.ka, t.la = this.la, t;

	} }, Vt.ua = ai, Vt.prototype = ri( ai.prototype, { vn: function () {

		var t = new dt(); return t.x = this.Ke, t.y = this.Le, t.z = this.Me, t;

	}, wn: function ( t ) {

		t.x = this.Ke, t.y = this.Le, t.z = this.Me;

	}, Oe: function () {

		var t, i, s; this.yf = 8 * this.Ke * this.Le * this.Me, t = this.Ke * this.Ke, i = this.Le * this.Le, s = this.Me * this.Me, this.mg = .3333333333333333 * ( i + s ), this.pg = this.og = this.ng = 0, this.qg = .3333333333333333 * ( s + t ), this.tg = this.sg = this.rg = 0, this.ug = .3333333333333333 * ( t + i );

	}, Nb: function ( t, i ) {

		var s, h, a, e, o, r, n, p, l; e = i.o * this.Gk + i.f * this.Hk + i.h * this.Ik, o = i.i * this.Gk + i.m * this.Hk + i.j * this.Ik, s = i.l * this.Gk + i.g * this.Hk + i.s * this.Ik, r = i.o * this.Jk + i.f * this.Kk + i.h * this.Lk, n = i.i * this.Jk + i.m * this.Kk + i.j * this.Lk, h = i.l * this.Jk + i.g * this.Kk + i.s * this.Lk, e = ( 0 > e ? - e : e ) + ( 0 > r ? - r : r ) + ( 0 > ( p = i.o * this.Mk + i.f * this.Nk + i.h * this.Ok ) ? - p : p ), o = ( 0 > o ? - o : o ) + ( 0 > n ? - n : n ) + ( 0 > ( l = i.i * this.Mk + i.m * this.Nk + i.j * this.Ok ) ? - l : l ), s = ( 0 > s ? - s : s ) + ( 0 > h ? - h : h ) + ( 0 > ( a = i.l * this.Mk + i.g * this.Nk + i.s * this.Ok ) ? - a : a ), t.ma = i.v - e, t.na = i.A - o, t.oa = i.B - s, t.ja = i.v + e, t.ka = i.A + o, t.la = i.B + s;

	}, Pd: function ( t, i ) {

		var s, h, a; a = h = s = this.Rb, s = s < this.Ke ? s : this.Ke, h = h < this.Le ? h : this.Le, a = a < this.Me ? a : this.Me, s = this.Ke - s, h = this.Le - h, a = this.Me - a, i.x = 0 < t.x ? s : - s, i.y = 0 < t.y ? h : - h, i.z = 0 < t.z ? a : - a;

	}, Di: function ( t, i, s, h, a, e, o ) {

		var r = this.Ke, n = this.Le, p = this.Me, l = 0, c = 0, y = 0, f = 1, u = 1, b = 1; if ( - 1e-6 < ( h -= t ) && 1e-6 > h ) {

			if ( t <= - r || t >= r ) return ! 1;

		} else {

			var v = 1 / h, g = ( - r - t ) * v; g > ( r = ( r - t ) * v ) && ( v = g, g = r, r = v ), 0 < g && ( l = g ), 1 > r && ( f = r );

		}

		if ( - 1e-6 < ( a -= i ) && 1e-6 > a ) {

			if ( i <= - n || i >= n ) return ! 1;

		} else ( r = ( - n - i ) * ( g = 1 / a ) ) > ( n = ( n - i ) * g ) && ( g = r, r = n, n = g ), 0 < r && ( c = r ), 1 > n && ( u = n ); if ( - 1e-6 < ( e -= s ) && 1e-6 > e ) {

			if ( s <= - p || s >= p ) return ! 1;

		} else ( n = ( - p - s ) * ( r = 1 / e ) ) > ( p = ( p - s ) * r ) && ( r = n, n = p, p = r ), 0 < n && ( y = n ), 1 > p && ( b = p ); if ( 1 <= l || 1 <= c || 1 <= y || 0 >= f || 0 >= u || 0 >= b ) return ! 1; if ( p = l, l = 0, c > p && ( p = c, l = 1 ), y > p && ( p = y, l = 2 ), u < f && ( f = u ), b < f && ( f = b ), p > f || ! p ) return ! 1; switch ( l ) {

			case 0:o.normal.za( 0 < h ? - 1 : 1, 0, 0 ); break; case 1:o.normal.za( 0, 0 < a ? - 1 : 1, 0 ); break; case 2:o.normal.za( 0, 0, 0 < e ? - 1 : 1 );

		}

		return o.position.za( t + p * h, i + p * a, s + p * e ), o.fraction = p, ! 0;

	} } ), Gt.ua = ai, Gt.prototype = ri( ai.prototype, { Xh: function () {

		return this.ab;

	}, Bj: function () {

		return this.Ib;

	}, Oe: function () {

		var t = this.ab * this.ab, i = this.Ib * this.Ib, s = 6.28318530717958 * t * this.Ib, h = 3.14159265358979 * t * this.ab * 4 / 3, a = ( this.yf = s + h ) ? 1 / this.yf : 0; this.mg = i = a * ( s * ( .25 * t + i / 3 ) + h * ( .4 * t + this.Ib * this.ab * .75 + i ) ), this.pg = this.og = this.ng = 0, this.qg = a * ( s * t * .5 + h * t * .4 ), this.tg = this.sg = this.rg = 0, this.ug = i;

	}, Nb: function ( t, i ) {

		var s, h, a, e, o, r; a = h = s = this.ab, e = i.f, o = i.m, r = i.g, s += e = ( 0 > e ? - e : e ) * this.Ib, h += o = ( 0 > o ? - o : o ) * this.Ib, a += r = ( 0 > r ? - r : r ) * this.Ib, t.ma = i.v - s, t.na = i.A - h, t.oa = i.B - a, t.ja = i.v + s, t.ka = i.A + h, t.la = i.B + a;

	}, Pd: function ( t, i ) {

		0 < t.y ? i.za( 0, this.Ib, 0 ) : i.za( 0, - this.Ib, 0 );

	}, Di: function ( t, i, s, h, a, e, o ) {

		var r, n, p, l = this.Ib, c = e - s, y = ( n = h - t ) * n + c * c, f = t * n + s * c, u = f * f - y * ( r = t * t + s * s - this.ab * this.ab ); if ( 0 > u ) return ! 1; if ( 0 < y ) {

			if ( 1 <= ( r = ( - f - ( u = Math.sqrt( u ) ) ) / y ) || 0 >= ( - f + u ) / y ) return ! 1;

		} else {

			if ( 0 <= r ) return ! 1; r = 0;

		}

		return ( y = i + ( a - i ) * r ) > - l && y < l ? 0 < r && ( e = r, f = o.normal.za( t + n * e, 0, s + c * e ), 0 < ( i = Math.sqrt( f.x * f.x + f.y * f.y + f.z * f.z ) ) && ( i = 1 / i ), a = f.y * i, h = f.z * i, f.x = f.x * i, f.y = a, f.z = h, o.position.za( t + e * n, y, s + e * c ), o.fraction = e, ! 0 ) : ! ( 0 > ( u = ( f = ( p = t - 0 ) * ( t = h - t ) + ( l = i - ( n = 0 > y ? - l : l ) ) * ( i = a - i ) + ( c = s - 0 ) * ( s = e - s ) ) * f - ( y = t * t + i * i + s * s ) * ( r = p * p + l * l + c * c - this.ab * this.ab ) ) ) && ( ! ( 0 > ( e = ( - f - Math.sqrt( u ) ) / y ) || 1 < e ) && ( 0 < ( f = ( t = p + t * e ) * t + ( y = l + i * e ) * y + ( s = c + s * e ) * s ) && ( f = 1 / Math.sqrt( f ) ), ( i = o.position ).x = t + 0, i.y = y + n, i.z = s + 0, ( n = o.normal ).x = t * f, n.y = y * f, n.z = s * f, o.fraction = e, ! 0 ) );

	} } ), Kt.ua = ai, Kt.prototype = ri( ai.prototype, { Xh: function () {

		return this.ab;

	}, Bj: function () {

		return this.Ib;

	}, Oe: function () {

		var t = this.ab * this.ab, i = this.Ib * this.Ib * 4; this.yf = 3.14159265358979 * t * this.Ib * 2 / 3, this.mg = .05 * ( 3 * t + 2 * i ), this.pg = this.og = this.ng = 0, this.qg = .3 * t, this.tg = this.sg = this.rg = 0, this.ug = .08333333333333333 * ( 3 * t + 2 * i );

	}, Nb: function ( t, i ) {

		var s, h, a, e, o, r, n, p, l, c, y, f; s = i.f, h = i.m, a = i.g, e = Math.sqrt( 1 - s * s ), o = Math.sqrt( 1 - h * h ), r = Math.sqrt( 1 - a * a ), e *= this.ab, o *= this.ab, r *= this.ab, s *= this.Ib, h *= this.Ib, l = - ( a *= this.Ib ) - r, f = - a + r, r = ( n = - s - e ) > ( c = - s + e ) ? n : c, o = ( p = - h - o ) > ( y = - h + o ) ? p : y, e = l > f ? l : f, n = n < c ? n : c, p = p < y ? p : y, l = l < f ? l : f, t.ma = i.v + ( n < s ? n : s ), t.na = i.A + ( p < h ? p : h ), t.oa = i.B + ( l < a ? l : a ), t.ja = i.v + ( r > s ? r : s ), t.ka = i.A + ( o > h ? o : h ), t.la = i.B + ( e > a ? e : a );

	}, Pd: function ( t, i ) {

		var s = t.x, h = t.y, a = t.z; 0 < h && h * h > this.uk * this.uk * ( s * s + h * h + a * a ) ? ( i.za( 0, this.Ib - this.Rb / this.uk, 0 ), 0 > i.y && ( i.y = 0 ) ) : ( h = ( s = t.x ) * s + ( t = t.z ) * t, 0 > ( a = ( ( a = 2 * this.Ib ) - this.Rb ) / a * this.ab - this.Rb / this.kk ) && ( a = 0 ), h = 0 < h ? a / Math.sqrt( h ) : 0, 0 > ( a = this.Ib - this.Rb ) && ( a = 0 ), i.x = s * h, i.y = - a, i.z = t * h );

	}, Di: function ( t, i, s, h, a, e, o ) {

		var r = this.Ib; h -= t, e -= s; var n = 0, p = 1; if ( - 1e-6 < ( a -= i ) && 1e-6 > a ) {

			if ( i <= - r || i >= r ) return ! 1;

		} else {

			if ( ( c = ( - r - i ) * ( y = 1 / a ) ) > ( y = ( r - i ) * y ) ) var l = c, c = y, y = l; 0 < c && ( n = c ), 1 > y && ( p = y );

		}

		if ( 1 <= n || 0 >= p ) return ! 1; i -= r; var f = ( c = ( l = this.kk * this.kk ) * ( t * h + i * a + s * e ) - i * a ) * c - ( y = l * ( h * h + a * a + e * e ) - a * a ) * ( l = l * ( t * t + i * i + s * s ) - i * i ); if ( y ) {

			if ( 0 > f ) return ! 1; if ( f = Math.sqrt( f ), 0 > y ) {

				if ( 0 < a ) {

					if ( l = 0, 0 >= ( c = ( - c + f ) / y ) ) return ! 1;

				} else if ( l = ( - c - f ) / y, c = 1, 1 <= l ) return ! 1;

			} else if ( l = ( - c - f ) / y, c = ( - c + f ) / y, 1 <= l || 0 >= c ) return ! 1;

		} else if ( y = - l / ( 2 * c ), 0 < c ) {

			if ( l = 0, c = y, 0 >= y ) return ! 1;

		} else if ( l = y, c = 1, 1 <= y ) return ! 1; if ( i += r, c <= n || p <= l ) return ! 1; if ( l < n ) {

			if ( ! ( r = n ) ) return ! 1; o.normal.za( 0, 0 < a ? - 1 : 1, 0 );

		} else {

			if ( ! ( r = l ) ) return ! 1; n = o.normal.za( t + h * r, 0, s + e * r ), 0 < ( p = Math.sqrt( n.x * n.x + n.y * n.y + n.z * n.z ) ) && ( p = 1 / p ), c = n.y * p, y = n.z * p, n.x = n.x * p, n.y = c, n.z = y, p = this.kk, c = n.y * p, y = n.z * p, n.x = n.x * p, n.y = c, n.z = y, o.normal.y += this.uk;

		}

		return o.position.za( t + r * h, i + r * a, s + r * e ), o.fraction = r, ! 0;

	} } ), Ht.ua = ai, Ht.prototype = ri( ai.prototype, { Nn: function () {

		return this.zb;

	}, Oe: function () {

		this.mg = this.yf = 1, this.pg = this.og = this.ng = 0, this.qg = 1, this.tg = this.sg = this.rg = 0, this.ug = 1; for ( var t = this.zb[ 0 ].x, i = this.zb[ 0 ].y, s = this.zb[ 0 ].z, h = this.zb[ 0 ].x, a = this.zb[ 0 ].y, e = this.zb[ 0 ].z, o = 1, r = this.Ne; o < r; ) {

			var n = o ++, p = this.zb[ n ].x, l = this.zb[ n ].y; p < t ? t = p : p > h && ( h = p ), l < i ? i = l : l > a && ( a = l ), ( n = this.zb[ n ].z ) < s ? s = n : n > e && ( e = n );

		}

		o = h - t, r = a - i, p = e - s, this.yf = o * r * p, t = .25 * ( ( t + h ) * ( t + h ) + ( i + a ) * ( i + a ) + ( s + e ) * ( s + e ) ), o = o * o * .25, r = r * r * .25, p = p * p * .25, this.mg = .3333333333333333 * ( r + p ) + t, this.pg = this.og = this.ng = 0, this.qg = .3333333333333333 * ( p + o ) + t, this.tg = this.sg = this.rg = 0, this.ug = .3333333333333333 * ( o + r ) + t;

	}, Nb: function ( t, i ) {

		var s, h, a, e, o, r, n, p, l, c, y, f; l = p = n = this.Rb, c = ( s = this.zb[ 0 ] ).x, y = s.y, f = s.z, h = i.o * c + i.f * y + i.h * f, s = i.i * c + i.m * y + i.j * f, a = i.l * c + i.g * y + i.s * f, c = h + i.v, y = s + i.A, s = c, h = y, a = f = a + i.B, e = c, o = y, r = f; for ( var u = 1, b = this.Ne; u < b; ) {

			var v, g; c = u ++, c = ( f = this.zb[ c ] ).x, y = f.y, f = f.z, v = i.o * c + i.f * y + i.h * f, g = i.i * c + i.m * y + i.j * f, f = i.l * c + i.g * y + i.s * f, c = v, y = g, s = s < ( c += i.v ) ? s : c, h = h < ( y += i.A ) ? h : y, a = a < ( f += i.B ) ? a : f, e = e > c ? e : c, o = o > y ? o : y, r = r > f ? r : f;

		}

		t.ma = s - n, t.na = h - p, t.oa = a - l, t.ja = e + n, t.ka = o + p, t.la = r + l;

	}, Pd: function ( t, i ) {

		for ( var s = ( s = this.zb[ 0 ] ).x * t.x + s.y * t.y + s.z * t.z, h = 0, a = 1, e = this.Ne; a < e; ) {

			var o, r = a ++; ( o = ( o = this.zb[ r ] ).x * t.x + o.y * t.y + o.z * t.z ) > s && ( s = o, h = r );

		}

		t = this.zb[ h ], i.x = t.x, i.y = t.y, i.z = t.z;

	} } ), Nt.ua = ai, Nt.prototype = ri( ai.prototype, { Xh: function () {

		return this.ab;

	}, Bj: function () {

		return this.Ib;

	}, Oe: function () {

		var t = this.ab * this.ab, i = this.Ib * this.Ib * 4; this.yf = 3.14159265358979 * t * this.Ib * 2, this.mg = .08333333333333333 * ( 3 * t + i ), this.pg = this.og = this.ng = 0, this.qg = .5 * t, this.tg = this.sg = this.rg = 0, this.ug = .08333333333333333 * ( 3 * t + i );

	}, Nb: function ( t, i ) {

		var s, h, a, e, o, r; s = 0 > ( s = i.f ) ? - s : s, h = 0 > ( h = i.m ) ? - h : h, a = 0 > ( a = i.g ) ? - a : a, e = Math.sqrt( 1 - s * s ), o = Math.sqrt( 1 - h * h ), r = Math.sqrt( 1 - a * a ), e *= this.ab, o *= this.ab, r *= this.ab, e += s *= this.Ib, o += h *= this.Ib, r += a *= this.Ib, t.ma = i.v - e, t.na = i.A - o, t.oa = i.B - r, t.ja = i.v + e, t.ka = i.A + o, t.la = i.B + r;

	}, Pd: function ( t, i ) {

		var s = t.x, h = t.z, a = s * s + h * h, e = this.ab - this.Rb; 0 > e && ( e = 0 ), a = 0 < a ? e / Math.sqrt( a ) : 0, 0 > ( e = this.Ib - this.Rb ) && ( e = 0 ), i.x = s * a, i.y = 0 < t.y ? e : - e, i.z = h * a;

	}, Di: function ( t, i, s, h, a, e, o ) {

		var r = this.Ib, n = 0, p = 1; if ( - 1e-6 < ( a -= i ) && 1e-6 > a ) {

			if ( i <= - r || i >= r ) return ! 1;

		} else ( l = ( - r - i ) * ( c = 1 / a ) ) > ( r = ( r - i ) * c ) && ( c = l, l = r, r = c ), 0 < l && ( n = l ), 1 > r && ( p = r ); if ( 1 <= n || 0 >= p ) return ! 1; var l, c, y = ( l = t * ( h -= t ) + s * ( e -= s ) ) * l - ( r = h * h + e * e ) * ( c = t * t + s * s - this.ab * this.ab ); if ( 0 > y ) return ! 1; if ( 0 < r ) {

			if ( c = ( - l - ( y = Math.sqrt( y ) ) ) / r, r = ( - l + y ) / r, 1 <= c || 0 >= r ) return ! 1;

		} else {

			if ( 0 <= c ) return ! 1; c = 0, r = 1;

		}

		if ( r <= n || p <= c ) return ! 1; if ( c < n ) {

			if ( ! n ) return ! 1; o.normal.za( 0, 0 < a ? - 1 : 1, 0 );

		} else {

			if ( ! ( n = c ) ) return ! 1; p = o.normal.za( t + h * n, 0, s + e * n ), 0 < ( r = Math.sqrt( p.x * p.x + p.y * p.y + p.z * p.z ) ) && ( r = 1 / r ), l = p.y * r, c = p.z * r, p.x = p.x * r, p.y = l, p.z = c;

		}

		return o.position.za( t + n * h, i + n * a, s + n * e ), o.fraction = n, ! 0;

	} } ), Pt.ua = ai, Pt.prototype = ri( ai.prototype, { Xh: function () {

		return this.ab;

	}, Oe: function () {

		this.yf = 4.188790204786386 * this.ab * this.ab * this.ab, this.mg = .4 * this.ab * this.ab, this.pg = this.og = this.ng = 0, this.qg = .4 * this.ab * this.ab, this.tg = this.sg = this.rg = 0, this.ug = .4 * this.ab * this.ab;

	}, Nb: function ( t, i ) {

		var s, h, a; a = h = s = this.ab, t.ma = i.v - s, t.na = i.A - h, t.oa = i.B - a, t.ja = i.v + s, t.ka = i.A + h, t.la = i.B + a;

	}, Pd: function ( t, i ) {

		i.Z();

	}, Di: function ( t, i, s, h, a, e, o ) {

		var r, n = t * ( h -= t ) + i * ( a -= i ) + s * ( r = e - s ), p = n * n - ( e = h * h + a * a + r * r ) * ( t * t + i * i + s * s - this.ab * this.ab ); return ! ( 0 > p ) && ( ! ( 0 > ( e = ( - n - Math.sqrt( p ) ) / e ) || 1 < e ) && ( 0 < ( h = ( t += h * e ) * t + ( i += a * e ) * i + ( s += r * e ) * s ) && ( h = 1 / Math.sqrt( h ) ), ( a = o.position ).x = t, a.y = i, a.z = s, ( a = o.normal ).x = t * h, a.y = i * h, a.z = s * h, o.fraction = e, ! 0 ) );

	} } ), Ft.prototype = { ua: function ( t, i ) {

		return this.Jb[ t ][ i ];

	} }, Lt.prototype = { mm: function () {

		for ( var t = 0, i = 0, s = this.numPoints; i < s; ) {

			var h = i ++; this.points[ h ].depth > t && ( t = this.points[ h ].depth );

		}

		return t;

	}, clear: function () {

		for ( var t = this.numPoints = 0, i = this.points; t < i.length; ) {

			var s = i[ t ]; ++ t, s.position1.Z(), s.position2.Z(), s.depth = 0, s.id = 0;

		}

		this.normal.Z();

	} }, Tt.prototype = { yh: function ( t, i, s, h ) {

		var a = t.normal; a.x = i, a.y = s, a.z = h, this.Sg && ( i = - ( t = t.normal ).y, s = - t.z, t.x = - t.x, t.y = i, t.z = s );

	}, Cg: function ( t, i, s, h, a, e, o, r, n ) {

		( t = t.points[ t.numPoints ++ ] ).depth = r, t.id = n, this.Sg ? ( ( r = t.position1 ).x = a, r.y = e, r.z = o, ( a = t.position2 ).x = i, a.y = s, a.z = h ) : ( ( r = t.position1 ).x = i, r.y = s, r.z = h, ( i = t.position2 ).x = a, i.y = e, i.z = o );

	}, th: function () {}, hm: function ( t, i, s, h, a, e ) {

		for ( var o = t.numPoints = 0, r = t.points; o < r.length; ) {

			var n = r[ o ]; ++ o, n.position1.Z(), n.position2.Z(), n.depth = 0, n.id = 0;

		}

		t.normal.Z(), this.Sg ? this.th( t, s, i, a, h, e ) : this.th( t, i, s, h, a, e );

	} }, It.ua = Tt, It.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a ) {

		var e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O, L, F, P, R, J, N, H, K, G, V, E, U, W, Y, X, $ = i, Z = s; t.incremental = ! 1, e = h.v, o = h.A, r = h.B, c = ( n = a.v ) - e, y = ( p = a.A ) - o, f = ( l = a.B ) - r, u = h.o, b = h.i, v = h.l, g = h.f, x = h.m, d = h.g, z = h.h, m = h.j, j = h.s, M = a.o, A = a.i, w = a.l, D = a.f, C = a.m, B = a.g, q = a.h, S = a.j, k = a.s, I = u * ( wh = $.Ke ), T = b * wh, O = v * wh, L = g * ( Bh = $.Le ), F = x * Bh, P = d * Bh, R = z * ( kh = $.Me ), J = m * kh, N = j * kh; var Q, _, tt, it = 1 / 0, st = - 1, ht = 0; tt = _ = Q = 0; var at = u * ( H = M * ( Dh = Z.Ke ) ) + b * ( K = A * Dh ) + v * ( G = w * Dh ), et = u * ( V = D * ( qh = Z.Le ) ) + b * ( E = C * qh ) + v * ( U = B * qh ), ot = u * ( W = q * ( Ih = Z.Me ) ) + b * ( Y = S * Ih ) + v * ( X = k * Ih ); 0 > at && ( at = - at ), 0 > et && ( et = - et ), 0 > ot && ( ot = - ot ); var rt = wh + ( at + et + ot ), nt = 0 > ( ds = u * c + b * y + v * f ), pt = nt ? - ds : ds; if ( pt < rt ) {

			var lt = rt - pt; lt < it && ( it = lt, st = 0, Q = u, _ = b, tt = v, ht = nt ? - 1 : 1 ); var ct = g * H + x * K + d * G, yt = g * V + x * E + d * U, ft = g * W + x * Y + d * X; 0 > ct && ( ct = - ct ), 0 > yt && ( yt = - yt ), 0 > ft && ( ft = - ft ); var ut = Bh + ( ct + yt + ft ), bt = 0 > ( ds = g * c + x * y + d * f ), vt = bt ? - ds : ds; if ( vt < ut ) {

				var xt = ut - vt; xt < it && ( it = xt, st = 1, Q = g, _ = x, tt = d, ht = bt ? - 1 : 1 ); var dt = z * H + m * K + j * G, zt = z * V + m * E + j * U, mt = z * W + m * Y + j * X; 0 > dt && ( dt = - dt ), 0 > zt && ( zt = - zt ), 0 > mt && ( mt = - mt ); var jt = kh + ( dt + zt + mt ), Mt = 0 > ( ds = z * c + m * y + j * f ), At = Mt ? - ds : ds; if ( At < jt ) {

					var wt = jt - At; wt < it && ( it = wt, st = 2, Q = z, _ = m, tt = j, ht = Mt ? - 1 : 1 ); it = it > gt.linearSlop ? it - gt.linearSlop : 0; var Dt = M * I + A * T + w * O, Ct = M * L + A * F + w * P, Bt = M * R + A * J + w * N; 0 > Dt && ( Dt = - Dt ), 0 > Ct && ( Ct = - Ct ), 0 > Bt && ( Bt = - Bt ); var qt = Dt + Ct + Bt + Dh, St = 0 > ( ds = M * c + A * y + w * f ), kt = St ? - ds : ds; if ( kt < qt ) {

						var It = qt - kt; It < it && ( it = It, st = 3, Q = M, _ = A, tt = w, ht = St ? - 1 : 1 ); var Tt = D * I + C * T + B * O, Ot = D * L + C * F + B * P, Lt = D * R + C * J + B * N; 0 > Tt && ( Tt = - Tt ), 0 > Ot && ( Ot = - Ot ), 0 > Lt && ( Lt = - Lt ); var Ft = Tt + Ot + Lt + qh, Pt = 0 > ( ds = D * c + C * y + B * f ), Rt = Pt ? - ds : ds; if ( Rt < Ft ) {

							var Jt = Ft - Rt; Jt < it && ( it = Jt, st = 4, Q = D, _ = C, tt = B, ht = Pt ? - 1 : 1 ); var Nt = q * I + S * T + k * O, Ht = q * L + S * F + k * P, Kt = q * R + S * J + k * N; 0 > Nt && ( Nt = - Nt ), 0 > Ht && ( Ht = - Ht ), 0 > Kt && ( Kt = - Kt ); var Gt = Nt + Ht + Kt + Ih, Vt = 0 > ( ds = q * c + S * y + k * f ), Et = Vt ? - ds : ds; if ( Et < Gt ) {

								var Ut = Gt - Et; Ut < it && ( it = Ut, st = 5, Q = q, _ = S, tt = k, ht = Vt ? - 1 : 1 ); var Wt, Yt, Xt; it = it > gt.linearSlop ? it - gt.linearSlop : 0; if ( Yt = v * M - u * w, Xt = u * A - b * M, ( Wt = b * w - v * A ) || Yt || Xt ) {

									var $t = Wt * Wt + Yt * Yt + Xt * Xt; 0 < $t && ( $t = 1 / Math.sqrt( $t ) ); var Zt = ( Wt *= $t ) * L + ( Yt *= $t ) * F + ( Xt *= $t ) * P, Qt = Wt * R + Yt * J + Xt * N; 0 > Zt && ( Zt = - Zt ), 0 > Qt && ( Qt = - Qt ); var _t = Wt * V + Yt * E + Xt * U, ti = Wt * W + Yt * Y + Xt * X; 0 > _t && ( _t = - _t ), 0 > ti && ( ti = - ti ); var ii = Zt + Qt + ( _t + ti ), si = 0 > ( ds = Wt * c + Yt * y + Xt * f ), hi = si ? - ds : ds; if ( ! ( hi < ii ) ) return; var ai = ii - hi; ai < it && ( it = ai, st = 6, Q = Wt, _ = Yt, tt = Xt, ht = si ? - 1 : 1 );

								}

								if ( Yt = v * D - u * B, Xt = u * C - b * D, ( Wt = b * B - v * C ) || Yt || Xt ) {

									var ei = Wt * Wt + Yt * Yt + Xt * Xt; 0 < ei && ( ei = 1 / Math.sqrt( ei ) ); var oi = ( Wt *= ei ) * L + ( Yt *= ei ) * F + ( Xt *= ei ) * P, ri = Wt * R + Yt * J + Xt * N; 0 > oi && ( oi = - oi ), 0 > ri && ( ri = - ri ); var ni = Wt * H + Yt * K + Xt * G, pi = Wt * W + Yt * Y + Xt * X; 0 > ni && ( ni = - ni ), 0 > pi && ( pi = - pi ); var li = oi + ri + ( ni + pi ), ci = 0 > ( ds = Wt * c + Yt * y + Xt * f ), yi = ci ? - ds : ds; if ( ! ( yi < li ) ) return; var fi = li - yi; fi < it && ( it = fi, st = 7, Q = Wt, _ = Yt, tt = Xt, ht = ci ? - 1 : 1 );

								}

								if ( Yt = v * q - u * k, Xt = u * S - b * q, ( Wt = b * k - v * S ) || Yt || Xt ) {

									var ui = Wt * Wt + Yt * Yt + Xt * Xt; 0 < ui && ( ui = 1 / Math.sqrt( ui ) ); var bi = ( Wt *= ui ) * L + ( Yt *= ui ) * F + ( Xt *= ui ) * P, vi = Wt * R + Yt * J + Xt * N; 0 > bi && ( bi = - bi ), 0 > vi && ( vi = - vi ); var gi = Wt * H + Yt * K + Xt * G, xi = Wt * V + Yt * E + Xt * U; 0 > gi && ( gi = - gi ), 0 > xi && ( xi = - xi ); var di = bi + vi + ( gi + xi ), zi = 0 > ( ds = Wt * c + Yt * y + Xt * f ), mi = zi ? - ds : ds; if ( ! ( mi < di ) ) return; var ji = di - mi; ji < it && ( it = ji, st = 8, Q = Wt, _ = Yt, tt = Xt, ht = zi ? - 1 : 1 );

								}

								if ( Yt = d * M - g * w, Xt = g * A - x * M, ( Wt = x * w - d * A ) || Yt || Xt ) {

									var Mi = Wt * Wt + Yt * Yt + Xt * Xt; 0 < Mi && ( Mi = 1 / Math.sqrt( Mi ) ); var Ai = ( Wt *= Mi ) * I + ( Yt *= Mi ) * T + ( Xt *= Mi ) * O, wi = Wt * R + Yt * J + Xt * N; 0 > Ai && ( Ai = - Ai ), 0 > wi && ( wi = - wi ); var Di = Wt * V + Yt * E + Xt * U, Ci = Wt * W + Yt * Y + Xt * X; 0 > Di && ( Di = - Di ), 0 > Ci && ( Ci = - Ci ); var Bi = Ai + wi + ( Di + Ci ), qi = 0 > ( ds = Wt * c + Yt * y + Xt * f ), Si = qi ? - ds : ds; if ( ! ( Si < Bi ) ) return; var ki = Bi - Si; ki < it && ( it = ki, st = 9, Q = Wt, _ = Yt, tt = Xt, ht = qi ? - 1 : 1 );

								}

								if ( Yt = d * D - g * B, Xt = g * C - x * D, ( Wt = x * B - d * C ) || Yt || Xt ) {

									var Ii = Wt * Wt + Yt * Yt + Xt * Xt; 0 < Ii && ( Ii = 1 / Math.sqrt( Ii ) ); var Ti = ( Wt *= Ii ) * I + ( Yt *= Ii ) * T + ( Xt *= Ii ) * O, Oi = Wt * R + Yt * J + Xt * N; 0 > Ti && ( Ti = - Ti ), 0 > Oi && ( Oi = - Oi ); var Li = Wt * H + Yt * K + Xt * G, Fi = Wt * W + Yt * Y + Xt * X; 0 > Li && ( Li = - Li ), 0 > Fi && ( Fi = - Fi ); var Pi = Ti + Oi + ( Li + Fi ), Ri = 0 > ( ds = Wt * c + Yt * y + Xt * f ), Ji = Ri ? - ds : ds; if ( ! ( Ji < Pi ) ) return; var Ni = Pi - Ji; Ni < it && ( it = Ni, st = 10, Q = Wt, _ = Yt, tt = Xt, ht = Ri ? - 1 : 1 );

								}

								if ( Yt = d * q - g * k, Xt = g * S - x * q, ( Wt = x * k - d * S ) || Yt || Xt ) {

									var Hi = Wt * Wt + Yt * Yt + Xt * Xt; 0 < Hi && ( Hi = 1 / Math.sqrt( Hi ) ); var Ki = ( Wt *= Hi ) * I + ( Yt *= Hi ) * T + ( Xt *= Hi ) * O, Gi = Wt * R + Yt * J + Xt * N; 0 > Ki && ( Ki = - Ki ), 0 > Gi && ( Gi = - Gi ); var Vi = Wt * H + Yt * K + Xt * G, Ei = Wt * V + Yt * E + Xt * U; 0 > Vi && ( Vi = - Vi ), 0 > Ei && ( Ei = - Ei ); var Ui = Ki + Gi + ( Vi + Ei ), Wi = 0 > ( ds = Wt * c + Yt * y + Xt * f ), Yi = Wi ? - ds : ds; if ( ! ( Yi < Ui ) ) return; var Xi = Ui - Yi; Xi < it && ( it = Xi, st = 11, Q = Wt, _ = Yt, tt = Xt, ht = Wi ? - 1 : 1 );

								}

								if ( Yt = j * M - z * w, Xt = z * A - m * M, ( Wt = m * w - j * A ) || Yt || Xt ) {

									var $i = Wt * Wt + Yt * Yt + Xt * Xt; 0 < $i && ( $i = 1 / Math.sqrt( $i ) ); var Zi = ( Wt *= $i ) * I + ( Yt *= $i ) * T + ( Xt *= $i ) * O, Qi = Wt * L + Yt * F + Xt * P; 0 > Zi && ( Zi = - Zi ), 0 > Qi && ( Qi = - Qi ); var _i = Wt * V + Yt * E + Xt * U, ts = Wt * W + Yt * Y + Xt * X; 0 > _i && ( _i = - _i ), 0 > ts && ( ts = - ts ); var is = Zi + Qi + ( _i + ts ), ss = 0 > ( ds = Wt * c + Yt * y + Xt * f ), hs = ss ? - ds : ds; if ( ! ( hs < is ) ) return; var as = is - hs; as < it && ( it = as, st = 12, Q = Wt, _ = Yt, tt = Xt, ht = ss ? - 1 : 1 );

								}

								if ( Yt = j * D - z * B, Xt = z * C - m * D, ( Wt = m * B - j * C ) || Yt || Xt ) {

									var es = Wt * Wt + Yt * Yt + Xt * Xt; 0 < es && ( es = 1 / Math.sqrt( es ) ); var os = ( Wt *= es ) * I + ( Yt *= es ) * T + ( Xt *= es ) * O, rs = Wt * L + Yt * F + Xt * P; 0 > os && ( os = - os ), 0 > rs && ( rs = - rs ); var ns = Wt * H + Yt * K + Xt * G, ps = Wt * W + Yt * Y + Xt * X; 0 > ns && ( ns = - ns ), 0 > ps && ( ps = - ps ); var ls = os + rs + ( ns + ps ), cs = 0 > ( ds = Wt * c + Yt * y + Xt * f ), ys = cs ? - ds : ds; if ( ! ( ys < ls ) ) return; var fs = ls - ys; fs < it && ( it = fs, st = 13, Q = Wt, _ = Yt, tt = Xt, ht = cs ? - 1 : 1 );

								}

								if ( Yt = j * q - z * k, Xt = z * S - m * q, ( Wt = m * k - j * S ) || Yt || Xt ) {

									var us = Wt * Wt + Yt * Yt + Xt * Xt; 0 < us && ( us = 1 / Math.sqrt( us ) ); var bs = ( Wt *= us ) * I + ( Yt *= us ) * T + ( Xt *= us ) * O, vs = Wt * L + Yt * F + Xt * P; 0 > bs && ( bs = - bs ), 0 > vs && ( vs = - vs ); var gs = Wt * H + Yt * K + Xt * G, xs = Wt * V + Yt * E + Xt * U; 0 > gs && ( gs = - gs ), 0 > xs && ( xs = - xs ); var ds, zs = bs + vs + ( gs + xs ), ms = 0 > ( ds = Wt * c + Yt * y + Xt * f ), js = ms ? - ds : ds; if ( ! ( js < zs ) ) return; var Ms = zs - js; Ms < it && ( it = Ms, st = 14, Q = Wt, _ = Yt, tt = Xt, ht = ms ? - 1 : 1 );

								}

								if ( 6 <= st ) {

									Q *= ht, _ *= ht, tt *= ht; var As, ws, Ds, Cs, Bs, qs, Ss, ks, Is, Ts, Os, Ls, Fs, Ps, Rs, Js = ( st - 6 ) / 3 | 0, Ns = st - 6 - 3 * Js; switch ( Js ) {

										case 0:Ss = u, ks = b, Is = v; var Hs = 0 < R * Q + J * _ + N * tt; 0 < L * Q + F * _ + P * tt ? Hs ? ( As = L + R, ws = F + J, Ds = P + N ) : ( As = L - R, ws = F - J, Ds = P - N ) : Hs ? ( As = R - L, ws = J - F, Ds = N - P ) : ( As = - ( As = L + R ), ws = - ( ws = F + J ), Ds = - ( Ds = P + N ) ); break; case 1:Ss = g, ks = x, Is = d; var Ks = 0 < R * Q + J * _ + N * tt; 0 < I * Q + T * _ + O * tt ? Ks ? ( As = I + R, ws = T + J, Ds = O + N ) : ( As = I - R, ws = T - J, Ds = O - N ) : Ks ? ( As = R - I, ws = J - T, Ds = N - O ) : ( As = - ( As = I + R ), ws = - ( ws = T + J ), Ds = - ( Ds = O + N ) ); break; default:Ss = z, ks = m, Is = j; var Gs = 0 < L * Q + F * _ + P * tt; 0 < I * Q + T * _ + O * tt ? Gs ? ( As = I + L, ws = T + F, Ds = O + P ) : ( As = I - L, ws = T - F, Ds = O - P ) : Gs ? ( As = L - I, ws = F - T, Ds = P - O ) : ( As = - ( As = I + L ), ws = - ( ws = T + F ), Ds = - ( Ds = O + P ) );

									}

									switch ( As = e + As, ws = o + ws, Ds = r + Ds, Ns ) {

										case 0:Ts = M, Os = A, Ls = w; var Vs = 0 < W * Q + Y * _ + X * tt; 0 < V * Q + E * _ + U * tt ? Vs ? ( Cs = V + W, Bs = E + Y, qs = U + X ) : ( Cs = V - W, Bs = E - Y, qs = U - X ) : Vs ? ( Cs = W - V, Bs = Y - E, qs = X - U ) : ( Cs = - ( Cs = V + W ), Bs = - ( Bs = E + Y ), qs = - ( qs = U + X ) ); break; case 1:Ts = D, Os = C, Ls = B; var Es = 0 < W * Q + Y * _ + X * tt; 0 < H * Q + K * _ + G * tt ? Es ? ( Cs = H + W, Bs = K + Y, qs = G + X ) : ( Cs = H - W, Bs = K - Y, qs = G - X ) : Es ? ( Cs = W - H, Bs = Y - K, qs = X - G ) : ( Cs = - ( Cs = H + W ), Bs = - ( Bs = K + Y ), qs = - ( qs = G + X ) ); break; default:Ts = q, Os = S, Ls = k; var Us = 0 < V * Q + E * _ + U * tt; 0 < H * Q + K * _ + G * tt ? Us ? ( Cs = H + V, Bs = K + E, qs = G + U ) : ( Cs = H - V, Bs = K - E, qs = G - U ) : Us ? ( Cs = V - H, Bs = E - K, qs = U - G ) : ( Cs = - ( Cs = H + V ), Bs = - ( Bs = K + E ), qs = - ( qs = G + U ) );

									}

									var Ws, Ys, Xs, $s, Zs, Qs, _s = Ss * Ts + ks * Os + Is * Ls, th = Ss * ( Fs = As - ( Cs = n - Cs ) ) + ks * ( Ps = ws - ( Bs = p - Bs ) ) + Is * ( Rs = Ds - ( qs = l - qs ) ), ih = Ts * Fs + Os * Ps + Ls * Rs, sh = 1 / ( 1 - _s * _s ), hh = ( _s * ih - th ) * sh, ah = ( ih - _s * th ) * sh; Ws = As + Ss * hh, Ys = ws + ks * hh, Xs = Ds + Is * hh, $s = Cs + Ts * ah, Zs = Bs + Os * ah, Qs = qs + Ls * ah, this.yh( t, - Q, - _, - tt ), this.Cg( t, Ws, Ys, Xs, $s, Zs, Qs, it, 4 );

								} else {

									var eh, oh, rh, nh, ph, lh, ch, yh, fh, uh, bh, vh, gh, xh, dh, zh, mh, jh; if ( 3 <= st ) {

										ht = - ht, c = - c, y = - y, f = - f; var Mh = $, Ah = ( $ = Z, Z = Mh, wh ), wh = Dh, Dh = Ah, Ch = Bh, Bh = qh, qh = Ch, Sh = kh, kh = Ih, Ih = Sh; eh = e, oh = o, rh = r, e = n, o = p, r = l, n = eh, p = oh, l = rh, eh = u, oh = b, rh = v, u = M, b = A, v = w, M = eh, A = oh, w = rh, eh = g, oh = x, rh = d, g = D, x = C, d = B, D = eh, C = oh, B = rh, eh = z, oh = m, rh = j, z = q, m = S, j = k, q = eh, S = oh, k = rh, eh = I, oh = T, rh = O, I = H, T = K, O = G, H = eh, K = oh, G = rh, eh = L, oh = F, rh = P, L = V, F = E, P = U, V = eh, E = oh, U = rh, eh = R, oh = J, rh = N, R = W, J = Y, N = X, W = eh, Y = oh, X = rh, st -= 3, nh = ! 0;

									} else nh = ! 1; switch ( st ) {

										case 0:ph = I, lh = T, ch = O, yh = u, fh = b, uh = v, bh = g, vh = x, gh = d, xh = z, dh = m, zh = j, mh = Bh, jh = kh; break; case 1:ph = L, lh = F, ch = P, yh = g, fh = x, uh = d, bh = z, vh = m, gh = j, xh = u, dh = b, zh = v, mh = kh, jh = wh; break; default:ph = R, lh = J, ch = N, yh = z, fh = m, uh = j, bh = u, vh = b, gh = v, xh = g, dh = x, zh = d, mh = wh, jh = Bh;

									}

									if ( 0 > ht ) {

										ph = - ph, lh = - lh, ch = - ch, yh = - yh, fh = - fh, uh = - uh, eh = bh, oh = vh, rh = gh, bh = xh, vh = dh, gh = zh, xh = eh, dh = oh, zh = rh; var Th = mh; mh = jh, jh = Th;

									}

									ph += e, lh += o, ch += r; var Oh, Lh, Fh, Ph, Rh, Jh, Nh, Hh, Kh, Gh, Vh, Eh, Uh = 1, Wh = 0, Yh = yh * M + fh * A + uh * w; switch ( Yh < Uh && ( Uh = Yh, Wh = 0 ), - Yh < Uh && ( Uh = - Yh, Wh = 1 ), ( Yh = yh * D + fh * C + uh * B ) < Uh && ( Uh = Yh, Wh = 2 ), - Yh < Uh && ( Uh = - Yh, Wh = 3 ), ( Yh = yh * q + fh * S + uh * k ) < Uh && ( Uh = Yh, Wh = 4 ), - Yh < Uh && ( Uh = - Yh, Wh = 5 ), Wh ) {

										case 0:Oh = H + V, Lh = K + E, Fh = G + U, Oh += W, Lh += Y, Fh += X, Ph = H - V, Rh = K - E, Jh = G - U, Ph += W, Rh += Y, Jh += X, Nh = H - V, Hh = K - E, Kh = G - U, Nh -= W, Hh -= Y, Kh -= X, Gh = H + V, Vh = K + E, Eh = G + U, Gh -= W, Vh -= Y, Eh -= X; break; case 1:Oh = V - H, Lh = E - K, Fh = U - G, Oh += W, Lh += Y, Fh += X, Ph = V - H, Rh = E - K, Jh = U - G, Ph -= W, Rh -= Y, Jh -= X, Nh = - ( Nh = H + V ), Hh = - ( Hh = K + E ), Kh = - ( Kh = G + U ), Nh -= W, Hh -= Y, Kh -= X, Gh = - ( Gh = H + V ), Vh = - ( Vh = K + E ), Eh = - ( Eh = G + U ), Gh += W, Vh += Y, Eh += X; break; case 2:Oh = H + V, Lh = K + E, Fh = G + U, Oh += W, Lh += Y, Fh += X, Ph = H + V, Rh = K + E, Jh = G + U, Ph -= W, Rh -= Y, Jh -= X, Nh = V - H, Hh = E - K, Kh = U - G, Nh -= W, Hh -= Y, Kh -= X, Gh = V - H, Vh = E - K, Eh = U - G, Gh += W, Vh += Y, Eh += X; break; case 3:Oh = H - V, Lh = K - E, Fh = G - U, Oh += W, Lh += Y, Fh += X, Ph = - ( Ph = H + V ), Rh = - ( Rh = K + E ), Jh = - ( Jh = G + U ), Ph += W, Rh += Y, Jh += X, Nh = - ( Nh = H + V ), Hh = - ( Hh = K + E ), Kh = - ( Kh = G + U ), Nh -= W, Hh -= Y, Kh -= X, Gh = H - V, Vh = K - E, Eh = G - U, Gh -= W, Vh -= Y, Eh -= X; break; case 4:Oh = H + V, Lh = K + E, Fh = G + U, Oh += W, Lh += Y, Fh += X, Ph = V - H, Rh = E - K, Jh = U - G, Ph += W, Rh += Y, Jh += X, Nh = - ( Nh = H + V ), Hh = - ( Hh = K + E ), Kh = - ( Kh = G + U ), Nh += W, Hh += Y, Kh += X, Gh = H - V, Vh = K - E, Eh = G - U, Gh += W, Vh += Y, Eh += X; break; default:Oh = H + V, Lh = K + E, Fh = G + U, Oh -= W, Lh -= Y, Fh -= X, Ph = H - V, Rh = K - E, Jh = G - U, Ph -= W, Rh -= Y, Jh -= X, Nh = - ( Nh = H + V ), Hh = - ( Hh = K + E ), Kh = - ( Kh = G + U ), Nh -= W, Hh -= Y, Kh -= X, Gh = V - H, Vh = E - K, Eh = U - G, Gh -= W, Vh -= Y, Eh -= X;

									}

									Oh += c, Lh += y, Fh += f, Ph += c, Rh += y, Jh += f, Nh += c, Hh += y, Kh += f, Gh += c, Vh += y, Eh += f; var Xh = this.Dg; Xh.w = mh, Xh.Dj = jh, Xh.Tc = 0, Xh.hc = 0; var $h = this.Dg, Zh = $h.Bc[ $h.Tc ++ ]; Zh.x = Oh * bh + Lh * vh + Fh * gh, Zh.y = Oh * xh + Lh * dh + Fh * zh, Zh.Oa = Oh, Zh.Pa = Lh, Zh.Qa = Fh; var Qh = this.Dg, _h = Qh.Bc[ Qh.Tc ++ ]; _h.x = Ph * bh + Rh * vh + Jh * gh, _h.y = Ph * xh + Rh * dh + Jh * zh, _h.Oa = Ph, _h.Pa = Rh, _h.Qa = Jh; var ta = this.Dg, ia = ta.Bc[ ta.Tc ++ ]; ia.x = Nh * bh + Hh * vh + Kh * gh, ia.y = Nh * xh + Hh * dh + Kh * zh, ia.Oa = Nh, ia.Pa = Hh, ia.Qa = Kh; var sa, ha, aa, ea = this.Dg, oa = ea.Bc[ ea.Tc ++ ]; oa.x = Gh * bh + Vh * vh + Eh * gh, oa.y = Gh * xh + Vh * dh + Eh * zh, oa.Oa = Gh, oa.Pa = Vh, oa.Qa = Eh, this.Dg.clip(), this.Dg.reduce(), nh ? ( sa = yh, ha = fh, aa = uh ) : ( sa = - yh, ha = - fh, aa = - uh ), this.yh( t, sa, ha, aa ); for ( var ra = 0, na = this.Dg.Tc; ra < na; ) {

										var pa, la, ca, ya = ra ++, fa = this.Dg.Bc[ ya ]; pa = fa.Oa, la = fa.Pa, ca = fa.Qa; var ua, ba, va, ga = ( ph - ( pa += e ) ) * yh + ( lh - ( la += o ) ) * fh + ( ch - ( ca += r ) ) * uh; ua = pa + yh * ga, ba = la + fh * ga, va = ca + uh * ga, ga > - gt.contactPersistenceThreshold && ( nh ? this.Cg( t, pa, la, ca, ua, ba, va, ga, ya ) : this.Cg( t, ua, ba, va, pa, la, ca, ga, ya ) );

									}

								}

							}

						}

					}

				}

			}

		}

	} } ), St.prototype = { clip: function () {

		for ( var t = 0, i = this.Tc; t < i; ) {

			var s = t ++, h = this.Bc[ s ], a = ( s = this.Bc[ ( s + 1 ) % this.Tc ], this.w + h.x ), e = this.w + s.x; if ( 0 < a && 0 < e )( s = this.ic[ this.hc ++ ] ).x = h.x, s.y = h.y, s.Oa = h.Oa, s.Pa = h.Pa, s.Qa = h.Qa; else if ( 0 < a && 0 >= e ) {

				var o = this.ic[ this.hc ++ ]; o.x = h.x, o.y = h.y, o.Oa = h.Oa, o.Pa = h.Pa, o.Qa = h.Qa, a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a;

			} else 0 >= a && 0 < e && ( a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a );

		}

		for ( t = this.Bc, this.Bc = this.ic, this.ic = t, this.Tc = this.hc, t = this.hc = 0, i = this.Tc; t < i; )s = t ++, h = this.Bc[ s ], s = this.Bc[ ( s + 1 ) % this.Tc ], a = this.w - h.x, e = this.w - s.x, 0 < a && 0 < e ? ( ( s = this.ic[ this.hc ++ ] ).x = h.x, s.y = h.y, s.Oa = h.Oa, s.Pa = h.Pa, s.Qa = h.Qa ) : 0 < a && 0 >= e ? ( ( o = this.ic[ this.hc ++ ] ).x = h.x, o.y = h.y, o.Oa = h.Oa, o.Pa = h.Pa, o.Qa = h.Qa, a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ) : 0 >= a && 0 < e && ( a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ); for ( t = this.Bc, this.Bc = this.ic, this.ic = t, this.Tc = this.hc, t = this.hc = 0, i = this.Tc; t < i; )s = t ++, h = this.Bc[ s ], s = this.Bc[ ( s + 1 ) % this.Tc ], a = this.Dj + h.y, e = this.Dj + s.y, 0 < a && 0 < e ? ( ( s = this.ic[ this.hc ++ ] ).x = h.x, s.y = h.y, s.Oa = h.Oa, s.Pa = h.Pa, s.Qa = h.Qa ) : 0 < a && 0 >= e ? ( ( o = this.ic[ this.hc ++ ] ).x = h.x, o.y = h.y, o.Oa = h.Oa, o.Pa = h.Pa, o.Qa = h.Qa, a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ) : 0 >= a && 0 < e && ( a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ); for ( t = this.Bc, this.Bc = this.ic, this.ic = t, this.Tc = this.hc, t = this.hc = 0, i = this.Tc; t < i; )s = t ++, h = this.Bc[ s ], s = this.Bc[ ( s + 1 ) % this.Tc ], a = this.Dj - h.y, e = this.Dj - s.y, 0 < a && 0 < e ? ( ( s = this.ic[ this.hc ++ ] ).x = h.x, s.y = h.y, s.Oa = h.Oa, s.Pa = h.Pa, s.Qa = h.Qa ) : 0 < a && 0 >= e ? ( ( o = this.ic[ this.hc ++ ] ).x = h.x, o.y = h.y, o.Oa = h.Oa, o.Pa = h.Pa, o.Qa = h.Qa, a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ) : 0 >= a && 0 < e && ( a /= a - e, ( e = this.ic[ this.hc ++ ] ).x = h.x + ( s.x - h.x ) * a, e.y = h.y + ( s.y - h.y ) * a, e.Oa = h.Oa + ( s.Oa - h.Oa ) * a, e.Pa = h.Pa + ( s.Pa - h.Pa ) * a, e.Qa = h.Qa + ( s.Qa - h.Qa ) * a ); t = this.Bc, this.Bc = this.ic, this.ic = t, this.Tc = this.hc, this.hc = 0;

	}, reduce: function () {

		if ( ! ( 4 > this.Tc ) ) {

			for ( var t = - 1 / 0, i = 1 / 0, s = - 1 / 0, h = 1 / 0, a = null, e = null, o = null, r = null, n = 0, p = this.Tc; n < p; ) {

				var l = n ++, c = 1 * ( l = this.Bc[ l ] ).x + 1 * l.y, y = - 1 * l.x + 1 * l.y; c > t && ( t = c, a = l ), c < i && ( i = c, e = l ), y > s && ( s = y, o = l ), y < h && ( h = y, r = l );

			}

			( t = this.ic[ this.hc ++ ] ).x = a.x, t.y = a.y, t.Oa = a.Oa, t.Pa = a.Pa, t.Qa = a.Qa, ( a = this.ic[ this.hc ++ ] ).x = o.x, a.y = o.y, a.Oa = o.Oa, a.Pa = o.Pa, a.Qa = o.Qa, ( o = this.ic[ this.hc ++ ] ).x = e.x, o.y = e.y, o.Oa = e.Oa, o.Pa = e.Pa, o.Qa = e.Qa, ( e = this.ic[ this.hc ++ ] ).x = r.x, e.y = r.y, e.Oa = r.Oa, e.Pa = r.Pa, e.Qa = r.Qa, r = this.Bc, this.Bc = this.ic, this.ic = r, this.Tc = this.hc, this.hc = 0;

		}

	} }, qt.prototype = { Xe: function () {

		null != this.oi && this.oi.clear();

	} }, Bt.ua = Tt, Bt.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a ) {

		var e, o, r, n, p, l; t.incremental = ! 1, e = h.f, o = h.m, r = h.g, n = a.f, p = a.m, l = a.g; var c, y, f, u, b, v, g, x, d, z = i.Ib, m = s.Ib; i = i.ab, s = s.ab, c = h.v + e * - z, y = h.A + o * - z, f = h.B + r * - z, e = h.v + e * z, u = h.A + o * z, b = h.B + r * z, o = a.v + n * - m, r = a.A + p * - m, h = a.B + l * - m, n = a.v + n * m, p = a.A + p * m, v = a.B + l * m, a = b - f, b = p - r, p = - ( ( g = c - o ) * ( e -= c ) + ( x = y - r ) * ( u -= y ) + ( d = f - h ) * a ), g = g * ( l = n - o ) + x * b + d * ( n = v - h ), d = e * l + u * b + a * n, v = m * m * 4, ( x = z * z * 4 ) || v ? x ? v ? ( ( m = x * v - d * d ) ? z = 0 > ( z = d * g + v * p ) ? 0 : z > m ? 1 : z / m : z = 0, 0 > ( m = z * d + g ) ? ( m = 0, z = 0 > ( z = p ) ? 0 : z > x ? 1 : z / x ) : m > v ? ( m = 1, z = 0 > ( z = d + p ) ? 0 : z > x ? 1 : z / x ) : m /= v ) : ( m = 0, z = 0 > ( z = p ) ? 0 : z > x ? 1 : z / x ) : ( z = 0, m = 0 > ( m = g ) ? 0 : m > v ? 1 : m / v ) : m = z = 0, y += u * z, ( z = ( u = ( c += e * z ) - ( o += l * m ) ) * u + ( e = y - ( r += b * m ) ) * e + ( m = ( f += a * z ) - ( h += n * m ) ) * m ) >= ( i + s ) * ( i + s ) || ( 0 < ( z = Math.sqrt( z ) ) ? ( u *= 1 / z, e *= 1 / z, m *= 1 / z ) : ( u = 1, m = e = 0 ), this.yh( t, u, e, m ), this.Cg( t, c + u * - i, y + e * - i, f + m * - i, o + u * s, r + e * s, h + m * s, i + s - z, 0 ) );

	} } ), Ct.ua = Tt, Ct.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a, e ) {

		var o = vt.cb; if ( h = o.zj( i, s, h, a, gt.enableGJKCaching ? e : null, ! 0 ), t.incremental = ! 0, h != bt.SUCCEEDED )console.log( 'GjkEpaDetector.hx:28:', 'GJK/EPA failed: status=' + h ); else if ( ! ( o.distance > i.Rb + s.Rb ) ) {

			var r, n, p, l, c, y; if ( h = ( e = o.closestPoint1 ).x, a = e.y, e = e.z, ( l = h - ( r = ( p = o.closestPoint2 ).x ) ) * l + ( c = a - ( n = p.y ) ) * c + ( y = e - ( p = p.z ) ) * y ) {

				0 > o.distance && ( l = - l, c = - c, y = - y ); var f = l * l + c * c + y * y; 0 < f && ( f = 1 / Math.sqrt( f ) ), l *= f, c *= f, y *= f, this.yh( t, l, c, y ), h += l * - i.Rb, a += c * - i.Rb, e += y * - i.Rb, r += l * s.Rb, n += c * s.Rb, p += y * s.Rb, this.Cg( t, h, a, e, r, n, p, i.Rb + s.Rb - o.distance, 0 );

			}

		}

	} } ), Dt.ua = Tt, Dt.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a ) {

		var e, o, r, n, p, l, c, y, f, u; if ( t.incremental = ! 1, r = - ( e = s.Ke ), n = - ( o = s.Le ), p = - ( s = s.Me ), i = i.ab, l = h.v - a.v, c = h.A - a.A, y = h.B - a.B, f = a.o * l + a.i * c + a.l * y, u = a.f * l + a.m * c + a.g * y, l = a.h * l + a.j * c + a.s * y, r < f && e > f && n < u && o > u && p < l && s > l ) {

			var b, v, g, x = s - ( 0 > l ? - l : l ); ( c = e - ( 0 > f ? - f : f ) ) < ( b = o - ( 0 > u ? - u : u ) ) ? c < x ? ( r = 0 < f ? 1 : - 1, v = p = n = 0, y = g = 1 ) : ( 0 < l ? ( n = r = 0, p = 1 ) : ( n = r = 0, p = - 1 ), g = v = 1, y = 0, c = x ) : b < x ? ( 0 < u ? ( r = 0, n = 1 ) : ( r = 0, n = - 1 ), p = 0, v = 1, g = 0, y = 1, c = b ) : ( 0 < l ? ( n = r = 0, p = 1 ) : ( n = r = 0, p = - 1 ), g = v = 1, y = 0, c = x ), f = r * e + v * f, o = n * o + g * u, l = p * s + y * l, s = a.o * f + a.f * o + a.h * l, u = a.i * f + a.m * o + a.j * l, o = a.l * f + a.g * o + a.s * l, l = a.o * r + a.f * n + a.h * p, f = a.i * r + a.m * n + a.j * p, e = a.l * r + a.g * n + a.s * p, this.yh( t, l, f, e ), this.Cg( t, h.v + l * - i, h.A + f * - i, h.B + e * - i, a.v + s, a.A + u, a.B + o, c, 0 );

		} else ( s = ( f -= e = ( e = f < ( e -= 1e-9 ) ? f : e ) > ( r += 1e-9 ) ? e : r ) * f + ( r = u - ( c = ( c = u < ( o -= 1e-9 ) ? u : o ) > ( n += 1e-9 ) ? c : n ) ) * r + ( n = l - ( y = ( y = l < ( s -= 1e-9 ) ? l : s ) > ( p += 1e-9 ) ? y : p ) ) * n ) >= i * i || ( s = Math.sqrt( s ), u = a.o * e + a.f * c + a.h * y, o = a.i * e + a.m * c + a.j * y, l = a.l * e + a.g * c + a.s * y, 0 < ( n = ( p = a.o * f + a.f * r + a.h * n ) * p + ( e = a.i * f + a.m * r + a.j * n ) * e + ( f = a.l * f + a.g * r + a.s * n ) * f ) && ( n = 1 / Math.sqrt( n ) ), r = p * n, e *= n, f *= n, this.yh( t, r, e, f ), this.Cg( t, h.v + r * - i, h.A + e * - i, h.B + f * - i, a.v + u, a.A + o, a.B + l, i - s, 0 ) );

	} } ), wt.ua = Tt, wt.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a ) {

		t.incremental = ! 1; var e, o, r, n, p, l, c, y, f, u = s.Ib; i = i.ab, s = s.ab, e = a.f, o = a.m, r = a.g, n = h.v, p = h.A, h = h.B, l = a.v + e * - u, c = a.A + o * - u, y = a.B + r * - u, e = a.v + e * u, o = a.A + o * u, f = a.B + r * u, r = o - c, u = u * u * 4, y += ( o = f - y ) * ( e = 0 > ( e = ( n - l ) * ( a = e - l ) + ( p - c ) * r + ( h - y ) * o ) ? 0 : e > u ? 1 : e / u ), ( a = ( o = n - ( u = l + a * e ) ) * o + ( r = p - ( c += r * e ) ) * r + ( l = h - y ) * l ) >= ( i + s ) * ( i + s ) || ( 0 < ( a = Math.sqrt( a ) ) ? ( o *= 1 / a, r *= 1 / a, l *= 1 / a ) : ( o = 1, l = r = 0 ), this.yh( t, o, r, l ), this.Cg( t, n + o * - i, p + r * - i, h + l * - i, u + o * s, c + r * s, y + l * s, i + s - a, 0 ) );

	} } ), At.ua = Tt, At.prototype = ri( Tt.prototype, { th: function ( t, i, s, h, a ) {

		var e, o, r; t.incremental = ! 1; var n = ( e = h.v - a.v ) * e + ( o = h.A - a.A ) * o + ( r = h.B - a.B ) * r; n >= ( ( i = i.ab ) + ( s = s.ab ) ) * ( i + s ) || ( 0 < ( n = Math.sqrt( n ) ) ? ( e *= 1 / n, o *= 1 / n, r *= 1 / n ) : ( e = 1, r = o = 0 ), this.yh( t, e, o, r ), this.Cg( t, h.v + e * - i, h.A + o * - i, h.B + r * - i, a.v + e * s, a.A + o * s, a.B + r * s, i + s - n, 0 ) );

	} } ), Mt.prototype = { io: function () {

		for ( var t = this.jd; null != t; ) {

			for ( var i = t.M, s = 0; 3 > s; ) {

				var h = s ++; if ( t.zb[ h ].sj = null, t.zb[ h ].Hi = null, - 1 == t.We[ h ] ) return this.Fc = 2, ! 1; if ( null == t.Ge[ h ] ) return this.Fc = 3, ! 1;

			}

			t = i;

		}

		return ! 0;

	}, km: function ( t, i, s ) {

		if ( i.bl != t ) {

			i.bl = t; var h = i.fi; h.x = s.x, h.y = s.y, h.z = s.z; var a = i.zb[ 0 ].xd, e = h.y - a.y, o = h.z - a.z; if ( h.x = h.x - a.x, h.y = e, h.z = o, h = i.fi, a = i.dk, i.rj = 0 < h.x * a.x + h.y * a.y + h.z * a.z, i.rj ) {

				for ( h = 0; 3 > h; ) if ( a = h ++, null != ( e = i.Ge[ a ] ) ) {

					( o = e.fi ).x = s.x, o.y = s.y, o.z = s.z; var r = e.zb[ 0 ].xd, n = o.y - r.y, p = o.z - r.z; o.x = o.x - r.x, o.y = n, o.z = p, o = e.fi, r = e.dk, e.rj = 0 < o.x * r.x + o.y * r.y + o.z * r.z, e.rj ? this.km( t, e, s ) : ( ( o = i.zb[ a ] ).Hi = i.zb[ i.Ai[ a ] ], o.sj = e );

				}

				for ( t = 0; 3 > t; )s = t ++, null != ( h = i.Ge[ s ] ) && ( a = i.We[ s ], h.Ge[ a ] = null, h.We[ a ] = - 1, i.Ge[ s ] = null, i.We[ s ] = - 1 ); this.lh --, t = i.ia, s = i.M, null != t && ( t.M = s ), null != s && ( s.ia = t ), i == this.jd && ( this.jd = this.jd.M ), i == this.Rc && ( this.Rc = this.Rc.ia ), i.M = null, i.ia = null, i.tk(), i.M = this.De, this.De = i;

			} else this.Fc = 6;

		}

	}, fh: function ( t, i, s, h ) {

		this.Fc = 0, this.Ne = 4, this.zb[ 0 ] = t, this.zb[ 1 ] = i, this.zb[ 2 ] = s, this.zb[ 3 ] = h; var a = this.mi, e = t.xd; a.x = e.x, a.y = e.y, a.z = e.z; e = i.xd; var o = a.y + e.y, r = a.z + e.z; return a.x += e.x, a.y = o, a.z = r, e = s.xd, o = a.y + e.y, r = a.z + e.z, a.x += e.x, a.y = o, a.z = r, e = h.xd, o = a.y + e.y, r = a.z + e.z, a.x += e.x, a.y = o, a.z = r, e = .25 * a.y, o = .25 * a.z, a.x = .25 * a.x, a.y = e, a.z = o, null != ( a = this.De ) ? ( this.De = a.M, a.M = null ) : a = new jt(), null != ( e = this.De ) ? ( this.De = e.M, e.M = null ) : e = new jt(), null != ( o = this.De ) ? ( this.De = o.M, o.M = null ) : o = new jt(), null != ( r = this.De ) ? ( this.De = r.M, r.M = null ) : r = new jt(), a.za( t, i, s, this.mi, ! 0 ) || ( this.Fc = 1 ), e.za( t, i, h, this.mi, ! 0 ) || ( this.Fc = 1 ), o.za( t, s, h, this.mi, ! 0 ) || ( this.Fc = 1 ), r.za( i, s, h, this.mi, ! 0 ) || ( this.Fc = 1 ), a.Rg( e ) || ( this.Fc = 1 ), a.Rg( o ) || ( this.Fc = 1 ), a.Rg( r ) || ( this.Fc = 1 ), e.Rg( o ) || ( this.Fc = 1 ), e.Rg( r ) || ( this.Fc = 1 ), o.Rg( r ) || ( this.Fc = 1 ), this.lh ++, null == this.jd ? this.jd = a : ( this.Rc.M = a, a.ia = this.Rc ), this.Rc = a, this.lh ++, null == this.jd ? this.jd = e : ( this.Rc.M = e, e.ia = this.Rc ), this.Rc = e, this.lh ++, null == this.jd ? this.jd = o : ( this.Rc.M = o, o.ia = this.Rc ), this.Rc = o, this.lh ++, null == this.jd ? this.jd = r : ( this.Rc.M = r, r.ia = this.Rc ), this.Rc = r, ! this.Fc;

	}, Vm: function ( t, i ) {

		this.zb[ this.Ne ++ ] = t; var s = i.zb[ 0 ]; if ( this.km( this.Ne, i, t.xd ), 0 != this.Fc ) return ! 1; i = s; for ( var h = null, a = null; ; ) {

			if ( null == i.Hi ) return this.Fc = 4, ! 1; if ( null == i.sj ) return this.Fc = 5, ! 1; var e = this.De; if ( null != e ? ( this.De = e.M, e.M = null ) : e = new jt(), null == a && ( a = e ), e.za( i, i.Hi, t, this.mi, ! 1 ) || ( this.Fc = 1 ), 0 != this.Fc ) return ! 1; if ( this.lh ++, null == this.jd ? this.jd = e : ( this.Rc.M = e, e.ia = this.Rc ), this.Rc = e, e.Rg( i.sj ) || ( this.Fc = 1 ), null == h || e.Rg( h ) || ( this.Fc = 1 ), h = e, ( i = i.Hi ) == s ) break;

		}

		return h.Rg( a ) || ( this.Fc = 1 ), 0 == this.Fc && this.io();

	} }, jt.prototype = { za: function ( t, i, s, h, a ) {

		null == a && ( a = ! 1 ); var e, o, r, n, p, l, c, y, f, u = t.xd; e = u.x, o = u.y, r = u.z; var b = i.xd; n = b.x, p = b.y, l = b.z; var v, g, x, d, z, m, j, M, A, w = s.xd; c = w.x, y = w.y, f = w.z; var D = ! 1; if ( 0 > ( e - h.x ) * ( j = ( g = p - o ) * ( m = f - r ) - ( x = l - r ) * ( z = y - o ) ) + ( o - h.y ) * ( M = x * ( d = c - e ) - ( v = n - e ) * m ) + ( r - h.z ) * ( A = v * z - g * d ) ) if ( a ) {

			var C = i; i = s, s = C, j *= - 1, M *= - 1, A *= - 1;

		} else D = ! 0; this.zb[ 0 ] = t, this.zb[ 1 ] = i, this.zb[ 2 ] = s; var B = this.dk; B.x = j, B.y = M, B.z = A; var q, S, k, I, T, O, L, F, P, R, J, N, H, K, G, V, E, U, W, Y, X, $ = t.xd, Z = i.xd, Q = s.xd, _ = this.fi; q = $.x, S = $.y, k = $.z, I = Z.x, T = Z.y, O = Z.z, L = Q.x; var tt, it, st, ht = I * ( ( K = ( F = Q.y ) - T ) * ( X = ( R = I - q ) * K - ( J = T - S ) * ( H = L - I ) ) - ( G = ( P = Q.z ) - O ) * ( Y = ( N = O - k ) * H - R * G ) ) + T * ( G * ( W = J * G - N * K ) - H * X ) + O * ( H * Y - K * W ), at = L * ( ( E = S - F ) * X - ( U = k - P ) * Y ) + F * ( U * W - ( V = q - L ) * X ) + P * ( V * Y - E * W ), et = - 1; if ( st = it = tt = 0, 0 > q * ( J * X - N * Y ) + S * ( N * W - R * X ) + k * ( R * Y - J * W ) ) {

			var ot, rt, nt, pt, lt, ct, yt, ft, ut, bt; if ( ot = $.x, rt = $.y, nt = $.z, 0 > ( bt = - ( bt = ( yt = ( pt = Z.x ) - ot ) * ot + ( ft = ( lt = Z.y ) - rt ) * rt + ( ut = ( ct = Z.z ) - nt ) * nt ) / ( yt * yt + ft * ft + ut * ut ) ) )_.x = ot, _.y = rt, _.z = nt; else if ( 1 < bt )_.x = pt, _.y = lt, _.z = ct; else {

				var vt, gt, xt; vt = ot + yt * bt, gt = rt + ft * bt, xt = nt + ut * bt, _.x = vt, _.y = gt, _.z = xt;

			}

			et = _.x * _.x + _.y * _.y + _.z * _.z, tt = _.x, it = _.y, st = _.z;

		}

		if ( 0 > ht ) {

			var dt, zt, mt, jt, Mt, At, wt, Dt, Ct, Bt; if ( dt = Z.x, zt = Z.y, mt = Z.z, 0 > ( Bt = - ( Bt = ( wt = ( jt = Q.x ) - dt ) * dt + ( Dt = ( Mt = Q.y ) - zt ) * zt + ( Ct = ( At = Q.z ) - mt ) * mt ) / ( wt * wt + Dt * Dt + Ct * Ct ) ) )_.x = dt, _.y = zt, _.z = mt; else if ( 1 < Bt )_.x = jt, _.y = Mt, _.z = At; else {

				var qt, St, kt; qt = dt + wt * Bt, St = zt + Dt * Bt, kt = mt + Ct * Bt, _.x = qt, _.y = St, _.z = kt;

			}

			var It = _.x * _.x + _.y * _.y + _.z * _.z; ( 0 > et || It < et ) && ( et = It, tt = _.x, it = _.y, st = _.z );

		}

		if ( 0 > at ) {

			var Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt, Ht, Kt; if ( Tt = $.x, Ot = $.y, Lt = $.z, 0 > ( Kt = - ( Kt = ( Jt = ( Ft = Q.x ) - Tt ) * Tt + ( Nt = ( Pt = Q.y ) - Ot ) * Ot + ( Ht = ( Rt = Q.z ) - Lt ) * Lt ) / ( Jt * Jt + Nt * Nt + Ht * Ht ) ) )_.x = Tt, _.y = Ot, _.z = Lt; else if ( 1 < Kt )_.x = Ft, _.y = Pt, _.z = Rt; else {

				var Gt, Vt, Et; Gt = Tt + Jt * Kt, Vt = Ot + Nt * Kt, Et = Lt + Ht * Kt, _.x = Gt, _.y = Vt, _.z = Et;

			}

			var Ut = _.x * _.x + _.y * _.y + _.z * _.z; ( 0 > et || Ut < et ) && ( et = Ut, tt = _.x, it = _.y, st = _.z );

		}

		if ( 0 < et )_.x = tt, _.y = it, _.z = st; else {

			var Wt, Yt = W * W + Y * Y + X * X; 0 < Yt && ( Yt = 1 / Math.sqrt( Yt ) ), tt = ( W *= Yt ) * ( Wt = ( q * W + S * ( Y *= Yt ) + k * ( X *= Yt ) ) / ( Wt = W * W + Y * Y + X * X ) ), it = Y * Wt, st = X * Wt, _.x = tt, _.y = it, _.z = st;

		}

		var Xt = this.fi; return this.Wj = Xt.x * Xt.x + Xt.y * Xt.y + Xt.z * Xt.z, this.Ge[ 0 ] = null, this.Ge[ 1 ] = null, this.Ge[ 2 ] = null, this.We[ 0 ] = - 1, this.We[ 1 ] = - 1, this.We[ 2 ] = - 1, ! D;

	}, Rg: function ( t ) {

		for ( var i = 0, s = 0; 3 > s; ) for ( var h = s ++, a = 0; 3 > a; ) {

			var e = a ++, o = this.Ai[ h ]; this.zb[ h ] == t.zb[ this.Ai[ e ] ] && this.zb[ o ] == t.zb[ e ] && ( this.Ge[ h ] = t, this.We[ h ] = e, t.Ge[ e ] = this, t.We[ e ] = h, ++ i );

		}

		return 1 == i;

	}, tk: function () {

		this.ia = this.M = null, this.bl = 0, this.rj = ! 1, this.Wj = 0, this.zb[ 0 ] = null, this.zb[ 1 ] = null, this.zb[ 2 ] = null, this.Ge[ 0 ] = null, this.Ge[ 1 ] = null, this.Ge[ 2 ] = null, this.We[ 0 ] = 0, this.We[ 1 ] = 0, this.We[ 2 ] = 0;

	} }, mt.prototype = { za: function ( t, i, s ) {

		var h = this.xd; return h.x = t.x, h.y = t.y, h.z = t.z, ( t = this.jb ).x = i.x, t.y = i.y, t.z = i.z, ( i = this.qb ).x = s.x, i.y = s.y, i.z = s.z, this.sj = this.Hi = this.M = null, this;

	}, tk: function () {

		this.sj = this.Hi = this.M = null;

	} }, zt.prototype = { clear: function () {

		this.Il.Z();

	} }, dt.prototype = { za: function ( t, i, s ) {

		return this.x = t, this.y = i, this.z = s, this;

	}, Z: function () {

		return this.z = this.y = this.x = 0, this;

	}, Lc: function ( t ) {

		return new dt( this.x + t.x, this.y + t.y, this.z + t.z );

	}, ua: function ( t, i ) {

		return new dt( this.x + t.x * i, this.y + t.y * i, this.z + t.z * i );

	}, ue: function ( t ) {

		return new dt( this.x - t.x, this.y - t.y, this.z - t.z );

	}, se: function ( t ) {

		return new dt( this.x * t, this.y * t, this.z * t );

	}, Ve: function ( t, i, s ) {

		return new dt( this.x * t, this.y * i, this.z * s );

	}, Yd: function ( t ) {

		return this.x * t.x + this.y * t.y + this.z * t.z;

	}, Hb: function ( t ) {

		return new dt( this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x );

	}, fd: function ( t ) {

		var i = this.y + t.y, s = this.z + t.z; return this.x += t.x, this.y = i, this.z = s, this;

	}, cb: function ( t, i ) {

		var s = this.y + t.y * i, h = this.z + t.z * i; return this.x += t.x * i, this.y = s, this.z = h, this;

	}, Ue: function ( t ) {

		var i = this.y - t.y, s = this.z - t.z; return this.x = this.x - t.x, this.y = i, this.z = s, this;

	}, te: function ( t ) {

		var i = this.y * t, s = this.z * t; return this.x = this.x * t, this.y = i, this.z = s, this;

	}, Mf: function ( t, i, s ) {

		return i = this.y * i, s = this.z * s, this.x = this.x * t, this.y = i, this.z = s, this;

	}, Mb: function ( t ) {

		var i = this.z * t.x - this.x * t.z, s = this.x * t.y - this.y * t.x; return this.x = this.y * t.z - this.z * t.y, this.y = i, this.z = s, this;

	}, pc: function ( t ) {

		return new dt( this.x * t.e00 + this.y * t.e01 + this.z * t.e02, this.x * t.e10 + this.y * t.e11 + this.z * t.e12, this.x * t.e20 + this.y * t.e21 + this.z * t.e22 );

	}, uc: function ( t ) {

		return new dt( this.x * t.e00 + this.y * t.e01 + this.z * t.e02 + t.e03, this.x * t.e10 + this.y * t.e11 + this.z * t.e12 + t.e13, this.x * t.e20 + this.y * t.e21 + this.z * t.e22 + t.e23 );

	}, Ac: function ( t ) {

		var i, s, h, a, e; return i = this.x, s = this.y, h = this.z, a = t.o * i + t.f * s + t.h * h, e = t.i * i + t.m * s + t.j * h, h = t.l * i + t.g * s + t.s * h, i = a + t.v, s = e + t.A, h += t.B, ( t = new dt() ).x = i, t.y = s, t.z = h, t;

	}, qc: function ( t ) {

		var i = this.x * t.e10 + this.y * t.e11 + this.z * t.e12, s = this.x * t.e20 + this.y * t.e21 + this.z * t.e22; return this.x = this.x * t.e00 + this.y * t.e01 + this.z * t.e02, this.y = i, this.z = s, this;

	}, vc: function ( t ) {

		var i = this.x * t.e10 + this.y * t.e11 + this.z * t.e12 + t.e13, s = this.x * t.e20 + this.y * t.e21 + this.z * t.e22 + t.e23; return this.x = this.x * t.e00 + this.y * t.e01 + this.z * t.e02 + t.e03, this.y = i, this.z = s, this;

	}, Ec: function ( t ) {

		var i, s, h, a, e; return i = this.x, s = this.y, h = this.z, a = t.o * i + t.f * s + t.h * h, e = t.i * i + t.m * s + t.j * h, h = t.l * i + t.g * s + t.s * h, i = a + t.v, s = e + t.A, h += t.B, this.x = i, this.y = s, this.z = h, this;

	}, length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}, pe: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}, re: function () {

		var t = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z ); return 0 < t && ( t = 1 / t ), new dt( this.x * t, this.y * t, this.z * t );

	}, qe: function () {

		var t = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z ); 0 < t && ( t = 1 / t ); var i = this.y * t, s = this.z * t; return this.x = this.x * t, this.y = i, this.z = s, this;

	}, Jc: function () {

		return new dt( - this.x, - this.y, - this.z );

	}, Kc: function () {

		var t = - this.y, i = - this.z; return this.x = - this.x, this.y = t, this.z = i, this;

	}, de: function ( t ) {

		return this.x = t.x, this.y = t.y, this.z = t.z, this;

	}, clone: function () {

		return new dt( this.x, this.y, this.z );

	}, toString: function () {

		return 'Vec3[' + ( 0 < this.x ? ( 1e7 * this.x + .5 | 0 ) / 1e7 : ( 1e7 * this.x - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.y ? ( 1e7 * this.y + .5 | 0 ) / 1e7 : ( 1e7 * this.y - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.z ? ( 1e7 * this.z + .5 | 0 ) / 1e7 : ( 1e7 * this.z - .5 | 0 ) / 1e7 ) + ']';

	} }, xt.prototype = { Wf: function () {

		return this.B = this.A = this.v = 0, this.o = 1, this.i = this.h = this.f = 0, this.m = 1, this.g = this.l = this.j = 0, this.s = 1, this;

	}, Hb: function () {

		var t = new dt(); return t.x = this.v, t.y = this.A, t.z = this.B, t;

	}, Mb: function ( t ) {

		t.x = this.v, t.y = this.A, t.z = this.B;

	}, Ec: function ( t ) {

		return this.v = t.x, this.A = t.y, this.B = t.z, this;

	}, Lc: function ( t ) {

		var i, s; i = t.x, s = t.y, t = t.z, this.v += i, this.A += s, this.B += t;

	}, pc: function () {

		var t = new ft(); return t.e00 = this.o, t.e01 = this.f, t.e02 = this.h, t.e10 = this.i, t.e11 = this.m, t.e12 = this.j, t.e20 = this.l, t.e21 = this.g, t.e22 = this.s, t;

	}, qc: function ( t ) {

		t.e00 = this.o, t.e01 = this.f, t.e02 = this.h, t.e10 = this.i, t.e11 = this.m, t.e12 = this.j, t.e20 = this.l, t.e21 = this.g, t.e22 = this.s;

	}, Jc: function ( t ) {

		return this.o = t.e00, this.f = t.e01, this.h = t.e02, this.i = t.e10, this.m = t.e11, this.j = t.e12, this.l = t.e20, this.g = t.e21, this.s = t.e22, this;

	}, Kc: function ( t ) {

		var i, s, h; i = t.x, s = t.y, h = t.z, t = Math.sin( i ); var a = Math.sin( s ), e = Math.sin( h ); i = Math.cos( i ), s = Math.cos( s ), h = Math.cos( h ), this.o = s * h, this.f = - s * e, this.h = a, this.i = i * e + h * t * a, this.m = i * h - t * a * e, this.j = - s * t, this.l = t * e - i * h * a, this.g = h * t + i * a * e, this.s = i * s;

	}, uc: function ( t ) {

		var i, s, h, a, e, o, r, n, p, l; i = t.e00, s = t.e01, h = t.e02, a = t.e10, e = t.e11, o = t.e12, r = t.e20, n = t.e21, p = t.e22, t = i * this.o + s * this.i + h * this.l, l = i * this.f + s * this.m + h * this.g, i = i * this.h + s * this.j + h * this.s, s = a * this.o + e * this.i + o * this.l, h = a * this.f + e * this.m + o * this.g, a = a * this.h + e * this.j + o * this.s, e = r * this.o + n * this.i + p * this.l, o = r * this.f + n * this.m + p * this.g, r = r * this.h + n * this.j + p * this.s, this.o = t, this.f = l, this.h = i, this.i = s, this.m = h, this.j = a, this.l = e, this.g = o, this.s = r;

	}, vc: function ( t ) {

		var i, s, h, a, e, o, r; i = t.x, s = t.y, t = t.z, o = Math.sin( i ); var n = Math.sin( s ), p = Math.sin( t ), l = Math.cos( i ); r = Math.cos( s ); var c = Math.cos( t ); h = r * c, a = - r * p, t = l * p + c * o * n, i = l * c - o * n * p, e = - r * o, s = o * p - l * c * n, o = c * o + l * n * p, r *= l, p = h * this.o + a * this.i + n * this.l, l = h * this.f + a * this.m + n * this.g, n = h * this.h + a * this.j + n * this.s, h = t * this.o + i * this.i + e * this.l, a = t * this.f + i * this.m + e * this.g, t = t * this.h + i * this.j + e * this.s, i = s * this.o + o * this.i + r * this.l, e = s * this.f + o * this.m + r * this.g, s = s * this.h + o * this.j + r * this.s, this.o = p, this.f = l, this.h = n, this.i = h, this.m = a, this.j = t, this.l = i, this.g = e, this.s = s;

	}, ua: function () {

		var t, i, s, h, a, e = new pt(); return 0 < ( h = ( t = this.o ) + ( i = this.m ) + ( s = this.s ) ) ? ( h = .5 * ( a = Math.sqrt( h + 1 ) ), a = .5 / a, t = ( this.g - this.j ) * a, i = ( this.h - this.l ) * a, s = ( this.i - this.f ) * a ) : t > i ? t > s ? ( t = .5 * ( a = Math.sqrt( t - i - s + 1 ) ), a = .5 / a, i = ( this.f + this.i ) * a, s = ( this.h + this.l ) * a, h = ( this.g - this.j ) * a ) : ( s = .5 * ( a = Math.sqrt( s - t - i + 1 ) ), a = .5 / a, t = ( this.h + this.l ) * a, i = ( this.j + this.g ) * a, h = ( this.i - this.f ) * a ) : i > s ? ( i = .5 * ( a = Math.sqrt( i - s - t + 1 ) ), a = .5 / a, t = ( this.f + this.i ) * a, s = ( this.j + this.g ) * a, h = ( this.h - this.l ) * a ) : ( s = .5 * ( a = Math.sqrt( s - t - i + 1 ) ), a = .5 / a, t = ( this.h + this.l ) * a, i = ( this.j + this.g ) * a, h = ( this.i - this.f ) * a ), e.x = t, e.y = i, e.z = s, e.w = h, e;

	}, cb: function ( t ) {

		var i, s, h, a, e; 0 < ( a = ( i = this.o ) + ( s = this.m ) + ( h = this.s ) ) ? ( a = .5 * ( e = Math.sqrt( a + 1 ) ), e = .5 / e, i = ( this.g - this.j ) * e, s = ( this.h - this.l ) * e, h = ( this.i - this.f ) * e ) : i > s ? i > h ? ( i = .5 * ( e = Math.sqrt( i - s - h + 1 ) ), e = .5 / e, s = ( this.f + this.i ) * e, h = ( this.h + this.l ) * e, a = ( this.g - this.j ) * e ) : ( h = .5 * ( e = Math.sqrt( h - i - s + 1 ) ), e = .5 / e, i = ( this.h + this.l ) * e, s = ( this.j + this.g ) * e, a = ( this.i - this.f ) * e ) : s > h ? ( s = .5 * ( e = Math.sqrt( s - h - i + 1 ) ), e = .5 / e, i = ( this.f + this.i ) * e, h = ( this.j + this.g ) * e, a = ( this.h - this.l ) * e ) : ( h = .5 * ( e = Math.sqrt( h - i - s + 1 ) ), e = .5 / e, i = ( this.h + this.l ) * e, s = ( this.j + this.g ) * e, a = ( this.i - this.f ) * e ), t.x = i, t.y = s, t.z = h, t.w = a;

	}, Ac: function ( t ) {

		var i, s, h; i = t.x, s = t.y, h = t.z; var a = t.w, e = 2 * i, o = 2 * s, r = 2 * h; t = i * e; var n = s * o; h *= r; var p = i * o; return s *= r, i *= r, e *= a, o *= a, a *= r, this.o = 1 - n - h, this.f = p - a, this.h = i + o, this.i = p + a, this.m = 1 - t - h, this.j = s - e, this.l = i - o, this.g = s + e, this.s = 1 - t - n, this;

	}, clone: function () {

		var t = new xt(); return t.v = this.v, t.A = this.A, t.B = this.B, t.o = this.o, t.f = this.f, t.h = this.h, t.i = this.i, t.m = this.m, t.j = this.j, t.l = this.l, t.g = this.g, t.s = this.s, t;

	}, de: function ( t ) {

		return this.v = t.v, this.A = t.A, this.B = t.B, this.o = t.o, this.f = t.f, this.h = t.h, this.i = t.i, this.m = t.m, this.j = t.j, this.l = t.l, this.g = t.g, this.s = t.s, this;

	} }, vt.pc = function () {

		return vt.cb;

	}, vt.prototype = { zj: function ( t, i, s, h, a, e ) {

		this.wj = t, this.jl = i, this.tc = s, this.Ic = h; var o, r, n, p = this.Na, l = this.jb, c = this.qb, y = this.closest, f = this.dir; ( null != a ? ( null == a.oi && ( a.oi = new zt() ), this.Pn( a.oi ) ) : f.Z(), f.x * f.x + f.y * f.y + f.z * f.z ) || ( o = h.v - s.v, r = h.A - s.A, n = h.B - s.B, f.x = o, f.y = r, f.z = n, 1e-6 > f.x * f.x + f.y * f.y + f.z * f.z && f.za( 1, 0, 0 ) ); this.ya = 0, this.zf( ! 1 ), this.Af( ! 1 ); var u = this.Na[ this.ya ], b = this.jb[ this.ya ]; u.x = b.x, u.y = b.y, u.z = b.z; var v = this.qb[ this.ya ], g = u.y - v.y, x = u.z - v.z; u.x = u.x - v.x, u.y = g, u.z = x, this.ya = 1; for ( var d = 0; 40 > d; ) {

			var z = 0; switch ( this.ya ) {

				case 1:var m = p[ 0 ]; y.x = m.x, y.y = m.y, y.z = m.z, z = 1; break; case 2:var j, M, A, w, D, C, B = p[ 0 ]; j = B.x, M = B.y, A = B.z; var q, S, k, I, T = p[ 1 ]; if ( 0 > ( I = - ( I = ( q = ( w = T.x ) - j ) * j + ( S = ( D = T.y ) - M ) * M + ( k = ( C = T.z ) - A ) * A ) / ( q * q + S * S + k * k ) ) ) {

					var O = y; O.x = j, O.y = M, O.z = A, z = 1;

				} else if ( 1 < I ) {

					var L = y; L.x = w, L.y = D, L.z = C, z = 2;

				} else {

					var F, P, R; F = j + q * I, P = M + S * I, R = A + k * I; var J = y; J.x = F, J.y = P, J.z = R, z = 3;

				}

					break; case 3:var N, H, K, G, V, E, U, W, Y, X, $, Z, Q, _, tt, it, st, ht, at = p[ 0 ], et = p[ 1 ], ot = p[ 2 ], rt = at; N = rt.x, H = rt.y, K = rt.z; var nt = et; G = nt.x, V = nt.y, E = nt.z; var pt, lt, ct, yt = ot; U = yt.x; var ft, ut, bt, vt = G * ( ( _ = ( W = yt.y ) - V ) * ( ct = ( X = G - N ) * _ - ( $ = V - H ) * ( Q = U - G ) ) - ( tt = ( Y = yt.z ) - E ) * ( lt = ( Z = E - K ) * Q - X * tt ) ) + V * ( tt * ( pt = $ * tt - Z * _ ) - Q * ct ) + E * ( Q * lt - _ * pt ), gt = U * ( ( st = H - W ) * ct - ( ht = K - Y ) * lt ) + W * ( ht * pt - ( it = N - U ) * ct ) + Y * ( it * lt - st * pt ), xt = - 1, dt = 0; if ( bt = ut = ft = 0, 0 > N * ( $ * ct - Z * lt ) + H * ( Z * pt - X * ct ) + K * ( X * lt - $ * pt ) ) {

					var mt, jt, Mt, At, wt, Dt, Ct = at; mt = Ct.x, jt = Ct.y, Mt = Ct.z; var Bt, qt, St, kt, It, Tt = et; if ( 0 > ( kt = - ( kt = ( Bt = ( At = Tt.x ) - mt ) * mt + ( qt = ( wt = Tt.y ) - jt ) * jt + ( St = ( Dt = Tt.z ) - Mt ) * Mt ) / ( Bt * Bt + qt * qt + St * St ) ) ) {

						var Ot = y; Ot.x = mt, Ot.y = jt, Ot.z = Mt, It = 1;

					} else if ( 1 < kt ) {

						var Lt = y; Lt.x = At, Lt.y = wt, Lt.z = Dt, It = 2;

					} else {

						var Ft, Pt, Rt; Ft = mt + Bt * kt, Pt = jt + qt * kt, Rt = Mt + St * kt; var Jt = y; Jt.x = Ft, Jt.y = Pt, Jt.z = Rt, It = 3;

					}

					dt = It, xt = y.x * y.x + y.y * y.y + y.z * y.z; var Nt = y; ft = Nt.x, ut = Nt.y, bt = Nt.z;

				}

					if ( 0 > vt ) {

						var Ht, Kt, Gt, Vt, Et, Ut, Wt = et; Ht = Wt.x, Kt = Wt.y, Gt = Wt.z; var Yt, Xt, $t, Zt, Qt, _t = ot; if ( 0 > ( Zt = - ( Zt = ( Yt = ( Vt = _t.x ) - Ht ) * Ht + ( Xt = ( Et = _t.y ) - Kt ) * Kt + ( $t = ( Ut = _t.z ) - Gt ) * Gt ) / ( Yt * Yt + Xt * Xt + $t * $t ) ) ) {

							var ti = y; ti.x = Ht, ti.y = Kt, ti.z = Gt, Qt = 1;

						} else if ( 1 < Zt ) {

							var ii = y; ii.x = Vt, ii.y = Et, ii.z = Ut, Qt = 2;

						} else {

							var si, hi, ai; si = Ht + Yt * Zt, hi = Kt + Xt * Zt, ai = Gt + $t * Zt; var ei = y; ei.x = si, ei.y = hi, ei.z = ai, Qt = 3;

						}

						var oi = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > xt || oi < xt ) {

							dt = Qt << 1, xt = oi; var ri = y; ft = ri.x, ut = ri.y, bt = ri.z;

						}

					}

					if ( 0 > gt ) {

						var ni, pi, li, ci, yi, fi, ui = at; ni = ui.x, pi = ui.y, li = ui.z; var bi, vi, gi, xi, di, zi = ot; if ( 0 > ( xi = - ( xi = ( bi = ( ci = zi.x ) - ni ) * ni + ( vi = ( yi = zi.y ) - pi ) * pi + ( gi = ( fi = zi.z ) - li ) * li ) / ( bi * bi + vi * vi + gi * gi ) ) ) {

							var mi = y; mi.x = ni, mi.y = pi, mi.z = li, di = 1;

						} else if ( 1 < xi ) {

							var ji = y; ji.x = ci, ji.y = yi, ji.z = fi, di = 2;

						} else {

							var Mi, Ai, wi; Mi = ni + bi * xi, Ai = pi + vi * xi, wi = li + gi * xi; var Di = y; Di.x = Mi, Di.y = Ai, Di.z = wi, di = 3;

						}

						var Ci = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > xt || Ci < xt ) {

							dt = 1 & di | ( 2 & di ) << 1, xt = Ci; var Bi = y; ft = Bi.x, ut = Bi.y, bt = Bi.z;

						}

					}

					if ( 0 < xt ) {

						var qi = y; qi.x = ft, qi.y = ut, qi.z = bt, z = dt;

					} else {

						var Si, ki = pt * pt + lt * lt + ct * ct; 0 < ki && ( ki = 1 / Math.sqrt( ki ) ), ft = ( pt *= ki ) * ( Si = ( N * pt + H * ( lt *= ki ) + K * ( ct *= ki ) ) / ( Si = pt * pt + lt * lt + ct * ct ) ), ut = lt * Si, bt = ct * Si; var Ii = y; Ii.x = ft, Ii.y = ut, Ii.z = bt, z = 7;

					}

					break; case 4:var Ti, Oi, Li, Fi, Pi, Ri, Ji, Ni, Hi, Ki, Gi, Vi, Ei, Ui, Wi, Yi, Xi, $i, Zi, Qi, _i, ts, is, ss, hs, as, es, os = p[ 0 ], rs = p[ 1 ], ns = p[ 2 ], ps = p[ 3 ], ls = os; Ti = ls.x, Oi = ls.y, Li = ls.z; var cs = rs; Fi = cs.x, Pi = cs.y, Ri = cs.z; var ys = ns; Ji = ys.x, Ni = ys.y, Hi = ys.z; var fs, us, bs, vs = ps; Ki = vs.x; var gs, xs, ds, zs = 0 < ( Ei = Fi - Ti ) * ( fs = ( as = ( Gi = vs.y ) - Pi ) * ( ss = Hi - Ri ) - ( es = ( Vi = vs.z ) - Ri ) * ( is = Ni - Pi ) ) + ( Ui = Pi - Oi ) * ( us = es * ( ts = Ji - Fi ) - ( hs = Ki - Fi ) * ss ) + ( Wi = Ri - Li ) * ( bs = hs * is - as * ts ) ? 1 : - 1, ms = Ti * ( ( Xi = Ni - Oi ) * ( _i = Vi - Li ) - ( $i = Hi - Li ) * ( Qi = Gi - Oi ) ) + Oi * ( $i * ( Zi = Ki - Ti ) - ( Yi = Ji - Ti ) * _i ) + Li * ( Yi * Qi - Xi * Zi ), js = Ti * ( Qi * Wi - _i * Ui ) + Oi * ( _i * Ei - Zi * Wi ) + Li * ( Zi * Ui - Qi * Ei ), Ms = Fi * fs + Pi * us + Ri * bs, As = - 1, ws = 0; if ( ds = xs = gs = 0, 0 > ( Ti * ( Ui * $i - Wi * Xi ) + Oi * ( Wi * Yi - Ei * $i ) + Li * ( Ei * Xi - Ui * Yi ) ) * zs ) {

					var Ds, Cs, Bs, qs, Ss, ks, Is, Ts, Os, Ls, Fs, Ps, Rs, Js, Ns, Hs, Ks, Gs, Vs = os; Ds = Vs.x, Cs = Vs.y, Bs = Vs.z; var Es = rs; qs = Es.x, Ss = Es.y, ks = Es.z; var Us, Ws, Ys, Xs = ns; Is = Xs.x; var $s, Zs, Qs, _s, th = qs * ( ( Js = ( Ts = Xs.y ) - Ss ) * ( Ys = ( Ls = qs - Ds ) * Js - ( Fs = Ss - Cs ) * ( Rs = Is - qs ) ) - ( Ns = ( Os = Xs.z ) - ks ) * ( Ws = ( Ps = ks - Bs ) * Rs - Ls * Ns ) ) + Ss * ( Ns * ( Us = Fs * Ns - Ps * Js ) - Rs * Ys ) + ks * ( Rs * Ws - Js * Us ), ih = Is * ( ( Ks = Cs - Ts ) * Ys - ( Gs = Bs - Os ) * Ws ) + Ts * ( Gs * Us - ( Hs = Ds - Is ) * Ys ) + Os * ( Hs * Ws - Ks * Us ), sh = - 1, hh = 0; if ( Qs = Zs = $s = 0, 0 > Ds * ( Fs * Ys - Ps * Ws ) + Cs * ( Ps * Us - Ls * Ys ) + Bs * ( Ls * Ws - Fs * Us ) ) {

						var ah, eh, oh, rh, nh, ph, lh = os; ah = lh.x, eh = lh.y, oh = lh.z; var ch, yh, fh, uh, bh, vh = rs; if ( 0 > ( uh = - ( uh = ( ch = ( rh = vh.x ) - ah ) * ah + ( yh = ( nh = vh.y ) - eh ) * eh + ( fh = ( ph = vh.z ) - oh ) * oh ) / ( ch * ch + yh * yh + fh * fh ) ) ) {

							var gh = y; gh.x = ah, gh.y = eh, gh.z = oh, bh = 1;

						} else if ( 1 < uh ) {

							var xh = y; xh.x = rh, xh.y = nh, xh.z = ph, bh = 2;

						} else {

							var dh, zh, mh; dh = ah + ch * uh, zh = eh + yh * uh, mh = oh + fh * uh; var jh = y; jh.x = dh, jh.y = zh, jh.z = mh, bh = 3;

						}

						hh = bh, sh = y.x * y.x + y.y * y.y + y.z * y.z; var Mh = y; $s = Mh.x, Zs = Mh.y, Qs = Mh.z;

					}

					if ( 0 > th ) {

						var Ah, wh, Dh, Ch, Bh, qh, Sh = rs; Ah = Sh.x, wh = Sh.y, Dh = Sh.z; var kh, Ih, Th, Oh, Lh, Fh = ns; if ( 0 > ( Oh = - ( Oh = ( kh = ( Ch = Fh.x ) - Ah ) * Ah + ( Ih = ( Bh = Fh.y ) - wh ) * wh + ( Th = ( qh = Fh.z ) - Dh ) * Dh ) / ( kh * kh + Ih * Ih + Th * Th ) ) ) {

							var Ph = y; Ph.x = Ah, Ph.y = wh, Ph.z = Dh, Lh = 1;

						} else if ( 1 < Oh ) {

							var Rh = y; Rh.x = Ch, Rh.y = Bh, Rh.z = qh, Lh = 2;

						} else {

							var Jh, Nh, Hh; Jh = Ah + kh * Oh, Nh = wh + Ih * Oh, Hh = Dh + Th * Oh; var Kh = y; Kh.x = Jh, Kh.y = Nh, Kh.z = Hh, Lh = 3;

						}

						var Gh = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > sh || Gh < sh ) {

							hh = Lh << 1, sh = Gh; var Vh = y; $s = Vh.x, Zs = Vh.y, Qs = Vh.z;

						}

					}

					if ( 0 > ih ) {

						var Eh, Uh, Wh, Yh, Xh, $h, Zh = os; Eh = Zh.x, Uh = Zh.y, Wh = Zh.z; var Qh, _h, ta, ia, sa, ha = ns; if ( 0 > ( ia = - ( ia = ( Qh = ( Yh = ha.x ) - Eh ) * Eh + ( _h = ( Xh = ha.y ) - Uh ) * Uh + ( ta = ( $h = ha.z ) - Wh ) * Wh ) / ( Qh * Qh + _h * _h + ta * ta ) ) ) {

							var aa = y; aa.x = Eh, aa.y = Uh, aa.z = Wh, sa = 1;

						} else if ( 1 < ia ) {

							var ea = y; ea.x = Yh, ea.y = Xh, ea.z = $h, sa = 2;

						} else {

							var oa, ra, na; oa = Eh + Qh * ia, ra = Uh + _h * ia, na = Wh + ta * ia; var pa = y; pa.x = oa, pa.y = ra, pa.z = na, sa = 3;

						}

						var la = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > sh || la < sh ) {

							hh = 1 & sa | ( 2 & sa ) << 1, sh = la; var ca = y; $s = ca.x, Zs = ca.y, Qs = ca.z;

						}

					}

					if ( 0 < sh ) {

						var ya = y; ya.x = $s, ya.y = Zs, ya.z = Qs, _s = hh;

					} else {

						var fa, ua = Us * Us + Ws * Ws + Ys * Ys; 0 < ua && ( ua = 1 / Math.sqrt( ua ) ), $s = ( Us *= ua ) * ( fa = ( Ds * Us + Cs * ( Ws *= ua ) + Bs * ( Ys *= ua ) ) / ( fa = Us * Us + Ws * Ws + Ys * Ys ) ), Zs = Ws * fa, Qs = Ys * fa; var ba = y; ba.x = $s, ba.y = Zs, ba.z = Qs, _s = 7;

					}

					ws = _s, As = y.x * y.x + y.y * y.y + y.z * y.z; var va = y; gs = va.x, xs = va.y, ds = va.z;

				}

					if ( 0 > ms * zs ) {

						var ga, xa, da, za, ma, ja, Ma, Aa, wa, Da, Ca, Ba, qa, Sa, ka, Ia, Ta, Oa, La = os; ga = La.x, xa = La.y, da = La.z; var Fa = ns; za = Fa.x, ma = Fa.y, ja = Fa.z; var Pa, Ra, Ja, Na = ps; Ma = Na.x; var Ha, Ka, Ga, Va, Ea = za * ( ( Sa = ( Aa = Na.y ) - ma ) * ( Ja = ( Da = za - ga ) * Sa - ( Ca = ma - xa ) * ( qa = Ma - za ) ) - ( ka = ( wa = Na.z ) - ja ) * ( Ra = ( Ba = ja - da ) * qa - Da * ka ) ) + ma * ( ka * ( Pa = Ca * ka - Ba * Sa ) - qa * Ja ) + ja * ( qa * Ra - Sa * Pa ), Ua = Ma * ( ( Ta = xa - Aa ) * Ja - ( Oa = da - wa ) * Ra ) + Aa * ( Oa * Pa - ( Ia = ga - Ma ) * Ja ) + wa * ( Ia * Ra - Ta * Pa ), Wa = - 1, Ya = 0; if ( Ga = Ka = Ha = 0, 0 > ga * ( Ca * Ja - Ba * Ra ) + xa * ( Ba * Pa - Da * Ja ) + da * ( Da * Ra - Ca * Pa ) ) {

							var Xa, $a, Za, Qa, _a, te, ie = os; Xa = ie.x, $a = ie.y, Za = ie.z; var se, he, ae, ee, oe, re = ns; if ( 0 > ( ee = - ( ee = ( se = ( Qa = re.x ) - Xa ) * Xa + ( he = ( _a = re.y ) - $a ) * $a + ( ae = ( te = re.z ) - Za ) * Za ) / ( se * se + he * he + ae * ae ) ) ) {

								var ne = y; ne.x = Xa, ne.y = $a, ne.z = Za, oe = 1;

							} else if ( 1 < ee ) {

								var pe = y; pe.x = Qa, pe.y = _a, pe.z = te, oe = 2;

							} else {

								var le, ce, ye; le = Xa + se * ee, ce = $a + he * ee, ye = Za + ae * ee; var fe = y; fe.x = le, fe.y = ce, fe.z = ye, oe = 3;

							}

							Ya = oe, Wa = y.x * y.x + y.y * y.y + y.z * y.z; var ue = y; Ha = ue.x, Ka = ue.y, Ga = ue.z;

						}

						if ( 0 > Ea ) {

							var be, ve, ge, xe, de, ze, me = ns; be = me.x, ve = me.y, ge = me.z; var je, Me, Ae, we, De, Ce = ps; if ( 0 > ( we = - ( we = ( je = ( xe = Ce.x ) - be ) * be + ( Me = ( de = Ce.y ) - ve ) * ve + ( Ae = ( ze = Ce.z ) - ge ) * ge ) / ( je * je + Me * Me + Ae * Ae ) ) ) {

								var Be = y; Be.x = be, Be.y = ve, Be.z = ge, De = 1;

							} else if ( 1 < we ) {

								var qe = y; qe.x = xe, qe.y = de, qe.z = ze, De = 2;

							} else {

								var Se, ke, Ie; Se = be + je * we, ke = ve + Me * we, Ie = ge + Ae * we; var Te = y; Te.x = Se, Te.y = ke, Te.z = Ie, De = 3;

							}

							var Oe = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > Wa || Oe < Wa ) {

								Ya = De << 1, Wa = Oe; var Le = y; Ha = Le.x, Ka = Le.y, Ga = Le.z;

							}

						}

						if ( 0 > Ua ) {

							var Fe, Pe, Re, Je, Ne, He, Ke = os; Fe = Ke.x, Pe = Ke.y, Re = Ke.z; var Ge, Ve, Ee, Ue, We, Ye = ps; if ( 0 > ( Ue = - ( Ue = ( Ge = ( Je = Ye.x ) - Fe ) * Fe + ( Ve = ( Ne = Ye.y ) - Pe ) * Pe + ( Ee = ( He = Ye.z ) - Re ) * Re ) / ( Ge * Ge + Ve * Ve + Ee * Ee ) ) ) {

								var Xe = y; Xe.x = Fe, Xe.y = Pe, Xe.z = Re, We = 1;

							} else if ( 1 < Ue ) {

								var $e = y; $e.x = Je, $e.y = Ne, $e.z = He, We = 2;

							} else {

								var Ze, Qe, _e; Ze = Fe + Ge * Ue, Qe = Pe + Ve * Ue, _e = Re + Ee * Ue; var to = y; to.x = Ze, to.y = Qe, to.z = _e, We = 3;

							}

							var io = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > Wa || io < Wa ) {

								Ya = 1 & We | ( 2 & We ) << 1, Wa = io; var so = y; Ha = so.x, Ka = so.y, Ga = so.z;

							}

						}

						if ( 0 < Wa ) {

							var ho = y; ho.x = Ha, ho.y = Ka, ho.z = Ga, Va = Ya;

						} else {

							var ao, eo = Pa * Pa + Ra * Ra + Ja * Ja; 0 < eo && ( eo = 1 / Math.sqrt( eo ) ), Ha = ( Pa *= eo ) * ( ao = ( ga * Pa + xa * ( Ra *= eo ) + da * ( Ja *= eo ) ) / ( ao = Pa * Pa + Ra * Ra + Ja * Ja ) ), Ka = Ra * ao, Ga = Ja * ao; var oo = y; oo.x = Ha, oo.y = Ka, oo.z = Ga, Va = 7;

						}

						var ro = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > As || ro < As ) {

							ws = 1 & Va | ( 6 & Va ) << 1, As = ro; var no = y; gs = no.x, xs = no.y, ds = no.z;

						}

					}

					if ( 0 > js * zs ) {

						var po, lo, co, yo, fo, uo, bo, vo, go, xo, zo, mo, jo, Mo, Ao, wo, Do, Co, Bo = os; po = Bo.x, lo = Bo.y, co = Bo.z; var qo = rs; yo = qo.x, fo = qo.y, uo = qo.z; var So, ko, Io, To = ps; bo = To.x; var Oo, Lo, Fo, Po, Ro = yo * ( ( Mo = ( vo = To.y ) - fo ) * ( Io = ( xo = yo - po ) * Mo - ( zo = fo - lo ) * ( jo = bo - yo ) ) - ( Ao = ( go = To.z ) - uo ) * ( ko = ( mo = uo - co ) * jo - xo * Ao ) ) + fo * ( Ao * ( So = zo * Ao - mo * Mo ) - jo * Io ) + uo * ( jo * ko - Mo * So ), Jo = bo * ( ( Do = lo - vo ) * Io - ( Co = co - go ) * ko ) + vo * ( Co * So - ( wo = po - bo ) * Io ) + go * ( wo * ko - Do * So ), No = - 1, Ho = 0; if ( Fo = Lo = Oo = 0, 0 > po * ( zo * Io - mo * ko ) + lo * ( mo * So - xo * Io ) + co * ( xo * ko - zo * So ) ) {

							var Ko, Go, Vo, Eo, Uo, Wo, Yo = os; Ko = Yo.x, Go = Yo.y, Vo = Yo.z; var Xo, $o, Zo, Qo, _o, tr = rs; if ( 0 > ( Qo = - ( Qo = ( Xo = ( Eo = tr.x ) - Ko ) * Ko + ( $o = ( Uo = tr.y ) - Go ) * Go + ( Zo = ( Wo = tr.z ) - Vo ) * Vo ) / ( Xo * Xo + $o * $o + Zo * Zo ) ) ) {

								var ir = y; ir.x = Ko, ir.y = Go, ir.z = Vo, _o = 1;

							} else if ( 1 < Qo ) {

								var sr = y; sr.x = Eo, sr.y = Uo, sr.z = Wo, _o = 2;

							} else {

								var hr, ar, er; hr = Ko + Xo * Qo, ar = Go + $o * Qo, er = Vo + Zo * Qo; var or = y; or.x = hr, or.y = ar, or.z = er, _o = 3;

							}

							Ho = _o, No = y.x * y.x + y.y * y.y + y.z * y.z; var rr = y; Oo = rr.x, Lo = rr.y, Fo = rr.z;

						}

						if ( 0 > Ro ) {

							var nr, pr, lr, cr, yr, fr, ur = rs; nr = ur.x, pr = ur.y, lr = ur.z; var br, vr, gr, xr, dr, zr = ps; if ( 0 > ( xr = - ( xr = ( br = ( cr = zr.x ) - nr ) * nr + ( vr = ( yr = zr.y ) - pr ) * pr + ( gr = ( fr = zr.z ) - lr ) * lr ) / ( br * br + vr * vr + gr * gr ) ) ) {

								var mr = y; mr.x = nr, mr.y = pr, mr.z = lr, dr = 1;

							} else if ( 1 < xr ) {

								var jr = y; jr.x = cr, jr.y = yr, jr.z = fr, dr = 2;

							} else {

								var Mr, Ar, wr; Mr = nr + br * xr, Ar = pr + vr * xr, wr = lr + gr * xr; var Dr = y; Dr.x = Mr, Dr.y = Ar, Dr.z = wr, dr = 3;

							}

							var Cr = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > No || Cr < No ) {

								Ho = dr << 1, No = Cr; var Br = y; Oo = Br.x, Lo = Br.y, Fo = Br.z;

							}

						}

						if ( 0 > Jo ) {

							var qr, Sr, kr, Ir, Tr, Or, Lr = os; qr = Lr.x, Sr = Lr.y, kr = Lr.z; var Fr, Pr, Rr, Jr, Nr, Hr = ps; if ( 0 > ( Jr = - ( Jr = ( Fr = ( Ir = Hr.x ) - qr ) * qr + ( Pr = ( Tr = Hr.y ) - Sr ) * Sr + ( Rr = ( Or = Hr.z ) - kr ) * kr ) / ( Fr * Fr + Pr * Pr + Rr * Rr ) ) ) {

								var Kr = y; Kr.x = qr, Kr.y = Sr, Kr.z = kr, Nr = 1;

							} else if ( 1 < Jr ) {

								var Gr = y; Gr.x = Ir, Gr.y = Tr, Gr.z = Or, Nr = 2;

							} else {

								var Vr, Er, Ur; Vr = qr + Fr * Jr, Er = Sr + Pr * Jr, Ur = kr + Rr * Jr; var Wr = y; Wr.x = Vr, Wr.y = Er, Wr.z = Ur, Nr = 3;

							}

							var Yr = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > No || Yr < No ) {

								Ho = 1 & Nr | ( 2 & Nr ) << 1, No = Yr; var Xr = y; Oo = Xr.x, Lo = Xr.y, Fo = Xr.z;

							}

						}

						if ( 0 < No ) {

							var $r = y; $r.x = Oo, $r.y = Lo, $r.z = Fo, Po = Ho;

						} else {

							var Zr, Qr = So * So + ko * ko + Io * Io; 0 < Qr && ( Qr = 1 / Math.sqrt( Qr ) ), Oo = ( So *= Qr ) * ( Zr = ( po * So + lo * ( ko *= Qr ) + co * ( Io *= Qr ) ) / ( Zr = So * So + ko * ko + Io * Io ) ), Lo = ko * Zr, Fo = Io * Zr; var _r = y; _r.x = Oo, _r.y = Lo, _r.z = Fo, Po = 7;

						}

						var tn = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > As || tn < As ) {

							ws = 3 & Po | ( 4 & Po ) << 1, As = tn; var sn = y; gs = sn.x, xs = sn.y, ds = sn.z;

						}

					}

					if ( 0 > Ms * zs ) {

						var hn, an, en, on, rn, nn, pn, ln, cn, yn, fn, un, bn, vn, gn, xn, dn, zn, mn = rs; hn = mn.x, an = mn.y, en = mn.z; var jn = ns; on = jn.x, rn = jn.y, nn = jn.z; var Mn, An, wn, Dn = ps; pn = Dn.x; var Cn, Bn, qn, Sn, kn = on * ( ( vn = ( ln = Dn.y ) - rn ) * ( wn = ( yn = on - hn ) * vn - ( fn = rn - an ) * ( bn = pn - on ) ) - ( gn = ( cn = Dn.z ) - nn ) * ( An = ( un = nn - en ) * bn - yn * gn ) ) + rn * ( gn * ( Mn = fn * gn - un * vn ) - bn * wn ) + nn * ( bn * An - vn * Mn ), In = pn * ( ( dn = an - ln ) * wn - ( zn = en - cn ) * An ) + ln * ( zn * Mn - ( xn = hn - pn ) * wn ) + cn * ( xn * An - dn * Mn ), Tn = - 1, On = 0; if ( qn = Bn = Cn = 0, 0 > hn * ( fn * wn - un * An ) + an * ( un * Mn - yn * wn ) + en * ( yn * An - fn * Mn ) ) {

							var Ln, Fn, Pn, Rn, Jn, Nn, Hn = rs; Ln = Hn.x, Fn = Hn.y, Pn = Hn.z; var Kn, Gn, Vn, En, Un, Wn = ns; if ( 0 > ( En = - ( En = ( Kn = ( Rn = Wn.x ) - Ln ) * Ln + ( Gn = ( Jn = Wn.y ) - Fn ) * Fn + ( Vn = ( Nn = Wn.z ) - Pn ) * Pn ) / ( Kn * Kn + Gn * Gn + Vn * Vn ) ) ) {

								var Yn = y; Yn.x = Ln, Yn.y = Fn, Yn.z = Pn, Un = 1;

							} else if ( 1 < En ) {

								var Xn = y; Xn.x = Rn, Xn.y = Jn, Xn.z = Nn, Un = 2;

							} else {

								var $n, Zn, Qn; $n = Ln + Kn * En, Zn = Fn + Gn * En, Qn = Pn + Vn * En; var _n = y; _n.x = $n, _n.y = Zn, _n.z = Qn, Un = 3;

							}

							On = Un, Tn = y.x * y.x + y.y * y.y + y.z * y.z; var tp = y; Cn = tp.x, Bn = tp.y, qn = tp.z;

						}

						if ( 0 > kn ) {

							var ip, sp, hp, ap, ep, op, rp = ns; ip = rp.x, sp = rp.y, hp = rp.z; var np, pp, lp, cp, yp, fp = ps; if ( 0 > ( cp = - ( cp = ( np = ( ap = fp.x ) - ip ) * ip + ( pp = ( ep = fp.y ) - sp ) * sp + ( lp = ( op = fp.z ) - hp ) * hp ) / ( np * np + pp * pp + lp * lp ) ) ) {

								var up = y; up.x = ip, up.y = sp, up.z = hp, yp = 1;

							} else if ( 1 < cp ) {

								var bp = y; bp.x = ap, bp.y = ep, bp.z = op, yp = 2;

							} else {

								var vp, gp, xp; vp = ip + np * cp, gp = sp + pp * cp, xp = hp + lp * cp; var dp = y; dp.x = vp, dp.y = gp, dp.z = xp, yp = 3;

							}

							var zp = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > Tn || zp < Tn ) {

								On = yp << 1, Tn = zp; var mp = y; Cn = mp.x, Bn = mp.y, qn = mp.z;

							}

						}

						if ( 0 > In ) {

							var jp, Mp, Ap, wp, Dp, Cp, Bp = rs; jp = Bp.x, Mp = Bp.y, Ap = Bp.z; var qp, Sp, kp, Ip, Tp, Op = ps; if ( 0 > ( Ip = - ( Ip = ( qp = ( wp = Op.x ) - jp ) * jp + ( Sp = ( Dp = Op.y ) - Mp ) * Mp + ( kp = ( Cp = Op.z ) - Ap ) * Ap ) / ( qp * qp + Sp * Sp + kp * kp ) ) ) {

								var Lp = y; Lp.x = jp, Lp.y = Mp, Lp.z = Ap, Tp = 1;

							} else if ( 1 < Ip ) {

								var Fp = y; Fp.x = wp, Fp.y = Dp, Fp.z = Cp, Tp = 2;

							} else {

								var Pp, Rp, Jp; Pp = jp + qp * Ip, Rp = Mp + Sp * Ip, Jp = Ap + kp * Ip; var Np = y; Np.x = Pp, Np.y = Rp, Np.z = Jp, Tp = 3;

							}

							var Hp = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > Tn || Hp < Tn ) {

								On = 1 & Tp | ( 2 & Tp ) << 1, Tn = Hp; var Kp = y; Cn = Kp.x, Bn = Kp.y, qn = Kp.z;

							}

						}

						if ( 0 < Tn ) {

							var Gp = y; Gp.x = Cn, Gp.y = Bn, Gp.z = qn, Sn = On;

						} else {

							var Vp, Ep = Mn * Mn + An * An + wn * wn; 0 < Ep && ( Ep = 1 / Math.sqrt( Ep ) ), Cn = ( Mn *= Ep ) * ( Vp = ( hn * Mn + an * ( An *= Ep ) + en * ( wn *= Ep ) ) / ( Vp = Mn * Mn + An * An + wn * wn ) ), Bn = An * Vp, qn = wn * Vp; var Up = y; Up.x = Cn, Up.y = Bn, Up.z = qn, Sn = 7;

						}

						var Wp = y.x * y.x + y.y * y.y + y.z * y.z; if ( 0 > As || Wp < As ) {

							ws = Sn << 1, As = Wp; var Yp = y; gs = Yp.x, xs = Yp.y, ds = Yp.z;

						}

					}

					if ( 0 < As ) {

						var Xp = y; Xp.x = gs, Xp.y = xs, Xp.z = ds, z = ws;

					} else y.Z(), z = 15;

			}

			if ( 1e-8 > y.x * y.x + y.y * y.y + y.z * y.z ) {

				if ( ! e ) return this.distance = 0; switch ( this.ya ) {

					case 1:this.Rn(); break; case 2:this.El(); break; case 3:this.Ll();

				}

				if ( 4 == this.ya ) {

					var $p = this.mn( t, i, s, h, p, l, c ); return 0 != $p ? ( this.distance = 0, $p ) : ( this.distance = - this.depth, 0 );

				}

				return this.distance = 0, 1;

			}

			this.Hm( z ), f.x = y.x, f.y = y.y, f.z = y.z; var Zp = f, Qp = - Zp.y, _p = - Zp.z; Zp.x = - Zp.x, Zp.y = Qp, Zp.z = _p, this.zf( ! 1 ), this.Af( ! 1 ); var tl = this.Na[ this.ya ], il = this.jb[ this.ya ]; tl.x = il.x, tl.y = il.y, tl.z = il.z; var sl = tl, hl = this.qb[ this.ya ], al = sl.y - hl.y, el = sl.z - hl.z; if ( sl.x = sl.x - hl.x, sl.y = al, sl.z = el, 1e-8 > f.x * f.x + f.y * f.y + f.z * f.z ) throw Error( '!?' ); var ol = p[ this.ya ]; if ( 1e-8 > ol.x * f.x + ol.y * f.y + ol.z * f.z - ( y.x * f.x + y.y * f.y + y.z * f.z ) ) return this.sm(), this.distance = Math.sqrt( y.x * y.x + y.y * y.y + y.z * y.z ), null != a && null != a.oi && this.Yn( a.oi ), 0; this.ya ++, ++ d;

		}

		return 2;

	}, fm: function ( t, i, s, h, a, e, o ) {

		this.wj = t, this.jl = i, this.tc = s, this.Ic = h; var r, n, p, l = this.Na, c = this.closest, y = this.dir; if ( r = h.v - s.v, n = h.A - s.A, p = h.B - s.B, y.x = r, y.y = n, y.z = p, 1e-6 > y.x * y.x + y.y * y.y + y.z * y.z && y.za( 1, 0, 0 ), this.ya = 0, null != this.wj ) this.zf( ! 0 ); else {

			var f = this.jb[ this.ya ]; f.x = this.tc.v, f.y = this.tc.A, f.z = this.tc.B;

		}

		this.Af( ! 0 ); var u = this.Na[ this.ya ], b = this.jb[ this.ya ]; u.x = b.x, u.y = b.y, u.z = b.z; var v = this.qb[ this.ya ], g = u.y - v.y, x = u.z - v.z; u.x = u.x - v.x, u.y = g, u.z = x, this.ya = 1; var d = 0, z = 0, m = this.Vn, j = this.Un; m.Z(), j.x = e.x, j.y = e.y, j.z = e.z; var M = j.y - a.y, A = j.z - a.z; for ( j.x = j.x - a.x, j.y = M, j.z = A; 40 > d; ) {

			var w = 0; switch ( this.ya ) {

				case 1:var D = l[ 0 ]; c.x = D.x, c.y = D.y, c.z = D.z, w = 1; break; case 2:var C, B, q, S, k, I, T = l[ 0 ]; C = T.x, B = T.y, q = T.z; var O, L, F, P, R = l[ 1 ]; if ( 0 > ( P = - ( P = ( O = ( S = R.x ) - C ) * C + ( L = ( k = R.y ) - B ) * B + ( F = ( I = R.z ) - q ) * q ) / ( O * O + L * L + F * F ) ) ) {

					var J = c; J.x = C, J.y = B, J.z = q, w = 1;

				} else if ( 1 < P ) {

					var N = c; N.x = S, N.y = k, N.z = I, w = 2;

				} else {

					var H, K, G; H = C + O * P, K = B + L * P, G = q + F * P; var V = c; V.x = H, V.y = K, V.z = G, w = 3;

				}

					break; case 3:var E, U, W, Y, X, $, Z, Q, _, tt, it, st, ht, at, et, ot, rt, nt, pt = l[ 0 ], lt = l[ 1 ], ct = l[ 2 ], yt = pt; E = yt.x, U = yt.y, W = yt.z; var ft = lt; Y = ft.x, X = ft.y, $ = ft.z; var ut, bt, vt, gt = ct; Z = gt.x; var xt, dt, zt, mt = Y * ( ( at = ( Q = gt.y ) - X ) * ( vt = ( tt = Y - E ) * at - ( it = X - U ) * ( ht = Z - Y ) ) - ( et = ( _ = gt.z ) - $ ) * ( bt = ( st = $ - W ) * ht - tt * et ) ) + X * ( et * ( ut = it * et - st * at ) - ht * vt ) + $ * ( ht * bt - at * ut ), jt = Z * ( ( rt = U - Q ) * vt - ( nt = W - _ ) * bt ) + Q * ( nt * ut - ( ot = E - Z ) * vt ) + _ * ( ot * bt - rt * ut ), Mt = - 1, At = 0; if ( zt = dt = xt = 0, 0 > E * ( it * vt - st * bt ) + U * ( st * ut - tt * vt ) + W * ( tt * bt - it * ut ) ) {

					var wt, Dt, Ct, Bt, qt, St, kt = pt; wt = kt.x, Dt = kt.y, Ct = kt.z; var It, Tt, Ot, Lt, Ft, Pt = lt; if ( 0 > ( Lt = - ( Lt = ( It = ( Bt = Pt.x ) - wt ) * wt + ( Tt = ( qt = Pt.y ) - Dt ) * Dt + ( Ot = ( St = Pt.z ) - Ct ) * Ct ) / ( It * It + Tt * Tt + Ot * Ot ) ) ) {

						var Rt = c; Rt.x = wt, Rt.y = Dt, Rt.z = Ct, Ft = 1;

					} else if ( 1 < Lt ) {

						var Jt = c; Jt.x = Bt, Jt.y = qt, Jt.z = St, Ft = 2;

					} else {

						var Nt, Ht, Kt; Nt = wt + It * Lt, Ht = Dt + Tt * Lt, Kt = Ct + Ot * Lt; var Gt = c; Gt.x = Nt, Gt.y = Ht, Gt.z = Kt, Ft = 3;

					}

					At = Ft, Mt = c.x * c.x + c.y * c.y + c.z * c.z; var Vt = c; xt = Vt.x, dt = Vt.y, zt = Vt.z;

				}

					if ( 0 > mt ) {

						var Et, Ut, Wt, Yt, Xt, $t, Zt = lt; Et = Zt.x, Ut = Zt.y, Wt = Zt.z; var Qt, _t, ti, ii, si, hi = ct; if ( 0 > ( ii = - ( ii = ( Qt = ( Yt = hi.x ) - Et ) * Et + ( _t = ( Xt = hi.y ) - Ut ) * Ut + ( ti = ( $t = hi.z ) - Wt ) * Wt ) / ( Qt * Qt + _t * _t + ti * ti ) ) ) {

							var ai = c; ai.x = Et, ai.y = Ut, ai.z = Wt, si = 1;

						} else if ( 1 < ii ) {

							var ei = c; ei.x = Yt, ei.y = Xt, ei.z = $t, si = 2;

						} else {

							var oi, ri, ni; oi = Et + Qt * ii, ri = Ut + _t * ii, ni = Wt + ti * ii; var pi = c; pi.x = oi, pi.y = ri, pi.z = ni, si = 3;

						}

						var li = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Mt || li < Mt ) {

							At = si << 1, Mt = li; var ci = c; xt = ci.x, dt = ci.y, zt = ci.z;

						}

					}

					if ( 0 > jt ) {

						var yi, fi, ui, bi, vi, gi, xi = pt; yi = xi.x, fi = xi.y, ui = xi.z; var di, zi, mi, ji, Mi, Ai = ct; if ( 0 > ( ji = - ( ji = ( di = ( bi = Ai.x ) - yi ) * yi + ( zi = ( vi = Ai.y ) - fi ) * fi + ( mi = ( gi = Ai.z ) - ui ) * ui ) / ( di * di + zi * zi + mi * mi ) ) ) {

							var wi = c; wi.x = yi, wi.y = fi, wi.z = ui, Mi = 1;

						} else if ( 1 < ji ) {

							var Di = c; Di.x = bi, Di.y = vi, Di.z = gi, Mi = 2;

						} else {

							var Ci, Bi, qi; Ci = yi + di * ji, Bi = fi + zi * ji, qi = ui + mi * ji; var Si = c; Si.x = Ci, Si.y = Bi, Si.z = qi, Mi = 3;

						}

						var ki = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Mt || ki < Mt ) {

							At = 1 & Mi | ( 2 & Mi ) << 1, Mt = ki; var Ii = c; xt = Ii.x, dt = Ii.y, zt = Ii.z;

						}

					}

					if ( 0 < Mt ) {

						var Ti = c; Ti.x = xt, Ti.y = dt, Ti.z = zt, w = At;

					} else {

						var Oi, Li = ut * ut + bt * bt + vt * vt; 0 < Li && ( Li = 1 / Math.sqrt( Li ) ), xt = ( ut *= Li ) * ( Oi = ( E * ut + U * ( bt *= Li ) + W * ( vt *= Li ) ) / ( Oi = ut * ut + bt * bt + vt * vt ) ), dt = bt * Oi, zt = vt * Oi; var Fi = c; Fi.x = xt, Fi.y = dt, Fi.z = zt, w = 7;

					}

					break; case 4:var Pi, Ri, Ji, Ni, Hi, Ki, Gi, Vi, Ei, Ui, Wi, Yi, Xi, $i, Zi, Qi, _i, ts, is, ss, hs, as, es, os, rs, ns, ps, ls = l[ 0 ], cs = l[ 1 ], ys = l[ 2 ], fs = l[ 3 ], us = ls; Pi = us.x, Ri = us.y, Ji = us.z; var bs = cs; Ni = bs.x, Hi = bs.y, Ki = bs.z; var vs = ys; Gi = vs.x, Vi = vs.y, Ei = vs.z; var gs, xs, ds, zs = fs; Ui = zs.x; var ms, js, Ms, As = 0 < ( Xi = Ni - Pi ) * ( gs = ( ns = ( Wi = zs.y ) - Hi ) * ( os = Ei - Ki ) - ( ps = ( Yi = zs.z ) - Ki ) * ( es = Vi - Hi ) ) + ( $i = Hi - Ri ) * ( xs = ps * ( as = Gi - Ni ) - ( rs = Ui - Ni ) * os ) + ( Zi = Ki - Ji ) * ( ds = rs * es - ns * as ) ? 1 : - 1, ws = Pi * ( ( _i = Vi - Ri ) * ( hs = Yi - Ji ) - ( ts = Ei - Ji ) * ( ss = Wi - Ri ) ) + Ri * ( ts * ( is = Ui - Pi ) - ( Qi = Gi - Pi ) * hs ) + Ji * ( Qi * ss - _i * is ), Ds = Pi * ( ss * Zi - hs * $i ) + Ri * ( hs * Xi - is * Zi ) + Ji * ( is * $i - ss * Xi ), Cs = Ni * gs + Hi * xs + Ki * ds, Bs = - 1, qs = 0; if ( Ms = js = ms = 0, 0 > ( Pi * ( $i * ts - Zi * _i ) + Ri * ( Zi * Qi - Xi * ts ) + Ji * ( Xi * _i - $i * Qi ) ) * As ) {

					var Ss, ks, Is, Ts, Os, Ls, Fs, Ps, Rs, Js, Ns, Hs, Ks, Gs, Vs, Es, Us, Ws, Ys = ls; Ss = Ys.x, ks = Ys.y, Is = Ys.z; var Xs = cs; Ts = Xs.x, Os = Xs.y, Ls = Xs.z; var $s, Zs, Qs, _s = ys; Fs = _s.x; var th, ih, sh, hh, ah = Ts * ( ( Gs = ( Ps = _s.y ) - Os ) * ( Qs = ( Js = Ts - Ss ) * Gs - ( Ns = Os - ks ) * ( Ks = Fs - Ts ) ) - ( Vs = ( Rs = _s.z ) - Ls ) * ( Zs = ( Hs = Ls - Is ) * Ks - Js * Vs ) ) + Os * ( Vs * ( $s = Ns * Vs - Hs * Gs ) - Ks * Qs ) + Ls * ( Ks * Zs - Gs * $s ), eh = Fs * ( ( Us = ks - Ps ) * Qs - ( Ws = Is - Rs ) * Zs ) + Ps * ( Ws * $s - ( Es = Ss - Fs ) * Qs ) + Rs * ( Es * Zs - Us * $s ), oh = - 1, rh = 0; if ( sh = ih = th = 0, 0 > Ss * ( Ns * Qs - Hs * Zs ) + ks * ( Hs * $s - Js * Qs ) + Is * ( Js * Zs - Ns * $s ) ) {

						var nh, ph, lh, ch, yh, fh, uh = ls; nh = uh.x, ph = uh.y, lh = uh.z; var bh, vh, gh, xh, dh, zh = cs; if ( 0 > ( xh = - ( xh = ( bh = ( ch = zh.x ) - nh ) * nh + ( vh = ( yh = zh.y ) - ph ) * ph + ( gh = ( fh = zh.z ) - lh ) * lh ) / ( bh * bh + vh * vh + gh * gh ) ) ) {

							var mh = c; mh.x = nh, mh.y = ph, mh.z = lh, dh = 1;

						} else if ( 1 < xh ) {

							var jh = c; jh.x = ch, jh.y = yh, jh.z = fh, dh = 2;

						} else {

							var Mh, Ah, wh; Mh = nh + bh * xh, Ah = ph + vh * xh, wh = lh + gh * xh; var Dh = c; Dh.x = Mh, Dh.y = Ah, Dh.z = wh, dh = 3;

						}

						rh = dh, oh = c.x * c.x + c.y * c.y + c.z * c.z; var Ch = c; th = Ch.x, ih = Ch.y, sh = Ch.z;

					}

					if ( 0 > ah ) {

						var Bh, qh, Sh, kh, Ih, Th, Oh = cs; Bh = Oh.x, qh = Oh.y, Sh = Oh.z; var Lh, Fh, Ph, Rh, Jh, Nh = ys; if ( 0 > ( Rh = - ( Rh = ( Lh = ( kh = Nh.x ) - Bh ) * Bh + ( Fh = ( Ih = Nh.y ) - qh ) * qh + ( Ph = ( Th = Nh.z ) - Sh ) * Sh ) / ( Lh * Lh + Fh * Fh + Ph * Ph ) ) ) {

							var Hh = c; Hh.x = Bh, Hh.y = qh, Hh.z = Sh, Jh = 1;

						} else if ( 1 < Rh ) {

							var Kh = c; Kh.x = kh, Kh.y = Ih, Kh.z = Th, Jh = 2;

						} else {

							var Gh, Vh, Eh; Gh = Bh + Lh * Rh, Vh = qh + Fh * Rh, Eh = Sh + Ph * Rh; var Uh = c; Uh.x = Gh, Uh.y = Vh, Uh.z = Eh, Jh = 3;

						}

						var Wh = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > oh || Wh < oh ) {

							rh = Jh << 1, oh = Wh; var Yh = c; th = Yh.x, ih = Yh.y, sh = Yh.z;

						}

					}

					if ( 0 > eh ) {

						var Xh, $h, Zh, Qh, _h, ta, ia = ls; Xh = ia.x, $h = ia.y, Zh = ia.z; var sa, ha, aa, ea, oa, ra = ys; if ( 0 > ( ea = - ( ea = ( sa = ( Qh = ra.x ) - Xh ) * Xh + ( ha = ( _h = ra.y ) - $h ) * $h + ( aa = ( ta = ra.z ) - Zh ) * Zh ) / ( sa * sa + ha * ha + aa * aa ) ) ) {

							var na = c; na.x = Xh, na.y = $h, na.z = Zh, oa = 1;

						} else if ( 1 < ea ) {

							var pa = c; pa.x = Qh, pa.y = _h, pa.z = ta, oa = 2;

						} else {

							var la, ca, ya; la = Xh + sa * ea, ca = $h + ha * ea, ya = Zh + aa * ea; var fa = c; fa.x = la, fa.y = ca, fa.z = ya, oa = 3;

						}

						var ua = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > oh || ua < oh ) {

							rh = 1 & oa | ( 2 & oa ) << 1, oh = ua; var ba = c; th = ba.x, ih = ba.y, sh = ba.z;

						}

					}

					if ( 0 < oh ) {

						var va = c; va.x = th, va.y = ih, va.z = sh, hh = rh;

					} else {

						var ga, xa = $s * $s + Zs * Zs + Qs * Qs; 0 < xa && ( xa = 1 / Math.sqrt( xa ) ), th = ( $s *= xa ) * ( ga = ( Ss * $s + ks * ( Zs *= xa ) + Is * ( Qs *= xa ) ) / ( ga = $s * $s + Zs * Zs + Qs * Qs ) ), ih = Zs * ga, sh = Qs * ga; var da = c; da.x = th, da.y = ih, da.z = sh, hh = 7;

					}

					qs = hh, Bs = c.x * c.x + c.y * c.y + c.z * c.z; var za = c; ms = za.x, js = za.y, Ms = za.z;

				}

					if ( 0 > ws * As ) {

						var ma, ja, Ma, Aa, wa, Da, Ca, Ba, qa, Sa, ka, Ia, Ta, Oa, La, Fa, Pa, Ra, Ja = ls; ma = Ja.x, ja = Ja.y, Ma = Ja.z; var Na = ys; Aa = Na.x, wa = Na.y, Da = Na.z; var Ha, Ka, Ga, Va = fs; Ca = Va.x; var Ea, Ua, Wa, Ya, Xa = Aa * ( ( Oa = ( Ba = Va.y ) - wa ) * ( Ga = ( Sa = Aa - ma ) * Oa - ( ka = wa - ja ) * ( Ta = Ca - Aa ) ) - ( La = ( qa = Va.z ) - Da ) * ( Ka = ( Ia = Da - Ma ) * Ta - Sa * La ) ) + wa * ( La * ( Ha = ka * La - Ia * Oa ) - Ta * Ga ) + Da * ( Ta * Ka - Oa * Ha ), $a = Ca * ( ( Pa = ja - Ba ) * Ga - ( Ra = Ma - qa ) * Ka ) + Ba * ( Ra * Ha - ( Fa = ma - Ca ) * Ga ) + qa * ( Fa * Ka - Pa * Ha ), Za = - 1, Qa = 0; if ( Wa = Ua = Ea = 0, 0 > ma * ( ka * Ga - Ia * Ka ) + ja * ( Ia * Ha - Sa * Ga ) + Ma * ( Sa * Ka - ka * Ha ) ) {

							var _a, te, ie, se, he, ae, ee = ls; _a = ee.x, te = ee.y, ie = ee.z; var oe, re, ne, pe, le, ce = ys; if ( 0 > ( pe = - ( pe = ( oe = ( se = ce.x ) - _a ) * _a + ( re = ( he = ce.y ) - te ) * te + ( ne = ( ae = ce.z ) - ie ) * ie ) / ( oe * oe + re * re + ne * ne ) ) ) {

								var ye = c; ye.x = _a, ye.y = te, ye.z = ie, le = 1;

							} else if ( 1 < pe ) {

								var fe = c; fe.x = se, fe.y = he, fe.z = ae, le = 2;

							} else {

								var ue, be, ve; ue = _a + oe * pe, be = te + re * pe, ve = ie + ne * pe; var ge = c; ge.x = ue, ge.y = be, ge.z = ve, le = 3;

							}

							Qa = le, Za = c.x * c.x + c.y * c.y + c.z * c.z; var xe = c; Ea = xe.x, Ua = xe.y, Wa = xe.z;

						}

						if ( 0 > Xa ) {

							var de, ze, me, je, Me, Ae, we = ys; de = we.x, ze = we.y, me = we.z; var De, Ce, Be, qe, Se, ke = fs; if ( 0 > ( qe = - ( qe = ( De = ( je = ke.x ) - de ) * de + ( Ce = ( Me = ke.y ) - ze ) * ze + ( Be = ( Ae = ke.z ) - me ) * me ) / ( De * De + Ce * Ce + Be * Be ) ) ) {

								var Ie = c; Ie.x = de, Ie.y = ze, Ie.z = me, Se = 1;

							} else if ( 1 < qe ) {

								var Te = c; Te.x = je, Te.y = Me, Te.z = Ae, Se = 2;

							} else {

								var Oe, Le, Fe; Oe = de + De * qe, Le = ze + Ce * qe, Fe = me + Be * qe; var Pe = c; Pe.x = Oe, Pe.y = Le, Pe.z = Fe, Se = 3;

							}

							var Re = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Za || Re < Za ) {

								Qa = Se << 1, Za = Re; var Je = c; Ea = Je.x, Ua = Je.y, Wa = Je.z;

							}

						}

						if ( 0 > $a ) {

							var Ne, He, Ke, Ge, Ve, Ee, Ue = ls; Ne = Ue.x, He = Ue.y, Ke = Ue.z; var We, Ye, Xe, $e, Ze, Qe = fs; if ( 0 > ( $e = - ( $e = ( We = ( Ge = Qe.x ) - Ne ) * Ne + ( Ye = ( Ve = Qe.y ) - He ) * He + ( Xe = ( Ee = Qe.z ) - Ke ) * Ke ) / ( We * We + Ye * Ye + Xe * Xe ) ) ) {

								var _e = c; _e.x = Ne, _e.y = He, _e.z = Ke, Ze = 1;

							} else if ( 1 < $e ) {

								var to = c; to.x = Ge, to.y = Ve, to.z = Ee, Ze = 2;

							} else {

								var io, so, ho; io = Ne + We * $e, so = He + Ye * $e, ho = Ke + Xe * $e; var ao = c; ao.x = io, ao.y = so, ao.z = ho, Ze = 3;

							}

							var eo = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Za || eo < Za ) {

								Qa = 1 & Ze | ( 2 & Ze ) << 1, Za = eo; var oo = c; Ea = oo.x, Ua = oo.y, Wa = oo.z;

							}

						}

						if ( 0 < Za ) {

							var ro = c; ro.x = Ea, ro.y = Ua, ro.z = Wa, Ya = Qa;

						} else {

							var no, po = Ha * Ha + Ka * Ka + Ga * Ga; 0 < po && ( po = 1 / Math.sqrt( po ) ), Ea = ( Ha *= po ) * ( no = ( ma * Ha + ja * ( Ka *= po ) + Ma * ( Ga *= po ) ) / ( no = Ha * Ha + Ka * Ka + Ga * Ga ) ), Ua = Ka * no, Wa = Ga * no; var lo = c; lo.x = Ea, lo.y = Ua, lo.z = Wa, Ya = 7;

						}

						var co = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Bs || co < Bs ) {

							qs = 1 & Ya | ( 6 & Ya ) << 1, Bs = co; var yo = c; ms = yo.x, js = yo.y, Ms = yo.z;

						}

					}

					if ( 0 > Ds * As ) {

						var fo, uo, bo, vo, go, xo, zo, mo, jo, Mo, Ao, wo, Do, Co, Bo, qo, So, ko, Io = ls; fo = Io.x, uo = Io.y, bo = Io.z; var To = cs; vo = To.x, go = To.y, xo = To.z; var Oo, Lo, Fo, Po = fs; zo = Po.x; var Ro, Jo, No, Ho, Ko = vo * ( ( Co = ( mo = Po.y ) - go ) * ( Fo = ( Mo = vo - fo ) * Co - ( Ao = go - uo ) * ( Do = zo - vo ) ) - ( Bo = ( jo = Po.z ) - xo ) * ( Lo = ( wo = xo - bo ) * Do - Mo * Bo ) ) + go * ( Bo * ( Oo = Ao * Bo - wo * Co ) - Do * Fo ) + xo * ( Do * Lo - Co * Oo ), Go = zo * ( ( So = uo - mo ) * Fo - ( ko = bo - jo ) * Lo ) + mo * ( ko * Oo - ( qo = fo - zo ) * Fo ) + jo * ( qo * Lo - So * Oo ), Vo = - 1, Eo = 0; if ( No = Jo = Ro = 0, 0 > fo * ( Ao * Fo - wo * Lo ) + uo * ( wo * Oo - Mo * Fo ) + bo * ( Mo * Lo - Ao * Oo ) ) {

							var Uo, Wo, Yo, Xo, $o, Zo, Qo = ls; Uo = Qo.x, Wo = Qo.y, Yo = Qo.z; var _o, tr, ir, sr, hr, ar = cs; if ( 0 > ( sr = - ( sr = ( _o = ( Xo = ar.x ) - Uo ) * Uo + ( tr = ( $o = ar.y ) - Wo ) * Wo + ( ir = ( Zo = ar.z ) - Yo ) * Yo ) / ( _o * _o + tr * tr + ir * ir ) ) ) {

								var er = c; er.x = Uo, er.y = Wo, er.z = Yo, hr = 1;

							} else if ( 1 < sr ) {

								var or = c; or.x = Xo, or.y = $o, or.z = Zo, hr = 2;

							} else {

								var rr, nr, pr; rr = Uo + _o * sr, nr = Wo + tr * sr, pr = Yo + ir * sr; var lr = c; lr.x = rr, lr.y = nr, lr.z = pr, hr = 3;

							}

							Eo = hr, Vo = c.x * c.x + c.y * c.y + c.z * c.z; var cr = c; Ro = cr.x, Jo = cr.y, No = cr.z;

						}

						if ( 0 > Ko ) {

							var yr, fr, ur, br, vr, gr, xr = cs; yr = xr.x, fr = xr.y, ur = xr.z; var dr, zr, mr, jr, Mr, Ar = fs; if ( 0 > ( jr = - ( jr = ( dr = ( br = Ar.x ) - yr ) * yr + ( zr = ( vr = Ar.y ) - fr ) * fr + ( mr = ( gr = Ar.z ) - ur ) * ur ) / ( dr * dr + zr * zr + mr * mr ) ) ) {

								var wr = c; wr.x = yr, wr.y = fr, wr.z = ur, Mr = 1;

							} else if ( 1 < jr ) {

								var Dr = c; Dr.x = br, Dr.y = vr, Dr.z = gr, Mr = 2;

							} else {

								var Cr, Br, qr; Cr = yr + dr * jr, Br = fr + zr * jr, qr = ur + mr * jr; var Sr = c; Sr.x = Cr, Sr.y = Br, Sr.z = qr, Mr = 3;

							}

							var kr = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Vo || kr < Vo ) {

								Eo = Mr << 1, Vo = kr; var Ir = c; Ro = Ir.x, Jo = Ir.y, No = Ir.z;

							}

						}

						if ( 0 > Go ) {

							var Tr, Or, Lr, Fr, Pr, Rr, Jr = ls; Tr = Jr.x, Or = Jr.y, Lr = Jr.z; var Nr, Hr, Kr, Gr, Vr, Er = fs; if ( 0 > ( Gr = - ( Gr = ( Nr = ( Fr = Er.x ) - Tr ) * Tr + ( Hr = ( Pr = Er.y ) - Or ) * Or + ( Kr = ( Rr = Er.z ) - Lr ) * Lr ) / ( Nr * Nr + Hr * Hr + Kr * Kr ) ) ) {

								var Ur = c; Ur.x = Tr, Ur.y = Or, Ur.z = Lr, Vr = 1;

							} else if ( 1 < Gr ) {

								var Wr = c; Wr.x = Fr, Wr.y = Pr, Wr.z = Rr, Vr = 2;

							} else {

								var Yr, Xr, $r; Yr = Tr + Nr * Gr, Xr = Or + Hr * Gr, $r = Lr + Kr * Gr; var Zr = c; Zr.x = Yr, Zr.y = Xr, Zr.z = $r, Vr = 3;

							}

							var Qr = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Vo || Qr < Vo ) {

								Eo = 1 & Vr | ( 2 & Vr ) << 1, Vo = Qr; var _r = c; Ro = _r.x, Jo = _r.y, No = _r.z;

							}

						}

						if ( 0 < Vo ) {

							var tn = c; tn.x = Ro, tn.y = Jo, tn.z = No, Ho = Eo;

						} else {

							var sn, hn = Oo * Oo + Lo * Lo + Fo * Fo; 0 < hn && ( hn = 1 / Math.sqrt( hn ) ), Ro = ( Oo *= hn ) * ( sn = ( fo * Oo + uo * ( Lo *= hn ) + bo * ( Fo *= hn ) ) / ( sn = Oo * Oo + Lo * Lo + Fo * Fo ) ), Jo = Lo * sn, No = Fo * sn; var an = c; an.x = Ro, an.y = Jo, an.z = No, Ho = 7;

						}

						var en = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Bs || en < Bs ) {

							qs = 3 & Ho | ( 4 & Ho ) << 1, Bs = en; var on = c; ms = on.x, js = on.y, Ms = on.z;

						}

					}

					if ( 0 > Cs * As ) {

						var rn, nn, pn, ln, cn, yn, fn, un, bn, vn, gn, xn, dn, zn, mn, jn, Mn, An, wn = cs; rn = wn.x, nn = wn.y, pn = wn.z; var Dn = ys; ln = Dn.x, cn = Dn.y, yn = Dn.z; var Cn, Bn, qn, Sn = fs; fn = Sn.x; var kn, In, Tn, On, Ln = ln * ( ( zn = ( un = Sn.y ) - cn ) * ( qn = ( vn = ln - rn ) * zn - ( gn = cn - nn ) * ( dn = fn - ln ) ) - ( mn = ( bn = Sn.z ) - yn ) * ( Bn = ( xn = yn - pn ) * dn - vn * mn ) ) + cn * ( mn * ( Cn = gn * mn - xn * zn ) - dn * qn ) + yn * ( dn * Bn - zn * Cn ), Fn = fn * ( ( Mn = nn - un ) * qn - ( An = pn - bn ) * Bn ) + un * ( An * Cn - ( jn = rn - fn ) * qn ) + bn * ( jn * Bn - Mn * Cn ), Pn = - 1, Rn = 0; if ( Tn = In = kn = 0, 0 > rn * ( gn * qn - xn * Bn ) + nn * ( xn * Cn - vn * qn ) + pn * ( vn * Bn - gn * Cn ) ) {

							var Jn, Nn, Hn, Kn, Gn, Vn, En = cs; Jn = En.x, Nn = En.y, Hn = En.z; var Un, Wn, Yn, Xn, $n, Zn = ys; if ( 0 > ( Xn = - ( Xn = ( Un = ( Kn = Zn.x ) - Jn ) * Jn + ( Wn = ( Gn = Zn.y ) - Nn ) * Nn + ( Yn = ( Vn = Zn.z ) - Hn ) * Hn ) / ( Un * Un + Wn * Wn + Yn * Yn ) ) ) {

								var Qn = c; Qn.x = Jn, Qn.y = Nn, Qn.z = Hn, $n = 1;

							} else if ( 1 < Xn ) {

								var _n = c; _n.x = Kn, _n.y = Gn, _n.z = Vn, $n = 2;

							} else {

								var tp, ip, sp; tp = Jn + Un * Xn, ip = Nn + Wn * Xn, sp = Hn + Yn * Xn; var hp = c; hp.x = tp, hp.y = ip, hp.z = sp, $n = 3;

							}

							Rn = $n, Pn = c.x * c.x + c.y * c.y + c.z * c.z; var ap = c; kn = ap.x, In = ap.y, Tn = ap.z;

						}

						if ( 0 > Ln ) {

							var ep, op, rp, np, pp, lp, cp = ys; ep = cp.x, op = cp.y, rp = cp.z; var yp, fp, up, bp, vp, gp = fs; if ( 0 > ( bp = - ( bp = ( yp = ( np = gp.x ) - ep ) * ep + ( fp = ( pp = gp.y ) - op ) * op + ( up = ( lp = gp.z ) - rp ) * rp ) / ( yp * yp + fp * fp + up * up ) ) ) {

								var xp = c; xp.x = ep, xp.y = op, xp.z = rp, vp = 1;

							} else if ( 1 < bp ) {

								var dp = c; dp.x = np, dp.y = pp, dp.z = lp, vp = 2;

							} else {

								var zp, mp, jp; zp = ep + yp * bp, mp = op + fp * bp, jp = rp + up * bp; var Mp = c; Mp.x = zp, Mp.y = mp, Mp.z = jp, vp = 3;

							}

							var Ap = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Pn || Ap < Pn ) {

								Rn = vp << 1, Pn = Ap; var wp = c; kn = wp.x, In = wp.y, Tn = wp.z;

							}

						}

						if ( 0 > Fn ) {

							var Dp, Cp, Bp, qp, Sp, kp, Ip = cs; Dp = Ip.x, Cp = Ip.y, Bp = Ip.z; var Tp, Op, Lp, Fp, Pp, Rp = fs; if ( 0 > ( Fp = - ( Fp = ( Tp = ( qp = Rp.x ) - Dp ) * Dp + ( Op = ( Sp = Rp.y ) - Cp ) * Cp + ( Lp = ( kp = Rp.z ) - Bp ) * Bp ) / ( Tp * Tp + Op * Op + Lp * Lp ) ) ) {

								var Jp = c; Jp.x = Dp, Jp.y = Cp, Jp.z = Bp, Pp = 1;

							} else if ( 1 < Fp ) {

								var Np = c; Np.x = qp, Np.y = Sp, Np.z = kp, Pp = 2;

							} else {

								var Hp, Kp, Gp; Hp = Dp + Tp * Fp, Kp = Cp + Op * Fp, Gp = Bp + Lp * Fp; var Vp = c; Vp.x = Hp, Vp.y = Kp, Vp.z = Gp, Pp = 3;

							}

							var Ep = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Pn || Ep < Pn ) {

								Rn = 1 & Pp | ( 2 & Pp ) << 1, Pn = Ep; var Up = c; kn = Up.x, In = Up.y, Tn = Up.z;

							}

						}

						if ( 0 < Pn ) {

							var Wp = c; Wp.x = kn, Wp.y = In, Wp.z = Tn, On = Rn;

						} else {

							var Yp, Xp = Cn * Cn + Bn * Bn + qn * qn; 0 < Xp && ( Xp = 1 / Math.sqrt( Xp ) ), kn = ( Cn *= Xp ) * ( Yp = ( rn * Cn + nn * ( Bn *= Xp ) + pn * ( qn *= Xp ) ) / ( Yp = Cn * Cn + Bn * Bn + qn * qn ) ), In = Bn * Yp, Tn = qn * Yp; var $p = c; $p.x = kn, $p.y = In, $p.z = Tn, On = 7;

						}

						var Zp = c.x * c.x + c.y * c.y + c.z * c.z; if ( 0 > Bs || Zp < Bs ) {

							qs = On << 1, Bs = Zp; var Qp = c; ms = Qp.x, js = Qp.y, Ms = Qp.z;

						}

					}

					if ( 0 < Bs ) {

						var _p = c; _p.x = ms, _p.y = js, _p.z = Ms, w = qs;

					} else c.Z(), w = 15;

			}

			if ( this.Hm( w ), 1e-8 > c.x * c.x + c.y * c.y + c.z * c.z ) {

				if ( ! z || 4 == this.ya ) {

					o.fraction = z; break;

				}

				this.sm(), o.fraction = z; var tl = o.normal; tl.x = y.x, tl.y = y.y, tl.z = y.z; var il = tl, sl = Math.sqrt( il.x * il.x + il.y * il.y + il.z * il.z ); 0 < sl && ( sl = 1 / sl ); var hl = il.y * sl, al = il.z * sl; il.x = il.x * sl, il.y = hl, il.z = al; var el = o.position, ol = this.closestPoint1; el.x = ol.x, el.y = ol.y, el.z = ol.z; var rl = el, nl = rl.y + a.y * z, pl = rl.z + a.z * z; return rl.x += a.x * z, rl.y = nl, rl.z = pl, ! 0;

			}

			y.x = c.x, y.y = c.y, y.z = c.z; var ll = y, cl = - ll.y, yl = - ll.z; if ( ll.x = - ll.x, ll.y = cl, ll.z = yl, null != this.wj ) this.zf( ! 0 ); else {

				var fl = this.jb[ this.ya ]; fl.x = this.tc.v, fl.y = this.tc.A, fl.z = this.tc.B;

			}

			this.Af( ! 0 ); var ul = this.Na[ this.ya ], bl = this.jb[ this.ya ]; ul.x = bl.x, ul.y = bl.y, ul.z = bl.z; var vl = ul, gl = this.qb[ this.ya ], xl = vl.y - gl.y, dl = vl.z - gl.z; vl.x = vl.x - gl.x, vl.y = xl, vl.z = dl; var zl = l[ this.ya ], ml = zl.y - m.y, jl = zl.z - m.z; if ( zl.x = zl.x - m.x, zl.y = ml, zl.z = jl, 1e-8 > y.x * y.x + y.y * y.y + y.z * y.z ) throw Error( '!?' ); var Ml = l[ this.ya ], Al = y, wl = Ml.x * Al.x + Ml.y * Al.y + Ml.z * Al.z; if ( 0 > wl ) {

				if ( 0 <= j.x * Al.x + j.y * Al.y + j.z * Al.z ) break; var Dl = wl / ( j.x * Al.x + j.y * Al.y + j.z * Al.z ); if ( 1 <= ( z = z + Dl ) ) break; var Cl = m.y + j.y * Dl, Bl = m.z + j.z * Dl; m.x = m.x + j.x * Dl, m.y = Cl, m.z = Bl; for ( var ql = 0, Sl = this.ya + 1; ql < Sl; ) {

					var kl = l[ ql ++ ], Il = - Dl, Tl = kl.y + j.y * Il, Ol = kl.z + j.z * Il; kl.x = kl.x + j.x * Il, kl.y = Tl, kl.z = Ol;

				}

			}

			for ( var Ll = ! 1, Fl = 0, Pl = this.ya; Fl < Pl; ) {

				var Rl = Fl ++, Jl = l[ Rl ].x - l[ this.ya ].x, Nl = l[ Rl ].y - l[ this.ya ].y, Hl = l[ Rl ].z - l[ this.ya ].z; if ( 1e-8 > Jl * Jl + Nl * Nl + Hl * Hl ) {

					Ll = ! 0; break;

				}

			}

			Ll || this.ya ++, ++ d;

		}

		return ! 1;

	}, sm: function () {

		switch ( this.ya ) {

			case 1:var t = this.closestPoint1, i = this.jb[ 0 ]; t.x = i.x, t.y = i.y, t.z = i.z; var s = this.closestPoint2, h = this.qb[ 0 ]; s.x = h.x, s.y = h.y, s.z = h.z; break; case 2:var a, e, o, r = this.closest; a = r.x, e = r.y, o = r.z; var n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M = this.Na[ 0 ]; n = M.x, p = M.y, l = M.z; var A = this.jb[ 0 ]; c = A.x, y = A.y, f = A.z; var w = this.qb[ 0 ]; u = w.x, b = w.y, v = w.z; var D = this.Na[ 1 ]; g = D.x, x = D.y, d = D.z; var C = this.jb[ 1 ]; z = C.x, m = C.y, j = C.z; var B, q, S, k = this.qb[ 1 ], I = ( B = g - n ) * B + ( q = x - p ) * q + ( S = d - l ) * S; I && ( I = 1 / I ); var T, O, L, F, P, R, J = ( ( a - n ) * B + ( e - p ) * q + ( o - l ) * S ) * I; T = c + ( z - c ) * J, O = y + ( m - y ) * J, L = f + ( j - f ) * J, F = u + ( k.x - u ) * J, P = b + ( k.y - b ) * J, R = v + ( k.z - v ) * J; var N = this.closestPoint1; N.x = T, N.y = O, N.z = L; var H = this.closestPoint2; H.x = F, H.y = P, H.z = R; break; case 3:var K, G, V, E = this.closest; K = E.x, G = E.y, V = E.z; var U, W, Y, X, $, Z, Q, _, tt, it, st, ht, at, et, ot, rt, nt, pt, lt, ct, yt, ft, ut, bt, vt = this.Na[ 0 ]; U = vt.x, W = vt.y, Y = vt.z; var gt = this.jb[ 0 ]; X = gt.x, $ = gt.y, Z = gt.z; var xt = this.qb[ 0 ]; Q = xt.x, _ = xt.y, tt = xt.z; var dt = this.Na[ 1 ]; it = dt.x, st = dt.y, ht = dt.z; var zt = this.jb[ 1 ]; at = zt.x, et = zt.y, ot = zt.z; var mt = this.qb[ 1 ]; rt = mt.x, nt = mt.y, pt = mt.z; var jt = this.Na[ 2 ]; lt = jt.x, ct = jt.y, yt = jt.z; var Mt = this.jb[ 2 ]; ft = Mt.x, ut = Mt.y, bt = Mt.z; var At, wt, Dt, Ct, Bt, qt, St, kt, It, Tt = this.qb[ 2 ], Ot = ( At = it - U ) * At + ( wt = st - W ) * wt + ( Dt = ht - Y ) * Dt, Lt = At * ( Ct = lt - U ) + wt * ( Bt = ct - W ) + Dt * ( qt = yt - Y ), Ft = Ct * Ct + Bt * Bt + qt * qt, Pt = At * ( St = K - U ) + wt * ( kt = G - W ) + Dt * ( It = V - Y ), Rt = Ct * St + Bt * kt + qt * It, Jt = Ot * Ft - Lt * Lt; Jt && ( Jt = 1 / Jt ); var Nt, Ht, Kt, Gt, Vt, Et, Ut = ( Pt * Ft - Rt * Lt ) * Jt, Wt = ( - Pt * Lt + Rt * Ot ) * Jt; Nt = X + ( at - X ) * Ut, Ht = $ + ( et - $ ) * Ut, Kt = Z + ( ot - Z ) * Ut, Nt += ( ft - X ) * Wt, Ht += ( ut - $ ) * Wt, Kt += ( bt - Z ) * Wt, Gt = Q + ( rt - Q ) * Ut, Vt = _ + ( nt - _ ) * Ut, Et = tt + ( pt - tt ) * Ut, Gt += ( Tt.x - Q ) * Wt, Vt += ( Tt.y - _ ) * Wt, Et += ( Tt.z - tt ) * Wt; var Yt = this.closestPoint1; Yt.x = Nt, Yt.y = Ht, Yt.z = Kt; var Xt = this.closestPoint2; Xt.x = Gt, Xt.y = Vt, Xt.z = Et; break; default:throw Error( '!?' );

		}

	}, Pn: function ( t ) {

		var i = this.dir; t = t.Il, i.x = t.x, i.y = t.y, i.z = t.z;

	}, Yn: function ( t ) {

		t = t.Il; var i = this.closest; t.x = i.x, t.y = i.y, t.z = i.z; i = - t.y; var s = - t.z; t.x = - t.x, t.y = i, t.z = s;

	}, Hm: function ( t ) {

		switch ( this.ya = t, this.ya = ( 5 & this.ya ) + ( this.ya >> 1 & 5 ), this.ya = ( 3 & this.ya ) + ( this.ya >> 2 & 3 ), t ) {

			case 2:t = this.Na[ 0 ]; var i = this.Na[ 1 ]; t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 1 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 1 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 4:t = this.Na[ 0 ], i = this.Na[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 5:t = this.Na[ 1 ], i = this.Na[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 1 ], i = this.jb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 1 ], i = this.qb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 6:t = this.Na[ 0 ], i = this.Na[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 8:t = this.Na[ 0 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 9:t = this.Na[ 1 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 1 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 1 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 10:t = this.Na[ 0 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 11:t = this.Na[ 2 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 2 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 2 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 12:t = this.Na[ 0 ], i = this.Na[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 2 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.Na[ 1 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 1 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 1 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 13:t = this.Na[ 1 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 1 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 1 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z; break; case 14:t = this.Na[ 0 ], i = this.Na[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.jb[ 0 ], i = this.jb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z, t = this.qb[ 0 ], i = this.qb[ 3 ], t.x = i.x, t.y = i.y, t.z = i.z;

		}

	}, zf: function ( t ) {

		var i, s, h, a, e, o, r; a = ( o = this.dir ).x, e = o.y, o = o.z, s = this.tc.o * a + this.tc.i * e + this.tc.l * o, r = this.tc.f * a + this.tc.m * e + this.tc.g * o, i = this.tc.h * a + this.tc.j * e + this.tc.s * o, ( h = this.dir ).x = s, h.y = r, h.z = i, this.wj.Pd( this.dir, this.jb[ this.ya ] ), t && ( t = this.dir, 0 < ( i = Math.sqrt( t.x * t.x + t.y * t.y + t.z * t.z ) ) && ( i = 1 / i ), s = t.y * i, r = t.z * i, t.x = t.x * i, t.y = s, t.z = r, t = this.jb[ this.ya ], i = this.dir, s = this.wj.Rb, r = t.y + i.y * s, h = t.z + i.z * s, t.x += i.x * s, t.y = r, t.z = h ), i = ( t = this.jb[ this.ya ] ).x, s = t.y, h = t.z, r = this.tc.o * i + this.tc.f * s + this.tc.h * h, t = this.tc.i * i + this.tc.m * s + this.tc.j * h, s = this.tc.l * i + this.tc.g * s + this.tc.s * h, i = r + this.tc.v, t += this.tc.A, s += this.tc.B, ( r = this.jb[ this.ya ] ).x = i, r.y = t, r.z = s, ( t = this.dir ).x = a, t.y = e, t.z = o;

	}, Af: function ( t ) {

		var i, s, h, a, e, o, r; a = ( o = this.dir ).x, e = o.y, o = o.z, i = this.Ic.o * a + this.Ic.i * e + this.Ic.l * o, s = this.Ic.f * a + this.Ic.m * e + this.Ic.g * o, r = this.Ic.h * a + this.Ic.j * e + this.Ic.s * o, ( h = this.dir ).x = - i, h.y = - s, h.z = - r, this.jl.Pd( this.dir, this.qb[ this.ya ] ), t && ( t = this.dir, 0 < ( i = Math.sqrt( t.x * t.x + t.y * t.y + t.z * t.z ) ) && ( i = 1 / i ), s = t.y * i, r = t.z * i, t.x = t.x * i, t.y = s, t.z = r, t = this.qb[ this.ya ], i = this.dir, s = this.jl.Rb, r = t.y + i.y * s, h = t.z + i.z * s, t.x += i.x * s, t.y = r, t.z = h ), i = ( t = this.qb[ this.ya ] ).x, s = t.y, h = t.z, r = this.Ic.o * i + this.Ic.f * s + this.Ic.h * h, t = this.Ic.i * i + this.Ic.m * s + this.Ic.j * h, s = this.Ic.l * i + this.Ic.g * s + this.Ic.s * h, i = r + this.Ic.v, t += this.Ic.A, s += this.Ic.B, ( r = this.qb[ this.ya ] ).x = i, r.y = t, r.z = s, ( t = this.dir ).x = a, t.y = e, t.z = o;

	}, Rn: function () {

		for ( var t = 0; 3 > t; ) {

			var i = t ++, s = this.dir; i = this.uj[ i ]; s.x = i.x, s.y = i.y, s.z = i.z, this.zf( ! 1 ), this.Af( ! 1 ), s = this.Na[ this.ya ], i = this.jb[ this.ya ], s.x = i.x, s.y = i.y, s.z = i.z; i = this.qb[ this.ya ]; var h = s.y - i.y, a = s.z - i.z; if ( s.x = s.x - i.x, s.y = h, s.z = a, this.ya ++, this.El(), 4 == this.ya ) break; if ( this.ya --, i = - ( s = this.dir ).y, h = - s.z, s.x = - s.x, s.y = i, s.z = h, this.zf( ! 1 ), this.Af( ! 1 ), s = this.Na[ this.ya ], i = this.jb[ this.ya ], s.x = i.x, s.y = i.y, s.z = i.z, i = this.qb[ this.ya ], h = s.y - i.y, a = s.z - i.z, s.x = s.x - i.x, s.y = h, s.z = a, this.ya ++, this.El(), 4 == this.ya ) break; this.ya --;

		}

	}, El: function () {

		var t, i, s, h, a, e, o, r, n; for ( t = ( s = this.dir ).x, i = s.y, s = s.z, h = ( e = this.Na[ 0 ] ).x, a = e.y, e = e.z, h -= o = ( n = this.Na[ 1 ] ).x, a -= r = n.y, e -= n = n.z, r = 0; 3 > r; ) {

			var p, l; if ( n = r ++, o = ( n = this.uj[ n ] ).x, p = n.y, n = a * ( l = n.z ) - e * p, l = e * o - h * l, o = h * p - a * o, ( p = this.dir ).x = n, p.y = l, p.z = o, this.zf( ! 1 ), this.Af( ! 1 ), n = this.Na[ this.ya ], o = this.jb[ this.ya ], n.x = o.x, n.y = o.y, n.z = o.z, o = this.qb[ this.ya ], p = n.y - o.y, l = n.z - o.z, n.x = n.x - o.x, n.y = p, n.z = l, this.ya ++, this.Ll(), 4 == this.ya ) break; if ( this.ya --, o = - ( n = this.dir ).y, p = - n.z, n.x = - n.x, n.y = o, n.z = p, this.zf( ! 1 ), this.Af( ! 1 ), n = this.Na[ this.ya ], o = this.jb[ this.ya ], n.x = o.x, n.y = o.y, n.z = o.z, o = this.qb[ this.ya ], p = n.y - o.y, l = n.z - o.z, n.x = n.x - o.x, n.y = p, n.z = l, this.ya ++, this.Ll(), 4 == this.ya ) break; this.ya --;

		}

		( h = this.dir ).x = t, h.y = i, h.z = s;

	}, Ll: function () {

		var t, i, s; for ( t = ( s = this.dir ).x, i = s.y, s = s.z; ; ) {

			var h, a, e, o, r, n, p, l, c; if ( h = ( e = this.Na[ 0 ] ).x, a = e.y, e = e.z, o = ( l = this.Na[ 1 ] ).x, r = l.y, n = l.z, p = ( c = this.Na[ 2 ] ).x, o -= h, r -= a, a = ( l = c.y ) - a, e = r * ( l = ( c = c.z ) - e ) - ( n -= e ) * a, l = n * ( h = p - h ) - o * l, a = o * a - r * h, ( o = this.dir ).x = e, o.y = l, o.z = a, this.zf( ! 1 ), this.Af( ! 1 ), a = this.Na[ this.ya ], e = this.jb[ this.ya ], a.x = e.x, a.y = e.y, a.z = e.z, e = this.qb[ this.ya ], o = a.y - e.y, h = a.z - e.z, a.x = a.x - e.x, a.y = o, a.z = h, this.ya ++, this.tm() ) break; if ( this.ya --, e = - ( a = this.dir ).y, o = - a.z, a.x = - a.x, a.y = e, a.z = o, this.zf( ! 1 ), this.Af( ! 1 ), a = this.Na[ this.ya ], e = this.jb[ this.ya ], a.x = e.x, a.y = e.y, a.z = e.z, e = this.qb[ this.ya ], o = a.y - e.y, h = a.z - e.z, a.x = a.x - e.x, a.y = o, a.z = h, this.ya ++, this.tm() ) break; this.ya --; break;

		}

		( a = this.dir ).x = t, a.y = i, a.z = s;

	}, tm: function () {

		var t = this.Na[ 2 ].x - this.Na[ 0 ].x, i = this.Na[ 2 ].y - this.Na[ 0 ].y, s = this.Na[ 2 ].z - this.Na[ 0 ].z, h = this.Na[ 3 ].x - this.Na[ 0 ].x, a = this.Na[ 3 ].y - this.Na[ 0 ].y, e = this.Na[ 3 ].z - this.Na[ 0 ].z; return 1e-12 < ( t = ( this.Na[ 1 ].x - this.Na[ 0 ].x ) * ( i * e - s * a ) - ( this.Na[ 1 ].y - this.Na[ 0 ].y ) * ( t * e - s * h ) + ( this.Na[ 1 ].z - this.Na[ 0 ].z ) * ( t * a - i * h ) ) || - 1e-12 > t;

	}, mn: function ( t, i, s, h, a, e, o ) {

		for ( var r = this.Og; 0 < r.lh; ) {

			var n = r.jd; r.lh --; var p = n.ia, l = n.M; null != p && ( p.M = l ), null != l && ( l.ia = p ), n == r.jd && ( r.jd = r.jd.M ), n == r.Rc && ( r.Rc = r.Rc.ia ), n.M = null, n.ia = null, n.tk(), n.M = r.De, r.De = n;

		}

		for ( ;0 < r.Ne; ) {

			var c = r.zb[ -- r.Ne ]; c.tk(), c.M = r.bf, r.bf = c;

		}

		var y = this.Og, f = this.Og, u = f.bf; null != u ? ( f.bf = u.M, u.M = null ) : u = new mt(); var b = u.za( a[ 0 ], e[ 0 ], o[ 0 ] ), v = this.Og, g = v.bf; null != g ? ( v.bf = g.M, g.M = null ) : g = new mt(); var x = g.za( a[ 1 ], e[ 1 ], o[ 1 ] ), d = this.Og, z = d.bf; null != z ? ( d.bf = z.M, z.M = null ) : z = new mt(); var m = z.za( a[ 2 ], e[ 2 ], o[ 2 ] ), j = this.Og, M = j.bf; if ( null != M ? ( j.bf = M.M, M.M = null ) : M = new mt(), ! y.fh( b, x, m, M.za( a[ 3 ], e[ 3 ], o[ 3 ] ) ) ) return bt.EPA_FAILED_TO_INIT; this.ya = 0; for ( var A = this.Na[ 0 ], w = this.jb[ 0 ], D = this.qb[ 0 ], C = 0; 40 > C; ) {

			for ( var B = this.Og.jd, q = 1 / 0, S = null; null != B; ) {

				var k = B.M; B.Wj < q && ( q = B.Wj, S = B ), B = k;

			}

			var I = S, T = this.dir, O = I.dk; T.x = O.x, T.y = O.y, T.z = O.z; var L = T, F = Math.sqrt( L.x * L.x + L.y * L.y + L.z * L.z ); 0 < F && ( F = 1 / F ); var P = L.y * F, R = L.z * F; L.x = L.x * F, L.y = P, L.z = R, this.zf( ! 1 ), this.Af( ! 1 ); var J = this.Na[ this.ya ], N = this.jb[ this.ya ]; J.x = N.x, J.y = N.y, J.z = N.z; var H = J, K = this.qb[ this.ya ], G = H.y - K.y, V = H.z - K.z; H.x = H.x - K.x, H.y = G, H.z = V; var E = I.zb[ 0 ], U = I.zb[ 1 ], W = I.zb[ 2 ], Y = E.xd, X = this.dir, $ = this.dir; if ( 1e-6 > A.x * $.x + A.y * $.y + A.z * $.z - ( Y.x * X.x + Y.y * X.y + Y.z * X.z ) || 39 == C ) {

				var Z = this.closest, Q = this.dir; Z.x = Q.x, Z.y = Q.y, Z.z = Q.z; var _ = Z, tt = this.dir, it = E.xd, st = this.dir, ht = ( tt.x * it.x + tt.y * it.y + tt.z * it.z ) / ( st.x * st.x + st.y * st.y + st.z * st.z ), at = _.y * ht, et = _.z * ht; _.x = _.x * ht, _.y = at, _.z = et; var ot, rt, nt, pt = this.closest; ot = pt.x, rt = pt.y, nt = pt.z; var lt, ct, yt, ft, ut, vt, gt, xt, dt, zt, jt, Mt, At, wt, Dt, Ct, Bt, qt, St, kt, It, Tt, Ot, Lt, Ft = E.xd; lt = Ft.x, ct = Ft.y, yt = Ft.z; var Pt = E.jb; ft = Pt.x, ut = Pt.y, vt = Pt.z; var Rt = E.qb; gt = Rt.x, xt = Rt.y, dt = Rt.z; var Jt = U.xd; zt = Jt.x, jt = Jt.y, Mt = Jt.z; var Nt = U.jb; At = Nt.x, wt = Nt.y, Dt = Nt.z; var Ht = U.qb; Ct = Ht.x, Bt = Ht.y, qt = Ht.z; var Kt = W.xd; St = Kt.x, kt = Kt.y, It = Kt.z; var Gt = W.jb; Tt = Gt.x, Ot = Gt.y, Lt = Gt.z; var Vt, Et, Ut, Wt, Yt, Xt, $t, Zt, Qt, _t = W.qb, ti = ( Vt = zt - lt ) * Vt + ( Et = jt - ct ) * Et + ( Ut = Mt - yt ) * Ut, ii = Vt * ( Wt = St - lt ) + Et * ( Yt = kt - ct ) + Ut * ( Xt = It - yt ), si = Wt * Wt + Yt * Yt + Xt * Xt, hi = Vt * ( $t = ot - lt ) + Et * ( Zt = rt - ct ) + Ut * ( Qt = nt - yt ), ai = Wt * $t + Yt * Zt + Xt * Qt, ei = ti * si - ii * ii; ei && ( ei = 1 / ei ); var oi, ri, ni, pi, li, ci, yi = ( hi * si - ai * ii ) * ei, fi = ( - hi * ii + ai * ti ) * ei; oi = ft + ( At - ft ) * yi, ri = ut + ( wt - ut ) * yi, ni = vt + ( Dt - vt ) * yi, oi += ( Tt - ft ) * fi, ri += ( Ot - ut ) * fi, ni += ( Lt - vt ) * fi, pi = gt + ( Ct - gt ) * yi, li = xt + ( Bt - xt ) * yi, ci = dt + ( qt - dt ) * yi, pi += ( _t.x - gt ) * fi, li += ( _t.y - xt ) * fi, ci += ( _t.z - dt ) * fi; var ui = this.closestPoint1; ui.x = oi, ui.y = ri, ui.z = ni; var bi = this.closestPoint2; bi.x = pi, bi.y = li, bi.z = ci; var vi = this.closest; return this.depth = Math.sqrt( vi.x * vi.x + vi.y * vi.y + vi.z * vi.z ), bt.SUCCEEDED;

			}

			var gi = this.Og, xi = gi.bf; null != xi ? ( gi.bf = xi.M, xi.M = null ) : xi = new mt(); var di = xi.za( A, w, D ); if ( ! this.Og.Vm( di, I ) ) return bt.EPA_FAILED_TO_ADD_VERTEX; ++ C;

		}

		return bt.EPA_DID_NOT_CONVERGE;

	}, ua: function ( t, i, s, h, a ) {

		return this.zj( t, i, s, h, a, ! 0 );

	}, cb: function ( t, i, s, h, a ) {

		return this.zj( t, i, s, h, a, ! 1 );

	}, Bf: function ( t, i, s, h, a, e, o ) {

		return this.fm( t, i, s, h, a, e, o );

	}, Vd: function ( t, i, s, h, a ) {

		var e = this.ao; e.v = s.x, e.A = s.y, e.B = s.z; var o = this.bo, r = this.co; o.x = h.x, o.y = h.y, o.z = h.z, h = o.y - s.y; var n = o.z - s.z; return o.x = o.x - s.x, o.y = h, o.z = n, r.Z(), this.fm( null, t, e, i, o, r, a );

	} }, ut.qc = function ( t, i, s ) {

		var h, a, e, o, r, n, p, l; return h = t.x, a = t.y, t = t.z, 0 > ( l = - ( ( r = ( e = i.x ) - h ) * h + ( n = ( o = i.y ) - a ) * a + ( p = ( i = i.z ) - t ) * t ) / ( r * r + n * n + p * p ) ) ? ( s.x = h, s.y = a, s.z = t, 1 ) : 1 < l ? ( s.x = e, s.y = o, s.z = i, 2 ) : ( s.x = h + r * l, s.y = a + n * l, s.z = t + p * l, 3 );

	}, ut.uc = function ( t, i, s, h ) {

		var a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A; a = t.x, e = t.y, o = t.z, r = i.x, n = i.y, p = i.z, d = a - ( l = s.x ), z = e - ( c = s.y ), m = o - ( y = s.z ); var w, D, C, B, q, S = - 1, k = 0; ( C = D = w = 0, 0 > a * ( ( u = n - e ) * ( A = ( f = r - a ) * ( g = c - n ) - u * ( v = l - r ) ) - ( b = p - o ) * ( M = b * v - f * ( x = y - p ) ) ) + e * ( b * ( j = u * x - b * g ) - f * A ) + o * ( f * M - u * j ) ) && ( f = t.x, S = t.y, w = t.z, 0 > ( k = - ( ( q = ( u = i.x ) - f ) * f + ( C = ( b = i.y ) - S ) * S + ( D = ( B = i.z ) - w ) * w ) / ( q * q + C * C + D * D ) ) ? ( h.x = f, h.y = S, h.z = w, D = 1 ) : 1 < k ? ( h.x = u, h.y = b, h.z = B, D = 2 ) : ( f += q * k, S += C * k, w += D * k, h.x = f, h.y = S, h.z = w, D = 3 ), k = D, S = w = h.x * h.x + h.y * h.y + h.z * h.z, w = h.x, D = h.y, C = h.z ); return 0 > r * ( g * A - x * M ) + n * ( x * j - v * A ) + p * ( v * M - g * j ) && ( v = i.x, r = i.y, i = i.z, 0 > ( p = - ( ( b = ( x = s.x ) - v ) * v + ( g = ( f = s.y ) - r ) * r + ( n = ( u = s.z ) - i ) * i ) / ( b * b + g * g + n * n ) ) ? ( h.x = v, h.y = r, h.z = i, i = 1 ) : 1 < p ? ( h.x = x, h.y = f, h.z = u, i = 2 ) : ( v += b * p, r += g * p, i += n * p, h.x = v, h.y = r, h.z = i, i = 3 ), r = h.x * h.x + h.y * h.y + h.z * h.z, 0 > S || r < S ) && ( k = i << 1, S = r, w = h.x, D = h.y, C = h.z ), 0 > l * ( z * A - m * M ) + c * ( m * j - d * A ) + y * ( d * M - z * j ) && ( c = t.x, l = t.y, t = t.z, 0 > ( y = - ( ( r = ( d = s.x ) - c ) * c + ( m = ( z = s.y ) - l ) * l + ( s = ( i = s.z ) - t ) * t ) / ( r * r + m * m + s * s ) ) ? ( h.x = c, h.y = l, h.z = t, s = 1 ) : 1 < y ? ( h.x = d, h.y = z, h.z = i, s = 2 ) : ( c += r * y, l += m * y, s = t + s * y, h.x = c, h.y = l, h.z = s, s = 3 ), t = h.x * h.x + h.y * h.y + h.z * h.z, 0 > S || t < S ) && ( k = 1 & s | ( 2 & s ) << 1, S = t, w = h.x, D = h.y, C = h.z ), 0 < S ? ( h.x = w, h.y = D, h.z = C, k ) : ( 0 < ( s = j * j + M * M + A * A ) && ( s = 1 / Math.sqrt( s ) ), w = ( j *= s ) * ( a = ( a * j + e * ( M *= s ) + o * ( A *= s ) ) / ( j * j + M * M + A * A ) ), D = M * a, C = A * a, h.x = w, h.y = D, h.z = C, 7 );

	}, ut.vc = function ( t, i, s, h, a ) {

		var e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O; e = t.x, o = t.y, r = t.z, n = i.x, p = i.y, l = i.z, c = s.x, y = s.y, f = s.z, u = h.x; var L, F, P, R = 0 < ( g = n - e ) * ( I = ( S = ( b = h.y ) - p ) * ( B = f - l ) - ( k = ( v = h.z ) - l ) * ( C = y - p ) ) + ( x = p - o ) * ( T = k * ( D = c - n ) - ( q = u - n ) * B ) + ( d = l - r ) * ( O = q * C - S * D ) ? 1 : - 1, J = e * ( ( m = y - o ) * ( w = v - r ) - ( j = f - r ) * ( A = b - o ) ) + o * ( j * ( M = u - e ) - ( z = c - e ) * w ) + r * ( z * A - m * M ), N = e * ( A * d - w * x ) + o * ( w * g - M * d ) + r * ( M * x - A * g ), H = n * I + p * T + l * O, K = - 1, G = 0; if ( P = F = L = 0, 0 > ( e * ( x * j - d * m ) + o * ( d * z - g * j ) + r * ( g * m - x * z ) ) * R ) {

			var V, E, U, W, Y, X, $, Z, Q, _, tt, it, st, ht, at, et, ot, rt, nt, pt, lt; V = t.x, E = t.y, U = t.z, W = i.x, Y = i.y, X = i.z, $ = s.x; var ct, yt, ft, ut, bt = W * ( ( ht = ( Z = s.y ) - Y ) * ( lt = ( _ = W - V ) * ht - ( tt = Y - E ) * ( st = $ - W ) ) - ( at = ( Q = s.z ) - X ) * ( pt = ( it = X - U ) * st - _ * at ) ) + Y * ( at * ( nt = tt * at - it * ht ) - st * lt ) + X * ( st * pt - ht * nt ), vt = $ * ( ( ot = E - Z ) * lt - ( rt = U - Q ) * pt ) + Z * ( rt * nt - ( et = V - $ ) * lt ) + Q * ( et * pt - ot * nt ), gt = - 1, xt = 0; if ( ft = yt = ct = 0, 0 > V * ( tt * lt - it * pt ) + E * ( it * nt - _ * lt ) + U * ( _ * pt - tt * nt ) ) {

				var dt, zt, mt, jt, Mt, At, wt, Dt, Ct, Bt, qt; if ( dt = t.x, zt = t.y, mt = t.z, 0 > ( Bt = - ( Bt = ( wt = ( jt = i.x ) - dt ) * dt + ( Dt = ( Mt = i.y ) - zt ) * zt + ( Ct = ( At = i.z ) - mt ) * mt ) / ( wt * wt + Dt * Dt + Ct * Ct ) ) )a.x = dt, a.y = zt, a.z = mt, qt = 1; else if ( 1 < Bt )a.x = jt, a.y = Mt, a.z = At, qt = 2; else {

					var St, kt, It; St = dt + wt * Bt, kt = zt + Dt * Bt, It = mt + Ct * Bt, a.x = St, a.y = kt, a.z = It, qt = 3;

				}

				xt = qt, gt = a.x * a.x + a.y * a.y + a.z * a.z; ct = a.x, yt = a.y, ft = a.z;

			}

			if ( 0 > bt ) {

				var Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt, Ht, Kt, Gt; if ( Tt = i.x, Ot = i.y, Lt = i.z, 0 > ( Kt = - ( Kt = ( Jt = ( Ft = s.x ) - Tt ) * Tt + ( Nt = ( Pt = s.y ) - Ot ) * Ot + ( Ht = ( Rt = s.z ) - Lt ) * Lt ) / ( Jt * Jt + Nt * Nt + Ht * Ht ) ) )a.x = Tt, a.y = Ot, a.z = Lt, Gt = 1; else if ( 1 < Kt )a.x = Ft, a.y = Pt, a.z = Rt, Gt = 2; else {

					var Vt, Et, Ut; Vt = Tt + Jt * Kt, Et = Ot + Nt * Kt, Ut = Lt + Ht * Kt, a.x = Vt, a.y = Et, a.z = Ut, Gt = 3;

				}

				var Wt = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > gt || Wt < gt ) && ( xt = Gt << 1, gt = Wt, ct = a.x, yt = a.y, ft = a.z );

			}

			if ( 0 > vt ) {

				var Yt, Xt, $t, Zt, Qt, _t, ti, ii, si, hi, ai; if ( Yt = t.x, Xt = t.y, $t = t.z, 0 > ( hi = - ( hi = ( ti = ( Zt = s.x ) - Yt ) * Yt + ( ii = ( Qt = s.y ) - Xt ) * Xt + ( si = ( _t = s.z ) - $t ) * $t ) / ( ti * ti + ii * ii + si * si ) ) )a.x = Yt, a.y = Xt, a.z = $t, ai = 1; else if ( 1 < hi )a.x = Zt, a.y = Qt, a.z = _t, ai = 2; else {

					var ei, oi, ri; ei = Yt + ti * hi, oi = Xt + ii * hi, ri = $t + si * hi, a.x = ei, a.y = oi, a.z = ri, ai = 3;

				}

				var ni = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > gt || ni < gt ) && ( xt = 1 & ai | ( 2 & ai ) << 1, gt = ni, ct = a.x, yt = a.y, ft = a.z );

			}

			if ( 0 < gt )a.x = ct, a.y = yt, a.z = ft, ut = xt; else {

				var pi, li = nt * nt + pt * pt + lt * lt; 0 < li && ( li = 1 / Math.sqrt( li ) ), ct = ( nt *= li ) * ( pi = ( V * nt + E * ( pt *= li ) + U * ( lt *= li ) ) / ( pi = nt * nt + pt * pt + lt * lt ) ), yt = pt * pi, ft = lt * pi, a.x = ct, a.y = yt, a.z = ft, ut = 7;

			}

			G = ut, K = a.x * a.x + a.y * a.y + a.z * a.z; L = a.x, F = a.y, P = a.z;

		}

		if ( 0 > J * R ) {

			var ci, yi, fi, ui, bi, vi, gi, xi, di, zi, mi, ji, Mi, Ai, wi, Di, Ci, Bi, qi, Si, ki; ci = t.x, yi = t.y, fi = t.z, ui = s.x, bi = s.y, vi = s.z, gi = h.x; var Ii, Ti, Oi, Li, Fi = ui * ( ( Ai = ( xi = h.y ) - bi ) * ( ki = ( zi = ui - ci ) * Ai - ( mi = bi - yi ) * ( Mi = gi - ui ) ) - ( wi = ( di = h.z ) - vi ) * ( Si = ( ji = vi - fi ) * Mi - zi * wi ) ) + bi * ( wi * ( qi = mi * wi - ji * Ai ) - Mi * ki ) + vi * ( Mi * Si - Ai * qi ), Pi = gi * ( ( Ci = yi - xi ) * ki - ( Bi = fi - di ) * Si ) + xi * ( Bi * qi - ( Di = ci - gi ) * ki ) + di * ( Di * Si - Ci * qi ), Ri = - 1, Ji = 0; if ( Oi = Ti = Ii = 0, 0 > ci * ( mi * ki - ji * Si ) + yi * ( ji * qi - zi * ki ) + fi * ( zi * Si - mi * qi ) ) {

				var Ni, Hi, Ki, Gi, Vi, Ei, Ui, Wi, Yi, Xi, $i; if ( Ni = t.x, Hi = t.y, Ki = t.z, 0 > ( Xi = - ( Xi = ( Ui = ( Gi = s.x ) - Ni ) * Ni + ( Wi = ( Vi = s.y ) - Hi ) * Hi + ( Yi = ( Ei = s.z ) - Ki ) * Ki ) / ( Ui * Ui + Wi * Wi + Yi * Yi ) ) )a.x = Ni, a.y = Hi, a.z = Ki, $i = 1; else if ( 1 < Xi )a.x = Gi, a.y = Vi, a.z = Ei, $i = 2; else {

					var Zi, Qi, _i; Zi = Ni + Ui * Xi, Qi = Hi + Wi * Xi, _i = Ki + Yi * Xi, a.x = Zi, a.y = Qi, a.z = _i, $i = 3;

				}

				Ji = $i, Ri = a.x * a.x + a.y * a.y + a.z * a.z; Ii = a.x, Ti = a.y, Oi = a.z;

			}

			if ( 0 > Fi ) {

				var ts, is, ss, hs, as, es, os, rs, ns, ps, ls; if ( ts = s.x, is = s.y, ss = s.z, 0 > ( ps = - ( ps = ( os = ( hs = h.x ) - ts ) * ts + ( rs = ( as = h.y ) - is ) * is + ( ns = ( es = h.z ) - ss ) * ss ) / ( os * os + rs * rs + ns * ns ) ) )a.x = ts, a.y = is, a.z = ss, ls = 1; else if ( 1 < ps )a.x = hs, a.y = as, a.z = es, ls = 2; else {

					var cs, ys, fs; cs = ts + os * ps, ys = is + rs * ps, fs = ss + ns * ps, a.x = cs, a.y = ys, a.z = fs, ls = 3;

				}

				var us = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > Ri || us < Ri ) && ( Ji = ls << 1, Ri = us, Ii = a.x, Ti = a.y, Oi = a.z );

			}

			if ( 0 > Pi ) {

				var bs, vs, gs, xs, ds, zs, ms, js, Ms, As, ws; if ( bs = t.x, vs = t.y, gs = t.z, 0 > ( As = - ( As = ( ms = ( xs = h.x ) - bs ) * bs + ( js = ( ds = h.y ) - vs ) * vs + ( Ms = ( zs = h.z ) - gs ) * gs ) / ( ms * ms + js * js + Ms * Ms ) ) )a.x = bs, a.y = vs, a.z = gs, ws = 1; else if ( 1 < As )a.x = xs, a.y = ds, a.z = zs, ws = 2; else {

					var Ds, Cs, Bs; Ds = bs + ms * As, Cs = vs + js * As, Bs = gs + Ms * As, a.x = Ds, a.y = Cs, a.z = Bs, ws = 3;

				}

				var qs = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > Ri || qs < Ri ) && ( Ji = 1 & ws | ( 2 & ws ) << 1, Ri = qs, Ii = a.x, Ti = a.y, Oi = a.z );

			}

			if ( 0 < Ri )a.x = Ii, a.y = Ti, a.z = Oi, Li = Ji; else {

				var Ss, ks = qi * qi + Si * Si + ki * ki; 0 < ks && ( ks = 1 / Math.sqrt( ks ) ), Ii = ( qi *= ks ) * ( Ss = ( ci * qi + yi * ( Si *= ks ) + fi * ( ki *= ks ) ) / ( Ss = qi * qi + Si * Si + ki * ki ) ), Ti = Si * Ss, Oi = ki * Ss, a.x = Ii, a.y = Ti, a.z = Oi, Li = 7;

			}

			var Is = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > K || Is < K ) && ( G = 1 & Li | ( 6 & Li ) << 1, K = Is, L = a.x, F = a.y, P = a.z );

		}

		if ( 0 > N * R ) {

			var Ts, Os, Ls, Fs, Ps, Rs, Js, Ns, Hs, Ks, Gs, Vs, Es, Us, Ws, Ys, Xs, $s, Zs, Qs, _s; Ts = t.x, Os = t.y, Ls = t.z, Fs = i.x, Ps = i.y, Rs = i.z, Js = h.x; var th, ih, sh, hh, ah = Fs * ( ( Us = ( Ns = h.y ) - Ps ) * ( _s = ( Ks = Fs - Ts ) * Us - ( Gs = Ps - Os ) * ( Es = Js - Fs ) ) - ( Ws = ( Hs = h.z ) - Rs ) * ( Qs = ( Vs = Rs - Ls ) * Es - Ks * Ws ) ) + Ps * ( Ws * ( Zs = Gs * Ws - Vs * Us ) - Es * _s ) + Rs * ( Es * Qs - Us * Zs ), eh = Js * ( ( Xs = Os - Ns ) * _s - ( $s = Ls - Hs ) * Qs ) + Ns * ( $s * Zs - ( Ys = Ts - Js ) * _s ) + Hs * ( Ys * Qs - Xs * Zs ), oh = - 1, rh = 0; if ( sh = ih = th = 0, 0 > Ts * ( Gs * _s - Vs * Qs ) + Os * ( Vs * Zs - Ks * _s ) + Ls * ( Ks * Qs - Gs * Zs ) ) {

				var nh, ph, lh, ch, yh, fh, uh, bh, vh, gh, xh; if ( nh = t.x, ph = t.y, lh = t.z, 0 > ( gh = - ( gh = ( uh = ( ch = i.x ) - nh ) * nh + ( bh = ( yh = i.y ) - ph ) * ph + ( vh = ( fh = i.z ) - lh ) * lh ) / ( uh * uh + bh * bh + vh * vh ) ) )a.x = nh, a.y = ph, a.z = lh, xh = 1; else if ( 1 < gh )a.x = ch, a.y = yh, a.z = fh, xh = 2; else {

					var dh, zh, mh; dh = nh + uh * gh, zh = ph + bh * gh, mh = lh + vh * gh, a.x = dh, a.y = zh, a.z = mh, xh = 3;

				}

				rh = xh, oh = a.x * a.x + a.y * a.y + a.z * a.z; th = a.x, ih = a.y, sh = a.z;

			}

			if ( 0 > ah ) {

				var jh, Mh, Ah, wh, Dh, Ch, Bh, qh, Sh, kh, Ih; if ( jh = i.x, Mh = i.y, Ah = i.z, 0 > ( kh = - ( kh = ( Bh = ( wh = h.x ) - jh ) * jh + ( qh = ( Dh = h.y ) - Mh ) * Mh + ( Sh = ( Ch = h.z ) - Ah ) * Ah ) / ( Bh * Bh + qh * qh + Sh * Sh ) ) )a.x = jh, a.y = Mh, a.z = Ah, Ih = 1; else if ( 1 < kh )a.x = wh, a.y = Dh, a.z = Ch, Ih = 2; else {

					var Th, Oh, Lh; Th = jh + Bh * kh, Oh = Mh + qh * kh, Lh = Ah + Sh * kh, a.x = Th, a.y = Oh, a.z = Lh, Ih = 3;

				}

				var Fh = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > oh || Fh < oh ) && ( rh = Ih << 1, oh = Fh, th = a.x, ih = a.y, sh = a.z );

			}

			if ( 0 > eh ) {

				var Ph, Rh, Jh, Nh, Hh, Kh, Gh, Vh, Eh, Uh, Wh; if ( Ph = t.x, Rh = t.y, Jh = t.z, 0 > ( Uh = - ( Uh = ( Gh = ( Nh = h.x ) - Ph ) * Ph + ( Vh = ( Hh = h.y ) - Rh ) * Rh + ( Eh = ( Kh = h.z ) - Jh ) * Jh ) / ( Gh * Gh + Vh * Vh + Eh * Eh ) ) )a.x = Ph, a.y = Rh, a.z = Jh, Wh = 1; else if ( 1 < Uh )a.x = Nh, a.y = Hh, a.z = Kh, Wh = 2; else {

					var Yh, Xh, $h; Yh = Ph + Gh * Uh, Xh = Rh + Vh * Uh, $h = Jh + Eh * Uh, a.x = Yh, a.y = Xh, a.z = $h, Wh = 3;

				}

				var Zh = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > oh || Zh < oh ) && ( rh = 1 & Wh | ( 2 & Wh ) << 1, oh = Zh, th = a.x, ih = a.y, sh = a.z );

			}

			if ( 0 < oh )a.x = th, a.y = ih, a.z = sh, hh = rh; else {

				var Qh, _h = Zs * Zs + Qs * Qs + _s * _s; 0 < _h && ( _h = 1 / Math.sqrt( _h ) ), th = ( Zs *= _h ) * ( Qh = ( Ts * Zs + Os * ( Qs *= _h ) + Ls * ( _s *= _h ) ) / ( Qh = Zs * Zs + Qs * Qs + _s * _s ) ), ih = Qs * Qh, sh = _s * Qh, a.x = th, a.y = ih, a.z = sh, hh = 7;

			}

			var ta = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > K || ta < K ) && ( G = 3 & hh | ( 4 & hh ) << 1, K = ta, L = a.x, F = a.y, P = a.z );

		}

		if ( 0 > H * R ) {

			var ia, sa, ha, aa, ea, oa, ra, na, pa, la, ca, ya, fa, ua, ba, va, ga, xa, da, za, ma; ia = i.x, sa = i.y, ha = i.z, aa = s.x, ea = s.y, oa = s.z, ra = h.x; var ja, Ma, Aa, wa, Da = aa * ( ( ua = ( na = h.y ) - ea ) * ( ma = ( la = aa - ia ) * ua - ( ca = ea - sa ) * ( fa = ra - aa ) ) - ( ba = ( pa = h.z ) - oa ) * ( za = ( ya = oa - ha ) * fa - la * ba ) ) + ea * ( ba * ( da = ca * ba - ya * ua ) - fa * ma ) + oa * ( fa * za - ua * da ), Ca = ra * ( ( ga = sa - na ) * ma - ( xa = ha - pa ) * za ) + na * ( xa * da - ( va = ia - ra ) * ma ) + pa * ( va * za - ga * da ), Ba = - 1, qa = 0; if ( Aa = Ma = ja = 0, 0 > ia * ( ca * ma - ya * za ) + sa * ( ya * da - la * ma ) + ha * ( la * za - ca * da ) ) {

				var Sa, ka, Ia, Ta, Oa, La, Fa, Pa, Ra, Ja, Na; if ( Sa = i.x, ka = i.y, Ia = i.z, 0 > ( Ja = - ( Ja = ( Fa = ( Ta = s.x ) - Sa ) * Sa + ( Pa = ( Oa = s.y ) - ka ) * ka + ( Ra = ( La = s.z ) - Ia ) * Ia ) / ( Fa * Fa + Pa * Pa + Ra * Ra ) ) )a.x = Sa, a.y = ka, a.z = Ia, Na = 1; else if ( 1 < Ja )a.x = Ta, a.y = Oa, a.z = La, Na = 2; else {

					var Ha, Ka, Ga; Ha = Sa + Fa * Ja, Ka = ka + Pa * Ja, Ga = Ia + Ra * Ja, a.x = Ha, a.y = Ka, a.z = Ga, Na = 3;

				}

				qa = Na, Ba = a.x * a.x + a.y * a.y + a.z * a.z; ja = a.x, Ma = a.y, Aa = a.z;

			}

			if ( 0 > Da ) {

				var Va, Ea, Ua, Wa, Ya, Xa, $a, Za, Qa, _a, te; if ( Va = s.x, Ea = s.y, Ua = s.z, 0 > ( _a = - ( _a = ( $a = ( Wa = h.x ) - Va ) * Va + ( Za = ( Ya = h.y ) - Ea ) * Ea + ( Qa = ( Xa = h.z ) - Ua ) * Ua ) / ( $a * $a + Za * Za + Qa * Qa ) ) )a.x = Va, a.y = Ea, a.z = Ua, te = 1; else if ( 1 < _a )a.x = Wa, a.y = Ya, a.z = Xa, te = 2; else {

					var ie, se, he; ie = Va + $a * _a, se = Ea + Za * _a, he = Ua + Qa * _a, a.x = ie, a.y = se, a.z = he, te = 3;

				}

				var ae = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > Ba || ae < Ba ) && ( qa = te << 1, Ba = ae, ja = a.x, Ma = a.y, Aa = a.z );

			}

			if ( 0 > Ca ) {

				var ee, oe, re, ne, pe, le, ce, ye, fe, ue, be; if ( ee = i.x, oe = i.y, re = i.z, 0 > ( ue = - ( ue = ( ce = ( ne = h.x ) - ee ) * ee + ( ye = ( pe = h.y ) - oe ) * oe + ( fe = ( le = h.z ) - re ) * re ) / ( ce * ce + ye * ye + fe * fe ) ) )a.x = ee, a.y = oe, a.z = re, be = 1; else if ( 1 < ue )a.x = ne, a.y = pe, a.z = le, be = 2; else {

					var ve, ge, xe; ve = ee + ce * ue, ge = oe + ye * ue, xe = re + fe * ue, a.x = ve, a.y = ge, a.z = xe, be = 3;

				}

				var de = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > Ba || de < Ba ) && ( qa = 1 & be | ( 2 & be ) << 1, Ba = de, ja = a.x, Ma = a.y, Aa = a.z );

			}

			if ( 0 < Ba )a.x = ja, a.y = Ma, a.z = Aa, wa = qa; else {

				var ze, me = da * da + za * za + ma * ma; 0 < me && ( me = 1 / Math.sqrt( me ) ), ja = ( da *= me ) * ( ze = ( ia * da + sa * ( za *= me ) + ha * ( ma *= me ) ) / ( ze = da * da + za * za + ma * ma ) ), Ma = za * ze, Aa = ma * ze, a.x = ja, a.y = Ma, a.z = Aa, wa = 7;

			}

			var je = a.x * a.x + a.y * a.y + a.z * a.z; ( 0 > K || je < K ) && ( G = wa << 1, K = je, L = a.x, F = a.y, P = a.z );

		}

		return 0 < K ? ( a.x = L, a.y = F, a.z = P, G ) : ( a.Z(), 15 );

	}, ft.prototype = { za: function ( t, i, s, h, a, e, o, r, n ) {

		return this.e00 = t, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, this;

	}, Wf: function () {

		return this.e00 = 1, this.e10 = this.e02 = this.e01 = 0, this.e11 = 1, this.e21 = this.e20 = this.e12 = 0, this.e22 = 1, this;

	}, Ac: function ( t ) {

		return new ft( this.e00 + t.e00, this.e01 + t.e01, this.e02 + t.e02, this.e10 + t.e10, this.e11 + t.e11, this.e12 + t.e12, this.e20 + t.e20, this.e21 + t.e21, this.e22 + t.e22 );

	}, Ug: function ( t ) {

		return new ft( this.e00 - t.e00, this.e01 - t.e01, this.e02 - t.e02, this.e10 - t.e10, this.e11 - t.e11, this.e12 - t.e12, this.e20 - t.e20, this.e21 - t.e21, this.e22 - t.e22 );

	}, Mf: function ( t ) {

		return new ft( this.e00 * t, this.e01 * t, this.e02 * t, this.e10 * t, this.e11 * t, this.e12 * t, this.e20 * t, this.e21 * t, this.e22 * t );

	}, re: function ( t ) {

		return new ft( this.e00 * t.e00 + this.e01 * t.e10 + this.e02 * t.e20, this.e00 * t.e01 + this.e01 * t.e11 + this.e02 * t.e21, this.e00 * t.e02 + this.e01 * t.e12 + this.e02 * t.e22, this.e10 * t.e00 + this.e11 * t.e10 + this.e12 * t.e20, this.e10 * t.e01 + this.e11 * t.e11 + this.e12 * t.e21, this.e10 * t.e02 + this.e11 * t.e12 + this.e12 * t.e22, this.e20 * t.e00 + this.e21 * t.e10 + this.e22 * t.e20, this.e20 * t.e01 + this.e21 * t.e11 + this.e22 * t.e21, this.e20 * t.e02 + this.e21 * t.e12 + this.e22 * t.e22 );

	}, Ec: function ( t ) {

		var i = this.e01 + t.e01, s = this.e02 + t.e02, h = this.e10 + t.e10, a = this.e11 + t.e11, e = this.e12 + t.e12, o = this.e20 + t.e20, r = this.e21 + t.e21, n = this.e22 + t.e22; return this.e00 += t.e00, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, this;

	}, Vg: function ( t ) {

		var i = this.e01 - t.e01, s = this.e02 - t.e02, h = this.e10 - t.e10, a = this.e11 - t.e11, e = this.e12 - t.e12, o = this.e20 - t.e20, r = this.e21 - t.e21, n = this.e22 - t.e22; return this.e00 = this.e00 - t.e00, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, this;

	}, Tg: function ( t ) {

		var i = this.e01 * t, s = this.e02 * t, h = this.e10 * t, a = this.e11 * t, e = this.e12 * t, o = this.e20 * t, r = this.e21 * t, n = this.e22 * t; return this.e00 = this.e00 * t, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, this;

	}, se: function ( t ) {

		var i = this.e00 * t.e01 + this.e01 * t.e11 + this.e02 * t.e21, s = this.e00 * t.e02 + this.e01 * t.e12 + this.e02 * t.e22, h = this.e10 * t.e00 + this.e11 * t.e10 + this.e12 * t.e20, a = this.e10 * t.e01 + this.e11 * t.e11 + this.e12 * t.e21, e = this.e10 * t.e02 + this.e11 * t.e12 + this.e12 * t.e22, o = this.e20 * t.e00 + this.e21 * t.e10 + this.e22 * t.e20, r = this.e20 * t.e01 + this.e21 * t.e11 + this.e22 * t.e21, n = this.e20 * t.e02 + this.e21 * t.e12 + this.e22 * t.e22; return this.e00 = this.e00 * t.e00 + this.e01 * t.e10 + this.e02 * t.e20, this.e01 = i, this.e02 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e20 = o, this.e21 = r, this.e22 = n, this;

	}, Ue: function ( t, i, s ) {

		return new ft( this.e00 * t, this.e01 * t, this.e02 * t, this.e10 * i, this.e11 * i, this.e12 * i, this.e20 * s, this.e21 * s, this.e22 * s );

	}, Lc: function ( t, i, s ) {

		return new ft( this.e00 * t, this.e01 * i, this.e02 * s, this.e10 * t, this.e11 * i, this.e12 * s, this.e20 * t, this.e21 * i, this.e22 * s );

	}, te: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = Math.cos( t ), o = 1 - e; t = i * i * o + e; var r = i * s * o - h * a, n = i * h * o + s * a, p = s * i * o + h * a, l = s * s * o + e, c = s * h * o - i * a, y = h * i * o - s * a; return i = h * s * o + i * a, h = h * h * o + e, new ft( t * this.e00 + r * this.e10 + n * this.e20, t * this.e01 + r * this.e11 + n * this.e21, t * this.e02 + r * this.e12 + n * this.e22, p * this.e00 + l * this.e10 + c * this.e20, p * this.e01 + l * this.e11 + c * this.e21, p * this.e02 + l * this.e12 + c * this.e22, y * this.e00 + i * this.e10 + h * this.e20, y * this.e01 + i * this.e11 + h * this.e21, y * this.e02 + i * this.e12 + h * this.e22 );

	}, Jc: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = Math.cos( t ), o = 1 - e; t = i * i * o + e; var r = i * s * o - h * a, n = i * h * o + s * a, p = s * i * o + h * a, l = s * s * o + e, c = s * h * o - i * a, y = h * i * o - s * a; return i = h * s * o + i * a, h = h * h * o + e, new ft( this.e00 * t + this.e01 * p + this.e02 * y, this.e00 * r + this.e01 * l + this.e02 * i, this.e00 * n + this.e01 * c + this.e02 * h, this.e10 * t + this.e11 * p + this.e12 * y, this.e10 * r + this.e11 * l + this.e12 * i, this.e10 * n + this.e11 * c + this.e12 * h, this.e20 * t + this.e21 * p + this.e22 * y, this.e20 * r + this.e21 * l + this.e22 * i, this.e20 * n + this.e21 * c + this.e22 * h );

	}, Ve: function ( t, i, s ) {

		var h = this.e01 * t, a = this.e02 * t, e = this.e10 * i, o = this.e11 * i; i = this.e12 * i; var r = this.e20 * s, n = this.e21 * s; return s = this.e22 * s, this.e00 = this.e00 * t, this.e01 = h, this.e02 = a, this.e10 = e, this.e11 = o, this.e12 = i, this.e20 = r, this.e21 = n, this.e22 = s, this;

	}, fd: function ( t, i, s ) {

		var h = this.e01 * i, a = this.e02 * s, e = this.e10 * t, o = this.e11 * i, r = this.e12 * s, n = this.e20 * t; return i = this.e21 * i, s = this.e22 * s, this.e00 = this.e00 * t, this.e01 = h, this.e02 = a, this.e10 = e, this.e11 = o, this.e12 = r, this.e20 = n, this.e21 = i, this.e22 = s, this;

	}, ue: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = Math.cos( t ), o = 1 - e; t = i * i * o + e; var r = i * s * o - h * a, n = i * h * o + s * a, p = s * i * o + h * a, l = s * s * o + e, c = s * h * o - i * a, y = h * i * o - s * a; return i = h * s * o + i * a, o = h * h * o + e, h = t * this.e01 + r * this.e11 + n * this.e21, s = t * this.e02 + r * this.e12 + n * this.e22, a = p * this.e00 + l * this.e10 + c * this.e20, e = p * this.e01 + l * this.e11 + c * this.e21, p = p * this.e02 + l * this.e12 + c * this.e22, l = y * this.e00 + i * this.e10 + o * this.e20, c = y * this.e01 + i * this.e11 + o * this.e21, y = y * this.e02 + i * this.e12 + o * this.e22, this.e00 = t * this.e00 + r * this.e10 + n * this.e20, this.e01 = h, this.e02 = s, this.e10 = a, this.e11 = e, this.e12 = p, this.e20 = l, this.e21 = c, this.e22 = y, this;

	}, Kc: function ( t, i, s, h ) {

		var a = Math.sin( t ); t = i * i * ( f = 1 - ( y = Math.cos( t ) ) ) + y; var e = i * s * f - h * a, o = i * h * f + s * a, r = s * i * f + h * a, n = s * s * f + y, p = s * h * f - i * a, l = h * i * f - s * a; i = h * s * f + i * a; var c = h * h * f + y; h = this.e00 * e + this.e01 * n + this.e02 * i, s = this.e00 * o + this.e01 * p + this.e02 * c; a = this.e10 * t + this.e11 * r + this.e12 * l; var y = this.e10 * e + this.e11 * n + this.e12 * i, f = this.e10 * o + this.e11 * p + this.e12 * c, u = this.e20 * t + this.e21 * r + this.e22 * l; e = this.e20 * e + this.e21 * n + this.e22 * i, o = this.e20 * o + this.e21 * p + this.e22 * c; return this.e00 = this.e00 * t + this.e01 * r + this.e02 * l, this.e01 = h, this.e02 = s, this.e10 = a, this.e11 = y, this.e12 = f, this.e20 = u, this.e21 = e, this.e22 = o, this;

	}, ji: function () {

		return new ft( this.e00, this.e10, this.e20, this.e01, this.e11, this.e21, this.e02, this.e12, this.e22 );

	}, ki: function () {

		var t = this.e10, i = this.e20, s = this.e01, h = this.e11, a = this.e21, e = this.e02, o = this.e12, r = this.e22; return this.e00 = this.e00, this.e01 = t, this.e02 = i, this.e10 = s, this.e11 = h, this.e12 = a, this.e20 = e, this.e21 = o, this.e22 = r, this;

	}, Yd: function () {

		return this.e00 * ( this.e11 * this.e22 - this.e12 * this.e21 ) - this.e01 * ( this.e10 * this.e22 - this.e12 * this.e20 ) + this.e02 * ( this.e10 * this.e21 - this.e11 * this.e20 );

	}, Xg: function () {

		return this.e00 + this.e11 + this.e22;

	}, pe: function () {

		var t = this.e11 * this.e22 - this.e12 * this.e21, i = this.e10 * this.e22 - this.e12 * this.e20, s = this.e10 * this.e21 - this.e11 * this.e20, h = this.e01 * this.e22 - this.e02 * this.e21, a = this.e00 * this.e22 - this.e02 * this.e20, e = this.e00 * this.e21 - this.e01 * this.e20, o = this.e01 * this.e12 - this.e02 * this.e11, r = this.e00 * this.e12 - this.e02 * this.e10, n = this.e00 * this.e11 - this.e01 * this.e10, p = this.e00 * t - this.e01 * i + this.e02 * s; return p && ( p = 1 / p ), new ft( t * p, - h * p, o * p, - i * p, a * p, - r * p, s * p, - e * p, n * p );

	}, qe: function () {

		var t = this.e11 * this.e22 - this.e12 * this.e21, i = this.e10 * this.e22 - this.e12 * this.e20, s = this.e10 * this.e21 - this.e11 * this.e20, h = this.e01 * this.e22 - this.e02 * this.e21, a = this.e00 * this.e22 - this.e02 * this.e20, e = this.e00 * this.e21 - this.e01 * this.e20, o = this.e01 * this.e12 - this.e02 * this.e11, r = this.e00 * this.e12 - this.e02 * this.e10, n = this.e00 * this.e11 - this.e01 * this.e10, p = this.e00 * t - this.e01 * i + this.e02 * s; return p && ( p = 1 / p ), this.e00 = t * p, this.e01 = - h * p, this.e02 = o * p, this.e10 = - i * p, this.e11 = a * p, this.e12 = - r * p, this.e20 = s * p, this.e21 = - e * p, this.e22 = n * p, this;

	}, Wg: function ( t ) {

		return null == t && ( t = ! 1 ), t ? [ this.e00, this.e10, this.e20, this.e01, this.e11, this.e21, this.e02, this.e12, this.e22 ] : [ this.e00, this.e01, this.e02, this.e10, this.e11, this.e12, this.e20, this.e21, this.e22 ];

	}, de: function ( t ) {

		return this.e00 = t.e00, this.e01 = t.e01, this.e02 = t.e02, this.e10 = t.e10, this.e11 = t.e11, this.e12 = t.e12, this.e20 = t.e20, this.e21 = t.e21, this.e22 = t.e22, this;

	}, clone: function () {

		return new ft( this.e00, this.e01, this.e02, this.e10, this.e11, this.e12, this.e20, this.e21, this.e22 );

	}, Hb: function ( t ) {

		var i = t.x, s = t.y, h = t.z, a = t.w, e = 2 * h; t = i * ( n = 2 * i ); var o = s * ( p = 2 * s ), r = ( h = h * e, i * p ), n = ( s = s * e, i = i * e, a * n ), p = a * p; a *= e; return this.e00 = 1 - o - h, this.e01 = r - a, this.e02 = i + p, this.e10 = r + a, this.e11 = 1 - t - h, this.e12 = s - n, this.e20 = i - p, this.e21 = s + n, this.e22 = 1 - t - o, this;

	}, Pj: function () {

		var t = new pt(), i = this.e00, s = this.e11, h = this.e22, a = i + s + h; return 0 < a ? ( i = Math.sqrt( a + 1 ), t.w = .5 * i, i = .5 / i, t.x = ( this.e21 - this.e12 ) * i, t.y = ( this.e02 - this.e20 ) * i, t.z = ( this.e10 - this.e01 ) * i ) : i > s ? i > h ? ( i = Math.sqrt( i - s - h + 1 ), t.x = .5 * i, i = .5 / i, t.y = ( this.e01 + this.e10 ) * i, t.z = ( this.e02 + this.e20 ) * i, t.w = ( this.e21 - this.e12 ) * i ) : ( i = Math.sqrt( h - i - s + 1 ), t.z = .5 * i, i = .5 / i, t.x = ( this.e02 + this.e20 ) * i, t.y = ( this.e12 + this.e21 ) * i, t.w = ( this.e10 - this.e01 ) * i ) : s > h ? ( i = Math.sqrt( s - h - i + 1 ), t.y = .5 * i, i = .5 / i, t.x = ( this.e01 + this.e10 ) * i, t.z = ( this.e12 + this.e21 ) * i, t.w = ( this.e02 - this.e20 ) * i ) : ( i = Math.sqrt( h - i - s + 1 ), t.z = .5 * i, i = .5 / i, t.x = ( this.e02 + this.e20 ) * i, t.y = ( this.e12 + this.e21 ) * i, t.w = ( this.e10 - this.e01 ) * i ), t;

	}, cb: function ( t ) {

		var i = Math.sin( t.x ), s = Math.sin( t.y ), h = Math.sin( t.z ), a = Math.cos( t.x ), e = Math.cos( t.y ); return t = Math.cos( t.z ), this.e00 = e * t, this.e01 = - e * h, this.e02 = s, this.e10 = a * h + t * i * s, this.e11 = a * t - i * s * h, this.e12 = - e * i, this.e20 = i * h - a * t * s, this.e21 = t * i + a * s * h, this.e22 = a * e, this;

	}, li: function () {

		var t = this.e02; return - 1 >= t ? new dt( .5 * ( t = Math.atan2( this.e21, this.e11 ) ), - 1.570796326794895, .5 * - t ) : 1 <= t ? new dt( .5 * ( t = Math.atan2( this.e21, this.e11 ) ), 1.570796326794895, .5 * t ) : new dt( Math.atan2( - this.e12, this.e22 ), Math.asin( t ), Math.atan2( - this.e01, this.e00 ) );

	}, uc: function ( t ) {

		return 0 == t ? new dt( this.e00, this.e01, this.e02 ) : 1 == t ? new dt( this.e10, this.e11, this.e12 ) : 2 == t ? new dt( this.e20, this.e21, this.e22 ) : null;

	}, pc: function ( t ) {

		return 0 == t ? new dt( this.e00, this.e10, this.e20 ) : 1 == t ? new dt( this.e01, this.e11, this.e21 ) : 2 == t ? new dt( this.e02, this.e12, this.e22 ) : null;

	}, vc: function ( t, i ) {

		0 == t ? i.za( this.e00, this.e01, this.e02 ) : 1 == t ? i.za( this.e10, this.e11, this.e12 ) : 2 == t ? i.za( this.e20, this.e21, this.e22 ) : i.Z();

	}, qc: function ( t, i ) {

		0 == t ? i.za( this.e00, this.e10, this.e20 ) : 1 == t ? i.za( this.e01, this.e11, this.e21 ) : 2 == t ? i.za( this.e02, this.e12, this.e22 ) : i.Z();

	}, Mb: function ( t, i, s ) {

		var h = t.y, a = t.z, e = i.x, o = i.y; i = i.z; var r = s.x, n = s.y; return s = s.z, this.e00 = t.x, this.e01 = h, this.e02 = a, this.e10 = e, this.e11 = o, this.e12 = i, this.e20 = r, this.e21 = n, this.e22 = s, this;

	}, ua: function ( t, i, s ) {

		var h = i.x, a = s.x, e = t.y, o = i.y, r = s.y, n = t.z; return i = i.z, s = s.z, this.e00 = t.x, this.e01 = h, this.e02 = a, this.e10 = e, this.e11 = o, this.e12 = r, this.e20 = n, this.e21 = i, this.e22 = s, this;

	}, toString: function () {

		return 'Mat3[' + ( 0 < this.e00 ? ( 1e7 * this.e00 + .5 | 0 ) / 1e7 : ( 1e7 * this.e00 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e01 ? ( 1e7 * this.e01 + .5 | 0 ) / 1e7 : ( 1e7 * this.e01 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e02 ? ( 1e7 * this.e02 + .5 | 0 ) / 1e7 : ( 1e7 * this.e02 - .5 | 0 ) / 1e7 ) + ',\n     ' + ( 0 < this.e10 ? ( 1e7 * this.e10 + .5 | 0 ) / 1e7 : ( 1e7 * this.e10 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e11 ? ( 1e7 * this.e11 + .5 | 0 ) / 1e7 : ( 1e7 * this.e11 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e12 ? ( 1e7 * this.e12 + .5 | 0 ) / 1e7 : ( 1e7 * this.e12 - .5 | 0 ) / 1e7 ) + ',\n     ' + ( 0 < this.e20 ? ( 1e7 * this.e20 + .5 | 0 ) / 1e7 : ( 1e7 * this.e20 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e21 ? ( 1e7 * this.e21 + .5 | 0 ) / 1e7 : ( 1e7 * this.e21 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e22 ? ( 1e7 * this.e22 + .5 | 0 ) / 1e7 : ( 1e7 * this.e22 - .5 | 0 ) / 1e7 ) + ']';

	} }, yt.prototype = { za: function ( t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b ) {

		return this.e00 = t, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, Wf: function () {

		return this.e00 = 1, this.e10 = this.e03 = this.e02 = this.e01 = 0, this.e11 = 1, this.e21 = this.e20 = this.e13 = this.e12 = 0, this.e22 = 1, this.e32 = this.e31 = this.e30 = this.e23 = 0, this.e33 = 1, this;

	}, pc: function ( t ) {

		return new yt( this.e00 + t.e00, this.e01 + t.e01, this.e02 + t.e02, this.e03 + t.e03, this.e10 + t.e10, this.e11 + t.e11, this.e12 + t.e12, this.e13 + t.e13, this.e20 + t.e20, this.e21 + t.e21, this.e22 + t.e22, this.e23 + t.e23, this.e30 + t.e30, this.e31 + t.e31, this.e32 + t.e32, this.e33 + t.e33 );

	}, Mf: function ( t ) {

		return new yt( this.e00 - t.e00, this.e01 - t.e01, this.e02 - t.e02, this.e03 - t.e03, this.e10 - t.e10, this.e11 - t.e11, this.e12 - t.e12, this.e13 - t.e13, this.e20 - t.e20, this.e21 - t.e21, this.e22 - t.e22, this.e23 - t.e23, this.e30 - t.e30, this.e31 - t.e31, this.e32 - t.e32, this.e33 - t.e33 );

	}, Ue: function ( t ) {

		return new yt( this.e00 * t, this.e01 * t, this.e02 * t, this.e03 * t, this.e10 * t, this.e11 * t, this.e12 * t, this.e13 * t, this.e20 * t, this.e21 * t, this.e22 * t, this.e23 * t, this.e30 * t, this.e31 * t, this.e32 * t, this.e33 * t );

	}, Yd: function ( t ) {

		return new yt( this.e00 * t.e00 + this.e01 * t.e10 + this.e02 * t.e20 + this.e03 * t.e30, this.e00 * t.e01 + this.e01 * t.e11 + this.e02 * t.e21 + this.e03 * t.e31, this.e00 * t.e02 + this.e01 * t.e12 + this.e02 * t.e22 + this.e03 * t.e32, this.e00 * t.e03 + this.e01 * t.e13 + this.e02 * t.e23 + this.e03 * t.e33, this.e10 * t.e00 + this.e11 * t.e10 + this.e12 * t.e20 + this.e13 * t.e30, this.e10 * t.e01 + this.e11 * t.e11 + this.e12 * t.e21 + this.e13 * t.e31, this.e10 * t.e02 + this.e11 * t.e12 + this.e12 * t.e22 + this.e13 * t.e32, this.e10 * t.e03 + this.e11 * t.e13 + this.e12 * t.e23 + this.e13 * t.e33, this.e20 * t.e00 + this.e21 * t.e10 + this.e22 * t.e20 + this.e23 * t.e30, this.e20 * t.e01 + this.e21 * t.e11 + this.e22 * t.e21 + this.e23 * t.e31, this.e20 * t.e02 + this.e21 * t.e12 + this.e22 * t.e22 + this.e23 * t.e32, this.e20 * t.e03 + this.e21 * t.e13 + this.e22 * t.e23 + this.e23 * t.e33, this.e30 * t.e00 + this.e31 * t.e10 + this.e32 * t.e20 + this.e33 * t.e30, this.e30 * t.e01 + this.e31 * t.e11 + this.e32 * t.e21 + this.e33 * t.e31, this.e30 * t.e02 + this.e31 * t.e12 + this.e32 * t.e22 + this.e33 * t.e32, this.e30 * t.e03 + this.e31 * t.e13 + this.e32 * t.e23 + this.e33 * t.e33 );

	}, qc: function ( t ) {

		var i = this.e01 + t.e01, s = this.e02 + t.e02, h = this.e03 + t.e03, a = this.e10 + t.e10, e = this.e11 + t.e11, o = this.e12 + t.e12, r = this.e13 + t.e13, n = this.e20 + t.e20, p = this.e21 + t.e21, l = this.e22 + t.e22, c = this.e23 + t.e23, y = this.e30 + t.e30, f = this.e31 + t.e31, u = this.e32 + t.e32, b = this.e33 + t.e33; return this.e00 += t.e00, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, Tg: function ( t ) {

		var i = this.e01 - t.e01, s = this.e02 - t.e02, h = this.e03 - t.e03, a = this.e10 - t.e10, e = this.e11 - t.e11, o = this.e12 - t.e12, r = this.e13 - t.e13, n = this.e20 - t.e20, p = this.e21 - t.e21, l = this.e22 - t.e22, c = this.e23 - t.e23, y = this.e30 - t.e30, f = this.e31 - t.e31, u = this.e32 - t.e32, b = this.e33 - t.e33; return this.e00 = this.e00 - t.e00, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, Ve: function ( t ) {

		var i = this.e01 * t, s = this.e02 * t, h = this.e03 * t, a = this.e10 * t, e = this.e11 * t, o = this.e12 * t, r = this.e13 * t, n = this.e20 * t, p = this.e21 * t, l = this.e22 * t, c = this.e23 * t, y = this.e30 * t, f = this.e31 * t, u = this.e32 * t, b = this.e33 * t; return this.e00 = this.e00 * t, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, pe: function ( t ) {

		var i = this.e00 * t.e01 + this.e01 * t.e11 + this.e02 * t.e21 + this.e03 * t.e31, s = this.e00 * t.e02 + this.e01 * t.e12 + this.e02 * t.e22 + this.e03 * t.e32, h = this.e00 * t.e03 + this.e01 * t.e13 + this.e02 * t.e23 + this.e03 * t.e33, a = this.e10 * t.e00 + this.e11 * t.e10 + this.e12 * t.e20 + this.e13 * t.e30, e = this.e10 * t.e01 + this.e11 * t.e11 + this.e12 * t.e21 + this.e13 * t.e31, o = this.e10 * t.e02 + this.e11 * t.e12 + this.e12 * t.e22 + this.e13 * t.e32, r = this.e10 * t.e03 + this.e11 * t.e13 + this.e12 * t.e23 + this.e13 * t.e33, n = this.e20 * t.e00 + this.e21 * t.e10 + this.e22 * t.e20 + this.e23 * t.e30, p = this.e20 * t.e01 + this.e21 * t.e11 + this.e22 * t.e21 + this.e23 * t.e31, l = this.e20 * t.e02 + this.e21 * t.e12 + this.e22 * t.e22 + this.e23 * t.e32, c = this.e20 * t.e03 + this.e21 * t.e13 + this.e22 * t.e23 + this.e23 * t.e33, y = this.e30 * t.e00 + this.e31 * t.e10 + this.e32 * t.e20 + this.e33 * t.e30, f = this.e30 * t.e01 + this.e31 * t.e11 + this.e32 * t.e21 + this.e33 * t.e31, u = this.e30 * t.e02 + this.e31 * t.e12 + this.e32 * t.e22 + this.e33 * t.e32, b = this.e30 * t.e03 + this.e31 * t.e13 + this.e32 * t.e23 + this.e33 * t.e33; return this.e00 = this.e00 * t.e00 + this.e01 * t.e10 + this.e02 * t.e20 + this.e03 * t.e30, this.e01 = i, this.e02 = s, this.e03 = h, this.e10 = a, this.e11 = e, this.e12 = o, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = l, this.e23 = c, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, te: function ( t, i, s ) {

		return new yt( this.e00 * t, this.e01 * t, this.e02 * t, this.e03 * t, this.e10 * i, this.e11 * i, this.e12 * i, this.e13 * i, this.e20 * s, this.e21 * s, this.e22 * s, this.e23 * s, this.e30, this.e31, this.e32, this.e33 );

	}, Ac: function ( t, i, s ) {

		return new yt( this.e00 * t, this.e01 * i, this.e02 * s, this.e03, this.e10 * t, this.e11 * i, this.e12 * s, this.e13, this.e20 * t, this.e21 * i, this.e22 * s, this.e23, this.e30 * t, this.e31 * i, this.e32 * s, this.e33 );

	}, re: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = Math.cos( t ), o = 1 - e; t = i * i * o + e; var r = i * s * o - h * a, n = i * h * o + s * a, p = s * i * o + h * a, l = s * s * o + e, c = s * h * o - i * a, y = h * i * o - s * a; return i = h * s * o + i * a, h = h * h * o + e, new yt( t * this.e00 + r * this.e10 + n * this.e20, t * this.e01 + r * this.e11 + n * this.e21, t * this.e02 + r * this.e12 + n * this.e22, t * this.e03 + r * this.e13 + n * this.e23, p * this.e00 + l * this.e10 + c * this.e20, p * this.e01 + l * this.e11 + c * this.e21, p * this.e02 + l * this.e12 + c * this.e22, p * this.e03 + l * this.e13 + c * this.e23, y * this.e00 + i * this.e10 + h * this.e20, y * this.e01 + i * this.e11 + h * this.e21, y * this.e02 + i * this.e12 + h * this.e22, y * this.e03 + i * this.e13 + h * this.e23, this.e30, this.e31, this.e32, this.e33 );

	}, uc: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = Math.cos( t ), o = 1 - e; t = i * i * o + e; var r = i * s * o - h * a, n = i * h * o + s * a, p = s * i * o + h * a, l = s * s * o + e, c = s * h * o - i * a, y = h * i * o - s * a; return i = h * s * o + i * a, h = h * h * o + e, new yt( this.e00 * t + this.e01 * p + this.e02 * y, this.e00 * r + this.e01 * l + this.e02 * i, this.e00 * n + this.e01 * c + this.e02 * h, this.e03, this.e10 * t + this.e11 * p + this.e12 * y, this.e10 * r + this.e11 * l + this.e12 * i, this.e10 * n + this.e11 * c + this.e12 * h, this.e13, this.e20 * t + this.e21 * p + this.e22 * y, this.e20 * r + this.e21 * l + this.e22 * i, this.e20 * n + this.e21 * c + this.e22 * h, this.e23, this.e30 * t + this.e31 * p + this.e32 * y, this.e30 * r + this.e31 * l + this.e32 * i, this.e30 * n + this.e31 * c + this.e32 * h, this.e33 );

	}, ki: function ( t, i, s ) {

		return new yt( this.e00 + t * this.e30, this.e01 + t * this.e31, this.e02 + t * this.e32, this.e03 + t * this.e33, this.e10 + i * this.e30, this.e11 + i * this.e31, this.e12 + i * this.e32, this.e13 + i * this.e33, this.e20 + s * this.e30, this.e21 + s * this.e31, this.e22 + s * this.e32, this.e23 + s * this.e33, this.e30, this.e31, this.e32, this.e33 );

	}, ua: function ( t, i, s ) {

		return new yt( this.e00, this.e01, this.e02, this.e00 * t + this.e01 * i + this.e02 * s + this.e03, this.e10, this.e11, this.e12, this.e10 * t + this.e11 * i + this.e12 * s + this.e13, this.e20, this.e21, this.e22, this.e20 * t + this.e21 * i + this.e22 * s + this.e23, this.e30, this.e31, this.e32, this.e30 * t + this.e31 * i + this.e32 * s + this.e33 );

	}, ue: function ( t, i, s ) {

		var h = this.e01 * t, a = this.e02 * t, e = this.e03 * t, o = this.e10 * i, r = this.e11 * i, n = this.e12 * i; i = this.e13 * i; var p = this.e20 * s, l = this.e21 * s, c = this.e22 * s; s = this.e23 * s; var y = this.e30, f = this.e31, u = this.e32, b = this.e33; return this.e00 = this.e00 * t, this.e01 = h, this.e02 = a, this.e03 = e, this.e10 = o, this.e11 = r, this.e12 = n, this.e13 = i, this.e20 = p, this.e21 = l, this.e22 = c, this.e23 = s, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, Ec: function ( t, i, s ) {

		var h = this.e01 * i, a = this.e02 * s, e = this.e03, o = this.e10 * t, r = this.e11 * i, n = this.e12 * s, p = this.e13, l = this.e20 * t, c = this.e21 * i, y = this.e22 * s, f = this.e23, u = this.e30 * t; i = this.e31 * i, s = this.e32 * s; var b = this.e33; return this.e00 = this.e00 * t, this.e01 = h, this.e02 = a, this.e03 = e, this.e10 = o, this.e11 = r, this.e12 = n, this.e13 = p, this.e20 = l, this.e21 = c, this.e22 = y, this.e23 = f, this.e30 = u, this.e31 = i, this.e32 = s, this.e33 = b, this;

	}, se: function ( t, i, s, h ) {

		var a = Math.sin( t ), e = i * s * ( u = 1 - ( f = Math.cos( t ) ) ) - h * a, o = i * h * u + s * a, r = s * i * u + h * a, n = s * s * u + f, p = s * h * u - i * a, l = h * i * u - s * a, c = h * s * u + i * a, y = h * h * u + f; h = ( t = i * i * u + f ) * this.e01 + e * this.e11 + o * this.e21, i = t * this.e02 + e * this.e12 + o * this.e22, s = t * this.e03 + e * this.e13 + o * this.e23; a = r * this.e00 + n * this.e10 + p * this.e20; var f = r * this.e01 + n * this.e11 + p * this.e21, u = r * this.e02 + n * this.e12 + p * this.e22, b = ( r = r * this.e03 + n * this.e13 + p * this.e23, n = l * this.e00 + c * this.e10 + y * this.e20, p = l * this.e01 + c * this.e11 + y * this.e21, l * this.e02 + c * this.e12 + y * this.e22 ), v = ( l = l * this.e03 + c * this.e13 + y * this.e23, c = this.e30, y = this.e31, this.e32 ), g = this.e33; return this.e00 = t * this.e00 + e * this.e10 + o * this.e20, this.e01 = h, this.e02 = i, this.e03 = s, this.e10 = a, this.e11 = f, this.e12 = u, this.e13 = r, this.e20 = n, this.e21 = p, this.e22 = b, this.e23 = l, this.e30 = c, this.e31 = y, this.e32 = v, this.e33 = g, this;

	}, vc: function ( t, i, s, h ) {

		var a = Math.sin( t ); t = i * i * ( f = 1 - ( y = Math.cos( t ) ) ) + y; var e = i * s * f - h * a, o = i * h * f + s * a, r = s * i * f + h * a, n = s * s * f + y, p = s * h * f - i * a, l = h * i * f - s * a; i = h * s * f + i * a; var c = h * h * f + y; h = this.e00 * e + this.e01 * n + this.e02 * i, s = this.e00 * o + this.e01 * p + this.e02 * c; a = this.e03; var y = this.e10 * t + this.e11 * r + this.e12 * l, f = this.e10 * e + this.e11 * n + this.e12 * i, u = this.e10 * o + this.e11 * p + this.e12 * c, b = this.e13, v = this.e20 * t + this.e21 * r + this.e22 * l, g = this.e20 * e + this.e21 * n + this.e22 * i, x = this.e20 * o + this.e21 * p + this.e22 * c, d = this.e23, z = this.e30 * t + this.e31 * r + this.e32 * l; e = this.e30 * e + this.e31 * n + this.e32 * i, o = this.e30 * o + this.e31 * p + this.e32 * c, p = this.e33; return this.e00 = this.e00 * t + this.e01 * r + this.e02 * l, this.e01 = h, this.e02 = s, this.e03 = a, this.e10 = y, this.e11 = f, this.e12 = u, this.e13 = b, this.e20 = v, this.e21 = g, this.e22 = x, this.e23 = d, this.e30 = z, this.e31 = e, this.e32 = o, this.e33 = p, this;

	}, li: function ( t, i, s ) {

		var h = this.e01 + t * this.e31, a = this.e02 + t * this.e32, e = this.e03 + t * this.e33, o = this.e10 + i * this.e30, r = this.e11 + i * this.e31, n = this.e12 + i * this.e32; i = this.e13 + i * this.e33; var p = this.e20 + s * this.e30, l = this.e21 + s * this.e31, c = this.e22 + s * this.e32; s = this.e23 + s * this.e33; var y = this.e30, f = this.e31, u = this.e32, b = this.e33; return this.e00 += t * this.e30, this.e01 = h, this.e02 = a, this.e03 = e, this.e10 = o, this.e11 = r, this.e12 = n, this.e13 = i, this.e20 = p, this.e21 = l, this.e22 = c, this.e23 = s, this.e30 = y, this.e31 = f, this.e32 = u, this.e33 = b, this;

	}, cb: function ( t, i, s ) {

		var h = this.e01, a = this.e02, e = this.e00 * t + this.e01 * i + this.e02 * s + this.e03, o = this.e10, r = this.e11, n = this.e12, p = this.e10 * t + this.e11 * i + this.e12 * s + this.e13, l = this.e20, c = this.e21, y = this.e22, f = this.e20 * t + this.e21 * i + this.e22 * s + this.e23, u = this.e30, b = this.e31, v = this.e32; return t = this.e30 * t + this.e31 * i + this.e32 * s + this.e33, this.e00 = this.e00, this.e01 = h, this.e02 = a, this.e03 = e, this.e10 = o, this.e11 = r, this.e12 = n, this.e13 = p, this.e20 = l, this.e21 = c, this.e22 = y, this.e23 = f, this.e30 = u, this.e31 = b, this.e32 = v, this.e33 = t, this;

	}, Wg: function () {

		return new yt( this.e00, this.e10, this.e20, this.e30, this.e01, this.e11, this.e21, this.e31, this.e02, this.e12, this.e22, this.e32, this.e03, this.e13, this.e23, this.e33 );

	}, Xg: function () {

		var t = this.e10, i = this.e20, s = this.e30, h = this.e01, a = this.e11, e = this.e21, o = this.e31, r = this.e02, n = this.e12, p = this.e22, l = this.e32, c = this.e03, y = this.e13, f = this.e23, u = this.e33; return this.e00 = this.e00, this.e01 = t, this.e02 = i, this.e03 = s, this.e10 = h, this.e11 = a, this.e12 = e, this.e13 = o, this.e20 = r, this.e21 = n, this.e22 = p, this.e23 = l, this.e30 = c, this.e31 = y, this.e32 = f, this.e33 = u, this;

	}, Jc: function () {

		var t = this.e20 * this.e31 - this.e21 * this.e30, i = this.e20 * this.e32 - this.e22 * this.e30, s = this.e20 * this.e33 - this.e23 * this.e30, h = this.e21 * this.e32 - this.e22 * this.e31, a = this.e21 * this.e33 - this.e23 * this.e31, e = this.e22 * this.e33 - this.e23 * this.e32; return this.e00 * ( this.e11 * e - this.e12 * a + this.e13 * h ) - this.e01 * ( this.e10 * e - this.e12 * s + this.e13 * i ) + this.e02 * ( this.e10 * a - this.e11 * s + this.e13 * t ) - this.e03 * ( this.e10 * h - this.e11 * i + this.e12 * t );

	}, Vg: function () {

		return this.e00 + this.e11 + this.e22 + this.e33;

	}, Lc: function () {

		var t = this.e00 * this.e11 - this.e01 * this.e10, i = this.e00 * this.e12 - this.e02 * this.e10, s = this.e00 * this.e13 - this.e03 * this.e10, h = this.e01 * this.e12 - this.e02 * this.e11, a = this.e01 * this.e13 - this.e03 * this.e11, e = this.e02 * this.e13 - this.e03 * this.e12, o = this.e20 * this.e31 - this.e21 * this.e30, r = this.e20 * this.e32 - this.e22 * this.e30, n = this.e20 * this.e33 - this.e23 * this.e30, p = this.e21 * this.e32 - this.e22 * this.e31, l = this.e21 * this.e33 - this.e23 * this.e31, c = this.e22 * this.e33 - this.e23 * this.e32, y = this.e11 * c - this.e12 * l + this.e13 * p, f = this.e10 * c - this.e12 * n + this.e13 * r, u = this.e10 * l - this.e11 * n + this.e13 * o, b = this.e10 * p - this.e11 * r + this.e12 * o, v = this.e01 * c - this.e02 * l + this.e03 * p, g = ( c = this.e00 * c - this.e02 * n + this.e03 * r, n = this.e00 * l - this.e01 * n + this.e03 * o, o = this.e00 * p - this.e01 * r + this.e02 * o, r = this.e31 * e - this.e32 * a + this.e33 * h, p = this.e30 * e - this.e32 * s + this.e33 * i, l = this.e30 * a - this.e31 * s + this.e33 * t, this.e30 * h - this.e31 * i + this.e32 * t ), x = this.e21 * e - this.e22 * a + this.e23 * h; e = this.e20 * e - this.e22 * s + this.e23 * i, s = this.e20 * a - this.e21 * s + this.e23 * t, t = this.e20 * h - this.e21 * i + this.e22 * t; return ( i = this.e00 * y - this.e01 * f + this.e02 * u - this.e03 * b ) && ( i = 1 / i ), new yt( y * i, - v * i, r * i, - x * i, - f * i, c * i, - p * i, e * i, u * i, - n * i, l * i, - s * i, - b * i, o * i, - g * i, t * i );

	}, fd: function () {

		var t = this.e00 * this.e11 - this.e01 * this.e10, i = this.e00 * this.e12 - this.e02 * this.e10, s = this.e00 * this.e13 - this.e03 * this.e10, h = this.e01 * this.e12 - this.e02 * this.e11, a = this.e01 * this.e13 - this.e03 * this.e11, e = this.e02 * this.e13 - this.e03 * this.e12, o = this.e20 * this.e31 - this.e21 * this.e30, r = this.e20 * this.e32 - this.e22 * this.e30, n = this.e20 * this.e33 - this.e23 * this.e30, p = this.e21 * this.e32 - this.e22 * this.e31, l = this.e21 * this.e33 - this.e23 * this.e31, c = this.e22 * this.e33 - this.e23 * this.e32, y = this.e11 * c - this.e12 * l + this.e13 * p, f = this.e10 * c - this.e12 * n + this.e13 * r, u = this.e10 * l - this.e11 * n + this.e13 * o, b = this.e10 * p - this.e11 * r + this.e12 * o, v = this.e01 * c - this.e02 * l + this.e03 * p, g = ( c = this.e00 * c - this.e02 * n + this.e03 * r, n = this.e00 * l - this.e01 * n + this.e03 * o, o = this.e00 * p - this.e01 * r + this.e02 * o, r = this.e31 * e - this.e32 * a + this.e33 * h, p = this.e30 * e - this.e32 * s + this.e33 * i, l = this.e30 * a - this.e31 * s + this.e33 * t, this.e30 * h - this.e31 * i + this.e32 * t ), x = this.e21 * e - this.e22 * a + this.e23 * h; e = this.e20 * e - this.e22 * s + this.e23 * i, s = this.e20 * a - this.e21 * s + this.e23 * t, t = this.e20 * h - this.e21 * i + this.e22 * t; return ( i = this.e00 * y - this.e01 * f + this.e02 * u - this.e03 * b ) && ( i = 1 / i ), this.e00 = y * i, this.e01 = - v * i, this.e02 = r * i, this.e03 = - x * i, this.e10 = - f * i, this.e11 = c * i, this.e12 = - p * i, this.e13 = e * i, this.e20 = u * i, this.e21 = - n * i, this.e22 = l * i, this.e23 = - s * i, this.e30 = - b * i, this.e31 = o * i, this.e32 = - g * i, this.e33 = t * i, this;

	}, Mb: function ( t, i, s, h, a, e, o, r, n ) {

		h = t - h, a = i - a, e = s - e, h *= l = 1 / Math.sqrt( h * h + a * a + e * e ); var p = r * ( e *= l ) - n * ( a *= l ); n = n * h - o * e, o = o * a - r * h, r = a * ( o *= l = 1 / Math.sqrt( p * p + n * n + o * o ) ) - e * ( n *= l ); var l = e * ( p *= l ) - h * o, c = h * n - a * p; return this.e00 = p, this.e01 = n, this.e02 = o, this.e03 = - ( p * t + n * i + o * s ), this.e10 = r, this.e11 = l, this.e12 = c, this.e13 = - ( r * t + l * i + c * s ), this.e20 = h, this.e21 = a, this.e22 = e, this.e23 = - ( h * t + a * i + e * s ), this.e32 = this.e31 = this.e30 = 0, this.e33 = 1, this;

	}, qe: function ( t, i, s, h ) {

		return t = 1 / Math.tan( .5 * t ), h /= s - h, this.e00 = t / i, this.e10 = this.e03 = this.e02 = this.e01 = 0, this.e11 = t, this.e21 = this.e20 = this.e13 = this.e12 = 0, this.e22 = h, this.e23 = s * h, this.e31 = this.e30 = 0, this.e32 = - 1, this.e33 = 0, this;

	}, ji: function ( t, i, s, h ) {

		return h = 1 / ( s - h ), this.e00 = 2 / t, this.e10 = this.e03 = this.e02 = this.e01 = 0, this.e11 = 2 / i, this.e21 = this.e20 = this.e13 = this.e12 = 0, this.e22 = h, this.e23 = s * h, this.e32 = this.e31 = this.e30 = 0, this.e33 = 1, this;

	}, Ug: function ( t ) {

		return null == t && ( t = ! 1 ), t ? [ this.e00, this.e10, this.e20, this.e30, this.e01, this.e11, this.e21, this.e31, this.e02, this.e12, this.e22, this.e32, this.e03, this.e13, this.e23, this.e33 ] : [ this.e00, this.e01, this.e02, this.e03, this.e10, this.e11, this.e12, this.e13, this.e20, this.e21, this.e22, this.e23, this.e30, this.e31, this.e32, this.e33 ];

	}, de: function ( t ) {

		return this.e00 = t.e00, this.e01 = t.e01, this.e02 = t.e02, this.e03 = t.e03, this.e10 = t.e10, this.e11 = t.e11, this.e12 = t.e12, this.e13 = t.e13, this.e20 = t.e20, this.e21 = t.e21, this.e22 = t.e22, this.e23 = t.e23, this.e30 = t.e30, this.e31 = t.e31, this.e32 = t.e32, this.e33 = t.e33, this;

	}, Kc: function ( t ) {

		var i = t.e01, s = t.e02, h = t.e10, a = t.e11, e = t.e12, o = t.e20, r = t.e21, n = t.e22; return this.e00 = t.e00, this.e01 = i, this.e02 = s, this.e03 = 0, this.e10 = h, this.e11 = a, this.e12 = e, this.e13 = 0, this.e20 = o, this.e21 = r, this.e22 = n, this.e32 = this.e31 = this.e30 = this.e23 = 0, this.e33 = 1, this;

	}, Hb: function ( t ) {

		return this.e00 = t.o, this.e01 = t.f, this.e02 = t.h, this.e10 = t.i, this.e11 = t.m, this.e12 = t.j, this.e20 = t.l, this.e21 = t.g, this.e22 = t.s, this.e03 = t.v, this.e13 = t.A, this.e23 = t.B, this.e32 = this.e31 = this.e30 = 0, this.e33 = 1, this;

	}, clone: function () {

		return new yt( this.e00, this.e01, this.e02, this.e03, this.e10, this.e11, this.e12, this.e13, this.e20, this.e21, this.e22, this.e23, this.e30, this.e31, this.e32, this.e33 );

	}, toString: function () {

		return 'Mat4[' + ( 0 < this.e00 ? ( 1e7 * this.e00 + .5 | 0 ) / 1e7 : ( 1e7 * this.e00 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e01 ? ( 1e7 * this.e01 + .5 | 0 ) / 1e7 : ( 1e7 * this.e01 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e02 ? ( 1e7 * this.e02 + .5 | 0 ) / 1e7 : ( 1e7 * this.e02 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e03 ? ( 1e7 * this.e03 + .5 | 0 ) / 1e7 : ( 1e7 * this.e03 - .5 | 0 ) / 1e7 ) + ',\n    ' + ( 0 < this.e10 ? ( 1e7 * this.e10 + .5 | 0 ) / 1e7 : ( 1e7 * this.e10 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e11 ? ( 1e7 * this.e11 + .5 | 0 ) / 1e7 : ( 1e7 * this.e11 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e12 ? ( 1e7 * this.e12 + .5 | 0 ) / 1e7 : ( 1e7 * this.e12 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e13 ? ( 1e7 * this.e13 + .5 | 0 ) / 1e7 : ( 1e7 * this.e13 - .5 | 0 ) / 1e7 ) + ',\n    ' + ( 0 < this.e20 ? ( 1e7 * this.e20 + .5 | 0 ) / 1e7 : ( 1e7 * this.e20 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e21 ? ( 1e7 * this.e21 + .5 | 0 ) / 1e7 : ( 1e7 * this.e21 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e22 ? ( 1e7 * this.e22 + .5 | 0 ) / 1e7 : ( 1e7 * this.e22 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e23 ? ( 1e7 * this.e23 + .5 | 0 ) / 1e7 : ( 1e7 * this.e23 - .5 | 0 ) / 1e7 ) + ',\n    ' + ( 0 < this.e30 ? ( 1e7 * this.e30 + .5 | 0 ) / 1e7 : ( 1e7 * this.e30 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e31 ? ( 1e7 * this.e31 + .5 | 0 ) / 1e7 : ( 1e7 * this.e31 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e32 ? ( 1e7 * this.e32 + .5 | 0 ) / 1e7 : ( 1e7 * this.e32 - .5 | 0 ) / 1e7 ) + ', ' + ( 0 < this.e33 ? ( 1e7 * this.e33 + .5 | 0 ) / 1e7 : ( 1e7 * this.e33 - .5 | 0 ) / 1e7 ) + ']';

	} }, ct.abs = function ( t ) {

		return 0 < t ? t : - t;

	}, ct.sin = function ( t ) {

		return Math.sin( t );

	}, ct.cos = function ( t ) {

		return Math.cos( t );

	}, ct.tan = function ( t ) {

		return Math.tan( t );

	}, ct.asin = function ( t ) {

		return Math.asin( t );

	}, ct.acos = function ( t ) {

		return Math.acos( t );

	}, ct.atan = function ( t ) {

		return Math.atan( t );

	}, ct.fd = function ( t ) {

		return - 1 >= t ? - 1.570796326794895 : 1 <= t ? 1.570796326794895 : Math.asin( t );

	}, ct.Lc = function ( t ) {

		return - 1 >= t ? 3.14159265358979 : 1 <= t ? 0 : Math.acos( t );

	}, ct.atan2 = function ( t, i ) {

		return Math.atan2( t, i );

	}, ct.sqrt = function ( t ) {

		return Math.sqrt( t );

	}, ct.Hb = function ( t, i, s ) {

		return t < i ? i : t > s ? s : t;

	}, ct.Ac = function () {

		return Math.random();

	}, ct.Ec = function ( t, i ) {

		return t + Math.random() * ( i - t );

	}, ct.Kc = function ( t, i ) {

		return new dt( t + Math.random() * ( i - t ), t + Math.random() * ( i - t ), t + Math.random() * ( i - t ) );

	}, ct.Jc = function () {

		return new dt( 2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1 );

	}, lt.prototype = { Ac: function () {

		return 0 == this.c ? new dt() : this.b[ -- this.c ];

	}, qc: function () {

		return 0 == this.eb ? new ft() : this.bb[ -- this.eb ];

	}, uc: function () {

		return 0 == this.dg ? new yt() : this.Lf[ -- this.dg ];

	}, vc: function () {

		return 0 == this.ee ? new pt() : this.Wd[ -- this.ee ];

	}, ua: function ( t, i, s, h ) {

		if ( null != t ) {

			if ( t.Z(), this.c == this.b.length ) {

				for ( var a = Array( this.c << 1 ), e = 0, o = this.c; e < o; ) {

					var r = e ++; a[ r ] = this.b[ r ], this.b[ r ] = null;

				}

				this.b = a;

			}

			this.b[ this.c ++ ] = t;

		}

		if ( null != i ) {

			if ( i.e00 = 1, i.e01 = 0, i.e02 = 0, i.e10 = 0, i.e11 = 1, i.e12 = 0, i.e20 = 0, i.e21 = 0, i.e22 = 1, this.eb == this.bb.length ) {

				for ( t = Array( this.eb << 1 ), a = 0, e = this.eb; a < e; )t[ o = a ++ ] = this.bb[ o ], this.bb[ o ] = null; this.bb = t;

			}

			this.bb[ this.eb ++ ] = i;

		}

		if ( null != s ) {

			if ( s.e00 = 1, s.e01 = 0, s.e02 = 0, s.e03 = 0, s.e10 = 0, s.e11 = 1, s.e12 = 0, s.e13 = 0, s.e20 = 0, s.e21 = 0, s.e22 = 1, s.e23 = 0, s.e30 = 0, s.e31 = 0, s.e32 = 0, s.e33 = 1, this.dg == this.Lf.length ) {

				for ( i = Array( this.dg << 1 ), t = 0, a = this.dg; t < a; )i[ e = t ++ ] = this.Lf[ e ], this.Lf[ e ] = null; this.Lf = i;

			}

			this.Lf[ this.dg ++ ] = s;

		}

		if ( null != h ) {

			if ( h.x = 0, h.y = 0, h.z = 0, h.w = 1, this.ee == this.Wd.length ) {

				for ( s = Array( this.ee << 1 ), i = 0, t = this.ee; i < t; )s[ a = i ++ ] = this.Wd[ a ], this.Wd[ a ] = null; this.Wd = s;

			}

			this.Wd[ this.ee ++ ] = h;

		}

	}, pc: function ( t ) {

		if ( t.Z(), this.c == this.b.length ) {

			for ( var i = Array( this.c << 1 ), s = 0, h = this.c; s < h; ) {

				var a = s ++; i[ a ] = this.b[ a ], this.b[ a ] = null;

			}

			this.b = i;

		}

		this.b[ this.c ++ ] = t;

	}, cb: function ( t ) {

		if ( t.e00 = 1, t.e01 = 0, t.e02 = 0, t.e10 = 0, t.e11 = 1, t.e12 = 0, t.e20 = 0, t.e21 = 0, t.e22 = 1, this.eb == this.bb.length ) {

			for ( var i = Array( this.eb << 1 ), s = 0, h = this.eb; s < h; ) {

				var a = s ++; i[ a ] = this.bb[ a ], this.bb[ a ] = null;

			}

			this.bb = i;

		}

		this.bb[ this.eb ++ ] = t;

	}, Hb: function ( t ) {

		if ( t.e00 = 1, t.e01 = 0, t.e02 = 0, t.e03 = 0, t.e10 = 0, t.e11 = 1, t.e12 = 0, t.e13 = 0, t.e20 = 0, t.e21 = 0, t.e22 = 1, t.e23 = 0, t.e30 = 0, t.e31 = 0, t.e32 = 0, t.e33 = 1, this.dg == this.Lf.length ) {

			for ( var i = Array( this.dg << 1 ), s = 0, h = this.dg; s < h; ) {

				var a = s ++; i[ a ] = this.Lf[ a ], this.Lf[ a ] = null;

			}

			this.Lf = i;

		}

		this.Lf[ this.dg ++ ] = t;

	}, Mb: function ( t ) {

		if ( t.x = 0, t.y = 0, t.z = 0, t.w = 1, this.ee == this.Wd.length ) {

			for ( var i = Array( this.ee << 1 ), s = 0, h = this.ee; s < h; ) {

				var a = s ++; i[ a ] = this.Wd[ a ], this.Wd[ a ] = null;

			}

			this.Wd = i;

		}

		this.Wd[ this.ee ++ ] = t;

	} }, pt.prototype = { Wf: function () {

		return this.z = this.y = this.x = 0, this.w = 1, this;

	}, za: function ( t, i, s, h ) {

		return this.x = t, this.y = i, this.z = s, this.w = h, this;

	}, ua: function ( t ) {

		return new pt( this.x + t.x, this.y + t.y, this.z + t.z, this.w + t.w );

	}, Ec: function ( t ) {

		return new pt( this.x - t.x, this.y - t.y, this.z - t.z, this.w - t.w );

	}, vc: function ( t ) {

		return new pt( this.x * t, this.y * t, this.z * t, this.w * t );

	}, cb: function ( t ) {

		var i = this.y + t.y, s = this.z + t.z, h = this.w + t.w; return this.x += t.x, this.y = i, this.z = s, this.w = h, this;

	}, Jc: function ( t ) {

		var i = this.y - t.y, s = this.z - t.z, h = this.w - t.w; return this.x = this.x - t.x, this.y = i, this.z = s, this.w = h, this;

	}, Ac: function ( t ) {

		var i = this.y * t, s = this.z * t, h = this.w * t; return this.x = this.x * t, this.y = i, this.z = s, this.w = h, this;

	}, length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}, pc: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}, Hb: function ( t ) {

		return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;

	}, uc: function () {

		var t = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); return 0 < t && ( t = 1 / t ), new pt( this.x * t, this.y * t, this.z * t, this.w * t );

	}, qc: function () {

		var t = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); 0 < t && ( t = 1 / t ); var i = this.y * t, s = this.z * t, h = this.w * t; return this.x = this.x * t, this.y = i, this.z = s, this.w = h, this;

	}, Kc: function ( t, i ) {

		var s = t.x, h = t.y; t = t.z; var a, e = i.x, o = i.y; return i = i.z, this.w = Math.sqrt( .5 * ( s * e + h * o + t * i + 1 ) ), this.w ? ( a = .5 / this.w, this.x = ( h * i - t * o ) * a, this.y = ( t * e - s * i ) * a, this.z = ( s * o - h * e ) * a, this ) : ( i = t * t, ( e = s * s ) < ( o = h * h ) ? e < i ? ( a = 1 / Math.sqrt( o + i ), this.x = 0, this.y = t * a, this.z = - h * a ) : ( a = 1 / Math.sqrt( e + o ), this.z = 0, this.x = h * a, this.y = - s * a ) : o < i ? ( a = 1 / Math.sqrt( i + e ), this.y = 0, this.z = s * a, this.x = - t * a ) : ( a = 1 / Math.sqrt( e + o ), this.z = 0, this.x = h * a, this.y = - s * a ), this );

	}, Lc: function ( t, i ) {

		var s, h, a; if ( 0 > ( e = this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w ) ? ( e = - e, s = - t.x, h = - t.y, a = - t.z, t = - t.w ) : ( s = t.x, h = t.y, a = t.z, t = t.w ), .999999 < e ) return s = new pt( this.x + ( s - this.x ) * i, this.y + ( h - this.y ) * i, this.z + ( a - this.z ) * i, this.w + ( t - this.w ) * i ), 0 < ( h = Math.sqrt( s.x * s.x + s.y * s.y + s.z * s.z + s.w * s.w ) ) && ( h = 1 / h ), a = s.y * h, t = s.z * h, e = s.w * h, s.x = s.x * h, s.y = a, s.z = t, s.w = e, s; i *= Math.acos( e ), s -= this.x * e, h -= this.y * e, a -= this.z * e, t -= this.w * e; var e = 1 / Math.sqrt( s * s + h * h + a * a + t * t ), o = Math.sin( i ); return i = Math.cos( i ), new pt( this.x * i + s * e * o, this.y * i + h * e * o, this.z * i + a * e * o, this.w * i + t * e * o );

	}, de: function ( t ) {

		return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;

	}, clone: function () {

		return new pt( this.x, this.y, this.z, this.w );

	}, Mb: function ( t ) {

		var i = t.e00, s = t.e11, h = t.e22, a = i + s + h; return 0 < a ? ( i = Math.sqrt( a + 1 ), this.w = .5 * i, i = .5 / i, this.x = ( t.e21 - t.e12 ) * i, this.y = ( t.e02 - t.e20 ) * i, this.z = ( t.e10 - t.e01 ) * i ) : i > s ? i > h ? ( i = Math.sqrt( i - s - h + 1 ), this.x = .5 * i, i = .5 / i, this.y = ( t.e01 + t.e10 ) * i, this.z = ( t.e02 + t.e20 ) * i, this.w = ( t.e21 - t.e12 ) * i ) : ( i = Math.sqrt( h - i - s + 1 ), this.z = .5 * i, i = .5 / i, this.x = ( t.e02 + t.e20 ) * i, this.y = ( t.e12 + t.e21 ) * i, this.w = ( t.e10 - t.e01 ) * i ) : s > h ? ( i = Math.sqrt( s - h - i + 1 ), this.y = .5 * i, i = .5 / i, this.x = ( t.e01 + t.e10 ) * i, this.z = ( t.e12 + t.e21 ) * i, this.w = ( t.e02 - t.e20 ) * i ) : ( i = Math.sqrt( h - i - s + 1 ), this.z = .5 * i, i = .5 / i, this.x = ( t.e02 + t.e20 ) * i, this.y = ( t.e12 + t.e21 ) * i, this.w = ( t.e10 - t.e01 ) * i ), this;

	}, fd: function () {

		var t = new ft(), i = this.x, s = this.y, h = 2 * ( o = this.z ), a = i * ( n = 2 * i ), e = s * ( p = 2 * s ), o = o * h, r = i * p, n = ( s = s * h, i = i * h, ( l = this.w ) * n ), p = l * p, l = l * h; return t.e00 = 1 - e - o, t.e01 = r - l, t.e02 = i + p, t.e10 = r + l, t.e11 = 1 - a - o, t.e12 = s - n, t.e20 = i - p, t.e21 = s + n, t.e22 = 1 - a - e, t;

	}, toString: function () {

		return 'Quat[' + ( 0 < this.x ? ( 1e7 * this.x + .5 | 0 ) / 1e7 : ( 1e7 * this.x - .5 | 0 ) / 1e7 ) + ' i,\n    ' + ( 0 < this.y ? ( 1e7 * this.y + .5 | 0 ) / 1e7 : ( 1e7 * this.y - .5 | 0 ) / 1e7 ) + ' j,\n    ' + ( 0 < this.z ? ( 1e7 * this.z + .5 | 0 ) / 1e7 : ( 1e7 * this.z - .5 | 0 ) / 1e7 ) + ' k,\n    ' + ( 0 < this.w ? ( 1e7 * this.w + .5 | 0 ) / 1e7 : ( 1e7 * this.w - .5 | 0 ) / 1e7 ) + ']';

	} }, nt.prototype = { hn: function () {

		if ( null != this.Lh ) {

			var t = this.Td, i = this.Ym; if ( this.Lh.hm( i, this.Zb.Kb, this.$b.Kb, this.Zb.a, this.$b.a, this.$i ), ( this.Td = 0 < i.numPoints ) ? ( this.Ja.Wm( i.normal ), this.Ye.Hc = i.mm() > gt.contactUseAlternativePositionCorrectionAlgorithmDepthThreshold ? gt.alternativeContactPositionCorrectionAlgorithm : gt.defaultContactPositionCorrectionAlgorithm, i.incremental ? this.Zl.On( i, this.C.a, this.D.a ) : this.Zl.eo( i, this.C.a, this.D.a ) ) : this.Ja.Xe(), this.Td && ! t ) {

				i = this.Zb.yd; var s = this.$b.yd; i == s && ( s = null ), null != i && i.beginContact( this ), null != s && s.beginContact( this );

			}

			! this.Td && t && ( ( t = this.Zb.yd ) == ( i = this.$b.yd ) && ( i = null ), null != t && t.endContact( this ), null != i && i.endContact( this ) ), this.Td && ( ( t = this.Zb.yd ) == ( i = this.$b.yd ) && ( i = null ), null != t && t.preSolve( this ), null != i && i.preSolve( this ) );

		}

	}, Vk: function () {

		var t = this.Zb.yd, i = this.$b.yd; t == i && ( i = null ), null != t && t.postSolve( this ), null != i && i.postSolve( this );

	}, pc: function () {

		return this.Zb;

	}, qc: function () {

		return this.$b;

	}, sk: function () {

		return this.Td;

	}, cb: function () {

		return this.Ja;

	}, ua: function () {

		return this.Ye;

	}, Mb: function () {

		return this.ia;

	}, Hb: function () {

		return this.M;

	} }, rt.prototype = { ua: function () {

		return this.Zd;

	}, Hb: function () {

		return this.Qc;

	}, Mb: function () {

		return this.ia;

	}, cb: function () {

		return this.M;

	} }, ot.prototype = { pn: function () {

		for ( var t = this.jc.ce; null != t; ) {

			for ( var i = t.M; ; ) {

				var s; if ( t.mh.Cc < t.nh.Cc ? ( s = t.mh.userData, t = t.nh.userData ) : ( s = t.nh.userData, t = t.mh.userData ), ! this.Gm( s, t ) ) break; var h, a = s.Yb, e = t.Yb; h = a.Ae < e.Ae ? a.Ob : e.Ob; a = s.Cc, e = t.Cc; for ( var o = ! 1; null != h; ) {

					var r = h.M; if ( ( h = h.Zd ).Zb.Cc == a && h.$b.Cc == e ) {

						o = h.Zj = ! 0; break;

					}

					h = r;

				}

				o || ( null != ( a = this.lg ) ? ( this.lg = a.M, a.M = null ) : a = new nt(), null == this.zd ? this.zd = a : ( this.ye.M = a, a.ia = this.ye ), this.ye = a, a.Zj = ! 0, e = this.Xm.Jb[ s.Kb.Lb ][ t.Kb.Lb ], a.Zb = s, a.$b = t, a.C = s.Yb, a.D = t.Yb, a.Td = ! 1, null == a.C.Ob ? a.C.Ob = a.rb : ( a.C.kc.M = a.rb, a.rb.ia = a.C.kc ), a.C.kc = a.rb, null == a.D.Ob ? a.D.Ob = a.sb : ( a.D.kc.M = a.sb, a.sb.ia = a.D.kc ), a.D.kc = a.sb, a.C.Ae ++, a.D.Ae ++, a.rb.Qc = a.D, a.sb.Qc = a.C, a.rb.Zd = a, a.sb.Zd = a, a.Lh = e, ( a = a.Ye ).Zb = s, a.$b = t, a.C = a.Zb.Yb, a.D = a.$b.Yb, a.pj = a.C.a, a.qj = a.D.a, this.Bi ++ ); break;

			}

			t = i;

		}

	}, qn: function () {

		for ( var t = this.jc.Yj, i = this.zd; null != i; ) {

			for ( var s = i.M; ; ) {

				if ( i.Zj ) {

					i.Zj = ! 1, i.ik = ! 1; break;

				}

				if ( ! t ) {

					var h = i.ia, a = i.M; null != h && ( h.M = a ), null != a && ( a.ia = h ), i == this.zd && ( this.zd = this.zd.M ), i == this.ye && ( this.ye = this.ye.ia ), i.M = null, i.ia = null, i.Td && ( ( h = i.Zb.yd ) == ( a = i.$b.yd ) && ( a = null ), null != h && h.endContact( i ), null != a && a.endContact( i ) ), h = i.rb.ia, a = i.rb.M, null != h && ( h.M = a ), null != a && ( a.ia = h ), i.rb == i.C.Ob && ( i.C.Ob = i.C.Ob.M ), i.rb == i.C.kc && ( i.C.kc = i.C.kc.ia ), i.rb.M = null, i.rb.ia = null, h = i.sb.ia, a = i.sb.M, null != h && ( h.M = a ), null != a && ( a.ia = h ), i.sb == i.D.Ob && ( i.D.Ob = i.D.Ob.M ), i.sb == i.D.kc && ( i.D.kc = i.D.kc.ia ), i.sb.M = null, i.sb.ia = null, i.C.Ae --, i.D.Ae --, i.rb.Qc = null, i.sb.Qc = null, i.rb.Zd = null, i.sb.Zd = null, i.Zb = null, i.$b = null, i.C = null, i.D = null, i.Td = ! 1, i.$i.Xe(), i.Ja.Xe(), i.Lh = null, ( h = i.Ye ).Zb = null, h.$b = null, h.C = null, h.D = null, h.pj = null, h.qj = null, i.M = this.lg, this.lg = i, this.Bi --; break;

				}

				h = i.Zb, a = i.$b; var e = h.Yb, o = ! ( o = a.Yb ).Gb && 1 != o.Lb; if ( ( e.Gb || 1 == e.Lb ) && ! o ) {

					i.ik = ! 0; break;

				}

				e = h.u, o = a.u; var r = h.tb, n = a.tb; if ( ! ( r.J < n.G && r.G > n.J && r.K < n.H && r.H > n.K && r.L < n.I && r.I > n.L && this.Gm( h, a ) ) ) {

					h = i.ia, a = i.M, null != h && ( h.M = a ), null != a && ( a.ia = h ), i == this.zd && ( this.zd = this.zd.M ), i == this.ye && ( this.ye = this.ye.ia ), i.M = null, i.ia = null, i.Td && ( ( h = i.Zb.yd ) == ( a = i.$b.yd ) && ( a = null ), null != h && h.endContact( i ), null != a && a.endContact( i ) ), h = i.rb.ia, a = i.rb.M, null != h && ( h.M = a ), null != a && ( a.ia = h ), i.rb == i.C.Ob && ( i.C.Ob = i.C.Ob.M ), i.rb == i.C.kc && ( i.C.kc = i.C.kc.ia ), i.rb.M = null, i.rb.ia = null, h = i.sb.ia, a = i.sb.M, null != h && ( h.M = a ), null != a && ( a.ia = h ), i.sb == i.D.Ob && ( i.D.Ob = i.D.Ob.M ), i.sb == i.D.kc && ( i.D.kc = i.D.kc.ia ), i.sb.M = null, i.sb.ia = null, i.C.Ae --, i.D.Ae --, i.rb.Qc = null, i.sb.Qc = null, i.rb.Zd = null, i.sb.Zd = null, i.Zb = null, i.$b = null, i.C = null, i.D = null, i.Td = ! 1, i.$i.Xe(), i.Ja.Xe(), i.Lh = null, ( h = i.Ye ).Zb = null, h.$b = null, h.C = null, h.D = null, h.pj = null, h.qj = null, i.M = this.lg, this.lg = i, this.Bi --; break;

				}

				i.ik = ! ( e.ma < o.ja && e.ja > o.ma && e.na < o.ka && e.ka > o.na && e.oa < o.la && e.la > o.oa ); break;

			}

			i = s;

		}

	}, Gm: function ( t, i ) {

		var s = t.Yb, h = i.Yb; if ( s == h || 0 != s.Lb && 0 != h.Lb || ! ( t.Tj & i.Uj && i.Tj & t.Uj ) ) return ! 1; for ( s.kh < h.kh ? ( t = s.ze, s = h ) : t = h.ze; null != t; ) {

			if ( t.Qc == s && ! t.Pk.Ak ) return ! 1; t = t.M;

		}

		return ! 0;

	}, gl: function () {

		this.jc.Ii(), this.pn(), this.qn();

	}, Vk: function () {

		for ( var t = this.zd; null != t; ) {

			var i = t.M; t.Td && t.Vk(), t = i;

		}

	}, cb: function () {

		return this.Bi;

	}, ua: function () {

		return this.zd;

	} }, et.prototype = { Xe: function () {

		for ( ;0 < this.Hf; ) this.Jf[ -- this.Hf ] = null; for ( ;0 < this.If; ) this.Kf[ -- this.If ] = null; for ( ;0 < this.wh; ) this.Eh[ -- this.wh ] = null; for ( ;0 < this.vh; ) this.Dh[ -- this.vh ] = null;

	}, zk: function ( t ) {

		if ( this.Hf == this.Jf.length ) {

			for ( var i = Array( this.Hf << 1 ), s = 0, h = this.Hf; s < h; ) {

				var a = s ++; i[ a ] = this.Jf[ a ], this.Jf[ a ] = null;

			}

			this.Jf = i;

		}

		t.Nf = ! 0, this.Jf[ this.Hf ++ ] = t;

	}, Ol: function ( t, i ) {

		if ( this.If == this.Kf.length ) {

			for ( var s = Array( this.If << 1 ), h = 0, a = this.If; h < a; ) {

				var e = h ++; s[ e ] = this.Kf[ e ], this.Kf[ e ] = null;

			}

			this.Kf = s;

		}

		if ( t.Nf = ! 0, this.Kf[ this.If ++ ] = t, i == W.SPLIT_IMPULSE ) {

			if ( this.wh == this.Eh.length ) {

				for ( s = Array( this.wh << 1 ), h = 0, a = this.wh; h < a; )s[ e = h ++ ] = this.Eh[ e ], this.Eh[ e ] = null; this.Eh = s;

			}

			this.Eh[ this.wh ++ ] = t;

		}

		if ( i == W.NGS ) {

			if ( this.vh == this.Dh.length ) {

				for ( i = Array( this.vh << 1 ), s = 0, h = this.vh; s < h; )i[ a = s ++ ] = this.Dh[ a ], this.Dh[ a ] = null; this.Dh = i;

			}

			this.Dh[ this.vh ++ ] = t;

		}

	}, gn: function ( t, i ) {

		t = t.dt; var s = i.pa, h = i.a; if ( s.v = h.v, s.A = h.A, s.B = h.B, s.o = h.o, s.f = h.f, s.h = h.h, s.i = h.i, s.m = h.m, s.j = h.j, s.l = h.l, s.g = h.g, s.s = h.s, i.Bk && i.gb * i.gb + i.hb * i.hb + i.ib * i.ib < gt.sleepingVelocityThreshold * gt.sleepingVelocityThreshold && i.kb * i.kb + i.lb * i.lb + i.mb * i.mb < gt.sleepingAngularVelocityThreshold * gt.sleepingAngularVelocityThreshold ? ( i.yb += t, i.yb > gt.sleepingTimeThreshold && ( i.Gb = ! 0, i.yb = 0 ) ) : i.yb = 0, ! i.Gb ) {

			if ( 0 == i.Lb ) {

				s = 1 / ( 1 + ( s = t * i.$j ) + ( h = s * s ) * ( .5 + .16666666666666666 * s + .041666666666666664 * h ) ), h = 1 / ( 1 + ( h = t * i.Qj ) + ( p = h * h ) * ( .5 + .16666666666666666 * h + .041666666666666664 * p ) ); var a, e, o, r, n, p = this.nm * i.eh; a = this.om * i.eh, e = this.pm * i.eh, p += i.Mh * i.$a, a += i.Nh * i.$a, e += i.Oh * i.$a, r = i.P * i.vf + i.R * i.wf + i.S * i.xf, n = i.T * i.vf + i.U * i.wf + i.V * i.xf, o = i.W * i.vf + i.X * i.wf + i.Y * i.xf, i.gb += p * t, i.hb += a * t, i.ib += e * t, i.gb *= s, i.hb *= s, i.ib *= s, i.kb += r * t, i.lb += n * t, i.mb += o * t, i.kb *= h, i.lb *= h, i.mb *= h;

			}

			for ( i.Wl( t ), t = i.Dc; null != t; ) {

				var l, c, y, f, u; s = t.M, h = t.pa, a = t.ha, e = ( p = i.pa ).o * a.o + p.f * a.i + p.h * a.l, o = p.o * a.f + p.f * a.m + p.h * a.g, r = p.o * a.h + p.f * a.j + p.h * a.s, n = p.i * a.o + p.m * a.i + p.j * a.l, l = p.i * a.f + p.m * a.m + p.j * a.g, c = p.i * a.h + p.m * a.j + p.j * a.s, y = p.l * a.o + p.g * a.i + p.s * a.l, f = p.l * a.f + p.g * a.m + p.s * a.g, u = p.l * a.h + p.g * a.j + p.s * a.s, h.o = e, h.f = o, h.h = r, h.i = n, h.m = l, h.j = c, h.l = y, h.g = f, h.s = u, e = p.o * a.v + p.f * a.A + p.h * a.B, o = p.i * a.v + p.m * a.A + p.j * a.B, a = p.l * a.v + p.g * a.A + p.s * a.B, h.v = e, h.A = o, h.B = a, h.v += p.v, h.A += p.A, h.B += p.B, h = t.a, a = t.ha, e = ( p = i.a ).o * a.o + p.f * a.i + p.h * a.l, o = p.o * a.f + p.f * a.m + p.h * a.g, r = p.o * a.h + p.f * a.j + p.h * a.s, n = p.i * a.o + p.m * a.i + p.j * a.l, l = p.i * a.f + p.m * a.m + p.j * a.g, c = p.i * a.h + p.m * a.j + p.j * a.s, y = p.l * a.o + p.g * a.i + p.s * a.l, f = p.l * a.f + p.g * a.m + p.s * a.g, u = p.l * a.h + p.g * a.j + p.s * a.s, h.o = e, h.f = o, h.h = r, h.i = n, h.m = l, h.j = c, h.l = y, h.g = f, h.s = u, e = p.o * a.v + p.f * a.A + p.h * a.B, o = p.i * a.v + p.m * a.A + p.j * a.B, a = p.l * a.v + p.g * a.A + p.s * a.B, h.v = e, h.A = o, h.B = a, h.v += p.v, h.A += p.A, h.B += p.B, t.Kb.Nb( t.u, t.pa ), h = t.u.ma, p = t.u.na, a = t.u.oa, e = t.u.ja, o = t.u.ka, r = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = h < t.u.ma ? h : t.u.ma, t.u.na = p < t.u.na ? p : t.u.na, t.u.oa = a < t.u.oa ? a : t.u.oa, t.u.ja = e > t.u.ja ? e : t.u.ja, t.u.ka = o > t.u.ka ? o : t.u.ka, t.u.la = r > t.u.la ? r : t.u.la, null != t.tb && ( h = t.a.v - t.pa.v, p = t.a.A - t.pa.A, a = t.a.B - t.pa.B, ( e = t.rc ).x = h, e.y = p, e.z = a, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = s;

			}

		}

	}, fn: function ( t, i, s ) {

		for ( var h = t.dt, a = ! 0, e = 0, o = this.Hf; e < o; ) {

			var r = e ++, n = this.Jf[ r ], p = n.pa, l = n.a; if ( p.v = l.v, p.A = l.A, p.B = l.B, p.o = l.o, p.f = l.f, p.h = l.h, p.i = l.i, p.m = l.m, p.j = l.j, p.l = l.l, p.g = l.g, p.s = l.s, n.Gb = ! 1, n.Bk && n.gb * n.gb + n.hb * n.hb + n.ib * n.ib < gt.sleepingVelocityThreshold * gt.sleepingVelocityThreshold && n.kb * n.kb + n.lb * n.lb + n.mb * n.mb < gt.sleepingAngularVelocityThreshold * gt.sleepingAngularVelocityThreshold ? n.yb += h : n.yb = 0, n.yb < gt.sleepingTimeThreshold && ( a = ! 1 ), 0 == n.Lb ) {

				var c, y, f, u, b, v, g = h * n.$j, x = g * g, d = 1 / ( 1 + g + x * ( .5 + .16666666666666666 * g + .041666666666666664 * x ) ), z = h * n.Qj, m = z * z, j = 1 / ( 1 + z + m * ( .5 + .16666666666666666 * z + .041666666666666664 * m ) ); c = this.nm * n.eh, y = this.om * n.eh, f = this.pm * n.eh, c += n.Mh * n.$a, y += n.Nh * n.$a, f += n.Oh * n.$a, u = n.P * n.vf + n.R * n.wf + n.S * n.xf, b = n.T * n.vf + n.U * n.wf + n.V * n.xf, v = n.W * n.vf + n.X * n.wf + n.Y * n.xf, n.gb += c * h, n.hb += y * h, n.ib += f * h, n.gb *= d, n.hb *= d, n.ib *= d, n.kb += u * h, n.lb += b * h, n.mb += v * h, n.kb *= j, n.lb *= j, n.mb *= j;

			}

		}

		if ( a ) for ( var M = 0, A = this.Hf; M < A; ) {

			var w = M ++, D = this.Jf[ w ]; D.Gb = ! 0, D.yb = 0;

		} else {

			for ( var C = 0, B = this.If; C < B; ) {

				var q = C ++; this.Kf[ q ].xh( t );

			}

			for ( var S = 0, k = this.If; S < k; ) {

				var I = S ++; this.Kf[ I ].Gh( t );

			}

			for ( var T = 0; T < i; ) {

				T ++; for ( var O = 0, L = this.If; O < L; ) {

					var F = O ++; this.Kf[ F ].Ch();

				}

			}

			for ( var P = 0, R = this.If; P < R; ) {

				var J = P ++; this.Kf[ J ].Li( t );

			}

			for ( var N = 0, H = this.Hf; N < H; ) {

				var K = N ++; this.Jf[ K ].Wl( h );

			}

			for ( var G = 0, V = this.wh; G < V; ) {

				var E = G ++; this.Eh[ E ].Pg( t );

			}

			for ( var U = 0; U < s; ) {

				U ++; for ( var W = 0, Y = this.wh; W < Y; ) {

					var X = W ++; this.Eh[ X ].Bh();

				}

			}

			for ( var $ = 0, Z = this.Hf; $ < Z; ) {

				var Q = $ ++; this.Jf[ Q ].dn();

			}

			for ( var _ = 0, tt = this.vh; _ < tt; ) {

				var it = _ ++; this.Dh[ it ].Pg( t );

			}

			for ( var st = 0; st < s; ) {

				st ++; for ( var ht = 0, at = this.vh; ht < at; ) {

					var et = ht ++; this.Dh[ et ].Ah( t );

				}

			}

			for ( var ot = 0, rt = this.If; ot < rt; ) {

				var nt = ot ++; this.Kf[ nt ].postSolve();

			}

			for ( var pt = 0, lt = this.Hf; pt < lt; ) for ( var ct = pt ++, yt = this.Jf[ ct ], ft = yt.Dc; null != ft; ) {

				var ut, bt, vt, xt, dt, zt, mt, jt, Mt, At, wt, Dt, Ct = ft.M, Bt = ft.pa, qt = ft.ha, St = yt.pa; ut = St.o * qt.o + St.f * qt.i + St.h * qt.l, bt = St.o * qt.f + St.f * qt.m + St.h * qt.g, vt = St.o * qt.h + St.f * qt.j + St.h * qt.s, xt = St.i * qt.o + St.m * qt.i + St.j * qt.l, dt = St.i * qt.f + St.m * qt.m + St.j * qt.g, zt = St.i * qt.h + St.m * qt.j + St.j * qt.s, mt = St.l * qt.o + St.g * qt.i + St.s * qt.l, jt = St.l * qt.f + St.g * qt.m + St.s * qt.g, Mt = St.l * qt.h + St.g * qt.j + St.s * qt.s, Bt.o = ut, Bt.f = bt, Bt.h = vt, Bt.i = xt, Bt.m = dt, Bt.j = zt, Bt.l = mt, Bt.g = jt, Bt.s = Mt, At = St.o * qt.v + St.f * qt.A + St.h * qt.B, wt = St.i * qt.v + St.m * qt.A + St.j * qt.B, Dt = St.l * qt.v + St.g * qt.A + St.s * qt.B, Bt.v = At, Bt.A = wt, Bt.B = Dt, Bt.v += St.v, Bt.A += St.A, Bt.B += St.B; var kt, It, Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt, Ht, Kt, Gt, Vt, Et, Ut, Wt, Yt, Xt = ft.a, $t = ft.ha, Zt = yt.a; if ( kt = Zt.o * $t.o + Zt.f * $t.i + Zt.h * $t.l, It = Zt.o * $t.f + Zt.f * $t.m + Zt.h * $t.g, Tt = Zt.o * $t.h + Zt.f * $t.j + Zt.h * $t.s, Ot = Zt.i * $t.o + Zt.m * $t.i + Zt.j * $t.l, Lt = Zt.i * $t.f + Zt.m * $t.m + Zt.j * $t.g, Ft = Zt.i * $t.h + Zt.m * $t.j + Zt.j * $t.s, Pt = Zt.l * $t.o + Zt.g * $t.i + Zt.s * $t.l, Rt = Zt.l * $t.f + Zt.g * $t.m + Zt.s * $t.g, Jt = Zt.l * $t.h + Zt.g * $t.j + Zt.s * $t.s, Xt.o = kt, Xt.f = It, Xt.h = Tt, Xt.i = Ot, Xt.m = Lt, Xt.j = Ft, Xt.l = Pt, Xt.g = Rt, Xt.s = Jt, Nt = Zt.o * $t.v + Zt.f * $t.A + Zt.h * $t.B, Ht = Zt.i * $t.v + Zt.m * $t.A + Zt.j * $t.B, Kt = Zt.l * $t.v + Zt.g * $t.A + Zt.s * $t.B, Xt.v = Nt, Xt.A = Ht, Xt.B = Kt, Xt.v += Zt.v, Xt.A += Zt.A, Xt.B += Zt.B, ft.Kb.Nb( ft.u, ft.pa ), Gt = ft.u.ma, Vt = ft.u.na, Et = ft.u.oa, Ut = ft.u.ja, Wt = ft.u.ka, Yt = ft.u.la, ft.Kb.Nb( ft.u, ft.a ), ft.u.ma = Gt < ft.u.ma ? Gt : ft.u.ma, ft.u.na = Vt < ft.u.na ? Vt : ft.u.na, ft.u.oa = Et < ft.u.oa ? Et : ft.u.oa, ft.u.ja = Ut > ft.u.ja ? Ut : ft.u.ja, ft.u.ka = Wt > ft.u.ka ? Wt : ft.u.ka, ft.u.la = Yt > ft.u.la ? Yt : ft.u.la, null != ft.tb ) {

					var Qt, _t, ti; Qt = ft.a.v - ft.pa.v, _t = ft.a.A - ft.pa.A, ti = ft.a.B - ft.pa.B; var ii = ft.rc; ii.x = Qt, ii.y = _t, ii.z = ti, ft.Yb.oc.jc.wd( ft.tb, ft.u, ft.rc );

				}

				ft = Ct;

			}

		}

	} }, ht.prototype = { gl: function () {

		var t = ( new Date() ).getTime() / 1e3; this.Kh.gl(), X.broadPhaseCollisionTime = 1e3 * ( ( new Date() ).getTime() / 1e3 - t ); t = ( new Date() ).getTime() / 1e3; for ( var i = this.Kh.zd; null != i; ) {

			var s = i.M; i.ik || i.hn(), i = s;

		}

		X.narrowPhaseCollisionTime = 1e3 * ( ( new Date() ).getTime() / 1e3 - t );

	}, en: function () {

		var t = ( new Date() ).getTime() / 1e3; if ( gt.disableSleeping ) for ( var i = this.uf; null != i; ) {

			var s = i.M; i.Gb = ! 1, i.yb = 0, i = s;

		}

		if ( this.ph.length < this.jj ) {

			for ( i = this.ph.length << 1; i < this.jj; )i <<= 1; this.ph = Array( i );

		}

		for ( this.ek = 0, i = this.vg, s = this.Fk, i.nm = s.x, i.om = s.y, i.pm = s.z, i = this.uf, this.tf = 0; null != i; ) {

			for ( s = i.M; ! i.Nf && ! i.Gb && 1 != i.Lb; ) {

				if ( 0 == i.Ae && 0 == i.kh ) {

					this.vg.gn( this.Sh, i ), this.ek ++; break;

				}

				this.kn( i ), this.vg.fn( this.Sh, this.Uk, this.Tk ), this.vg.Xe(), this.ek ++; break;

			}

			i = s;

		}

		for ( this.Kh.Vk(), i = this.uf; null != i; )s = i.M, i.Nf = ! 1, i = s; for ( i = this.uf; null != i; )s = i.M, i.Mh = 0, i.Nh = 0, i.Oh = 0, i.vf = 0, i.wf = 0, i.xf = 0, i = s; for ( ;0 < this.tf; ) this.af[ -- this.tf ].Nf = ! 1, this.af[ this.tf ] = null; X.dynamicsTime = 1e3 * ( ( new Date() ).getTime() / 1e3 - t );

	}, kn: function ( t ) {

		var i = 1; for ( this.vg.zk( t ), this.ph[ 0 ] = t; 0 < i; ) if ( t = this.ph[ -- i ], this.ph[ i ] = null, 1 != t.Lb ) {

			for ( var s = t.Ob; null != s; ) {

				var h = s.M, a = s.Zd.Ye, e = s.Zd.Ye.jk; if ( a.sk() && ! e.Nf ) {

					if ( this.af.length == this.tf ) {

						for ( var o = Array( this.tf << 1 ), r = 0, n = this.tf; r < n; ) {

							var p = r ++; o[ p ] = this.af[ p ], this.af[ p ] = null;

						}

						this.af = o;

					}

					this.af[ this.tf ++ ] = e, this.vg.Ol( e, a.Hc ), ( s = s.Qc ).Nf || ( this.vg.zk( s ), this.ph[ i ++ ] = s );

				}

				s = h;

			}

			for ( h = t.ze; null != h; ) {

				if ( t = h.M, ! ( a = ( s = h.Pk ).jk ).Nf ) {

					if ( this.af.length == this.tf ) {

						for ( e = Array( this.tf << 1 ), o = 0, r = this.tf; o < r; )e[ n = o ++ ] = this.af[ n ], this.af[ n ] = null; this.af = e;

					}

					this.af[ this.tf ++ ] = a, this.vg.Ol( a, s.Hc ), ( h = h.Qc ).Nf || ( this.vg.zk( h ), this.ph[ i ++ ] = h );

				}

				h = t;

			}

		}

	}, pe: function ( t ) {

		0 < this.Sh.dt && ( this.Sh.dtRatio = t / this.Sh.dt ), this.Sh.dt = t, this.Sh.invDt = 1 / t, t = ( new Date() ).getTime() / 1e3, this.gl(), this.en(), X.totalTime = 1e3 * ( ( new Date() ).getTime() / 1e3 - t );

	}, cb: function ( t ) {

		if ( null != t.oc ) throw Error( 'A rigid body cannot belong to multiple worlds.' ); for ( null == this.uf ? this.uf = t : ( this.Ei.M = t, t.ia = this.Ei ), this.Ei = t, t.oc = this, t = t.Dc; null != t; ) {

			var i = t.M; t.tb = this.jc.Vh( t, t.u ), t.Cc = this.Xl ++, this.zg ++, t = i;

		}

		this.jj ++;

	}, qe: function ( t ) {

		if ( t.oc != this ) throw Error( "The rigid body doesn't belong to the world." ); var i = t.ia, s = t.M; for ( null != i && ( i.M = s ), null != s && ( s.ia = i ), t == this.uf && ( this.uf = this.uf.M ), t == this.Ei && ( this.Ei = this.Ei.ia ), t.M = null, t.ia = null, t.oc = null, t = t.Dc; null != t; ) {

			i = t.M, this.jc.Wh( t.tb ), t.tb = null, t.Cc = - 1; for ( var h = t.Yb.Ob; null != h; ) {

				s = h.M; var a = h.Zd; if ( a.Zb == t || a.$b == t ) {

					( h = h.Qc ).Gb = ! 1, h.yb = 0; h = this.Kh; var e = a.ia, o = a.M; null != e && ( e.M = o ), null != o && ( o.ia = e ), a == h.zd && ( h.zd = h.zd.M ), a == h.ye && ( h.ye = h.ye.ia ), a.M = null, a.ia = null, a.Td && ( ( e = a.Zb.yd ) == ( o = a.$b.yd ) && ( o = null ), null != e && e.endContact( a ), null != o && o.endContact( a ) ), e = a.rb.ia, o = a.rb.M, null != e && ( e.M = o ), null != o && ( o.ia = e ), a.rb == a.C.Ob && ( a.C.Ob = a.C.Ob.M ), a.rb == a.C.kc && ( a.C.kc = a.C.kc.ia ), a.rb.M = null, a.rb.ia = null, e = a.sb.ia, o = a.sb.M, null != e && ( e.M = o ), null != o && ( o.ia = e ), a.sb == a.D.Ob && ( a.D.Ob = a.D.Ob.M ), a.sb == a.D.kc && ( a.D.kc = a.D.kc.ia ), a.sb.M = null, a.sb.ia = null, a.C.Ae --, a.D.Ae --, a.rb.Qc = null, a.sb.Qc = null, a.rb.Zd = null, a.sb.Zd = null, a.Zb = null, a.$b = null, a.C = null, a.D = null, a.Td = ! 1, a.$i.Xe(), a.Ja.Xe(), a.Lh = null, ( e = a.Ye ).Zb = null, e.$b = null, e.C = null, e.D = null, e.pj = null, e.qj = null, a.M = h.lg, h.lg = a, h.Bi --;

				}

				h = s;

			}

			this.zg --, t = i;

		}

		this.jj --;

	}, ua: function ( t ) {

		if ( null != t.oc ) throw Error( 'A joint cannot belong to multiple worlds.' ); null == this.Ph ? this.Ph = t : ( this.zi.M = t, t.ia = this.zi ), this.zi = t, t.oc = this, t.rb.Qc = t.D, t.sb.Qc = t.C, null == t.C.ze ? t.C.ze = t.rb : ( t.C.Ze.M = t.rb, t.rb.ia = t.C.Ze ), t.C.Ze = t.rb, null == t.D.ze ? t.D.ze = t.sb : ( t.D.Ze.M = t.sb, t.sb.ia = t.D.Ze ), t.D.Ze = t.sb, t.C.kh ++, t.D.kh ++; var i = t.C; i.Gb = ! 1, i.yb = 0, ( i = t.D ).Gb = ! 1, i.yb = 0, t.hd(), this.Sk ++;

	}, Kl: function ( t ) {

		if ( t.oc != this ) throw Error( "The joint doesn't belong to the world." ); var i = t.ia, s = t.M; null != i && ( i.M = s ), null != s && ( s.ia = i ), t == this.Ph && ( this.Ph = this.Ph.M ), t == this.zi && ( this.zi = this.zi.ia ), t.M = null, t.ia = null, t.oc = null, i = t.rb.ia, s = t.rb.M, null != i && ( i.M = s ), null != s && ( s.ia = i ), t.rb == t.C.ze && ( t.C.ze = t.C.ze.M ), t.rb == t.C.Ze && ( t.C.Ze = t.C.Ze.ia ), t.rb.M = null, t.rb.ia = null, i = t.sb.ia, s = t.sb.M, null != i && ( i.M = s ), null != s && ( s.ia = i ), t.sb == t.D.ze && ( t.D.ze = t.D.ze.M ), t.sb == t.D.Ze && ( t.D.Ze = t.D.Ze.ia ), t.sb.M = null, t.sb.ia = null, t.rb.Qc = null, t.sb.Qc = null, t.C.kh --, t.D.kh --, ( i = t.C ).Gb = ! 1, i.yb = 0, ( t = t.D ).Gb = ! 1, t.yb = 0, this.Sk --;

	}, Hb: function () {

		null != this.ni && ( 2 == this.jc.Lb && this.Zm( this.ni, this.jc.ge ), this.bn( this.ni ), this.$m( this.ni ) );

	}, Vd: function ( t, i, s ) {

		var h = this.gk.vj; h.x = t.x, h.y = t.y, h.z = t.z, ( h = this.gk.end ).x = i.x, h.y = i.y, h.z = i.z, this.gk.xj = s, this.jc.Vd( t, i, this.gk );

	}, Bf: function ( t, i, s, h ) {

		this.aj.em = t; var a = this.aj.vj; a.v = i.v, a.A = i.A, a.B = i.B, a.o = i.o, a.f = i.f, a.h = i.h, a.i = i.i, a.m = i.m, a.j = i.j, a.l = i.l, a.g = i.g, a.s = i.s, ( a = this.aj.eg ).x = s.x, a.y = s.y, a.z = s.z, this.aj.xj = h, this.jc.Bf( t, i, s, this.aj );

	}, qh: function ( t, i ) {

		this.yk.u.de( t ), this.yk.Ql = i, this.jc.qh( t, this.yk );

	}, fd: function () {

		return this.uf;

	}, vc: function () {

		return this.Ph;

	}, Mb: function () {

		return this.jc;

	}, pc: function () {

		return this.Kh;

	}, Kc: function () {

		return this.jj;

	}, Ec: function () {

		return this.Sk;

	}, Yd: function () {

		return this.zg;

	}, Ac: function () {

		return this.ek;

	}, Lc: function () {

		return this.Uk;

	}, ue: function ( t ) {

		this.Uk = t;

	}, Jc: function () {

		return this.Tk;

	}, te: function ( t ) {

		this.Tk = t;

	}, uc: function () {

		return this.Fk;

	}, se: function ( t ) {

		var i = this.Fk; i.x = t.x, i.y = t.y, i.z = t.z;

	} }, st.ua = ii, st.prototype = ri( ii.prototype, { process: function ( t ) {

		( t = t.userData ).Kb.Vd( this.vj, this.end, t.a, this.Mi ) && this.xj.process( t, this.Mi );

	} } ), it.ua = ii, it.prototype = ri( ii.prototype, { process: function ( t ) {

		var i = ( t = t.userData ).Kb.Lb; 0 > i || 5 < i || vt.cb.Bf( this.em, t.Kb, this.vj, t.a, this.eg, this.Z, this.Mi ) && this.xj.process( t, this.Mi );

	} } ), tt.ua = ii, tt.prototype = ri( ii.prototype, { process: function ( t ) {

		var i = ( t = t.userData ).u; i.ma < this.u.ja && i.ja > this.u.ma && i.na < this.u.ka && i.ka > this.u.na && i.oa < this.u.la && i.la > this.u.oa && this.Ql.process( t );

	} } ), _.prototype = { process: function () {} }, Q.prototype = { beginContact: function () {}, preSolve: function () {}, postSolve: function () {}, endContact: function () {} }, Z.prototype = { process: function () {} }, $.ua = Z, $.prototype = ri( Z.prototype, { clear: function () {

		this.shape = null, this.fraction = 1, this.position.Z(), this.normal.Z(), this.hit = ! 1;

	}, process: function ( t, i ) {

		if ( i.fraction < this.fraction ) {

			this.shape = t, this.hit = ! 0, this.fraction = i.fraction, t = this.position; var s = i.position; t.x = s.x, t.y = s.y, t.z = s.z, t = this.normal, i = i.normal, t.x = i.x, t.y = i.y, t.z = i.z;

		}

	} } ), Y.prototype = { xh: function () {}, Gh: function () {}, Ch: function () {}, Li: function () {}, Pg: function () {}, Bh: function () {}, Ah: function () {}, postSolve: function () {} }, U.prototype = { $d: function ( t, i ) {

		var s, h, a, e, o, r, n, p, l; i.Qe = this.C, i.Re = this.D, s = this.Ja.wg, h = this.Ja.xg, a = this.Ja.yg, e = this.Ja.lj, o = this.Ja.mj, r = this.Ja.nj, n = this.Ja.Vi, p = this.Ja.Wi, l = this.Ja.Xi; for ( var c = Math.sqrt( this.Zb.Xj * this.$b.Xj ), y = Math.sqrt( this.Zb.hk * this.$b.hk ), f = this.Ja.be, u = i.Ka = 0; u < f; ) {

			var b = u ++; if ( 0 > ( b = this.Ja.wc[ b ] ).Gc )b.lf = ! 0, ( b = b.ae ).bd = 0, b.zc = 0, b.yc = 0, b.ub = 0, b.df = 0, b.ef = 0, b.ff = 0; else {

				b.lf = ! 1; var v = i.rows[ i.Ka ++ ]; v.friction = c, v.Ma = 0; var g = v.Ng; g.va = s, g.wa = h, g.xa = a, g.Ba = s, g.Ca = h, g.Da = a, g.aa = b.Eb * a - b.Fb * h, g.ba = b.Fb * s - b.Db * a, g.ca = b.Db * h - b.Eb * s, g.ea = b.fc * a - b.gc * h, g.fa = b.gc * s - b.ec * a, g.ga = b.ec * h - b.fc * s, ( g = v.Lj ).va = e, g.wa = o, g.xa = r, g.Ba = e, g.Ca = o, g.Da = r, g.aa = b.Eb * r - b.Fb * o, g.ba = b.Fb * e - b.Db * r, g.ca = b.Db * o - b.Eb * e, g.ea = b.fc * r - b.gc * o, g.fa = b.gc * e - b.ec * r, g.ga = b.ec * o - b.fc * e, ( g = v.Kj ).va = n, g.wa = p, g.xa = l, g.Ba = n, g.Ca = p, g.Da = l, g.aa = b.Eb * l - b.Fb * p, g.ba = b.Fb * n - b.Db * l, g.ca = b.Db * p - b.Eb * n, g.ea = b.fc * l - b.gc * p, g.fa = b.gc * n - b.ec * l, g.ga = b.ec * p - b.fc * n, g = ( g = v.Ng ).va * this.C.gb + g.wa * this.C.hb + g.xa * this.C.ib + ( g.aa * this.C.kb + g.ba * this.C.lb + g.ca * this.C.mb ) - ( g.Ba * this.D.gb + g.Ca * this.D.hb + g.Da * this.D.ib + ( g.ea * this.D.kb + g.fa * this.D.lb + g.ga * this.D.mb ) ), v.Fa = g < - gt.contactEnableBounceThreshold && ! b.Pe ? - g * y : 0, this.Hc == W.BAUMGARTE && b.Gc > gt.linearSlop && ( g = ( b.Gc - gt.linearSlop ) * gt.velocityBaumgarte * t.invDt, v.Fa < g && ( v.Fa = g ) ), b.Pe || ( ( g = b.ae ).bd = 0, g.zc = 0, g.yc = 0, g.ub = 0, g.df = 0, g.ef = 0, g.ff = 0 ), v.ta = b.ae;

			}

		}

	}, gd: function ( t ) {

		var i, s, h; t.Qe = this.C, t.Re = this.D, i = this.Ja.wg, s = this.Ja.xg, h = this.Ja.yg; for ( var a = this.Ja.be, e = t.Ka = 0; e < a; ) {

			var o = e ++; if ( ! ( o = this.Ja.wc[ o ] ).lf ) {

				var r = t.rows[ t.Ka ++ ], n = r.Ng; n.va = i, n.wa = s, n.xa = h, n.Ba = i, n.Ca = s, n.Da = h, n.aa = o.Eb * h - o.Fb * s, n.ba = o.Fb * i - o.Db * h, n.ca = o.Db * s - o.Eb * i, n.ea = o.fc * h - o.gc * s, n.fa = o.gc * i - o.ec * h, n.ga = o.ec * s - o.fc * i, r.Fa = o.Gc - gt.linearSlop, 0 > r.Fa && ( r.Fa = 0 ), r.ta = o.ae;

			}

		}

	}, al: function () {

		this.Ja.Yl( this.pj, this.qj );

	}, cb: function () {

		return this.Zb;

	}, Hb: function () {

		return this.$b;

	}, ua: function () {

		return this.Ja;

	}, sk: function () {

		for ( var t = 0, i = this.Ja.be; t < i; ) {

			var s = t ++; if ( 0 <= this.Ja.wc[ s ].Gc ) return ! 0;

		}

		return ! 1;

	} }, E.prototype = { de: function ( t ) {

		this.bd = t.bd, this.zc = t.zc, this.yc = t.yc, this.df = t.df, this.ef = t.ef, this.ff = t.ff;

	} }, V.prototype = { Xe: function () {

		for ( var t = 0, i = this.be; t < i; ) {

			var s = t ++; ( s = this.wc[ s ] ).mf = 0, s.nf = 0, s.pf = 0, s.qf = 0, s.rf = 0, s.sf = 0, s.Db = 0, s.Eb = 0, s.Fb = 0, s.ec = 0, s.fc = 0, s.gc = 0, s.Jd = 0, s.Kd = 0, s.Ld = 0, s.Md = 0, s.Nd = 0, s.Od = 0, s.Gc = 0; var h = s.ae; h.bd = 0, h.zc = 0, h.yc = 0, h.ub = 0, h.df = 0, h.ef = 0, h.ff = 0, s.Pe = ! 1, s.lf = ! 1, s.Cc = - 1;

		}

		this.be = 0;

	}, Wm: function ( t ) {

		this.wg = t.x, this.xg = t.y, this.yg = t.z; var i, s = t.x, h = t.y, a = s * s, e = h * h, o = ( t = t.z ) * t; a < e ? a < o ? ( a = 0, e = - t * ( o = 1 / Math.sqrt( e + o ) ), i = h * ( o *= h ) - t * e, t = - s * o, s *= e ) : ( a = - h * ( e = 1 / Math.sqrt( a + e ) ), o = 0, i = - t * ( e *= s ), t *= a, s = s * e - h * a ) : e < o ? ( a = t * ( o = 1 / Math.sqrt( a + o ) ), e = 0, i = h * ( o *= - s ), t = t * a - s * o, s = - h * a ) : ( a = - h * ( e = 1 / Math.sqrt( a + e ) ), o = 0, i = - t * ( e *= s ), t *= a, s = s * e - h * a ), this.lj = a, this.mj = e, this.nj = o, this.Vi = i, this.Wi = t, this.Xi = s;

	}, Yl: function ( t, i ) {

		for ( var s = 0, h = this.be; s < h; ) {

			var a, e, o, r = s ++; r = this.wc[ r ]; a = t.o * r.mf + t.f * r.nf + t.h * r.pf, e = t.i * r.mf + t.m * r.nf + t.j * r.pf, o = t.l * r.mf + t.g * r.nf + t.s * r.pf, r.Db = a, r.Eb = e, r.Fb = o, a = i.o * r.qf + i.f * r.rf + i.h * r.sf, e = i.i * r.qf + i.m * r.rf + i.j * r.sf, o = i.l * r.qf + i.g * r.rf + i.s * r.sf, r.ec = a, r.fc = e, r.gc = o, r.Jd = r.Db + t.v, r.Kd = r.Eb + t.A, r.Ld = r.Fb + t.B, r.Md = r.ec + i.v, r.Nd = r.fc + i.A, r.Od = r.gc + i.B, r.Gc = - ( ( r.Jd - r.Md ) * this.wg + ( r.Kd - r.Nd ) * this.xg + ( r.Ld - r.Od ) * this.yg );

		}

	}, Hb: function () {

		var t = new dt(); return t.x = this.wg, t.y = this.xg, t.z = this.yg, t;

	}, Mb: function ( t ) {

		t.x = this.wg, t.y = this.xg, t.z = this.yg;

	}, uc: function () {

		var t = new dt(); return t.x = this.lj, t.y = this.mj, t.z = this.nj, t;

	}, vc: function ( t ) {

		t.x = this.lj, t.y = this.mj, t.z = this.nj;

	}, ua: function () {

		var t = new dt(); return t.x = this.Vi, t.y = this.Wi, t.z = this.Xi, t;

	}, cb: function ( t ) {

		t.x = this.Vi, t.y = this.Wi, t.z = this.Xi;

	}, qc: function () {

		return this.wc;

	}, pc: function () {

		return this.be;

	} }, G.prototype = { Mb: function () {

		var t = new dt(); return t.x = this.Jd, t.y = this.Kd, t.z = this.Ld, t;

	}, pc: function ( t ) {

		t.x = this.Jd, t.y = this.Kd, t.z = this.Ld;

	}, qc: function () {

		var t = new dt(); return t.x = this.Md, t.y = this.Nd, t.z = this.Od, t;

	}, uc: function ( t ) {

		t.x = this.Md, t.y = this.Nd, t.z = this.Od;

	}, cb: function () {

		return this.Gc;

	}, Ac: function () {

		return this.Pe;

	}, Hb: function () {

		return this.ae.bd;

	}, vc: function () {

		return this.ae.zc;

	}, ua: function () {

		return this.ae.yc;

	}, Ec: function () {

		return ! this.lf;

	} }, K.prototype = { Wn: function () {

		for ( var t = this.Ja.be; 0 <= -- t; ) {

			var i, s; i = ( h = this.Ja.wc[ t ] ).Jd - h.Md, s = h.Kd - h.Nd; var h = h.Ld - h.Od, a = this.Ja.wg * i + this.Ja.xg * s + this.Ja.yg * h; a > gt.contactPersistenceThreshold ? this.Fm( t ) : ( i += this.Ja.wg * - a ) * i + ( s += this.Ja.xg * - a ) * s + ( h += this.Ja.yg * - a ) * h > gt.contactPersistenceThreshold * gt.contactPersistenceThreshold && this.Fm( t );

		}

	}, Fm: function ( t ) {

		var i = -- this.Ja.be; if ( t != i ) {

			var s = this.Ja.wc[ t ]; this.Ja.wc[ t ] = this.Ja.wc[ i ], this.Ja.wc[ i ] = s;

		}

		( t = this.Ja.wc[ i ] ).mf = 0, t.nf = 0, t.pf = 0, t.qf = 0, t.rf = 0, t.sf = 0, t.Db = 0, t.Eb = 0, t.Fb = 0, t.ec = 0, t.fc = 0, t.gc = 0, t.Jd = 0, t.Kd = 0, t.Ld = 0, t.Md = 0, t.Nd = 0, t.Od = 0, t.Gc = 0, ( i = t.ae ).bd = 0, i.zc = 0, i.yc = 0, i.ub = 0, i.df = 0, i.ef = 0, i.ff = 0, t.Pe = ! 1, t.lf = ! 1, t.Cc = - 1;

	}, jn: function ( t, i, s ) {

		if ( ( h = this.Ja.be ) == gt.maxManifoldPoints ) {

			var h = this.Ja.wc[ this.on( t, i, s ) ], a = t.position1; h.Jd = a.x, h.Kd = a.y, h.Ld = a.z, a = t.position2, h.Md = a.x, h.Nd = a.y, h.Od = a.z, h.Db = h.Jd - i.v, h.Eb = h.Kd - i.A, h.Fb = h.Ld - i.B, h.ec = h.Md - s.v, h.fc = h.Nd - s.A, h.gc = h.Od - s.B; var e; a = i.o * h.Db + i.i * h.Eb + i.l * h.Fb; e = i.f * h.Db + i.m * h.Eb + i.g * h.Fb, i = i.h * h.Db + i.j * h.Eb + i.s * h.Fb, h.mf = a, h.nf = e, h.pf = i, i = s.o * h.ec + s.i * h.fc + s.l * h.gc, a = s.f * h.ec + s.m * h.fc + s.g * h.gc, s = s.h * h.ec + s.j * h.fc + s.s * h.gc, h.qf = i, h.rf = a, h.sf = s, h.Gc = t.depth, ( s = h.ae ).bd = 0, s.zc = 0, s.yc = 0, s.ub = 0, s.df = 0, s.ef = 0, s.ff = 0, h.Cc = t.id, h.Pe = ! 1, h.lf = ! 1;

		} else h = this.Ja.wc[ h ], a = t.position1, h.Jd = a.x, h.Kd = a.y, h.Ld = a.z, a = t.position2, h.Md = a.x, h.Nd = a.y, h.Od = a.z, h.Db = h.Jd - i.v, h.Eb = h.Kd - i.A, h.Fb = h.Ld - i.B, h.ec = h.Md - s.v, h.fc = h.Nd - s.A, h.gc = h.Od - s.B, a = i.o * h.Db + i.i * h.Eb + i.l * h.Fb, e = i.f * h.Db + i.m * h.Eb + i.g * h.Fb, i = i.h * h.Db + i.j * h.Eb + i.s * h.Fb, h.mf = a, h.nf = e, h.pf = i, i = s.o * h.ec + s.i * h.fc + s.l * h.gc, a = s.f * h.ec + s.m * h.fc + s.g * h.gc, s = s.h * h.ec + s.j * h.fc + s.s * h.gc, h.qf = i, h.rf = a, h.sf = s, h.Gc = t.depth, ( s = h.ae ).bd = 0, s.zc = 0, s.yc = 0, s.ub = 0, s.df = 0, s.ef = 0, s.ff = 0, h.Cc = t.id, h.Pe = ! 1, h.lf = ! 1, this.Ja.be ++;

	}, on: function ( t, i ) {

		var s = this.Ja.wc[ 0 ], h = this.Ja.wc[ 1 ], a = this.Ja.wc[ 2 ], e = this.Ja.wc[ 3 ], o = s.Gc, r = 0; h.Gc > o && ( o = h.Gc, r = 1 ), a.Gc > o && ( o = a.Gc, r = 2 ), e.Gc > o && ( o = e.Gc, r = 3 ); var n, p, l, c = t.position1; n = c.x, p = c.y, l = c.z, n -= i.v, p -= i.A, l -= i.B; var y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O, L, F, P, R, J, N, H, K, G, V, E, U, W, Y, X, $, Z, Q, _, tt, it, st, ht, at, et, ot, rt, nt, pt, lt, ct, yt, ft, ut, bt, vt, gt, xt, dt, zt, mt, jt, Mt, At, wt, Dt, Ct, Bt, qt, St, kt, It, Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt, Ht, Kt, Gt, Vt, Et, Ut, Wt, Yt, Xt, $t, Zt, Qt, _t, ti, ii, si, hi, ai, ei, oi, ri, ni, pi, li, ci, yi = h.Db, fi = h.Eb, ui = h.Fb, bi = a.Db, vi = a.Eb, gi = a.Fb, xi = e.Db, di = e.Eb, zi = e.Fb, mi = ( S = ( f = vi - fi ) * ( g = l - zi ) - ( u = gi - ui ) * ( v = p - di ) ) * S + ( k = u * ( b = n - xi ) - ( y = bi - yi ) * g ) * k + ( I = y * v - f * b ) * I, ji = ( T = ( d = di - fi ) * ( M = l - gi ) - ( z = zi - ui ) * ( j = p - vi ) ) * T + ( O = z * ( m = n - bi ) - ( x = xi - yi ) * M ) * O + ( L = x * j - d * m ) * L, Mi = ( F = ( w = p - fi ) * ( q = zi - gi ) - ( D = l - ui ) * ( B = di - vi ) ) * F + ( P = D * ( C = xi - bi ) - ( A = n - yi ) * q ) * P + ( R = A * B - w * C ) * R, Ai = mi > ji ? mi > Mi ? mi : Mi : ji > Mi ? ji : Mi, wi = s.Db, Di = s.Eb, Ci = s.Fb, Bi = a.Db, qi = a.Eb, Si = a.Fb, ki = e.Db, Ii = e.Eb, Ti = e.Fb, Oi = ( ht = ( N = qi - Di ) * ( V = l - Ti ) - ( H = Si - Ci ) * ( G = p - Ii ) ) * ht + ( at = H * ( K = n - ki ) - ( J = Bi - wi ) * V ) * at + ( et = J * G - N * K ) * et, Li = ( ot = ( U = Ii - Di ) * ( $ = l - Si ) - ( W = Ti - Ci ) * ( X = p - qi ) ) * ot + ( rt = W * ( Y = n - Bi ) - ( E = ki - wi ) * $ ) * rt + ( nt = E * X - U * Y ) * nt, Fi = ( pt = ( Q = p - Di ) * ( st = Ti - Si ) - ( _ = l - Ci ) * ( it = Ii - qi ) ) * pt + ( lt = _ * ( tt = ki - Bi ) - ( Z = n - wi ) * st ) * lt + ( ct = Z * it - Q * tt ) * ct, Pi = Oi > Li ? Oi > Fi ? Oi : Fi : Li > Fi ? Li : Fi, Ri = s.Db, Ji = s.Eb, Ni = s.Fb, Hi = h.Db, Ki = h.Eb, Gi = h.Fb, Vi = e.Db, Ei = e.Eb, Ui = e.Fb, Wi = ( St = ( ft = Ki - Ji ) * ( gt = l - Ui ) - ( ut = Gi - Ni ) * ( vt = p - Ei ) ) * St + ( kt = ut * ( bt = n - Vi ) - ( yt = Hi - Ri ) * gt ) * kt + ( It = yt * vt - ft * bt ) * It, Yi = ( Tt = ( dt = Ei - Ji ) * ( Mt = l - Gi ) - ( zt = Ui - Ni ) * ( jt = p - Ki ) ) * Tt + ( Ot = zt * ( mt = n - Hi ) - ( xt = Vi - Ri ) * Mt ) * Ot + ( Lt = xt * jt - dt * mt ) * Lt, Xi = ( Ft = ( wt = p - Ji ) * ( qt = Ui - Gi ) - ( Dt = l - Ni ) * ( Bt = Ei - Ki ) ) * Ft + ( Pt = Dt * ( Ct = Vi - Hi ) - ( At = n - Ri ) * qt ) * Pt + ( Rt = At * Bt - wt * Ct ) * Rt, $i = Wi > Yi ? Wi > Xi ? Wi : Xi : Yi > Xi ? Yi : Xi, Zi = s.Db, Qi = s.Eb, _i = s.Fb, ts = h.Db, is = h.Eb, ss = h.Fb, hs = a.Db, as = a.Eb, es = a.Fb, os = ( hi = ( Nt = is - Qi ) * ( Vt = l - es ) - ( Ht = ss - _i ) * ( Gt = p - as ) ) * hi + ( ai = Ht * ( Kt = n - hs ) - ( Jt = ts - Zi ) * Vt ) * ai + ( ei = Jt * Gt - Nt * Kt ) * ei, rs = ( oi = ( Ut = as - Qi ) * ( $t = l - ss ) - ( Wt = es - _i ) * ( Xt = p - is ) ) * oi + ( ri = Wt * ( Yt = n - ts ) - ( Et = hs - Zi ) * $t ) * ri + ( ni = Et * Xt - Ut * Yt ) * ni, ns = ( pi = ( Qt = p - Qi ) * ( si = es - ss ) - ( _t = l - _i ) * ( ii = as - is ) ) * pi + ( li = _t * ( ti = hs - ts ) - ( Zt = n - Zi ) * si ) * li + ( ci = Zt * ii - Qt * ti ) * ci, ps = os > rs ? os > ns ? os : ns : rs > ns ? rs : ns, ls = Ai, cs = 0; return ( Pi > ls && 1 != r || ! r ) && ( ls = Pi, cs = 1 ), $i > ls && 2 != r && ( ls = $i, cs = 2 ), ps > ls && 3 != r && ( ls = ps, cs = 3 ), cs;

	}, rn: function ( t, i, s ) {

		for ( var h = gt.contactPersistenceThreshold * gt.contactPersistenceThreshold, a = - 1, e = 0, o = this.Ja.be; e < o; ) {

			var r, n, p, l, c, y, f = e ++, u = this.Ja.wc[ f ]; r = ( c = t.position1 ).x, n = c.y, p = c.z, l = ( y = t.position2 ).x, c = y.y, y = y.z, r -= i.v, n -= i.A, p -= i.B, l -= s.v, c -= s.A, y -= s.B, r = u.Db - r, n = u.Eb - n, p = u.Fb - p, l = u.ec - l, c = u.fc - c, u = u.gc - y, ( u = ( y = r * r + n * n + p * p ) < ( u = l * l + c * c + u * u ) ? y : u ) < h && ( h = u, a = f );

		}

		return a;

	}, eo: function ( t, i, s ) {

		this.Gl = this.Ja.be; for ( var h = 0, a = this.Gl; h < a; ) {

			var e = h ++, o = this.Hl[ e ]; e = this.Ja.wc[ e ]; o.mf = e.mf, o.nf = e.nf, o.pf = e.pf, o.qf = e.qf, o.rf = e.rf, o.sf = e.sf, o.Db = e.Db, o.Eb = e.Eb, o.Fb = e.Fb, o.ec = e.ec, o.fc = e.fc, o.gc = e.gc, o.Jd = e.Jd, o.Kd = e.Kd, o.Ld = e.Ld, o.Md = e.Md, o.Nd = e.Nd, o.Od = e.Od, o.Gc = e.Gc, o.ae.de( e.ae ), o.Cc = e.Cc, o.Pe = e.Pe, o.lf = ! 1;

		}

		for ( h = t.numPoints, this.Ja.be = h, a = 0; a < h; ) {

			e = a ++, o = this.Ja.wc[ e ]; var r = ( e = t.points[ e ] ).position1; o.Jd = r.x, o.Kd = r.y, o.Ld = r.z, r = e.position2, o.Md = r.x, o.Nd = r.y, o.Od = r.z, o.Db = o.Jd - i.v, o.Eb = o.Kd - i.A, o.Fb = o.Ld - i.B, o.ec = o.Md - s.v, o.fc = o.Nd - s.A, o.gc = o.Od - s.B; var n, p; r = i.o * o.Db + i.i * o.Eb + i.l * o.Fb; for ( n = i.f * o.Db + i.m * o.Eb + i.g * o.Fb, p = i.h * o.Db + i.j * o.Eb + i.s * o.Fb, o.mf = r, o.nf = n, o.pf = p, r = s.o * o.ec + s.i * o.fc + s.l * o.gc, n = s.f * o.ec + s.m * o.fc + s.g * o.gc, p = s.h * o.ec + s.j * o.fc + s.s * o.gc, o.qf = r, o.rf = n, o.sf = p, o.Gc = e.depth, ( r = o.ae ).bd = 0, r.zc = 0, r.yc = 0, r.ub = 0, r.df = 0, r.ef = 0, r.ff = 0, o.Cc = e.id, o.Pe = ! 1, o.lf = ! 1, e = 0, r = this.Gl; e < r; ) if ( n = e ++, n = this.Hl[ n ], o.Cc == n.Cc ) {

				o.ae.de( n.ae ), o.Pe = ! 0; break;

			}

		}

	}, On: function ( t, i, s ) {

		this.Ja.Yl( i, s ); for ( var h = 0, a = this.Ja.be; h < a; ) {

			var e = h ++; this.Ja.wc[ e ].Pe = ! 0;

		}

		t = t.points[ 0 ], - 1 == ( h = this.rn( t, i, s ) ) ? this.jn( t, i, s ) : ( h = this.Ja.wc[ h ], a = t.position1, h.Jd = a.x, h.Kd = a.y, h.Ld = a.z, a = t.position2, h.Md = a.x, h.Nd = a.y, h.Od = a.z, h.Db = h.Jd - i.v, h.Eb = h.Kd - i.A, h.Fb = h.Ld - i.B, h.ec = h.Md - s.v, h.fc = h.Nd - s.A, h.gc = h.Od - s.B, a = i.o * h.Db + i.i * h.Eb + i.l * h.Fb, e = i.f * h.Db + i.m * h.Eb + i.g * h.Fb, i = i.h * h.Db + i.j * h.Eb + i.s * h.Fb, h.mf = a, h.nf = e, h.pf = i, i = s.o * h.ec + s.i * h.fc + s.l * h.gc, a = s.f * h.ec + s.m * h.fc + s.g * h.gc, s = s.h * h.ec + s.j * h.fc + s.s * h.gc, h.qf = i, h.rf = a, h.sf = s, h.Gc = t.depth ), this.Wn();

	} }, H.prototype = { Im: function () {

		this.xc = 0, 0 == this.va && 0 == this.wa && 0 == this.xa && 0 == this.Ba && 0 == this.Ca && 0 == this.Da || ( this.xc |= 1 ), 0 == this.aa && 0 == this.ba && 0 == this.ca && 0 == this.ea && 0 == this.fa && 0 == this.ga || ( this.xc |= 2 );

	} }, F.prototype = { hd: function () {

		var t, i, s, h = this.C.a, a = this.D.a; t = h.o * this.dj + h.f * this.ej + h.h * this.fj, i = h.i * this.dj + h.m * this.ej + h.j * this.fj, s = h.l * this.dj + h.g * this.ej + h.s * this.fj, this.Sb = t, this.Tb = i, this.Ub = s, t = a.o * this.gj + a.f * this.hj + a.h * this.ij, i = a.i * this.gj + a.m * this.hj + a.j * this.ij, s = a.l * this.gj + a.g * this.hj + a.s * this.ij, this.Vb = t, this.Wb = i, this.Xb = s, this.Of = this.Sb + h.v, this.Pf = this.Tb + h.A, this.Qf = this.Ub + h.B, this.Rf = this.Vb + a.v, this.Sf = this.Wb + a.A, this.Tf = this.Xb + a.B, t = h.o * this.qa + h.f * this.ra + h.h * this.sa, i = h.i * this.qa + h.m * this.ra + h.j * this.sa, s = h.l * this.qa + h.g * this.ra + h.s * this.sa, this.vb = t, this.wb = i, this.xb = s, t = h.o * this.Ab + h.f * this.Bb + h.h * this.Cb, i = h.i * this.Ab + h.m * this.Bb + h.j * this.Cb, s = h.l * this.Ab + h.g * this.Bb + h.s * this.Cb, this.He = t, this.Ie = i, this.Je = s, t = h.o * this.lc + h.f * this.mc + h.h * this.nc, i = h.i * this.lc + h.m * this.mc + h.j * this.nc, h = h.l * this.lc + h.g * this.mc + h.s * this.nc, this.Hh = t, this.Ih = i, this.Jh = h, h = a.o * this.nb + a.f * this.ob + a.h * this.pb, t = a.i * this.nb + a.m * this.ob + a.j * this.pb, i = a.l * this.nb + a.g * this.ob + a.s * this.pb, this.bc = h, this.cc = t, this.dc = i, h = a.o * this.gh + a.f * this.hh + a.h * this.ih, t = a.i * this.gh + a.m * this.hh + a.j * this.ih, i = a.l * this.gh + a.g * this.hh + a.s * this.ih, this.ve = h, this.we = t, this.xe = i, h = a.o * this.Mc + a.f * this.Nc + a.h * this.Oc, t = a.i * this.Mc + a.m * this.Nc + a.j * this.Oc, a = a.l * this.Mc + a.g * this.Nc + a.s * this.Oc, this.ah = h, this.bh = t, this.dh = a;

	}, $d: function ( t, i ) {

		i.Qe = this.C, i.Re = this.D, i.Ka = 0;

	}, gd: function ( t ) {

		t.Qe = this.C, t.Re = this.D, t.Ka = 0;

	}, Rl: function () {

		var t = this.Pi * this.Pi + this.Qi * this.Qi + this.Ri * this.Ri, i = this.Si * this.Si + this.Ti * this.Ti + this.Ui * this.Ui; 0 < this.Yi && t > this.Yi * this.Yi ? ( this.oc.Kl( this ), this.component.dispatchEvent( { type: 'break', force: Math.sqrt( t ) } ) ) : 0 < this.Zi && i > this.Zi * this.Zi && ( this.oc.Kl( this ), this.component.dispatchEvent( { type: 'break', torque: Math.sqrt( i ) } ) );

	}, ue: function () {

		return this.C;

	}, Ue: function () {

		return this.D;

	}, Tg: function () {

		return this.Lb;

	}, cb: function () {

		var t = new dt(); return t.x = this.Of, t.y = this.Pf, t.z = this.Qf, t;

	}, Mb: function () {

		var t = new dt(); return t.x = this.Rf, t.y = this.Sf, t.z = this.Tf, t;

	}, Hb: function ( t ) {

		t.x = this.Of, t.y = this.Pf, t.z = this.Qf;

	}, pc: function ( t ) {

		t.x = this.Rf, t.y = this.Sf, t.z = this.Tf;

	}, pe: function () {

		var t = new dt(); return t.x = this.dj, t.y = this.ej, t.z = this.fj, t;

	}, re: function () {

		var t = new dt(); return t.x = this.gj, t.y = this.hj, t.z = this.ij, t;

	}, qe: function ( t ) {

		t.x = this.dj, t.y = this.ej, t.z = this.fj;

	}, se: function ( t ) {

		t.x = this.gj, t.y = this.hj, t.z = this.ij;

	}, Ec: function () {

		var t, i, s, h, a, e, o, r, n, p = new ft(); return t = this.vb, i = this.He, s = this.Hh, h = this.wb, a = this.Ie, e = this.Ih, o = this.xb, r = this.Je, n = this.Jh, p.e00 = t, p.e01 = i, p.e02 = s, p.e10 = h, p.e11 = a, p.e12 = e, p.e20 = o, p.e21 = r, p.e22 = n, p;

	}, Kc: function () {

		var t, i, s, h, a, e, o, r, n, p = new ft(); return t = this.bc, i = this.ve, s = this.ah, h = this.cc, a = this.we, e = this.bh, o = this.dc, r = this.xe, n = this.dh, p.e00 = t, p.e01 = i, p.e02 = s, p.e10 = h, p.e11 = a, p.e12 = e, p.e20 = o, p.e21 = r, p.e22 = n, p;

	}, Jc: function ( t ) {

		var i, s, h, a, e, o, r, n, p; i = this.vb, s = this.He, h = this.Hh, a = this.wb, e = this.Ie, o = this.Ih, r = this.xb, n = this.Je, p = this.Jh, t.e00 = i, t.e01 = s, t.e02 = h, t.e10 = a, t.e11 = e, t.e12 = o, t.e20 = r, t.e21 = n, t.e22 = p;

	}, Lc: function ( t ) {

		var i, s, h, a, e, o, r, n, p; i = this.bc, s = this.ve, h = this.ah, a = this.cc, e = this.we, o = this.bh, r = this.dc, n = this.xe, p = this.dh, t.e00 = i, t.e01 = s, t.e02 = h, t.e10 = a, t.e11 = e, t.e12 = o, t.e20 = r, t.e21 = n, t.e22 = p;

	}, ua: function () {

		return this.Ak;

	}, Ug: function ( t ) {

		this.Ak = t;

	}, fd: function () {

		return this.Yi;

	}, Vg: function ( t ) {

		this.Yi = t;

	}, Yd: function () {

		return this.Zi;

	}, Wg: function ( t ) {

		this.Zi = t;

	}, te: function () {

		return this.Hc;

	}, Xg: function ( t ) {

		switch ( t ) {

			case 0:case 1:case 2:break; default:throw Error( 'invalid position correction algorithm id: ' + t );

		}

		this.Hc = t;

	}, qc: function () {

		var t = new dt(); return t.x = this.Pi, t.y = this.Qi, t.z = this.Ri, t;

	}, uc: function ( t ) {

		t.x = this.Pi, t.y = this.Qi, t.z = this.Ri;

	}, vc: function () {

		var t = new dt(); return t.x = this.Si, t.y = this.Ti, t.z = this.Ui, t;

	}, Ac: function ( t ) {

		t.x = this.Si, t.y = this.Ti, t.z = this.Ui;

	}, Mf: function () {

		return this.ia;

	}, Ve: function () {

		return this.M;

	} }, L.ua = F, L.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		var h, a, e, o, r, n, p, l, c, y, f, u, b = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0, v = this.Df * b, g = this.Ef * b, x = this.Ee * b; b = this.Fe * b; h = - this.Ub, a = this.Tb, e = this.Ub, o = - this.Sb, r = - this.Tb, n = this.Sb, p = - this.Xb, l = this.Wb, c = this.Xb, y = - this.Vb, f = - this.Wb, u = this.Vb; var d, z = 1 / ( this.C.$a + this.D.$a ), m = this.da.cd, j = this.da.dd, M = this.da.ed, A = ( this.C.P * m + this.C.R * j + this.C.S * M ) * m + ( this.C.T * m + this.C.U * j + this.C.V * M ) * j + ( this.C.W * m + this.C.X * j + this.C.Y * M ) * M; if ( d = ( this.D.P * m + this.D.R * j + this.D.S * M ) * m + ( this.D.T * m + this.D.U * j + this.D.V * M ) * j + ( this.D.W * m + this.D.X * j + this.D.Y * M ) * M, 0 < A ) {

			var w = m * this.Sb + j * this.Tb + M * this.Ub; 0 < ( w = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - w * w ) && ( A = 0 < this.C.$a ? 1 / ( 1 / A + this.C.Pc * w ) : 0 );

		}

		if ( 0 < d && ( m = m * this.Vb + j * this.Wb + M * this.Xb, 0 < ( m = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - m * m ) && ( d = 0 < this.D.$a ? 1 / ( 1 / d + this.D.Pc * m ) : 0 ) ), A = A + d ? 1 / ( A + d ) : 0, 0 >= this.dl.frequency || ! s ) {

			d = this.Pb[ 0 ], ( j = ( m = t.rows[ t.Ka ++ ] ).Aa ).va = 0, j.wa = 0, j.xa = 0, j.Ba = 0, j.Ca = 0, j.Da = 0, j.aa = 0, j.ba = 0, j.ca = 0, j.ea = 0, j.fa = 0, j.ga = 0, m.Fa = 0, m.Ma = 0, m.Ia = 0, m.Ha = 0, m.motorSpeed = 0, m.fb = 0, m.ta = null, m.ta = d, d = m; var D; m = this.eg, w = this.cl, M = this.dl, j = gt.linearSlop; if ( s )M = 0, D = 1; else {

				if ( 0 < M.frequency ) {

					j = 0; var C = 6.28318530717958 * M.frequency; ( B = M.dampingRatio ) < gt.minSpringDamperDampingRatio && ( B = gt.minSpringDamperDampingRatio ), D = i.dt, B = 2 * B * C, C *= C, M.useSymplecticEuler ? ( M = 1 / ( D * B ), D = C / B ) : ( M = 1 / ( D * ( D * C + B ) ), D = C / ( D * C + B ) );

				} else M = 0, D = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; 0 < w.motorForce ? ( d.motorSpeed = w.motorSpeed, d.fb = w.motorForce * i.dt ) : ( d.motorSpeed = 0, d.fb = 0 );

			}

			var B = w.lowerLimit, q = w.upperLimit; B > q ? m = C = w = 0 : B == q ? ( w = - 1 / 0, C = 1 / 0, m -= B ) : m < B ? ( w = - 1 / 0, C = 0, 0 < ( m = m - B + j ) && ( m = 0 ) ) : m > q ? ( w = 0, C = 1 / 0, 0 > ( m = m - q - j ) && ( m = 0 ) ) : m = C = w = 0, d.Ia = w, d.Ha = C, d.Ma = M * ( z ? 1 / z : 0 ), d.Fa = m * D, ( d = d.Aa ).va = this.da.cd, d.wa = this.da.dd, d.xa = this.da.ed, d.Ba = this.da.cd, d.Ca = this.da.dd, d.Da = this.da.ed, d.aa = - 0, d.ba = - h, d.ca = - a, d.ea = - 0, d.fa = - p, d.ga = - l;

		}

		d = this.Pb[ 1 ], ( a = ( h = t.rows[ t.Ka ++ ] ).Aa ).va = 0, a.wa = 0, a.xa = 0, a.Ba = 0, a.Ca = 0, a.Da = 0, a.aa = 0, a.ba = 0, a.ca = 0, a.ea = 0, a.fa = 0, a.ga = 0, h.Fa = 0, h.Ma = 0, h.Ia = 0, h.Ha = 0, h.motorSpeed = 0, h.fb = 0, h.ta = d, ( d = h ).Fa = v, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).va = this.da.Qd, d.wa = this.da.Rd, d.xa = this.da.Sd, d.Ba = this.da.Qd, d.Ca = this.da.Rd, d.Da = this.da.Sd, d.aa = - e, d.ba = - 0, d.ca = - o, d.ea = - c, d.fa = - 0, d.ga = - y, v = this.Pb[ 2 ], ( e = ( d = t.rows[ t.Ka ++ ] ).Aa ).va = 0, e.wa = 0, e.xa = 0, e.Ba = 0, e.Ca = 0, e.Da = 0, e.aa = 0, e.ba = 0, e.ca = 0, e.ea = 0, e.fa = 0, e.ga = 0, d.Fa = 0, d.Ma = 0, d.Ia = 0, d.Ha = 0, d.motorSpeed = 0, d.fb = 0, d.ta = v, d.Fa = g, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).va = this.da.me, d.wa = this.da.ne, d.xa = this.da.oe, d.Ba = this.da.me, d.Ca = this.da.ne, d.Da = this.da.oe, d.aa = - r, d.ba = - n, d.ca = - 0, d.ea = - f, d.fa = - u, d.ga = - 0, ( 0 >= this.Xk.frequency || ! s ) && ( g = this.Pb[ 3 ], ( n = ( r = t.rows[ t.Ka ++ ] ).Aa ).va = 0, n.wa = 0, n.xa = 0, n.Ba = 0, n.Ca = 0, n.Da = 0, n.aa = 0, n.ba = 0, n.ca = 0, n.ea = 0, n.fa = 0, n.ga = 0, r.Fa = 0, r.Ma = 0, r.Ia = 0, r.Ha = 0, r.motorSpeed = 0, r.fb = 0, r.ta = g, d = r, g = this.angle, n = this.Wk, f = this.Xk, r = gt.angularSlop, s ? ( s = 0, f = 1 ) : ( 0 < f.frequency ? ( r = 0, s = 6.28318530717958 * f.frequency, ( v = f.dampingRatio ) < gt.minSpringDamperDampingRatio && ( v = gt.minSpringDamperDampingRatio ), u = i.dt, v = 2 * v * s, e = s * s, f.useSymplecticEuler ? ( s = 1 / ( u * v ), f = e / v ) : ( s = 1 / ( u * ( u * e + v ) ), f = e / ( u * e + v ) ) ) : ( s = 0, f = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0 ), 0 < n.motorTorque ? ( d.motorSpeed = n.motorSpeed, d.fb = n.motorTorque * i.dt ) : ( d.motorSpeed = 0, d.fb = 0 ) ), g = ( ( g - ( u = .5 * ( ( i = n.lowerLimit ) + ( n = n.upperLimit ) ) ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979 + u, i > n ? i = v = u = 0 : i == n ? ( u = - 1 / 0, v = 1 / 0, i = g - i ) : g < i ? ( u = - 1 / 0, v = 0, 0 < ( i = g - i + r ) && ( i = 0 ) ) : g > n ? ( u = 0, v = 1 / 0, 0 > ( i = g - n - r ) && ( i = 0 ) ) : i = v = u = 0, d.Ia = u, d.Ha = v, d.Ma = s * ( A ? 1 / A : 0 ), d.Fa = i * f, ( d = d.Aa ).aa = this.da.cd, d.ba = this.da.dd, d.ca = this.da.ed, d.ea = this.da.cd, d.fa = this.da.dd, d.ga = this.da.ed ), i = this.Pb[ 4 ], ( s = ( A = t.rows[ t.Ka ++ ] ).Aa ).va = 0, s.wa = 0, s.xa = 0, s.Ba = 0, s.Ca = 0, s.Da = 0, s.aa = 0, s.ba = 0, s.ca = 0, s.ea = 0, s.fa = 0, s.ga = 0, A.Fa = 0, A.Ma = 0, A.Ia = 0, A.Ha = 0, A.motorSpeed = 0, A.fb = 0, A.ta = i, ( d = A ).Fa = x, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).aa = this.da.Qd, d.ba = this.da.Rd, d.ca = this.da.Sd, d.ea = this.da.Qd, d.fa = this.da.Rd, d.ga = this.da.Sd, x = this.Pb[ 5 ], ( i = ( t = t.rows[ t.Ka ++ ] ).Aa ).va = 0, i.wa = 0, i.xa = 0, i.Ba = 0, i.Ca = 0, i.Da = 0, i.aa = 0, i.ba = 0, i.ca = 0, i.ea = 0, i.fa = 0, i.ga = 0, t.Fa = 0, t.Ma = 0, t.Ia = 0, t.Ha = 0, t.motorSpeed = 0, t.fb = 0, t.ta = x, ( d = t ).Fa = b, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).aa = this.da.me, d.ba = this.da.ne, d.ca = this.da.oe, d.ea = this.da.me, d.fa = this.da.ne, d.ga = this.da.oe;

	}, hd: function () {

		F.prototype.hd.call( this ); var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O, L, P, R = this.da, J = R.$.C.$a, N = R.$.D.$a; if ( - .999999999 > ( tt = R.$.vb * R.$.bc + R.$.wb * R.$.cc + R.$.xb * R.$.dc ) ) {

			var H, K, G, V, E = R.$.vb, U = R.$.wb, W = R.$.xb, Y = E * E, X = U * U, $ = W * W; Y < X ? Y < $ ? ( H = 0, K = W * ( V = 1 / Math.sqrt( X + $ ) ), G = - U * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ) : X < $ ? ( H = - W * ( V = 1 / Math.sqrt( $ + Y ) ), K = 0, G = E * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ), t = H, i = K, s = G, h = 0;

		} else {

			var Z, Q, _; Z = R.$.wb * R.$.dc - R.$.xb * R.$.cc, Q = R.$.xb * R.$.bc - R.$.vb * R.$.dc, _ = R.$.vb * R.$.cc - R.$.wb * R.$.bc; var tt, it = Math.sqrt( .5 * ( 1 + tt ) ); t = Z *= tt = .5 / it, i = Q *= tt, s = _ *= tt, h = it;

		}

		k = S = q = 0; var st = q * ( T = t ) + S * ( O = i ) + k * ( L = s ) + ( I = 1 ) * ( P = h ); if ( 0 > st && ( st = - st, T = - T, O = - O, L = - L, P = - P ), .999999 < st ) {

			var ht = ( T = q + J / ( J + N ) * ( T - q ) ) * T + ( O = S + J / ( J + N ) * ( O - S ) ) * O + ( L = k + J / ( J + N ) * ( L - k ) ) * L + ( P = I + J / ( J + N ) * ( P - I ) ) * P; 1e-32 < ht && ( ht = 1 / Math.sqrt( ht ) ), a = T * ht, e = O * ht, o = L * ht, r = P * ht;

		} else {

			var at = J / ( J + N ) * Math.acos( st ), et = ( T += q * - st ) * T + ( O += S * - st ) * O + ( L += k * - st ) * L + ( P += I * - st ) * P; 1e-32 < et && ( et = 1 / Math.sqrt( et ) ), T *= et, O *= et, L *= et, P *= et; var ot = Math.sin( at ), rt = Math.cos( at ); a = ( q *= rt ) + T * ot, e = ( S *= rt ) + O * ot, o = ( k *= rt ) + L * ot, r = ( I *= rt ) + P * ot;

		}

		var nt, pt, lt = 2 * a, ct = 2 * e, yt = 2 * o, ft = a * lt, ut = e * ct, bt = o * yt, vt = a * ct, gt = e * yt, xt = a * yt, dt = r * lt, zt = r * ct, mt = r * yt; if ( n = vt - mt, p = xt + zt, l = vt + mt, c = 1 - ft - bt, y = gt - dt, f = xt - zt, u = gt + dt, b = 1 - ft - ut, nt = ( 1 - ut - bt ) * R.$.vb + n * R.$.wb + p * R.$.xb, pt = l * R.$.vb + c * R.$.wb + y * R.$.xb, v = f * R.$.vb + u * R.$.wb + b * R.$.xb, M = R.cd, A = R.dd, w = R.ed, D = R.Qd, C = R.Rd, B = R.Sd, - .999999999 > ( It = M * nt + A * pt + w * v ) ) {

			var jt, Mt, At, wt, Dt = M * M, Ct = A * A, Bt = w * w; Dt < Ct ? Dt < Bt ? ( jt = 0, Mt = w * ( wt = 1 / Math.sqrt( Ct + Bt ) ), At = - A * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ) : Ct < Bt ? ( jt = - w * ( wt = 1 / Math.sqrt( Bt + Dt ) ), Mt = 0, At = M * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ), a = jt, e = Mt, o = At, r = 0;

		} else {

			var qt, St, kt; qt = A * v - w * pt, St = w * nt - M * v, kt = M * pt - A * nt; var It, Tt = Math.sqrt( .5 * ( 1 + It ) ); a = qt *= It = .5 / Tt, e = St *= It, o = kt *= It, r = Tt;

		}

		var Ot, Lt, Ft, Pt = 2 * a, Rt = 2 * e, Jt = 2 * o, Nt = a * Pt, Ht = e * Rt, Kt = o * Jt, Gt = a * Rt, Vt = e * Jt, Et = a * Jt, Ut = r * Pt, Wt = r * Rt, Yt = r * Jt; if ( 1e-6 < ( z = pt * ( d = ( f = Et - Wt ) * D + ( u = Vt + Ut ) * C + ( b = 1 - Nt - Ht ) * B ) - v * ( x = ( l = Gt + Yt ) * D + ( c = 1 - Nt - Kt ) * C + ( y = Vt - Ut ) * B ) ) * z + ( m = v * ( g = ( 1 - Ht - Kt ) * D + ( n = Gt - Yt ) * C + ( p = Et + Wt ) * B ) - nt * d ) * m + ( j = nt * x - pt * g ) * j ) {

			var Xt = z * z + m * m + j * j; 0 < Xt && ( Xt = 1 / Math.sqrt( Xt ) ), z *= Xt, m *= Xt, j *= Xt;

		} else {

			var $t, Zt = nt * nt, Qt = pt * pt, _t = v * v; Zt < Qt ? Zt < _t ? ( z = 0, m = v * ( $t = 1 / Math.sqrt( Qt + _t ) ), j = - pt * $t ) : ( z = pt * ( $t = 1 / Math.sqrt( Zt + Qt ) ), m = - nt * $t, j = 0 ) : Qt < _t ? ( z = - v * ( $t = 1 / Math.sqrt( _t + Zt ) ), m = 0, j = nt * $t ) : ( z = pt * ( $t = 1 / Math.sqrt( Zt + Qt ) ), m = - nt * $t, j = 0 );

		}

		g = m * v - j * pt, x = j * nt - z * v, d = z * pt - m * nt, R.cd = nt, R.dd = pt, R.ed = v, R.Qd = g, R.Rd = x, R.Sd = d, R.me = z, R.ne = m, R.oe = j, Ot = this.wb * this.dc - this.xb * this.cc, Lt = this.xb * this.bc - this.vb * this.dc, Ft = this.vb * this.cc - this.wb * this.bc; var ti, ii, si, hi, ai, ei, oi = this.vb * this.bc + this.wb * this.cc + this.xb * this.dc, ri = - 1 >= oi ? 3.14159265358979 : 1 <= oi ? 0 : Math.acos( oi ), ni = Ot * Ot + Lt * Lt + Ft * Ft; 0 < ni && ( ni = 1 / Math.sqrt( ni ) ), Ot *= ni, Lt *= ni, Ft *= ni, Ot *= ri, Lt *= ri, Ft *= ri, this.Ee = Ot * this.da.Qd + Lt * this.da.Rd + Ft * this.da.Sd, this.Fe = Ot * this.da.me + Lt * this.da.ne + Ft * this.da.oe, ti = this.Ie * this.xe - this.Je * this.we, ii = this.Je * this.ve - this.He * this.xe, si = this.He * this.we - this.Ie * this.ve, oi = this.He * this.ve + this.Ie * this.we + this.Je * this.xe, this.angle = - 1 >= oi ? 3.14159265358979 : 1 <= oi ? 0 : Math.acos( oi ), 0 > ti * this.da.cd + ii * this.da.dd + si * this.da.ed && ( this.angle = - this.angle ), hi = this.Rf - this.Of, ai = this.Sf - this.Pf, ei = this.Tf - this.Qf, this.eg = hi * this.da.cd + ai * this.da.dd + ei * this.da.ed, this.Df = hi * this.da.Qd + ai * this.da.Rd + ei * this.da.Sd, this.Ef = hi * this.da.me + ai * this.da.ne + ei * this.da.oe;

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Eg: function () {

		var t = new dt(); return t.x = this.vb, t.y = this.wb, t.z = this.xb, t;

	}, Gg: function () {

		var t = new dt(); return t.x = this.bc, t.y = this.cc, t.z = this.dc, t;

	}, Fg: function ( t ) {

		t.x = this.vb, t.y = this.wb, t.z = this.xb;

	}, Hg: function ( t ) {

		t.x = this.bc, t.y = this.cc, t.z = this.dc;

	}, Ig: function () {

		var t = new dt(); return t.x = this.qa, t.y = this.ra, t.z = this.sa, t;

	}, Kg: function () {

		var t = new dt(); return t.x = this.nb, t.y = this.ob, t.z = this.pb, t;

	}, Jg: function ( t ) {

		t.x = this.qa, t.y = this.ra, t.z = this.sa;

	}, Lg: function ( t ) {

		t.x = this.nb, t.y = this.ob, t.z = this.pb;

	}, In: function () {

		return this.dl;

	}, An: function () {

		return this.Xk;

	}, Hn: function () {

		return this.cl;

	}, zn: function () {

		return this.Wk;

	}, ol: function () {

		return this.angle;

	}, rl: function () {

		return this.eg;

	} } ), O.prototype = { fh: function ( t, i, s ) {

		this.rigidBody1 = t, this.rigidBody2 = i; var h, a, e, o = this.rigidBody1; h = s.x, a = s.y, e = s.z, h -= o.a.v, a -= o.a.A, e -= o.a.B, t = o.a.o * h + o.a.i * a + o.a.l * e, i = o.a.f * h + o.a.m * a + o.a.g * e, o = o.a.h * h + o.a.j * a + o.a.s * e, ( h = this.localAnchor1 ).x = t, h.y = i, h.z = o, i = this.rigidBody2, o = s.x, h = s.y, a = s.z, o -= i.a.v, h -= i.a.A, a -= i.a.B, s = i.a.o * o + i.a.i * h + i.a.l * a, t = i.a.f * o + i.a.m * h + i.a.g * a, i = i.a.h * o + i.a.j * h + i.a.s * a, ( o = this.localAnchor2 ).x = s, o.y = t, o.z = i;

	} }, T.ua = O, T.prototype = ri( O.prototype, { za: function ( t, i, s, h ) {

		var a, e, o, r; return this.fh( t, i, s ), a = h.x, e = h.y, o = h.z, s = t.a.o * a + t.a.i * e + t.a.l * o, r = t.a.f * a + t.a.m * e + t.a.g * o, t = t.a.h * a + t.a.j * e + t.a.s * o, ( a = this.localAxis1 ).x = s, a.y = r, a.z = t, r = h.x, t = h.y, a = h.z, h = i.a.o * r + i.a.i * t + i.a.l * a, s = i.a.f * r + i.a.m * t + i.a.g * a, i = i.a.h * r + i.a.j * t + i.a.s * a, ( r = this.localAxis2 ).x = h, r.y = s, r.z = i, this;

	} } ), S.prototype = { ua: function () {

		return this.Pk;

	}, Hb: function () {

		return this.Qc;

	}, Mb: function () {

		return this.ia;

	}, cb: function () {

		return this.M;

	} }, B.ua = F, B.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		var h, a, e, o, r, n, p, l, c, y, f, u, b, v, g = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0, x = this.Df * g, d = this.Ef * g, z = this.rh * g, m = this.Ee * g; g = this.Fe * g; if ( h = - this.Ub, a = this.Tb, e = this.Ub, o = - this.Sb, r = - this.Tb, n = this.Sb, p = - this.Xb, l = this.Wb, c = this.Xb, y = - this.Vb, f = - this.Wb, u = this.Vb, v = 1 / ( this.C.$a + this.D.$a ), 0 >= this.Ce.frequency || ! s ) {

			b = this.Pb[ 0 ], ( w = ( j = t.rows[ t.Ka ++ ] ).Aa ).va = 0, w.wa = 0, w.xa = 0, w.Ba = 0, w.Ca = 0, w.Da = 0, w.aa = 0, w.ba = 0, w.ca = 0, w.ea = 0, w.fa = 0, w.ga = 0, j.Fa = 0, j.Ma = 0, j.Ia = 0, j.Ha = 0, j.motorSpeed = 0, j.fb = 0, j.ta = b, b = j; var j = this.eg, M = this.Rh, A = this.Ce, w = gt.linearSlop; if ( s )A = 0, s = 1; else {

				if ( 0 < A.frequency ) {

					w = 0; var D = 6.28318530717958 * A.frequency, C = A.dampingRatio; C < gt.minSpringDamperDampingRatio && ( C = gt.minSpringDamperDampingRatio ), s = i.dt, C = 2 * C * D, D *= D, A.useSymplecticEuler ? ( A = 1 / ( s * C ), s = D / C ) : ( A = 1 / ( s * ( s * D + C ) ), s = D / ( s * D + C ) );

				} else A = 0, s = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; 0 < M.motorForce ? ( b.motorSpeed = M.motorSpeed, b.fb = M.motorForce * i.dt ) : ( b.motorSpeed = 0, b.fb = 0 );

			}

			( i = M.lowerLimit ) > ( D = M.upperLimit ) ? i = C = M = 0 : i == D ? ( M = - 1 / 0, C = 1 / 0, i = j - i ) : j < i ? ( M = - 1 / 0, C = 0, 0 < ( i = j - i + w ) && ( i = 0 ) ) : j > D ? ( M = 0, C = 1 / 0, 0 > ( i = j - D - w ) && ( i = 0 ) ) : i = C = M = 0, b.Ia = M, b.Ha = C, b.Ma = A * ( v ? 1 / v : 0 ), b.Fa = i * s, ( v = b.Aa ).va = this.da.cd, v.wa = this.da.dd, v.xa = this.da.ed, v.Ba = this.da.cd, v.Ca = this.da.dd, v.Da = this.da.ed, v.aa = - 0, v.ba = - h, v.ca = - a, v.ea = - 0, v.fa = - p, v.ga = - l;

		}

		h = this.Pb[ 1 ], ( p = ( a = t.rows[ t.Ka ++ ] ).Aa ).va = 0, p.wa = 0, p.xa = 0, p.Ba = 0, p.Ca = 0, p.Da = 0, p.aa = 0, p.ba = 0, p.ca = 0, p.ea = 0, p.fa = 0, p.ga = 0, a.Fa = 0, a.Ma = 0, a.Ia = 0, a.Ha = 0, a.motorSpeed = 0, a.fb = 0, a.ta = h, ( b = a ).Fa = x, b.Ma = 0, b.Ia = - 1 / 0, b.Ha = 1 / 0, ( v = b.Aa ).va = this.da.Qd, v.wa = this.da.Rd, v.xa = this.da.Sd, v.Ba = this.da.Qd, v.Ca = this.da.Rd, v.Da = this.da.Sd, v.aa = - e, v.ba = - 0, v.ca = - o, v.ea = - c, v.fa = - 0, v.ga = - y, x = this.Pb[ 2 ], ( o = ( e = t.rows[ t.Ka ++ ] ).Aa ).va = 0, o.wa = 0, o.xa = 0, o.Ba = 0, o.Ca = 0, o.Da = 0, o.aa = 0, o.ba = 0, o.ca = 0, o.ea = 0, o.fa = 0, o.ga = 0, e.Fa = 0, e.Ma = 0, e.Ia = 0, e.Ha = 0, e.motorSpeed = 0, e.fb = 0, e.ta = x, ( b = e ).Fa = d, b.Ma = 0, b.Ia = - 1 / 0, b.Ha = 1 / 0, ( v = b.Aa ).va = this.da.me, v.wa = this.da.ne, v.xa = this.da.oe, v.Ba = this.da.me, v.Ca = this.da.ne, v.Da = this.da.oe, v.aa = - r, v.ba = - n, v.ca = - 0, v.ea = - f, v.fa = - u, v.ga = - 0, d = this.Pb[ 3 ], ( n = ( r = t.rows[ t.Ka ++ ] ).Aa ).va = 0, n.wa = 0, n.xa = 0, n.Ba = 0, n.Ca = 0, n.Da = 0, n.aa = 0, n.ba = 0, n.ca = 0, n.ea = 0, n.fa = 0, n.ga = 0, r.Fa = 0, r.Ma = 0, r.Ia = 0, r.Ha = 0, r.motorSpeed = 0, r.fb = 0, r.ta = d, ( b = r ).Fa = z, b.Ma = 0, b.Ia = - 1 / 0, b.Ha = 1 / 0, ( v = b.Aa ).aa = 1, v.ba = 0, v.ca = 0, v.ea = 1, v.fa = 0, v.ga = 0, z = this.Pb[ 4 ], ( r = ( d = t.rows[ t.Ka ++ ] ).Aa ).va = 0, r.wa = 0, r.xa = 0, r.Ba = 0, r.Ca = 0, r.Da = 0, r.aa = 0, r.ba = 0, r.ca = 0, r.ea = 0, r.fa = 0, r.ga = 0, d.Fa = 0, d.Ma = 0, d.Ia = 0, d.Ha = 0, d.motorSpeed = 0, d.fb = 0, d.ta = z, ( b = d ).Fa = m, b.Ma = 0, b.Ia = - 1 / 0, b.Ha = 1 / 0, ( v = b.Aa ).aa = 0, v.ba = 1, v.ca = 0, v.ea = 0, v.fa = 1, v.ga = 0, m = this.Pb[ 5 ], ( z = ( t = t.rows[ t.Ka ++ ] ).Aa ).va = 0, z.wa = 0, z.xa = 0, z.Ba = 0, z.Ca = 0, z.Da = 0, z.aa = 0, z.ba = 0, z.ca = 0, z.ea = 0, z.fa = 0, z.ga = 0, t.Fa = 0, t.Ma = 0, t.Ia = 0, t.Ha = 0, t.motorSpeed = 0, t.fb = 0, t.ta = m, ( b = t ).Fa = g, b.Ma = 0, b.Ia = - 1 / 0, b.Ha = 1 / 0, ( v = b.Aa ).aa = 0, v.ba = 0, v.ca = 1, v.ea = 0, v.fa = 0, v.ga = 1;

	}, hd: function () {

		F.prototype.hd.call( this ); var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O, L, P, R = this.da, J = R.$.C.$a, N = R.$.D.$a; if ( - .999999999 > ( tt = R.$.vb * R.$.bc + R.$.wb * R.$.cc + R.$.xb * R.$.dc ) ) {

			var H, K, G, V, E = R.$.vb, U = R.$.wb, W = R.$.xb, Y = E * E, X = U * U, $ = W * W; Y < X ? Y < $ ? ( H = 0, K = W * ( V = 1 / Math.sqrt( X + $ ) ), G = - U * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ) : X < $ ? ( H = - W * ( V = 1 / Math.sqrt( $ + Y ) ), K = 0, G = E * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ), t = H, i = K, s = G, h = 0;

		} else {

			var Z, Q, _; Z = R.$.wb * R.$.dc - R.$.xb * R.$.cc, Q = R.$.xb * R.$.bc - R.$.vb * R.$.dc, _ = R.$.vb * R.$.cc - R.$.wb * R.$.bc; var tt, it = Math.sqrt( .5 * ( 1 + tt ) ); t = Z *= tt = .5 / it, i = Q *= tt, s = _ *= tt, h = it;

		}

		k = S = q = 0; var st = q * ( T = t ) + S * ( O = i ) + k * ( L = s ) + ( I = 1 ) * ( P = h ); if ( 0 > st && ( st = - st, T = - T, O = - O, L = - L, P = - P ), .999999 < st ) {

			var ht = ( T = q + J / ( J + N ) * ( T - q ) ) * T + ( O = S + J / ( J + N ) * ( O - S ) ) * O + ( L = k + J / ( J + N ) * ( L - k ) ) * L + ( P = I + J / ( J + N ) * ( P - I ) ) * P; 1e-32 < ht && ( ht = 1 / Math.sqrt( ht ) ), a = T * ht, e = O * ht, o = L * ht, r = P * ht;

		} else {

			var at = J / ( J + N ) * Math.acos( st ), et = ( T += q * - st ) * T + ( O += S * - st ) * O + ( L += k * - st ) * L + ( P += I * - st ) * P; 1e-32 < et && ( et = 1 / Math.sqrt( et ) ), T *= et, O *= et, L *= et, P *= et; var ot = Math.sin( at ), rt = Math.cos( at ); a = ( q *= rt ) + T * ot, e = ( S *= rt ) + O * ot, o = ( k *= rt ) + L * ot, r = ( I *= rt ) + P * ot;

		}

		var nt, pt, lt = 2 * a, ct = 2 * e, yt = 2 * o, ft = a * lt, ut = e * ct, bt = o * yt, vt = a * ct, gt = e * yt, xt = a * yt, dt = r * lt, zt = r * ct, mt = r * yt; if ( n = vt - mt, p = xt + zt, l = vt + mt, c = 1 - ft - bt, y = gt - dt, f = xt - zt, u = gt + dt, b = 1 - ft - ut, nt = ( 1 - ut - bt ) * R.$.vb + n * R.$.wb + p * R.$.xb, pt = l * R.$.vb + c * R.$.wb + y * R.$.xb, v = f * R.$.vb + u * R.$.wb + b * R.$.xb, M = R.cd, A = R.dd, w = R.ed, D = R.Qd, C = R.Rd, B = R.Sd, - .999999999 > ( It = M * nt + A * pt + w * v ) ) {

			var jt, Mt, At, wt, Dt = M * M, Ct = A * A, Bt = w * w; Dt < Ct ? Dt < Bt ? ( jt = 0, Mt = w * ( wt = 1 / Math.sqrt( Ct + Bt ) ), At = - A * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ) : Ct < Bt ? ( jt = - w * ( wt = 1 / Math.sqrt( Bt + Dt ) ), Mt = 0, At = M * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ), a = jt, e = Mt, o = At, r = 0;

		} else {

			var qt, St, kt; qt = A * v - w * pt, St = w * nt - M * v, kt = M * pt - A * nt; var It, Tt = Math.sqrt( .5 * ( 1 + It ) ); a = qt *= It = .5 / Tt, e = St *= It, o = kt *= It, r = Tt;

		}

		var Ot, Lt, Ft, Pt, Rt, Jt, Nt, Ht, Kt, Gt, Vt, Et, Ut, Wt, Yt, Xt, $t, Zt, Qt, _t, ti, ii, si, hi, ai, ei, oi = 2 * a, ri = 2 * e, ni = 2 * o, pi = a * oi, li = e * ri, ci = o * ni, yi = a * ri, fi = e * ni, ui = a * ni, bi = r * oi, vi = r * ri, gi = r * ni; if ( 1e-6 < ( z = pt * ( d = ( f = ui - vi ) * D + ( u = fi + bi ) * C + ( b = 1 - pi - li ) * B ) - v * ( x = ( l = yi + gi ) * D + ( c = 1 - pi - ci ) * C + ( y = fi - bi ) * B ) ) * z + ( m = v * ( g = ( 1 - li - ci ) * D + ( n = yi - gi ) * C + ( p = ui + vi ) * B ) - nt * d ) * m + ( j = nt * x - pt * g ) * j ) {

			var xi = z * z + m * m + j * j; 0 < xi && ( xi = 1 / Math.sqrt( xi ) ), z *= xi, m *= xi, j *= xi;

		} else {

			var di, zi = nt * nt, mi = pt * pt, ji = v * v; zi < mi ? zi < ji ? ( z = 0, m = v * ( di = 1 / Math.sqrt( mi + ji ) ), j = - pt * di ) : ( z = pt * ( di = 1 / Math.sqrt( zi + mi ) ), m = - nt * di, j = 0 ) : mi < ji ? ( z = - v * ( di = 1 / Math.sqrt( ji + zi ) ), m = 0, j = nt * di ) : ( z = pt * ( di = 1 / Math.sqrt( zi + mi ) ), m = - nt * di, j = 0 );

		}

		g = m * v - j * pt, x = j * nt - z * v, d = z * pt - m * nt, R.cd = nt, R.dd = pt, R.ed = v, R.Qd = g, R.Rd = x, R.Sd = d, R.me = z, R.ne = m, R.oe = j, Ot = this.vb, Lt = this.He, Ft = this.Hh, Pt = this.wb, Rt = this.Ie, Jt = this.Ih, Nt = this.xb, Ht = this.Je, Kt = this.Jh, _t = ( Gt = this.bc ) * Pt + ( Vt = this.ve ) * Rt + ( Et = this.ah ) * Jt, ti = Gt * Nt + Vt * Ht + Et * Kt, ii = ( Ut = this.cc ) * Ot + ( Wt = this.we ) * Lt + ( Yt = this.bh ) * Ft, hi = Ut * Nt + Wt * Ht + Yt * Kt, ai = ( Xt = this.dc ) * Ot + ( $t = this.xe ) * Lt + ( Zt = this.dh ) * Ft, ei = Xt * Pt + $t * Rt + Zt * Jt; var Mi, Ai, wi, Di, Ci, Bi = Xt * Nt + $t * Ht + Zt * Kt, qi = ( Qt = Gt * Ot + Vt * Lt + Et * Ft ) + ( si = Ut * Pt + Wt * Rt + Yt * Jt ) + Bi; 0 < qi ? ( Di = .5 * ( Ci = Math.sqrt( qi + 1 ) ), Mi = ( ei - hi ) * ( Ci = .5 / Ci ), Ai = ( ti - ai ) * Ci, wi = ( ii - _t ) * Ci ) : Qt > si ? Qt > Bi ? ( Mi = .5 * ( Ci = Math.sqrt( Qt - si - Bi + 1 ) ), Ai = ( _t + ii ) * ( Ci = .5 / Ci ), wi = ( ti + ai ) * Ci, Di = ( ei - hi ) * Ci ) : ( wi = .5 * ( Ci = Math.sqrt( Bi - Qt - si + 1 ) ), Mi = ( ti + ai ) * ( Ci = .5 / Ci ), Ai = ( hi + ei ) * Ci, Di = ( ii - _t ) * Ci ) : si > Bi ? ( Ai = .5 * ( Ci = Math.sqrt( si - Bi - Qt + 1 ) ), Mi = ( _t + ii ) * ( Ci = .5 / Ci ), wi = ( hi + ei ) * Ci, Di = ( ti - ai ) * Ci ) : ( wi = .5 * ( Ci = Math.sqrt( Bi - Qt - si + 1 ) ), Mi = ( ti + ai ) * ( Ci = .5 / Ci ), Ai = ( hi + ei ) * Ci, Di = ( ii - _t ) * Ci ); var Si = Di, ki = 2 * ( - 1 >= Si ? 3.14159265358979 : 1 <= Si ? 0 : Math.acos( Si ) ); this.rh = Mi, this.Ee = Ai, this.Fe = wi; var Ii, Ti, Oi, Li = this.rh * this.rh + this.Ee * this.Ee + this.Fe * this.Fe; 0 < Li && ( Li = 1 / Math.sqrt( Li ) ), this.rh *= Li, this.Ee *= Li, this.Fe *= Li, this.rh *= ki, this.Ee *= ki, this.Fe *= ki, Ii = this.Rf - this.Of, Ti = this.Sf - this.Pf, Oi = this.Tf - this.Qf, this.eg = Ii * this.da.cd + Ti * this.da.dd + Oi * this.da.ed, this.Df = Ii * this.da.Qd + Ti * this.da.Rd + Oi * this.da.Sd, this.Ef = Ii * this.da.me + Ti * this.da.ne + Oi * this.da.oe;

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Eg: function () {

		var t = new dt(); return t.x = this.vb, t.y = this.wb, t.z = this.xb, t;

	}, Gg: function () {

		var t = new dt(); return t.x = this.bc, t.y = this.cc, t.z = this.dc, t;

	}, Fg: function ( t ) {

		t.x = this.vb, t.y = this.wb, t.z = this.xb;

	}, Hg: function ( t ) {

		t.x = this.bc, t.y = this.cc, t.z = this.dc;

	}, Ig: function () {

		var t = new dt(); return t.x = this.qa, t.y = this.ra, t.z = this.sa, t;

	}, Kg: function () {

		var t = new dt(); return t.x = this.nb, t.y = this.ob, t.z = this.pb, t;

	}, Jg: function ( t ) {

		t.x = this.qa, t.y = this.ra, t.z = this.sa;

	}, Lg: function ( t ) {

		t.x = this.nb, t.y = this.ob, t.z = this.pb;

	}, Cj: function () {

		return this.Ce;

	}, ql: function () {

		return this.Rh;

	}, rl: function () {

		return this.eg;

	} } ), C.ua = O, C.prototype = ri( O.prototype, { za: function ( t, i, s, h ) {

		var a, e, o, r; return this.fh( t, i, s ), a = h.x, e = h.y, o = h.z, s = t.a.o * a + t.a.i * e + t.a.l * o, r = t.a.f * a + t.a.m * e + t.a.g * o, t = t.a.h * a + t.a.j * e + t.a.s * o, ( a = this.localAxis1 ).x = s, a.y = r, a.z = t, r = h.x, t = h.y, a = h.z, h = i.a.o * r + i.a.i * t + i.a.l * a, s = i.a.f * r + i.a.m * t + i.a.g * a, i = i.a.h * r + i.a.j * t + i.a.s * a, ( r = this.localAxis2 ).x = h, r.y = s, r.z = i, this;

	} } ), D.ua = F, D.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		var h, a, e = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; h = this.Mj * e, a = this.Df * e; var o, r, n, p, l, c, y, f, u, b, v, g, x = this.Ef * e; o = - this.Ub, r = this.Tb, n = this.Ub, p = - this.Sb, l = - this.Tb, c = this.Sb, y = - this.Xb, f = this.Wb, u = this.Xb, b = - this.Vb, v = - this.Wb, g = this.Vb; var d = this.je, z = this.ke, m = this.le, j = ( e = ( this.C.P * d + this.C.R * z + this.C.S * m ) * d + ( this.C.T * d + this.C.U * z + this.C.V * m ) * z + ( this.C.W * d + this.C.X * z + this.C.Y * m ) * m, ( this.D.P * d + this.D.R * z + this.D.S * m ) * d + ( this.D.T * d + this.D.U * z + this.D.V * m ) * z + ( this.D.W * d + this.D.X * z + this.D.Y * m ) * m ); if ( 0 < e ) {

			var M = d * this.Sb + z * this.Tb + m * this.Ub; 0 < ( M = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - M * M ) && ( e = 0 < this.C.$a ? 1 / ( 1 / e + this.C.Pc * M ) : 0 );

		}

		if ( 0 < j && ( d = d * this.Vb + z * this.Wb + m * this.Xb, 0 < ( d = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - d * d ) && ( j = 0 < this.D.$a ? 1 / ( 1 / j + this.D.Pc * d ) : 0 ) ), j = e + j ? 1 / ( e + j ) : 0, z = this.bc, m = this.cc, M = this.dc, e = ( this.C.P * z + this.C.R * m + this.C.S * M ) * z + ( this.C.T * z + this.C.U * m + this.C.V * M ) * m + ( this.C.W * z + this.C.X * m + this.C.Y * M ) * M, d = ( this.D.P * z + this.D.R * m + this.D.S * M ) * z + ( this.D.T * z + this.D.U * m + this.D.V * M ) * m + ( this.D.W * z + this.D.X * m + this.D.Y * M ) * M, 0 < e ) {

			var A = z * this.Sb + m * this.Tb + M * this.Ub; 0 < ( A = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - A * A ) && ( e = 0 < this.C.$a ? 1 / ( 1 / e + this.C.Pc * A ) : 0 );

		}

		0 < d && ( z = z * this.Vb + m * this.Wb + M * this.Xb, 0 < ( z = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - z * z ) && ( d = 0 < this.D.$a ? 1 / ( 1 / d + this.D.Pc * z ) : 0 ) ), e = e + d ? 1 / ( e + d ) : 0, d = this.Pb[ 0 ], ( m = ( z = t.rows[ t.Ka ++ ] ).Aa ).va = 0, m.wa = 0, m.xa = 0, m.Ba = 0, m.Ca = 0, m.Da = 0, m.aa = 0, m.ba = 0, m.ca = 0, m.ea = 0, m.fa = 0, m.ga = 0, z.Fa = 0, z.Ma = 0, z.Ia = 0, z.Ha = 0, z.motorSpeed = 0, z.fb = 0, z.ta = d, ( d = z ).Fa = h, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).va = 1, d.wa = 0, d.xa = 0, d.Ba = 1, d.Ca = 0, d.Da = 0, d.aa = - 0, d.ba = - o, d.ca = - r, d.ea = - 0, d.fa = - y, d.ga = - f, d = this.Pb[ 1 ], ( o = ( h = t.rows[ t.Ka ++ ] ).Aa ).va = 0, o.wa = 0, o.xa = 0, o.Ba = 0, o.Ca = 0, o.Da = 0, o.aa = 0, o.ba = 0, o.ca = 0, o.ea = 0, o.fa = 0, o.ga = 0, h.Fa = 0, h.Ma = 0, h.Ia = 0, h.Ha = 0, h.motorSpeed = 0, h.fb = 0, h.ta = d, ( d = h ).Fa = a, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).va = 0, d.wa = 1, d.xa = 0, d.Ba = 0, d.Ca = 1, d.Da = 0, d.aa = - n, d.ba = - 0, d.ca = - p, d.ea = - u, d.fa = - 0, d.ga = - b, d = this.Pb[ 2 ], ( n = ( a = t.rows[ t.Ka ++ ] ).Aa ).va = 0, n.wa = 0, n.xa = 0, n.Ba = 0, n.Ca = 0, n.Da = 0, n.aa = 0, n.ba = 0, n.ca = 0, n.ea = 0, n.fa = 0, n.ga = 0, a.Fa = 0, a.Ma = 0, a.Ia = 0, a.Ha = 0, a.motorSpeed = 0, a.fb = 0, a.ta = d, ( d = a ).Fa = x, d.Ma = 0, d.Ia = - 1 / 0, d.Ha = 1 / 0, ( d = d.Aa ).va = 0, d.wa = 0, d.xa = 1, d.Ba = 0, d.Ca = 0, d.Da = 1, d.aa = - l, d.ba = - c, d.ca = - 0, d.ea = - v, d.fa = - g, d.ga = - 0, 0 < this.Nj && ( 0 >= this.$k.frequency || ! s ) && ( d = this.Pb[ 3 ], ( l = ( x = t.rows[ t.Ka ++ ] ).Aa ).va = 0, l.wa = 0, l.xa = 0, l.Ba = 0, l.Ca = 0, l.Da = 0, l.aa = 0, l.ba = 0, l.ca = 0, l.ea = 0, l.fa = 0, l.ga = 0, x.Fa = 0, x.Ma = 0, x.Ia = 0, x.Ha = 0, x.motorSpeed = 0, x.fb = 0, x.ta = d, d = x, x = this.Nj, v = this.nl, c = this.$k, l = gt.angularSlop, s ? ( c = 0, g = 1 ) : ( 0 < c.frequency ? ( l = 0, n = 6.28318530717958 * c.frequency, ( a = c.dampingRatio ) < gt.minSpringDamperDampingRatio && ( a = gt.minSpringDamperDampingRatio ), g = i.dt, a = 2 * a * n, n *= n, c.useSymplecticEuler ? ( c = 1 / ( g * a ), g = n / a ) : ( c = 1 / ( g * ( g * n + a ) ), g = n / ( g * n + a ) ) ) : ( c = 0, g = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0 ), 0 < v.motorTorque ? ( d.motorSpeed = v.motorSpeed, d.fb = v.motorTorque * i.dt ) : ( d.motorSpeed = 0, d.fb = 0 ) ), x = ( ( x - ( n = .5 * ( ( a = v.lowerLimit ) + ( v = v.upperLimit ) ) ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979, x += n, a > v ? x = p = n = 0 : a == v ? ( n = - 1 / 0, p = 1 / 0, x -= a ) : x < a ? ( n = - 1 / 0, p = 0, 0 < ( x = x - a + l ) && ( x = 0 ) ) : x > v ? ( n = 0, p = 1 / 0, 0 > ( x = x - v - l ) && ( x = 0 ) ) : x = p = n = 0, d.Ia = n, d.Ha = p, d.Ma = c * ( j ? 1 / j : 0 ), d.Fa = x * g, ( d = d.Aa ).aa = this.je, d.ba = this.ke, d.ca = this.le, d.ea = this.je, d.fa = this.ke, d.ga = this.le ), ( 0 >= this.fl.frequency || ! s ) && ( j = this.Pb[ 4 ], ( d = ( t = t.rows[ t.Ka ++ ] ).Aa ).va = 0, d.wa = 0, d.xa = 0, d.Ba = 0, d.Ca = 0, d.Da = 0, d.aa = 0, d.ba = 0, d.ca = 0, d.ea = 0, d.fa = 0, d.ga = 0, t.Fa = 0, t.Ma = 0, t.Ia = 0, t.Ha = 0, t.motorSpeed = 0, t.fb = 0, t.ta = j, d = t, t = this.tj, x = this.el, l = this.fl, j = gt.angularSlop, s ? ( s = 0, l = 1 ) : ( 0 < l.frequency ? ( j = 0, s = 6.28318530717958 * l.frequency, ( v = l.dampingRatio ) < gt.minSpringDamperDampingRatio && ( v = gt.minSpringDamperDampingRatio ), c = i.dt, v = 2 * v * s, g = s * s, l.useSymplecticEuler ? ( s = 1 / ( c * v ), l = g / v ) : ( s = 1 / ( c * ( c * g + v ) ), l = g / ( c * g + v ) ) ) : ( s = 0, l = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0 ), 0 < x.motorTorque ? ( d.motorSpeed = x.motorSpeed, d.fb = x.motorTorque * i.dt ) : ( d.motorSpeed = 0, d.fb = 0 ) ), t = ( ( t - ( c = .5 * ( ( i = x.lowerLimit ) + ( x = x.upperLimit ) ) ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979, t += c, i > x ? i = v = c = 0 : i == x ? ( c = - 1 / 0, v = 1 / 0, i = t - i ) : t < i ? ( c = - 1 / 0, v = 0, 0 < ( i = t - i + j ) && ( i = 0 ) ) : t > x ? ( c = 0, v = 1 / 0, 0 > ( i = t - x - j ) && ( i = 0 ) ) : i = v = c = 0, d.Ia = c, d.Ha = v, d.Ma = s * ( e ? 1 / e : 0 ), d.Fa = i * l, ( d = d.Aa ).aa = this.gi, d.ba = this.hi, d.ca = this.ii, d.ea = this.gi, d.fa = this.hi, d.ga = this.ii );

	}, hd: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j; F.prototype.hd.call( this ), t = this.vb, i = this.wb, s = this.xb, h = this.bc, a = this.cc, e = this.dc, o = this.vb, r = this.He, n = this.Hh, p = this.wb, l = this.Ie, c = this.Ih, y = this.xb, f = this.Je, u = this.Jh, - .999999999 > ( z = t * h + i * a + s * e ) ? ( a = s * s, ( d = t * t ) < ( h = i * i ) ? d < a ? ( d = 0, s *= h = 1 / Math.sqrt( h + a ), t = - i * h ) : ( d = i * ( h = 1 / Math.sqrt( d + h ) ), s = - t * h, t = 0 ) : h < a ? ( d = - s * ( h = 1 / Math.sqrt( a + d ) ), s = 0, t *= h ) : ( d = i * ( h = 1 / Math.sqrt( d + h ) ), s = - t * h, t = 0 ), b = d, v = s, g = t, x = 0 ) : ( b = ( i * e - s * a ) * ( z = .5 / ( d = Math.sqrt( .5 * ( 1 + z ) ) ) ), v = ( s * h - t * e ) * z, g = ( t * a - i * h ) * z, x = d ), m = ( z = b ) * ( a = 2 * z ), j = ( e = v ) * ( s = 2 * e ), h = ( d = g ) * ( i = 2 * d ), d = z * s, e *= i, z *= i; var M = ( t = x ) * a, A = t * s; a = t * i, t = 1 - j - h, i = d - a, s = z + A, d += a, h = 1 - m - h, a = e - M, z -= A, e += M, m = 1 - m - j, this.kj = 2 * ( - 1 >= x ? 3.14159265358979 : 1 <= x ? 0 : Math.acos( x ) ), x = b, j = g, g = t * this.ve + d * this.we + z * this.xe, M = i * this.ve + h * this.we + e * this.xe, b = s * this.ve + a * this.we + m * this.xe, this.tj = Math.atan2( this.Hh * g + this.Ih * M + this.Jh * b, this.He * g + this.Ie * M + this.Je * b ), this.gi = this.vb + this.bc, this.hi = this.wb + this.cc, this.ii = this.xb + this.dc, 0 < ( b = this.gi * this.gi + this.hi * this.hi + this.ii * this.ii ) && ( b = 1 / Math.sqrt( b ) ), this.gi *= b, this.hi *= b, this.ii *= b, 0 < ( g = Math.sqrt( x * x + v * v + j * j ) ) && ( g = 1 / g ), b = r * ( x *= g * this.kj ) + l * ( v *= g * this.kj ) + f * ( j *= g * this.kj ), v = n * x + c * v + u * j, ( x = b * b * ( g = 1 / ( ( g = this.bk ) * g ) ) + v * v * ( j = 1 / ( ( x = this.ck ) * x ) ) ) ? ( A = ( x = b * ( M = Math.sqrt( 1 / x ) ) ) * g, j *= M *= v, 0 < ( b = ( b - x ) * ( A *= g = 1 / Math.sqrt( A * A + j * j ) ) + ( v - M ) * ( j *= g ) ) ? ( this.Nj = b, this.je = 0, this.ke = A, this.le = j, o = o * this.je + r * this.ke + n * this.le, p = p * this.je + l * this.ke + c * this.le, y = y * this.je + f * this.ke + u * this.le, this.je = o, this.ke = p, this.le = y, y = t * this.je + i * this.ke + s * this.le, f = d * this.je + h * this.ke + a * this.le, u = z * this.je + e * this.ke + m * this.le, this.je = y, this.ke = f, this.le = u ) : this.Nj = 0 ) : this.Nj = this.le = this.ke = this.je = 0, this.Mj = this.Rf - this.Of, this.Df = this.Sf - this.Pf, this.Ef = this.Tf - this.Qf;

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Eg: function () {

		var t = new dt(); return t.x = this.vb, t.y = this.wb, t.z = this.xb, t;

	}, Gg: function () {

		var t = new dt(); return t.x = this.bc, t.y = this.cc, t.z = this.dc, t;

	}, Fg: function ( t ) {

		t.x = this.vb, t.y = this.wb, t.z = this.xb;

	}, Hg: function ( t ) {

		t.x = this.bc, t.y = this.cc, t.z = this.dc;

	}, Ig: function () {

		var t = new dt(); return t.x = this.qa, t.y = this.ra, t.z = this.sa, t;

	}, Kg: function () {

		var t = new dt(); return t.x = this.nb, t.y = this.ob, t.z = this.pb, t;

	}, Jg: function ( t ) {

		t.x = this.qa, t.y = this.ra, t.z = this.sa;

	}, Lg: function ( t ) {

		t.x = this.nb, t.y = this.ob, t.z = this.pb;

	}, Mn: function () {

		return this.fl;

	}, Ln: function () {

		return this.el;

	}, Gn: function () {

		return this.$k;

	}, En: function () {

		var t = new dt(); return t.x = this.je, t.y = this.ke, t.z = this.le, t;

	}, Fn: function ( t ) {

		t.x = this.je, t.y = this.ke, t.z = this.le;

	}, Dn: function () {

		return this.kj;

	}, Kn: function () {

		return this.tj;

	} } ), w.ua = O, w.prototype = ri( O.prototype, { za: function ( t, i, s, h, a ) {

		var e, o, r, n; return this.fh( t, i, s ), e = h.x, o = h.y, r = h.z, s = t.a.o * e + t.a.i * o + t.a.l * r, n = t.a.f * e + t.a.m * o + t.a.g * r, e = t.a.h * e + t.a.j * o + t.a.s * r, ( o = this.localTwistAxis1 ).x = s, o.y = n, o.z = e, n = h.x, e = h.y, o = h.z, h = i.a.o * n + i.a.i * e + i.a.l * o, s = i.a.f * n + i.a.m * e + i.a.g * o, i = i.a.h * n + i.a.j * e + i.a.s * o, ( n = this.localTwistAxis2 ).x = h, n.y = s, n.z = i, h = a.x, s = a.y, n = a.z, a = t.a.o * h + t.a.i * s + t.a.l * n, i = t.a.f * h + t.a.m * s + t.a.g * n, t = t.a.h * h + t.a.j * s + t.a.s * n, ( h = this.localSwingAxis1 ).x = a, h.y = i, h.z = t, this;

	} } ), A.ua = F, A.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		var h, a, e = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; h = this.Mj * e, a = this.Df * e; var o, r, n, p, l, c, y, f, u, b, v, g, x = this.Ef * e, d = this.Ee * e; e = this.Fe * e; o = - this.Ub, r = this.Tb, n = this.Ub, p = - this.Sb, l = - this.Tb, c = this.Sb, y = - this.Xb, f = this.Wb, u = this.Xb, b = - this.Vb, v = - this.Wb, g = this.Vb; var z = this.da.cd, m = this.da.dd, j = this.da.ed, M = ( this.C.P * z + this.C.R * m + this.C.S * j ) * z + ( this.C.T * z + this.C.U * m + this.C.V * j ) * m + ( this.C.W * z + this.C.X * m + this.C.Y * j ) * j, A = ( this.D.P * z + this.D.R * m + this.D.S * j ) * z + ( this.D.T * z + this.D.U * m + this.D.V * j ) * m + ( this.D.W * z + this.D.X * m + this.D.Y * j ) * j; if ( 0 < M ) {

			var w = z * this.Sb + m * this.Tb + j * this.Ub; 0 < ( w = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - w * w ) && ( M = 0 < this.C.$a ? 1 / ( 1 / M + this.C.Pc * w ) : 0 );

		}

		0 < A && ( z = z * this.Vb + m * this.Wb + j * this.Xb, 0 < ( z = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - z * z ) && ( A = 0 < this.D.$a ? 1 / ( 1 / A + this.D.Pc * z ) : 0 ) ), M = M + A ? 1 / ( M + A ) : 0, A = this.Pb[ 0 ], ( m = ( z = t.rows[ t.Ka ++ ] ).Aa ).va = 0, m.wa = 0, m.xa = 0, m.Ba = 0, m.Ca = 0, m.Da = 0, m.aa = 0, m.ba = 0, m.ca = 0, m.ea = 0, m.fa = 0, m.ga = 0, z.Fa = 0, z.Ma = 0, z.Ia = 0, z.Ha = 0, z.motorSpeed = 0, z.fb = 0, z.ta = A, ( A = z ).Fa = h, A.Ma = 0, A.Ia = - 1 / 0, A.Ha = 1 / 0, ( A = A.Aa ).va = 1, A.wa = 0, A.xa = 0, A.Ba = 1, A.Ca = 0, A.Da = 0, A.aa = - 0, A.ba = - o, A.ca = - r, A.ea = - 0, A.fa = - y, A.ga = - f, A = this.Pb[ 1 ], ( o = ( h = t.rows[ t.Ka ++ ] ).Aa ).va = 0, o.wa = 0, o.xa = 0, o.Ba = 0, o.Ca = 0, o.Da = 0, o.aa = 0, o.ba = 0, o.ca = 0, o.ea = 0, o.fa = 0, o.ga = 0, h.Fa = 0, h.Ma = 0, h.Ia = 0, h.Ha = 0, h.motorSpeed = 0, h.fb = 0, h.ta = A, ( A = h ).Fa = a, A.Ma = 0, A.Ia = - 1 / 0, A.Ha = 1 / 0, ( A = A.Aa ).va = 0, A.wa = 1, A.xa = 0, A.Ba = 0, A.Ca = 1, A.Da = 0, A.aa = - n, A.ba = - 0, A.ca = - p, A.ea = - u, A.fa = - 0, A.ga = - b, a = this.Pb[ 2 ], ( n = ( A = t.rows[ t.Ka ++ ] ).Aa ).va = 0, n.wa = 0, n.xa = 0, n.Ba = 0, n.Ca = 0, n.Da = 0, n.aa = 0, n.ba = 0, n.ca = 0, n.ea = 0, n.fa = 0, n.ga = 0, A.Fa = 0, A.Ma = 0, A.Ia = 0, A.Ha = 0, A.motorSpeed = 0, A.fb = 0, A.ta = a, A.Fa = x, A.Ma = 0, A.Ia = - 1 / 0, A.Ha = 1 / 0, ( A = A.Aa ).va = 0, A.wa = 0, A.xa = 1, A.Ba = 0, A.Ca = 0, A.Da = 1, A.aa = - l, A.ba = - c, A.ca = - 0, A.ea = - v, A.fa = - g, A.ga = - 0, ( 0 >= this.Ce.frequency || ! s ) && ( x = this.Pb[ 3 ], ( c = ( l = t.rows[ t.Ka ++ ] ).Aa ).va = 0, c.wa = 0, c.xa = 0, c.Ba = 0, c.Ca = 0, c.Da = 0, c.aa = 0, c.ba = 0, c.ca = 0, c.ea = 0, c.fa = 0, c.ga = 0, l.Fa = 0, l.Ma = 0, l.Ia = 0, l.Ha = 0, l.motorSpeed = 0, l.fb = 0, l.ta = x, A = l, x = this.angle, c = this.Rh, v = this.Ce, l = gt.angularSlop, s ? ( s = 0, v = 1 ) : ( 0 < v.frequency ? ( l = 0, s = 6.28318530717958 * v.frequency, ( a = v.dampingRatio ) < gt.minSpringDamperDampingRatio && ( a = gt.minSpringDamperDampingRatio ), g = i.dt, a = 2 * a * s, n = s * s, v.useSymplecticEuler ? ( s = 1 / ( g * a ), v = n / a ) : ( s = 1 / ( g * ( g * n + a ) ), v = n / ( g * n + a ) ) ) : ( s = 0, v = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0 ), 0 < c.motorTorque ? ( A.motorSpeed = c.motorSpeed, A.fb = c.motorTorque * i.dt ) : ( A.motorSpeed = 0, A.fb = 0 ) ), x = ( ( x - ( g = .5 * ( ( i = c.lowerLimit ) + ( c = c.upperLimit ) ) ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979 + g, i > c ? i = a = g = 0 : i == c ? ( g = - 1 / 0, a = 1 / 0, i = x - i ) : x < i ? ( g = - 1 / 0, a = 0, 0 < ( i = x - i + l ) && ( i = 0 ) ) : x > c ? ( g = 0, a = 1 / 0, 0 > ( i = x - c - l ) && ( i = 0 ) ) : i = a = g = 0, A.Ia = g, A.Ha = a, A.Ma = s * ( M ? 1 / M : 0 ), A.Fa = i * v, ( A = A.Aa ).aa = this.da.cd, A.ba = this.da.dd, A.ca = this.da.ed, A.ea = this.da.cd, A.fa = this.da.dd, A.ga = this.da.ed ), i = this.Pb[ 4 ], ( s = ( M = t.rows[ t.Ka ++ ] ).Aa ).va = 0, s.wa = 0, s.xa = 0, s.Ba = 0, s.Ca = 0, s.Da = 0, s.aa = 0, s.ba = 0, s.ca = 0, s.ea = 0, s.fa = 0, s.ga = 0, M.Fa = 0, M.Ma = 0, M.Ia = 0, M.Ha = 0, M.motorSpeed = 0, M.fb = 0, M.ta = i, ( A = M ).Fa = d, A.Ma = 0, A.Ia = - 1 / 0, A.Ha = 1 / 0, ( A = A.Aa ).aa = this.da.Qd, A.ba = this.da.Rd, A.ca = this.da.Sd, A.ea = this.da.Qd, A.fa = this.da.Rd, A.ga = this.da.Sd, d = this.Pb[ 5 ], ( i = ( t = t.rows[ t.Ka ++ ] ).Aa ).va = 0, i.wa = 0, i.xa = 0, i.Ba = 0, i.Ca = 0, i.Da = 0, i.aa = 0, i.ba = 0, i.ca = 0, i.ea = 0, i.fa = 0, i.ga = 0, t.Fa = 0, t.Ma = 0, t.Ia = 0, t.Ha = 0, t.motorSpeed = 0, t.fb = 0, t.ta = d, ( A = t ).Fa = e, A.Ma = 0, A.Ia = - 1 / 0, A.Ha = 1 / 0, ( A = A.Aa ).aa = this.da.me, A.ba = this.da.ne, A.ca = this.da.oe, A.ea = this.da.me, A.fa = this.da.ne, A.ga = this.da.oe;

	}, hd: function () {

		F.prototype.hd.call( this ); var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A, w, D, C, B, q, S, k, I, T, O, L, P, R = this.da, J = R.$.C.$a, N = R.$.D.$a; if ( - .999999999 > ( tt = R.$.vb * R.$.bc + R.$.wb * R.$.cc + R.$.xb * R.$.dc ) ) {

			var H, K, G, V, E = R.$.vb, U = R.$.wb, W = R.$.xb, Y = E * E, X = U * U, $ = W * W; Y < X ? Y < $ ? ( H = 0, K = W * ( V = 1 / Math.sqrt( X + $ ) ), G = - U * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ) : X < $ ? ( H = - W * ( V = 1 / Math.sqrt( $ + Y ) ), K = 0, G = E * V ) : ( H = U * ( V = 1 / Math.sqrt( Y + X ) ), K = - E * V, G = 0 ), t = H, i = K, s = G, h = 0;

		} else {

			var Z, Q, _; Z = R.$.wb * R.$.dc - R.$.xb * R.$.cc, Q = R.$.xb * R.$.bc - R.$.vb * R.$.dc, _ = R.$.vb * R.$.cc - R.$.wb * R.$.bc; var tt, it = Math.sqrt( .5 * ( 1 + tt ) ); t = Z *= tt = .5 / it, i = Q *= tt, s = _ *= tt, h = it;

		}

		k = S = q = 0; var st = q * ( T = t ) + S * ( O = i ) + k * ( L = s ) + ( I = 1 ) * ( P = h ); if ( 0 > st && ( st = - st, T = - T, O = - O, L = - L, P = - P ), .999999 < st ) {

			var ht = ( T = q + J / ( J + N ) * ( T - q ) ) * T + ( O = S + J / ( J + N ) * ( O - S ) ) * O + ( L = k + J / ( J + N ) * ( L - k ) ) * L + ( P = I + J / ( J + N ) * ( P - I ) ) * P; 1e-32 < ht && ( ht = 1 / Math.sqrt( ht ) ), a = T * ht, e = O * ht, o = L * ht, r = P * ht;

		} else {

			var at = J / ( J + N ) * Math.acos( st ), et = ( T += q * - st ) * T + ( O += S * - st ) * O + ( L += k * - st ) * L + ( P += I * - st ) * P; 1e-32 < et && ( et = 1 / Math.sqrt( et ) ), T *= et, O *= et, L *= et, P *= et; var ot = Math.sin( at ), rt = Math.cos( at ); a = ( q *= rt ) + T * ot, e = ( S *= rt ) + O * ot, o = ( k *= rt ) + L * ot, r = ( I *= rt ) + P * ot;

		}

		var nt, pt, lt = 2 * a, ct = 2 * e, yt = 2 * o, ft = a * lt, ut = e * ct, bt = o * yt, vt = a * ct, gt = e * yt, xt = a * yt, dt = r * lt, zt = r * ct, mt = r * yt; if ( n = vt - mt, p = xt + zt, l = vt + mt, c = 1 - ft - bt, y = gt - dt, f = xt - zt, u = gt + dt, b = 1 - ft - ut, nt = ( 1 - ut - bt ) * R.$.vb + n * R.$.wb + p * R.$.xb, pt = l * R.$.vb + c * R.$.wb + y * R.$.xb, v = f * R.$.vb + u * R.$.wb + b * R.$.xb, M = R.cd, A = R.dd, w = R.ed, D = R.Qd, C = R.Rd, B = R.Sd, - .999999999 > ( It = M * nt + A * pt + w * v ) ) {

			var jt, Mt, At, wt, Dt = M * M, Ct = A * A, Bt = w * w; Dt < Ct ? Dt < Bt ? ( jt = 0, Mt = w * ( wt = 1 / Math.sqrt( Ct + Bt ) ), At = - A * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ) : Ct < Bt ? ( jt = - w * ( wt = 1 / Math.sqrt( Bt + Dt ) ), Mt = 0, At = M * wt ) : ( jt = A * ( wt = 1 / Math.sqrt( Dt + Ct ) ), Mt = - M * wt, At = 0 ), a = jt, e = Mt, o = At, r = 0;

		} else {

			var qt, St, kt; qt = A * v - w * pt, St = w * nt - M * v, kt = M * pt - A * nt; var It, Tt = Math.sqrt( .5 * ( 1 + It ) ); a = qt *= It = .5 / Tt, e = St *= It, o = kt *= It, r = Tt;

		}

		var Ot, Lt, Ft, Pt = 2 * a, Rt = 2 * e, Jt = 2 * o, Nt = a * Pt, Ht = e * Rt, Kt = o * Jt, Gt = a * Rt, Vt = e * Jt, Et = a * Jt, Ut = r * Pt, Wt = r * Rt, Yt = r * Jt; if ( 1e-6 < ( z = pt * ( d = ( f = Et - Wt ) * D + ( u = Vt + Ut ) * C + ( b = 1 - Nt - Ht ) * B ) - v * ( x = ( l = Gt + Yt ) * D + ( c = 1 - Nt - Kt ) * C + ( y = Vt - Ut ) * B ) ) * z + ( m = v * ( g = ( 1 - Ht - Kt ) * D + ( n = Gt - Yt ) * C + ( p = Et + Wt ) * B ) - nt * d ) * m + ( j = nt * x - pt * g ) * j ) {

			var Xt = z * z + m * m + j * j; 0 < Xt && ( Xt = 1 / Math.sqrt( Xt ) ), z *= Xt, m *= Xt, j *= Xt;

		} else {

			var $t, Zt = nt * nt, Qt = pt * pt, _t = v * v; Zt < Qt ? Zt < _t ? ( z = 0, m = v * ( $t = 1 / Math.sqrt( Qt + _t ) ), j = - pt * $t ) : ( z = pt * ( $t = 1 / Math.sqrt( Zt + Qt ) ), m = - nt * $t, j = 0 ) : Qt < _t ? ( z = - v * ( $t = 1 / Math.sqrt( _t + Zt ) ), m = 0, j = nt * $t ) : ( z = pt * ( $t = 1 / Math.sqrt( Zt + Qt ) ), m = - nt * $t, j = 0 );

		}

		g = m * v - j * pt, x = j * nt - z * v, d = z * pt - m * nt, R.cd = nt, R.dd = pt, R.ed = v, R.Qd = g, R.Rd = x, R.Sd = d, R.me = z, R.ne = m, R.oe = j, Ot = this.wb * this.dc - this.xb * this.cc, Lt = this.xb * this.bc - this.vb * this.dc, Ft = this.vb * this.cc - this.wb * this.bc; var ti, ii, si, hi = this.vb * this.bc + this.wb * this.cc + this.xb * this.dc, ai = - 1 >= hi ? 3.14159265358979 : 1 <= hi ? 0 : Math.acos( hi ), ei = Ot * Ot + Lt * Lt + Ft * Ft; 0 < ei && ( ei = 1 / Math.sqrt( ei ) ), Ot *= ei, Lt *= ei, Ft *= ei, Ot *= ai, Lt *= ai, Ft *= ai, this.Ee = Ot * this.da.Qd + Lt * this.da.Rd + Ft * this.da.Sd, this.Fe = Ot * this.da.me + Lt * this.da.ne + Ft * this.da.oe, ti = this.Ie * this.xe - this.Je * this.we, ii = this.Je * this.ve - this.He * this.xe, si = this.He * this.we - this.Ie * this.ve, hi = this.He * this.ve + this.Ie * this.we + this.Je * this.xe, this.angle = - 1 >= hi ? 3.14159265358979 : 1 <= hi ? 0 : Math.acos( hi ), 0 > ti * this.da.cd + ii * this.da.dd + si * this.da.ed && ( this.angle = - this.angle ), this.Mj = this.Rf - this.Of, this.Df = this.Sf - this.Pf, this.Ef = this.Tf - this.Qf;

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Eg: function () {

		var t = new dt(); return t.x = this.vb, t.y = this.wb, t.z = this.xb, t;

	}, Gg: function () {

		var t = new dt(); return t.x = this.bc, t.y = this.cc, t.z = this.dc, t;

	}, Fg: function ( t ) {

		t.x = this.vb, t.y = this.wb, t.z = this.xb;

	}, Hg: function ( t ) {

		t.x = this.bc, t.y = this.cc, t.z = this.dc;

	}, Ig: function () {

		var t = new dt(); return t.x = this.qa, t.y = this.ra, t.z = this.sa, t;

	}, Kg: function () {

		var t = new dt(); return t.x = this.nb, t.y = this.ob, t.z = this.pb, t;

	}, Jg: function ( t ) {

		t.x = this.qa, t.y = this.ra, t.z = this.sa;

	}, Lg: function ( t ) {

		t.x = this.nb, t.y = this.ob, t.z = this.pb;

	}, Cj: function () {

		return this.Ce;

	}, ql: function () {

		return this.Rh;

	}, ol: function () {

		return this.angle;

	} } ), M.ua = O, M.prototype = ri( O.prototype, { za: function ( t, i, s, h ) {

		var a, e, o, r; return this.fh( t, i, s ), a = h.x, e = h.y, o = h.z, s = t.a.o * a + t.a.i * e + t.a.l * o, r = t.a.f * a + t.a.m * e + t.a.g * o, t = t.a.h * a + t.a.j * e + t.a.s * o, ( a = this.localAxis1 ).x = s, a.y = r, a.z = t, r = h.x, t = h.y, a = h.z, h = i.a.o * r + i.a.i * t + i.a.l * a, s = i.a.f * r + i.a.m * t + i.a.g * a, i = i.a.h * r + i.a.j * t + i.a.s * a, ( r = this.localAxis2 ).x = h, r.y = s, r.z = i, this;

	} } ), j.prototype = { ua: function ( t, i ) {

		return this.lowerLimit = t, this.upperLimit = i, this;

	}, cb: function ( t, i ) {

		return this.motorSpeed = t, this.motorTorque = i, this;

	}, clone: function () {

		var t = new j(); return t.lowerLimit = this.lowerLimit, t.upperLimit = this.upperLimit, t.motorSpeed = this.motorSpeed, t.motorTorque = this.motorTorque, t;

	} }, m.ua = F, m.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		if ( ! ( 0 < this.Ce.frequency && s ) ) {

			var h, a, e, o, r, n, p, l, c, y, f, u, b, v; if ( h = this.Rf - this.Of, a = this.Sf - this.Pf, e = this.Tf - this.Qf, 0 < this.Ce.frequency ) {

				o = 6.28318530717958 * this.Ce.frequency, ( s = this.Ce.dampingRatio ) < gt.minSpringDamperDampingRatio && ( s = gt.minSpringDamperDampingRatio ), i = i.dt, s = 2 * s * o; var g = o * o; this.Ce.useSymplecticEuler ? ( o = 1 / ( i * s ), i = g / s ) : ( o = 1 / ( i * ( i * g + s ) ), i = g / ( i * g + s ) ), o *= this.C.$a + this.D.$a;

			} else o = 0, i = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; r = - this.Ub, n = this.Tb, p = this.Ub, l = - this.Sb, s = - this.Tb, g = this.Sb, c = - this.Xb, y = this.Wb, f = this.Xb, u = - this.Vb, b = - this.Wb, v = this.Vb; var x = this.Pb[ 0 ], d = t.rows[ t.Ka ++ ], z = d.Aa; z.va = 0, z.wa = 0, z.xa = 0, z.Ba = 0, z.Ca = 0, z.Da = 0, z.aa = 0, z.ba = 0, z.ca = 0, z.ea = 0, z.fa = 0, z.ga = 0, d.Fa = 0, d.Ma = 0, d.Ia = 0, d.Ha = 0, d.motorSpeed = 0, d.fb = 0, d.ta = x, ( x = d ).Fa = h * i, x.Ma = o, x.Ia = - 1 / 0, x.Ha = 1 / 0, ( h = x.Aa ).va = 1, h.wa = 0, h.xa = 0, h.Ba = 1, h.Ca = 0, h.Da = 0, h.aa = - 0, h.ba = - r, h.ca = - n, h.ea = - 0, h.fa = - c, h.ga = - y, h = this.Pb[ 1 ], ( n = ( r = t.rows[ t.Ka ++ ] ).Aa ).va = 0, n.wa = 0, n.xa = 0, n.Ba = 0, n.Ca = 0, n.Da = 0, n.aa = 0, n.ba = 0, n.ca = 0, n.ea = 0, n.fa = 0, n.ga = 0, r.Fa = 0, r.Ma = 0, r.Ia = 0, r.Ha = 0, r.motorSpeed = 0, r.fb = 0, r.ta = h, ( x = r ).Fa = a * i, x.Ma = o, x.Ia = - 1 / 0, x.Ha = 1 / 0, ( h = x.Aa ).va = 0, h.wa = 1, h.xa = 0, h.Ba = 0, h.Ca = 1, h.Da = 0, h.aa = - p, h.ba = - 0, h.ca = - l, h.ea = - f, h.fa = - 0, h.ga = - u, a = this.Pb[ 2 ], ( h = ( t = t.rows[ t.Ka ++ ] ).Aa ).va = 0, h.wa = 0, h.xa = 0, h.Ba = 0, h.Ca = 0, h.Da = 0, h.aa = 0, h.ba = 0, h.ca = 0, h.ea = 0, h.fa = 0, h.ga = 0, t.Fa = 0, t.Ma = 0, t.Ia = 0, t.Ha = 0, t.motorSpeed = 0, t.fb = 0, t.ta = a, ( x = t ).Fa = e * i, x.Ma = o, x.Ia = - 1 / 0, x.Ha = 1 / 0, ( h = x.Aa ).va = 0, h.wa = 0, h.xa = 1, h.Ba = 0, h.Ca = 0, h.Da = 1, h.aa = - s, h.ba = - g, h.ca = - 0, h.ea = - b, h.fa = - v, h.ga = - 0;

		}

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Cj: function () {

		return this.Ce;

	} } ), z.ua = O, z.prototype = ri( O.prototype, { za: function ( t, i, s ) {

		return this.fh( t, i, s ), this;

	} } ), d.prototype = { ua: function ( t, i ) {

		return this.frequency = t, this.dampingRatio = i, this;

	}, cb: function ( t ) {

		return this.useSymplecticEuler = t, this;

	}, clone: function () {

		var t = new d(); return t.frequency = this.frequency, t.dampingRatio = this.dampingRatio, t.useSymplecticEuler = this.useSymplecticEuler, t;

	} }, x.prototype = { ua: function ( t, i ) {

		return this.lowerLimit = t, this.upperLimit = i, this;

	}, cb: function ( t, i ) {

		return this.motorSpeed = t, this.motorForce = i, this;

	}, clone: function () {

		var t = new x(); return t.lowerLimit = this.lowerLimit, t.upperLimit = this.upperLimit, t.motorSpeed = this.motorSpeed, t.motorForce = this.motorForce, t;

	} }, g.ua = F, g.prototype = ri( F.prototype, { Ud: function ( t, i, s ) {

		var h, a, e = s ? 1 : this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; h = this.Mj * e, a = this.Df * e; var o, r, n, p, l, c, y, f, u, b, v, g, x, d, z, m, j, M, A = this.Ef * e, w = this.Pl * e; b = u = 0, o = - ( o = 0 ), r = - ( r = - this.Ub ), n = - ( n = this.Tb ), p = - ( p = this.Ub ), l = - ( l = 0 ), c = - ( c = - this.Sb ), y = - ( y = - this.Tb ), f = - ( f = this.Sb ), u = - u, b = - b, v = - ( v = - this.Xb ), g = - ( g = this.Wb ), x = - ( x = this.Xb ), d = - ( d = 0 ), z = - ( z = - this.Vb ), m = - ( m = - this.Wb ), j = - ( j = this.Vb ), M = - ( M = 0 ); var D = this.fg, C = this.gg, B = this.hg, q = ( this.C.P * D + this.C.R * C + this.C.S * B ) * D + ( this.C.T * D + this.C.U * C + this.C.V * B ) * C + ( this.C.W * D + this.C.X * C + this.C.Y * B ) * B, S = ( this.D.P * D + this.D.R * C + this.D.S * B ) * D + ( this.D.T * D + this.D.U * C + this.D.V * B ) * C + ( this.D.W * D + this.D.X * C + this.D.Y * B ) * B; if ( 0 < q ) {

			var k = D * this.Sb + C * this.Tb + B * this.Ub, I = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - k * k; 0 < I && ( q = 0 < this.C.$a ? 1 / ( 1 / q + this.C.Pc * I ) : 0 );

		}

		if ( 0 < S ) {

			var T = D * this.Vb + C * this.Wb + B * this.Xb, O = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - T * T; 0 < O && ( S = 0 < this.D.$a ? 1 / ( 1 / S + this.D.Pc * O ) : 0 );

		}

		var L = q + S ? 1 / ( q + S ) : 0, F = this.ig, P = this.jg, R = this.kg, J = ( this.C.P * F + this.C.R * P + this.C.S * R ) * F + ( this.C.T * F + this.C.U * P + this.C.V * R ) * P + ( this.C.W * F + this.C.X * P + this.C.Y * R ) * R, N = ( this.D.P * F + this.D.R * P + this.D.S * R ) * F + ( this.D.T * F + this.D.U * P + this.D.V * R ) * P + ( this.D.W * F + this.D.X * P + this.D.Y * R ) * R; if ( 0 < J ) {

			var H = F * this.Sb + P * this.Tb + R * this.Ub, K = this.Sb * this.Sb + this.Tb * this.Tb + this.Ub * this.Ub - H * H; 0 < K && ( J = 0 < this.C.$a ? 1 / ( 1 / J + this.C.Pc * K ) : 0 );

		}

		if ( 0 < N ) {

			var G = F * this.Vb + P * this.Wb + R * this.Xb, V = this.Vb * this.Vb + this.Wb * this.Wb + this.Xb * this.Xb - G * G; 0 < V && ( N = 0 < this.D.$a ? 1 / ( 1 / N + this.D.Pc * V ) : 0 );

		}

		var E = J + N ? 1 / ( J + N ) : 0, U = this.Pb[ 0 ], Y = t.rows[ t.Ka ++ ], X = Y.Aa; X.va = 0, X.wa = 0, X.xa = 0, X.Ba = 0, X.Ca = 0, X.Da = 0, X.aa = 0, X.ba = 0, X.ca = 0, X.ea = 0, X.fa = 0, X.ga = 0, Y.Fa = 0, Y.Ma = 0, Y.Ia = 0, Y.Ha = 0, Y.motorSpeed = 0, Y.fb = 0, Y.ta = U, ( nt = Y ).Fa = h, nt.Ma = 0, nt.Ia = - 1 / 0, nt.Ha = 1 / 0; var $ = nt.Aa; $.va = 1, $.wa = 0, $.xa = 0, $.Ba = 1, $.Ca = 0, $.Da = 0, $.aa = o, $.ba = r, $.ca = n, $.ea = b, $.fa = v, $.ga = g; var Z = this.Pb[ 1 ], Q = t.rows[ t.Ka ++ ], _ = Q.Aa; _.va = 0, _.wa = 0, _.xa = 0, _.Ba = 0, _.Ca = 0, _.Da = 0, _.aa = 0, _.ba = 0, _.ca = 0, _.ea = 0, _.fa = 0, _.ga = 0, Q.Fa = 0, Q.Ma = 0, Q.Ia = 0, Q.Ha = 0, Q.motorSpeed = 0, Q.fb = 0, Q.ta = Z, ( nt = Q ).Fa = a, nt.Ma = 0, nt.Ia = - 1 / 0, nt.Ha = 1 / 0, ( $ = nt.Aa ).va = 0, $.wa = 1, $.xa = 0, $.Ba = 0, $.Ca = 1, $.Da = 0, $.aa = p, $.ba = l, $.ca = c, $.ea = x, $.fa = d, $.ga = z; var tt = this.Pb[ 2 ], it = t.rows[ t.Ka ++ ], st = it.Aa; if ( st.va = 0, st.wa = 0, st.xa = 0, st.Ba = 0, st.Ca = 0, st.Da = 0, st.aa = 0, st.ba = 0, st.ca = 0, st.ea = 0, st.fa = 0, st.ga = 0, it.Fa = 0, it.Ma = 0, it.Ia = 0, it.Ha = 0, it.motorSpeed = 0, it.fb = 0, it.ta = tt, ( nt = it ).Fa = A, nt.Ma = 0, nt.Ia = - 1 / 0, nt.Ha = 1 / 0, ( $ = nt.Aa ).va = 0, $.wa = 0, $.xa = 1, $.Ba = 0, $.Ca = 0, $.Da = 1, $.aa = y, $.ba = f, $.ca = u, $.ea = m, $.fa = j, $.ga = M, ! this.Jm && ( 0 >= this.Yk.frequency || ! s ) ) {

			var ht = this.Pb[ 3 ], at = t.rows[ t.Ka ++ ], et = at.Aa; et.va = 0, et.wa = 0, et.xa = 0, et.Ba = 0, et.Ca = 0, et.Da = 0, et.aa = 0, et.ba = 0, et.ca = 0, et.ea = 0, et.fa = 0, et.ga = 0, at.Fa = 0, at.Ma = 0, at.Ia = 0, at.Ha = 0, at.motorSpeed = 0, at.fb = 0, at.ta = ht; var ot, rt, nt = at, pt = this.Ni, lt = this.Qk, ct = this.Yk, yt = gt.angularSlop; if ( s )ot = 0, rt = 1; else {

				if ( 0 < ct.frequency ) {

					yt = 0; var ft = 6.28318530717958 * ct.frequency, ut = ct.dampingRatio; ut < gt.minSpringDamperDampingRatio && ( ut = gt.minSpringDamperDampingRatio ); var bt = i.dt, vt = 2 * ut * ft, xt = ft * ft; ct.useSymplecticEuler ? ( ot = 1 / ( bt * vt ), rt = xt / vt ) : ( ot = 1 / ( bt * ( bt * xt + vt ) ), rt = xt / ( bt * xt + vt ) );

				} else ot = 0, rt = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; 0 < lt.motorTorque ? ( nt.motorSpeed = lt.motorSpeed, nt.fb = lt.motorTorque * i.dt ) : ( nt.motorSpeed = 0, nt.fb = 0 );

			}

			var dt, zt, mt, jt = lt.lowerLimit, Mt = lt.upperLimit, At = .5 * ( jt + Mt ); pt = ( pt = ( ( ( pt = pt - At ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979 ) + At; jt > Mt ? mt = zt = dt = 0 : jt == Mt ? ( dt = - 1 / 0, zt = 1 / 0, mt = pt - jt ) : pt < jt ? ( dt = - 1 / 0, zt = 0, 0 < ( mt = pt - jt + yt ) && ( mt = 0 ) ) : pt > Mt ? ( dt = 0, zt = 1 / 0, 0 > ( mt = pt - Mt - yt ) && ( mt = 0 ) ) : mt = zt = dt = 0; var wt = L ? 1 / L : 0; nt.Ia = dt, nt.Ha = zt, nt.Ma = ot * wt, nt.Fa = mt * rt, ( $ = nt.Aa ).aa = this.fg, $.ba = this.gg, $.ca = this.hg, $.ea = this.fg, $.fa = this.gg, $.ga = this.hg;

		}

		if ( ! this.Km ) {

			var Dt = this.Pb[ 4 ], Ct = t.rows[ t.Ka ++ ], Bt = Ct.Aa; Bt.va = 0, Bt.wa = 0, Bt.xa = 0, Bt.Ba = 0, Bt.Ca = 0, Bt.Da = 0, Bt.aa = 0, Bt.ba = 0, Bt.ca = 0, Bt.ea = 0, Bt.fa = 0, Bt.ga = 0, Ct.Fa = 0, Ct.Ma = 0, Ct.Ia = 0, Ct.Ha = 0, Ct.motorSpeed = 0, Ct.fb = 0, Ct.ta = Dt, ( nt = Ct ).Fa = w, nt.Ma = 0, nt.Ia = - 1 / 0, nt.Ha = 1 / 0, ( $ = nt.Aa ).aa = this.Yg, $.ba = this.Zg, $.ca = this.$g, $.ea = this.Yg, $.fa = this.Zg, $.ga = this.$g;

		}

		if ( ! this.Lm && ( 0 >= this.Zk.frequency || ! s ) ) {

			var qt = this.Pb[ 5 ], St = t.rows[ t.Ka ++ ], kt = St.Aa; kt.va = 0, kt.wa = 0, kt.xa = 0, kt.Ba = 0, kt.Ca = 0, kt.Da = 0, kt.aa = 0, kt.ba = 0, kt.ca = 0, kt.ea = 0, kt.fa = 0, kt.ga = 0, St.Fa = 0, St.Ma = 0, St.Ia = 0, St.Ha = 0, St.motorSpeed = 0, St.fb = 0, St.ta = qt; nt = St; var It, Tt, Ot = this.Oi, Lt = this.Rk, Ft = this.Zk, Pt = gt.angularSlop; if ( s )It = 0, Tt = 1; else {

				if ( 0 < Ft.frequency ) {

					Pt = 0; var Rt = 6.28318530717958 * Ft.frequency, Jt = Ft.dampingRatio; Jt < gt.minSpringDamperDampingRatio && ( Jt = gt.minSpringDamperDampingRatio ); var Nt = i.dt, Ht = 2 * Jt * Rt, Kt = Rt * Rt; Ft.useSymplecticEuler ? ( It = 1 / ( Nt * Ht ), Tt = Kt / Ht ) : ( It = 1 / ( Nt * ( Nt * Kt + Ht ) ), Tt = Kt / ( Nt * Kt + Ht ) );

				} else It = 0, Tt = this.Hc == W.BAUMGARTE ? i.invDt * gt.velocityBaumgarte : 0; 0 < Lt.motorTorque ? ( nt.motorSpeed = Lt.motorSpeed, nt.fb = Lt.motorTorque * i.dt ) : ( nt.motorSpeed = 0, nt.fb = 0 );

			}

			var Gt, Vt, Et, Ut = Lt.lowerLimit, Wt = Lt.upperLimit, Yt = .5 * ( Ut + Wt ); Ot = ( Ot = ( ( ( Ot = Ot - Yt ) + 3.14159265358979 ) % 6.28318530717958 + 6.28318530717958 ) % 6.28318530717958 - 3.14159265358979 ) + Yt; Ut > Wt ? Et = Vt = Gt = 0 : Ut == Wt ? ( Gt = - 1 / 0, Vt = 1 / 0, Et = Ot - Ut ) : Ot < Ut ? ( Gt = - 1 / 0, Vt = 0, 0 < ( Et = Ot - Ut + Pt ) && ( Et = 0 ) ) : Ot > Wt ? ( Gt = 0, Vt = 1 / 0, 0 > ( Et = Ot - Wt - Pt ) && ( Et = 0 ) ) : Et = Vt = Gt = 0; var Xt = E ? 1 / E : 0; nt.Ia = Gt, nt.Ha = Vt, nt.Ma = It * Xt, nt.Fa = Et * Tt, ( $ = nt.Aa ).aa = this.ig, $.ba = this.jg, $.ca = this.kg, $.ea = this.ig, $.fa = this.jg, $.ga = this.kg;

		}

	}, hd: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d, z; F.prototype.hd.call( this ), t = this.vb, i = this.wb, s = this.xb, o = this.ah, h = ( r = this.bh ) * s - ( n = this.dh ) * i, a = n * t - o * s, e = o * i - r * t, this.fg = a * n - e * r, this.gg = e * o - h * n, this.hg = h * r - a * o, this.Yg = h, this.Zg = a, this.$g = e, this.ig = i * e - s * a, this.jg = s * h - t * e, this.kg = t * a - i * h, 0 < ( t = this.fg * this.fg + this.gg * this.gg + this.hg * this.hg ) && ( t = 1 / Math.sqrt( t ) ), this.fg *= t, this.gg *= t, this.hg *= t, 0 < ( t = this.Yg * this.Yg + this.Zg * this.Zg + this.$g * this.$g ) && ( t = 1 / Math.sqrt( t ) ), this.Yg *= t, this.Zg *= t, this.$g *= t, 0 < ( t = this.ig * this.ig + this.jg * this.jg + this.kg * this.kg ) && ( t = 1 / Math.sqrt( t ) ), this.ig *= t, this.jg *= t, this.kg *= t, this.Jm = ! ( this.fg * this.fg + this.gg * this.gg + this.hg * this.hg ), this.Km = ! ( this.Yg * this.Yg + this.Zg * this.Zg + this.$g * this.$g ), this.Lm = ! ( this.ig * this.ig + this.jg * this.jg + this.kg * this.kg ), p = this.vb, t = this.He, i = this.Hh, l = this.wb, s = this.Ie, h = this.Ih, c = this.xb, a = this.Je, e = this.Jh, y = this.bc, f = this.ve, o = this.ah, u = this.cc, b = this.we, r = this.bh, v = this.dc, d = t * f + s * b + a * ( g = this.xe ), z = i * f + h * b + e * g, - 1 >= ( x = p * o + l * r + c * ( n = this.dh ) ) ? ( t = .5 * ( s = Math.atan2( z, d ) ), i = - 1.570796326794895, s = .5 * - s ) : 1 <= x ? ( t = .5 * ( s = Math.atan2( z, d ) ), i = 1.570796326794895, s *= .5 ) : ( x = Math.asin( x ), p = Math.atan2( - ( p * f + l * b + c * g ), p * y + l * u + c * v ), t = Math.atan2( - ( t * o + s * r + a * n ), i * o + h * r + e * n ), i = x, s = p ), this.Ni = t, this.Pl = i, this.Oi = s, this.Mj = this.Rf - this.Of, this.Df = this.Sf - this.Pf, this.Ef = this.Tf - this.Qf;

	}, $d: function ( t, i ) {

		F.prototype.$d.call( this, t, i ), this.Ud( i, t, ! 1 );

	}, gd: function ( t ) {

		F.prototype.gd.call( this, t ), this.Ud( t, null, ! 0 );

	}, Eg: function () {

		var t = new dt(); return t.x = this.vb, t.y = this.wb, t.z = this.xb, t;

	}, Gg: function () {

		var t = new dt(); return t.x = this.ah, t.y = this.bh, t.z = this.dh, t;

	}, Fg: function ( t ) {

		t.x = this.vb, t.y = this.wb, t.z = this.xb;

	}, Hg: function ( t ) {

		t.x = this.ah, t.y = this.bh, t.z = this.dh;

	}, Ig: function () {

		var t = new dt(); return t.x = this.qa, t.y = this.ra, t.z = this.sa, t;

	}, Kg: function () {

		var t = new dt(); return t.x = this.Mc, t.y = this.Nc, t.z = this.Oc, t;

	}, Jg: function ( t ) {

		t.x = this.qa, t.y = this.ra, t.z = this.sa;

	}, Lg: function ( t ) {

		t.x = this.Mc, t.y = this.Nc, t.z = this.Oc;

	}, Bn: function () {

		return this.Yk;

	}, Cn: function () {

		return this.Zk;

	}, xn: function () {

		return this.Qk;

	}, yn: function () {

		return this.Rk;

	}, sn: function () {

		return this.Ni;

	}, tn: function () {

		return this.Oi;

	} } ), v.ua = O, v.prototype = ri( O.prototype, { za: function ( t, i, s, h, a ) {

		var e, o, r; return this.fh( t, i, s ), e = h.x, o = h.y, r = h.z, h = t.a.o * e + t.a.i * o + t.a.l * r, s = t.a.f * e + t.a.m * o + t.a.g * r, t = t.a.h * e + t.a.j * o + t.a.s * r, ( e = this.localAxis1 ).x = h, e.y = s, e.z = t, h = a.x, s = a.y, e = a.z, a = i.a.o * h + i.a.i * s + i.a.l * e, t = i.a.f * h + i.a.m * s + i.a.g * e, i = i.a.h * h + i.a.j * s + i.a.s * e, ( h = this.localAxis2 ).x = a, h.y = t, h.z = i, this;

	} } ), y.prototype = { za: function ( t ) {

		this.Sc = t.Sc; for ( var i = 0, s = this.Sc; i < s; ) {

			var h = i ++; this.uh[ h ] = t.uh[ h ], this.zh[ h ] = t.zh[ h ];

		}

		for ( this.ie = t.ie, i = 0, s = this.ie; i < s; )h = i ++, this.Mg[ h ] = t.Mg[ h ];

	}, kl: function ( t, i, s, h, a, e, o ) {

		for ( var r = 0, n = this.ie; r < n; ) {

			var p = r ++, l = ( p = this.Mg[ p ], t.rows[ p ] ); this.il[ p ] = l.Fa * e - s[ p ] - l.Ma * h[ p ];

		}

		for ( r = i.cj, n = 0, p = this.Sc; n < p; ) {

			var c = n ++, y = ( l = this.uh[ c ], c = this.zh[ c ], t.rows[ l ] ); c = ( 0 > c ? y.Ia : 0 < c ? y.Ha : 0 ) - h[ l ]; if ( a[ l ] = c ) {

				y = 0; for ( var f = this.ie; y < f; ) {

					var u = y ++, b = u = this.Mg[ u ]; ( v = this.il )[ b ] -= r[ l ][ u ] * c;

				}

			}

		}

		for ( n = this.Mg, p = this.ie, c = l = 0; c < p; )l |= 1 << n[ y = c ++ ]; for ( i.Sj[ l ] || ( i.nn( l, n, p ), i.Sj[ l ] = ! 0 ), n = i.Ck[ l ], i = ! 0, p = 0, l = this.ie; p < l; ) {

			c = p ++, y = this.Mg[ c ], f = t.rows[ y ], b = u = h[ y ]; for ( var v = 0, g = this.ie; v < g; ) {

				var x = v ++; b = b + this.il[ this.Mg[ x ] ] * n[ c ][ x ];

			}

			if ( b < f.Ia - gt.directMlcpSolverEps || b > f.Ha + gt.directMlcpSolverEps ) {

				i = ! 1; break;

			}

			a[ y ] = b - u;

		}

		if ( o ) return ! 0; if ( ! i ) return ! 1; for ( o = 0, n = this.Sc; o < n; ) {

			for ( c = o ++, p = this.uh[ c ], l = t.rows[ p ], c = this.zh[ c ], y = h[ p ] + a[ p ], f = s[ p ], u = 0, b = t.Ka; u < b; )v = u ++, f += r[ p ][ v ] * a[ v ]; if ( p = l.Fa * e - f - l.Ma * y, 0 > c && p > gt.directMlcpSolverEps || 0 < c && p < - gt.directMlcpSolverEps ) {

				i = ! 1; break;

			}

		}

		return i;

	} }, l.prototype = { Uh: function ( t, i ) {

		if ( i == t.Ka )null == this.Th[ this.jf ] && ( this.Th[ this.jf ] = new y( this.Qn ) ), this.Th[ this.jf ++ ].za( this.cf ); else {

			var s = t.rows[ i ], h = s.Ia > - 1 / 0, a = s.Ha < 1 / 0; 0 == s.Ia && 0 == s.Ha ? ( ( a = this.cf ).uh[ a.Sc ] = i, a.zh[ a.Sc ] = 0, a.Sc ++, this.Uh( t, i + 1 ), this.cf.Sc -- ) : ( ( s = this.cf ).Mg[ s.ie ] = i, s.ie ++, this.Uh( t, i + 1 ), this.cf.ie --, h && ( ( h = this.cf ).uh[ h.Sc ] = i, h.zh[ h.Sc ] = - 1, h.Sc ++, this.Uh( t, i + 1 ), this.cf.Sc -- ), a && ( ( a = this.cf ).uh[ a.Sc ] = i, a.zh[ a.Sc ] = 1, a.Sc ++, this.Uh( t, i + 1 ), this.cf.Sc -- ) );

		}

	} }, p.prototype = {}, n.ua = Y, n.prototype = ri( Y.prototype, { xh: function ( t ) {

		this.$.hd(), this.$.$d( t, this.info ), this.C = this.info.Qe, this.D = this.info.Re, this.ei.ll( this.info, this.ac ), ( t = this.Se ).jf = 0, ( i = t.cf ).Sc = 0, i.ie = 0, t.Uh( this.info, 0 ), t = this.Ml; for ( var i = this.Se.jf, s = 0, h = 0, a = 0, e = t.n; a < e; ) {

			var o = a ++; ( o = t.sc[ o ] ) < i ? ( t.kf[ s ] = o, ++ s ) : ( t.kf[ i + h ] = o, ++ h );

		}

		i = t.sc, t.sc = t.kf, t.kf = i;

	}, Gh: function ( t ) {

		if ( 0 >= ( c = ( c = this.$.Hc == W.BAUMGARTE ? gt.jointWarmStartingFactorForBaungarte : gt.jointWarmStartingFactor ) * t.dtRatio ) ) for ( c = 0, t = this.info.Ka; c < t; ) {

			var i = c ++; ( i = this.info.rows[ i ].ta ).ta = 0, i.ad = 0, i.ub = 0;

		} else {

			for ( t = 0, i = this.info.Ka; t < i; ) {

				var s = t ++; ( u = ( y = ( f = this.info.rows[ s ] ).ta ).ta * c ) < f.Ia ? u = f.Ia : u > f.Ha && ( u = f.Ha ), y.ta = u, 0 < f.fb ? ( ( u = y.ad * c ) < - ( f = f.fb ) ? u = - f : u > f && ( u = f ), y.ad = u ) : y.ad = 0, this.Cf[ s ] = y.ta + y.ad;

			}

			var h, a, e, o, r, n, p, l, c = this.Cf, y = ( i = t = ! 1, s = this.C.gb, this.C.hb ), f = this.C.ib, u = this.D.gb; h = this.D.hb, a = this.D.ib, e = this.C.kb, o = this.C.lb, r = this.C.mb, n = this.D.kb, p = this.D.lb, l = this.D.mb; for ( var b = 0, v = this.info.Ka; b < v; ) {

				var g = b ++, x = this.info.rows[ g ].Aa, d = this.ac[ g ]; g = c[ g ]; 1 & x.xc && ( s += d.qd * g, y += d.rd * g, f += d.sd * g, u += d.td * - g, h += d.ud * - g, a += d.vd * - g, t = ! 0 ), 2 & x.xc && ( e += d.kd * g, o += d.ld * g, r += d.md * g, n += d.nd * - g, p += d.od * - g, l += d.pd * - g, i = ! 0 );

			}

			t && ( this.C.gb = s, this.C.hb = y, this.C.ib = f, this.D.gb = u, this.D.hb = h, this.D.ib = a ), i && ( this.C.kb = e, this.C.lb = o, this.C.mb = r, this.D.kb = n, this.D.lb = p, this.D.mb = l );

		}

	}, Ch: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c, y = this.info.Ka; t = this.C.gb, i = this.C.hb, s = this.C.ib, h = this.D.gb, a = this.D.hb, e = this.D.ib, o = this.C.kb, r = this.C.lb, n = this.C.mb, p = this.D.kb, l = this.D.lb, c = this.D.mb; for ( var f = 0; f < y; ) {

			var u, b = f ++, v = ( u = this.info.rows[ b ] ).ta, g = ( g = ( g = ( g = ( g = 0 ) + ( t * ( u = u.Aa ).va + i * u.wa + s * u.xa ) ) - ( h * u.Ba + a * u.Ca + e * u.Da ) ) + ( o * u.aa + r * u.ba + n * u.ca ) ) - ( p * u.ea + l * u.fa + c * u.ga ); this.Qg[ b ] = g, this.Yh[ b ] = v.ta, this.Aj[ b ] = 0;

		}

		for ( t = this.ei.cj, i = 0; i < y; ) if ( s = i ++, h = ( e = this.info.rows[ s ] ).ta, o = this.ac[ s ], 0 < e.fb ) for ( ( e = ( a = h.ad ) + o.Ff * ( - e.motorSpeed - this.Qg[ s ] ) ) < - ( o = h.ad ) ? e = - o : e > o && ( e = o ), h.ad = e, h = e - a, this.Aj[ s ] = h, a = 0, e = y; a < e; )r = o = a ++, ( n = this.Qg )[ r ] += h * t[ s ][ o ]; for ( i = ! 1, s = 0, h = this.Se.jf; s < h; ) if ( t = s ++, t = this.Ml.sc[ t ], this.Se.Th[ t ].kl( this.info, this.ei, this.Qg, this.Yh, this.Cf, 1, ! 1 ) ) {

			for ( i = 0; i < y; )h = i ++, s = this.Cf[ h ], this.info.rows[ h ].ta.ta += s, ( a = this.Aj )[ h ] += s; for ( y = this.Aj, s = i = ! 1, h = this.C.gb, a = this.C.hb, e = this.C.ib, o = this.D.gb, r = this.D.hb, n = this.D.ib, p = this.C.kb, l = this.C.lb, c = this.C.mb, f = this.D.kb, b = this.D.lb, v = this.D.mb, u = 0, g = this.info.Ka; u < g; ) {

				var x = u ++, d = this.info.rows[ x ].Aa, z = this.ac[ x ]; x = y[ x ]; 1 & d.xc && ( h += z.qd * x, a += z.rd * x, e += z.sd * x, o += z.td * - x, r += z.ud * - x, n += z.vd * - x, i = ! 0 ), 2 & d.xc && ( p += z.kd * x, l += z.ld * x, c += z.md * x, f += z.nd * - x, b += z.od * - x, v += z.pd * - x, s = ! 0 );

			}

			for ( i && ( this.C.gb = h, this.C.hb = a, this.C.ib = e, this.D.gb = o, this.D.hb = r, this.D.ib = n ), s && ( this.C.kb = p, this.C.lb = l, this.C.mb = c, this.D.kb = f, this.D.lb = b, this.D.mb = v ), y = this.Ml, i = 0; y.sc[ i ] != t; )++ i; for ( ;0 < i; )t = y.sc[ i ], y.sc[ i ] = y.sc[ i - 1 ], y.sc[ i - 1 ] = t, -- i; i = ! 0; break;

		}

		i || console.log( 'DirectJointConstraintSolver.hx:338:', 'could not find solution. (velocity)' );

	}, Li: function ( t ) {

		for ( var i, s, h, a, e, o, r = o = e = a = h = s = i = 0, n = this.info.Ka; r < n; ) {

			var p, l = r ++; l = ( p = this.info.rows[ l ] ).ta; 1 & ( p = p.Aa ).xc ? ( i += p.va * l.ta, s += p.wa * l.ta, h += p.xa * l.ta ) : 2 & p.xc && ( a += p.aa * l.ta, e += p.ba * l.ta, o += p.ca * l.ta );

		}

		this.$.Pi = i * t.invDt, this.$.Qi = s * t.invDt, this.$.Ri = h * t.invDt, this.$.Si = a * t.invDt, this.$.Ti = e * t.invDt, this.$.Ui = o * t.invDt;

	}, Pg: function () {

		this.$.hd(), this.$.gd( this.info ), this.C = this.info.Qe, this.D = this.info.Re, this.ei.ll( this.info, this.ac ), ( t = this.Se ).jf = 0, ( i = t.cf ).Sc = 0, i.ie = 0, t.Uh( this.info, 0 ); for ( var t = this.Ki, i = this.Se.jf, s = 0, h = 0, a = 0, e = t.n; a < e; ) {

			var o = a ++; ( o = t.sc[ o ] ) < i ? ( t.kf[ s ] = o, ++ s ) : ( t.kf[ i + h ] = o, ++ h );

		}

		for ( i = t.sc, t.sc = t.kf, t.kf = i, t = 0, i = this.info.Ka; t < i; )s = t ++, this.info.rows[ s ].ta.ub = 0;

	}, Bh: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c, y = this.info.Ka; t = this.C.Yc, i = this.C.Zc, s = this.C.$c, h = this.D.Yc, a = this.D.Zc, e = this.D.$c, o = this.C.Uc, r = this.C.Vc, n = this.C.Wc, p = this.D.Uc, l = this.D.Vc, c = this.D.Wc; for ( var f = 0; f < y; ) {

			var u, b = f ++, v = ( u = this.info.rows[ b ] ).ta, g = ( g = ( g = ( g = ( g = 0 ) + ( t * ( u = u.Aa ).va + i * u.wa + s * u.xa ) ) - ( h * u.Ba + a * u.Ca + e * u.Da ) ) + ( o * u.aa + r * u.ba + n * u.ca ) ) - ( p * u.ea + l * u.fa + c * u.ga ); this.Qg[ b ] = g, this.Yh[ b ] = v.ub;

		}

		for ( i = ! 1, s = 0, h = this.Se.jf; s < h; ) if ( t = s ++, t = this.Ki.sc[ t ], this.Se.Th[ t ].kl( this.info, this.ei, this.Qg, this.Yh, this.Cf, gt.positionSplitImpulseBaumgarte, ! 1 ) ) {

			for ( i = 0; i < y; )s = i ++, this.info.rows[ s ].ta.ub += this.Cf[ s ]; for ( y = this.Cf, s = i = ! 1, h = this.C.Yc, a = this.C.Zc, e = this.C.$c, o = this.D.Yc, r = this.D.Zc, n = this.D.$c, p = this.C.Uc, l = this.C.Vc, c = this.C.Wc, f = this.D.Uc, b = this.D.Vc, v = this.D.Wc, u = 0, g = this.info.Ka; u < g; ) {

				var x = u ++, d = this.info.rows[ x ].Aa, z = this.ac[ x ]; x = y[ x ]; 1 & d.xc && ( h += z.qd * x, a += z.rd * x, e += z.sd * x, o += z.td * - x, r += z.ud * - x, n += z.vd * - x, i = ! 0 ), 2 & d.xc && ( p += z.kd * x, l += z.ld * x, c += z.md * x, f += z.nd * - x, b += z.od * - x, v += z.pd * - x, s = ! 0 );

			}

			for ( i && ( this.C.Yc = h, this.C.Zc = a, this.C.$c = e, this.D.Yc = o, this.D.Zc = r, this.D.$c = n ), s && ( this.C.Uc = p, this.C.Vc = l, this.C.Wc = c, this.D.Uc = f, this.D.Vc = b, this.D.Wc = v ), y = this.Ki, i = 0; y.sc[ i ] != t; )++ i; for ( ;0 < i; )t = y.sc[ i ], y.sc[ i ] = y.sc[ i - 1 ], y.sc[ i - 1 ] = t, -- i; i = ! 0; break;

		}

		i || console.log( 'DirectJointConstraintSolver.hx:454:', 'could not find solution. (split impulse)' );

	}, Ah: function () {

		this.$.hd(), this.$.gd( this.info ), this.C = this.info.Qe, this.D = this.info.Re, this.ei.ll( this.info, this.ac ); var t = this.Se; t.jf = 0; var i = t.cf; i.Sc = 0, i.ie = 0, t.Uh( this.info, 0 ); for ( var s = this.Ki, h = this.Se.jf, a = 0, e = 0, o = 0, r = s.n; o < r; ) {

			var n = o ++, p = s.sc[ n ]; p < h ? ( s.kf[ a ] = p, ++ a ) : ( s.kf[ h + e ] = p, ++ e );

		}

		var l = s.sc; s.sc = s.kf, s.kf = l; for ( var c = this.info.Ka, y = 0; y < c; ) {

			var f = y ++, u = this.info.rows[ f ].ta; this.Qg[ f ] = 0, this.Yh[ f ] = u.ub;

		}

		for ( var b = ! 1, v = 0, g = this.Se.jf; v < g; ) {

			var x = v ++, d = this.Ki.sc[ x ]; if ( this.Se.Th[ d ].kl( this.info, this.ei, this.Qg, this.Yh, this.Cf, gt.positionNgsBaumgarte, ! 1 ) ) {

				for ( var z = 0, m = c; z < m; ) {

					var j = z ++; this.info.rows[ j ].ta.ub += this.Cf[ j ];

				}

				for ( var M, A, w, D, C, B, q, S, k, I, T, O, L = this.Cf, F = ! 1, P = ! 1, R = O = T = I = k = S = q = B = C = D = w = A = M = 0, J = this.info.Ka; R < J; ) {

					var N = R ++, H = this.info.rows[ N ].Aa, K = this.ac[ N ], G = L[ N ]; 1 & H.xc && ( M += K.qd * G, A += K.rd * G, w += K.sd * G, D += K.td * - G, C += K.ud * - G, B += K.vd * - G, F = ! 0 ), 2 & H.xc && ( q += K.kd * G, S += K.ld * G, k += K.md * G, I += K.nd * - G, T += K.od * - G, O += K.pd * - G, P = ! 0 );

				}

				if ( F ) {

					var V = this.C; V.a.v += M, V.a.A += A, V.a.B += w; var E = this.D; E.a.v += D, E.a.A += C, E.a.B += B;

				}

				if ( P ) {

					var U, W, Y, X, $, Z, Q = this.C, _ = Math.sqrt( q * q + S * S + k * k ), tt = .5 * _; if ( .5 > tt ) {

						var it = tt * tt; U = .5 * ( 1 - .16666666666666666 * it + it * it * .008333333333333333 ), W = 1 - .5 * it + it * it * .041666666666666664;

					} else U = Math.sin( tt ) / _, W = Math.cos( tt ); Y = q * U, X = S * U, $ = k * U, Z = W; var st, ht, at, et, ot, rt = Q.a.o, nt = Q.a.m, pt = Q.a.s, lt = rt + nt + pt; 0 < lt ? ( et = .5 * ( ot = Math.sqrt( lt + 1 ) ), ot = .5 / ot, st = ( Q.a.g - Q.a.j ) * ot, ht = ( Q.a.h - Q.a.l ) * ot, at = ( Q.a.i - Q.a.f ) * ot ) : rt > nt ? rt > pt ? ( st = .5 * ( ot = Math.sqrt( rt - nt - pt + 1 ) ), ot = .5 / ot, ht = ( Q.a.f + Q.a.i ) * ot, at = ( Q.a.h + Q.a.l ) * ot, et = ( Q.a.g - Q.a.j ) * ot ) : ( at = .5 * ( ot = Math.sqrt( pt - rt - nt + 1 ) ), ot = .5 / ot, st = ( Q.a.h + Q.a.l ) * ot, ht = ( Q.a.j + Q.a.g ) * ot, et = ( Q.a.i - Q.a.f ) * ot ) : nt > pt ? ( ht = .5 * ( ot = Math.sqrt( nt - pt - rt + 1 ) ), ot = .5 / ot, st = ( Q.a.f + Q.a.i ) * ot, at = ( Q.a.j + Q.a.g ) * ot, et = ( Q.a.h - Q.a.l ) * ot ) : ( at = .5 * ( ot = Math.sqrt( pt - rt - nt + 1 ) ), ot = .5 / ot, st = ( Q.a.h + Q.a.l ) * ot, ht = ( Q.a.j + Q.a.g ) * ot, et = ( Q.a.i - Q.a.f ) * ot ); var ct = ( st = Z * st + Y * et + X * at - $ * ht ) * st + ( ht = Z * ht - Y * at + X * et + $ * st ) * ht + ( at = Z * at + Y * ht - X * st + $ * et ) * at + ( et = Z * et - Y * st - X * ht - $ * at ) * et; 1e-32 < ct && ( ct = 1 / Math.sqrt( ct ) ); st *= ct, ht *= ct, at *= ct, et *= ct; var yt, ft, ut, bt, vt, xt, dt, zt, mt, jt, Mt, At, wt, Dt, Ct, Bt, qt, St, kt = 2 * st, It = 2 * ht, Tt = 2 * at, Ot = st * kt, Lt = ht * It, Ft = at * Tt, Pt = st * It, Rt = ht * Tt, Jt = st * Tt, Nt = et * kt, Ht = et * It, Kt = et * Tt; Q.a.o = 1 - Lt - Ft, Q.a.f = Pt - Kt, Q.a.h = Jt + Ht, Q.a.i = Pt + Kt, Q.a.m = 1 - Ot - Ft, Q.a.j = Rt - Nt, Q.a.l = Jt - Ht, Q.a.g = Rt + Nt, Q.a.s = 1 - Ot - Lt, yt = Q.a.o * Q.Ra + Q.a.f * Q.Ua + Q.a.h * Q.Xa, ft = Q.a.o * Q.Sa + Q.a.f * Q.Va + Q.a.h * Q.Ya, ut = Q.a.o * Q.Ta + Q.a.f * Q.Wa + Q.a.h * Q.Za, bt = Q.a.i * Q.Ra + Q.a.m * Q.Ua + Q.a.j * Q.Xa, vt = Q.a.i * Q.Sa + Q.a.m * Q.Va + Q.a.j * Q.Ya, xt = Q.a.i * Q.Ta + Q.a.m * Q.Wa + Q.a.j * Q.Za, dt = Q.a.l * Q.Ra + Q.a.g * Q.Ua + Q.a.s * Q.Xa, zt = Q.a.l * Q.Sa + Q.a.g * Q.Va + Q.a.s * Q.Ya, mt = Q.a.l * Q.Ta + Q.a.g * Q.Wa + Q.a.s * Q.Za, Q.P = yt, Q.R = ft, Q.S = ut, Q.T = bt, Q.U = vt, Q.V = xt, Q.W = dt, Q.X = zt, Q.Y = mt, jt = Q.P * Q.a.o + Q.R * Q.a.f + Q.S * Q.a.h, Mt = Q.P * Q.a.i + Q.R * Q.a.m + Q.S * Q.a.j, At = Q.P * Q.a.l + Q.R * Q.a.g + Q.S * Q.a.s, wt = Q.T * Q.a.o + Q.U * Q.a.f + Q.V * Q.a.h, Dt = Q.T * Q.a.i + Q.U * Q.a.m + Q.V * Q.a.j, Ct = Q.T * Q.a.l + Q.U * Q.a.g + Q.V * Q.a.s, Bt = Q.W * Q.a.o + Q.X * Q.a.f + Q.Y * Q.a.h, qt = Q.W * Q.a.i + Q.X * Q.a.m + Q.Y * Q.a.j, St = Q.W * Q.a.l + Q.X * Q.a.g + Q.Y * Q.a.s, Q.P = jt, Q.R = Mt, Q.S = At, Q.T = wt, Q.U = Dt, Q.V = Ct, Q.W = Bt, Q.X = qt, Q.Y = St, Q.P *= Q.N.x, Q.R *= Q.N.x, Q.S *= Q.N.x, Q.T *= Q.N.y, Q.U *= Q.N.y, Q.V *= Q.N.y, Q.W *= Q.N.z, Q.X *= Q.N.z, Q.Y *= Q.N.z; var Gt, Vt, Et, Ut, Wt, Yt, Xt = this.D, $t = Math.sqrt( I * I + T * T + O * O ), Zt = .5 * $t; if ( .5 > Zt ) {

						var Qt = Zt * Zt; Gt = .5 * ( 1 - .16666666666666666 * Qt + Qt * Qt * .008333333333333333 ), Vt = 1 - .5 * Qt + Qt * Qt * .041666666666666664;

					} else Gt = Math.sin( Zt ) / $t, Vt = Math.cos( Zt ); Et = I * Gt, Ut = T * Gt, Wt = O * Gt, Yt = Vt; var _t, ti, ii, si, hi, ai = Xt.a.o, ei = Xt.a.m, oi = Xt.a.s, ri = ai + ei + oi; 0 < ri ? ( si = .5 * ( hi = Math.sqrt( ri + 1 ) ), hi = .5 / hi, _t = ( Xt.a.g - Xt.a.j ) * hi, ti = ( Xt.a.h - Xt.a.l ) * hi, ii = ( Xt.a.i - Xt.a.f ) * hi ) : ai > ei ? ai > oi ? ( _t = .5 * ( hi = Math.sqrt( ai - ei - oi + 1 ) ), hi = .5 / hi, ti = ( Xt.a.f + Xt.a.i ) * hi, ii = ( Xt.a.h + Xt.a.l ) * hi, si = ( Xt.a.g - Xt.a.j ) * hi ) : ( ii = .5 * ( hi = Math.sqrt( oi - ai - ei + 1 ) ), hi = .5 / hi, _t = ( Xt.a.h + Xt.a.l ) * hi, ti = ( Xt.a.j + Xt.a.g ) * hi, si = ( Xt.a.i - Xt.a.f ) * hi ) : ei > oi ? ( ti = .5 * ( hi = Math.sqrt( ei - oi - ai + 1 ) ), hi = .5 / hi, _t = ( Xt.a.f + Xt.a.i ) * hi, ii = ( Xt.a.j + Xt.a.g ) * hi, si = ( Xt.a.h - Xt.a.l ) * hi ) : ( ii = .5 * ( hi = Math.sqrt( oi - ai - ei + 1 ) ), hi = .5 / hi, _t = ( Xt.a.h + Xt.a.l ) * hi, ti = ( Xt.a.j + Xt.a.g ) * hi, si = ( Xt.a.i - Xt.a.f ) * hi ); var ni = ( _t = Yt * _t + Et * si + Ut * ii - Wt * ti ) * _t + ( ti = Yt * ti - Et * ii + Ut * si + Wt * _t ) * ti + ( ii = Yt * ii + Et * ti - Ut * _t + Wt * si ) * ii + ( si = Yt * si - Et * _t - Ut * ti - Wt * ii ) * si; 1e-32 < ni && ( ni = 1 / Math.sqrt( ni ) ); _t *= ni, ti *= ni, ii *= ni, si *= ni; var pi, li, ci, yi, fi, ui, bi, vi, gi, xi, di, zi, mi, ji, Mi, Ai, wi, Di, Ci = 2 * _t, Bi = 2 * ti, qi = 2 * ii, Si = _t * Ci, ki = ti * Bi, Ii = ii * qi, Ti = _t * Bi, Oi = ti * qi, Li = _t * qi, Fi = si * Ci, Pi = si * Bi, Ri = si * qi; Xt.a.o = 1 - ki - Ii, Xt.a.f = Ti - Ri, Xt.a.h = Li + Pi, Xt.a.i = Ti + Ri, Xt.a.m = 1 - Si - Ii, Xt.a.j = Oi - Fi, Xt.a.l = Li - Pi, Xt.a.g = Oi + Fi, Xt.a.s = 1 - Si - ki, pi = Xt.a.o * Xt.Ra + Xt.a.f * Xt.Ua + Xt.a.h * Xt.Xa, li = Xt.a.o * Xt.Sa + Xt.a.f * Xt.Va + Xt.a.h * Xt.Ya, ci = Xt.a.o * Xt.Ta + Xt.a.f * Xt.Wa + Xt.a.h * Xt.Za, yi = Xt.a.i * Xt.Ra + Xt.a.m * Xt.Ua + Xt.a.j * Xt.Xa, fi = Xt.a.i * Xt.Sa + Xt.a.m * Xt.Va + Xt.a.j * Xt.Ya, ui = Xt.a.i * Xt.Ta + Xt.a.m * Xt.Wa + Xt.a.j * Xt.Za, bi = Xt.a.l * Xt.Ra + Xt.a.g * Xt.Ua + Xt.a.s * Xt.Xa, vi = Xt.a.l * Xt.Sa + Xt.a.g * Xt.Va + Xt.a.s * Xt.Ya, gi = Xt.a.l * Xt.Ta + Xt.a.g * Xt.Wa + Xt.a.s * Xt.Za, Xt.P = pi, Xt.R = li, Xt.S = ci, Xt.T = yi, Xt.U = fi, Xt.V = ui, Xt.W = bi, Xt.X = vi, Xt.Y = gi, xi = Xt.P * Xt.a.o + Xt.R * Xt.a.f + Xt.S * Xt.a.h, di = Xt.P * Xt.a.i + Xt.R * Xt.a.m + Xt.S * Xt.a.j, zi = Xt.P * Xt.a.l + Xt.R * Xt.a.g + Xt.S * Xt.a.s, mi = Xt.T * Xt.a.o + Xt.U * Xt.a.f + Xt.V * Xt.a.h, ji = Xt.T * Xt.a.i + Xt.U * Xt.a.m + Xt.V * Xt.a.j, Mi = Xt.T * Xt.a.l + Xt.U * Xt.a.g + Xt.V * Xt.a.s, Ai = Xt.W * Xt.a.o + Xt.X * Xt.a.f + Xt.Y * Xt.a.h, wi = Xt.W * Xt.a.i + Xt.X * Xt.a.m + Xt.Y * Xt.a.j, Di = Xt.W * Xt.a.l + Xt.X * Xt.a.g + Xt.Y * Xt.a.s, Xt.P = xi, Xt.R = di, Xt.S = zi, Xt.T = mi, Xt.U = ji, Xt.V = Mi, Xt.W = Ai, Xt.X = wi, Xt.Y = Di, Xt.P *= Xt.N.x, Xt.R *= Xt.N.x, Xt.S *= Xt.N.x, Xt.T *= Xt.N.y, Xt.U *= Xt.N.y, Xt.V *= Xt.N.y, Xt.W *= Xt.N.z, Xt.X *= Xt.N.z, Xt.Y *= Xt.N.z;

				}

				for ( var Ji = this.Ki, Ni = 0; Ji.sc[ Ni ] != d; )++ Ni; for ( ;0 < Ni; ) {

					var Hi = Ji.sc[ Ni ]; Ji.sc[ Ni ] = Ji.sc[ Ni - 1 ], Ji.sc[ Ni - 1 ] = Hi, -- Ni;

				}

				b = ! 0; break;

			}

		}

		b || console.log( 'DirectJointConstraintSolver.hx:506:', 'could not find solution. (NGS)' );

	}, postSolve: function () {

		this.$.hd(), this.$.Rl();

	} } ), r.prototype = { nn: function ( t, i, s ) {

		for ( var h = 0; h < s; ) for ( var a = h ++, e = i[ a ], o = 0, r = s; o < r; ) {

			var n = o ++; this.wk[ a ][ n ] = this.$a[ e ][ i[ n ] ];

		}

		var p; switch ( h = this.wk, t = this.Ck[ t ], s ) {

			case 4:a = h[ 0 ], i = t[ 0 ], s = 1 / a[ 0 ], i[ 0 ] = s, a[ 1 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], a = h[ 1 ], i = t[ 1 ], s = 1 / a[ 1 ], i[ 1 ] = s, i[ 0 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], a = h[ 2 ], i = t[ 2 ], s = 1 / a[ 2 ], i[ 2 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, a[ 3 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], a = h[ 3 ], i = t[ 3 ], s = 1 / a[ 3 ], i[ 3 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], i = t[ 1 ], t[ 0 ][ 1 ] = i[ 0 ], i = t[ 2 ], t[ 0 ][ 2 ] = i[ 0 ], t[ 1 ][ 2 ] = i[ 1 ], i = t[ 3 ], t[ 0 ][ 3 ] = i[ 0 ], t[ 1 ][ 3 ] = i[ 1 ], t[ 2 ][ 3 ] = i[ 2 ]; break; case 5:a = h[ 0 ], i = t[ 0 ], s = 1 / a[ 0 ], i[ 0 ] = s, a[ 1 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], a = h[ 1 ], i = t[ 1 ], s = 1 / a[ 1 ], i[ 1 ] = s, i[ 0 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], a = h[ 2 ], i = t[ 2 ], s = 1 / a[ 2 ], i[ 2 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], a = h[ 3 ], i = t[ 3 ], s = 1 / a[ 3 ], i[ 3 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, a[ 4 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], p[ 3 ] = - s * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], a = h[ 4 ], i = t[ 4 ], s = 1 / a[ 4 ], i[ 4 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, i[ 3 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], p[ 2 ] -= i[ 2 ] * n[ 4 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], p[ 2 ] -= i[ 2 ] * n[ 4 ], p[ 3 ] -= i[ 3 ] * n[ 4 ], i = t[ 1 ], t[ 0 ][ 1 ] = i[ 0 ], i = t[ 2 ], t[ 0 ][ 2 ] = i[ 0 ], t[ 1 ][ 2 ] = i[ 1 ], i = t[ 3 ], t[ 0 ][ 3 ] = i[ 0 ], t[ 1 ][ 3 ] = i[ 1 ], t[ 2 ][ 3 ] = i[ 2 ], i = t[ 4 ], t[ 0 ][ 4 ] = i[ 0 ], t[ 1 ][ 4 ] = i[ 1 ], t[ 2 ][ 4 ] = i[ 2 ], t[ 3 ][ 4 ] = i[ 3 ]; break; case 6:a = h[ 0 ], i = t[ 0 ], s = 1 / a[ 0 ], i[ 0 ] = s, a[ 1 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, a[ 5 ] *= s, n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n[ 5 ] -= a[ 5 ] * n[ 0 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n[ 5 ] -= a[ 5 ] * n[ 0 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n[ 5 ] -= a[ 5 ] * n[ 0 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n[ 5 ] -= a[ 5 ] * n[ 0 ], n = h[ 5 ], ( p = t[ 5 ] )[ 0 ] = - s * n[ 0 ], n[ 1 ] -= a[ 1 ] * n[ 0 ], n[ 2 ] -= a[ 2 ] * n[ 0 ], n[ 3 ] -= a[ 3 ] * n[ 0 ], n[ 4 ] -= a[ 4 ] * n[ 0 ], n[ 5 ] -= a[ 5 ] * n[ 0 ], a = h[ 1 ], i = t[ 1 ], s = 1 / a[ 1 ], i[ 1 ] = s, i[ 0 ] *= s, a[ 2 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, a[ 5 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n[ 5 ] -= a[ 5 ] * n[ 1 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n[ 5 ] -= a[ 5 ] * n[ 1 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n[ 5 ] -= a[ 5 ] * n[ 1 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n[ 5 ] -= a[ 5 ] * n[ 1 ], n = h[ 5 ], ( p = t[ 5 ] )[ 0 ] -= i[ 0 ] * n[ 1 ], p[ 1 ] = - s * n[ 1 ], n[ 2 ] -= a[ 2 ] * n[ 1 ], n[ 3 ] -= a[ 3 ] * n[ 1 ], n[ 4 ] -= a[ 4 ] * n[ 1 ], n[ 5 ] -= a[ 5 ] * n[ 1 ], a = h[ 2 ], i = t[ 2 ], s = 1 / a[ 2 ], i[ 2 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, a[ 3 ] *= s, a[ 4 ] *= s, a[ 5 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n[ 5 ] -= a[ 5 ] * n[ 2 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n[ 5 ] -= a[ 5 ] * n[ 2 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n[ 5 ] -= a[ 5 ] * n[ 2 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n[ 5 ] -= a[ 5 ] * n[ 2 ], n = h[ 5 ], ( p = t[ 5 ] )[ 0 ] -= i[ 0 ] * n[ 2 ], p[ 1 ] -= i[ 1 ] * n[ 2 ], p[ 2 ] = - s * n[ 2 ], n[ 3 ] -= a[ 3 ] * n[ 2 ], n[ 4 ] -= a[ 4 ] * n[ 2 ], n[ 5 ] -= a[ 5 ] * n[ 2 ], a = h[ 3 ], i = t[ 3 ], s = 1 / a[ 3 ], i[ 3 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, a[ 4 ] *= s, a[ 5 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n[ 5 ] -= a[ 5 ] * n[ 3 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n[ 5 ] -= a[ 5 ] * n[ 3 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n[ 5 ] -= a[ 5 ] * n[ 3 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], p[ 3 ] = - s * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n[ 5 ] -= a[ 5 ] * n[ 3 ], n = h[ 5 ], ( p = t[ 5 ] )[ 0 ] -= i[ 0 ] * n[ 3 ], p[ 1 ] -= i[ 1 ] * n[ 3 ], p[ 2 ] -= i[ 2 ] * n[ 3 ], p[ 3 ] = - s * n[ 3 ], n[ 4 ] -= a[ 4 ] * n[ 3 ], n[ 5 ] -= a[ 5 ] * n[ 3 ], a = h[ 4 ], i = t[ 4 ], s = 1 / a[ 4 ], i[ 4 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, i[ 3 ] *= s, a[ 5 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], n[ 5 ] -= a[ 5 ] * n[ 4 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], n[ 5 ] -= a[ 5 ] * n[ 4 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], p[ 2 ] -= i[ 2 ] * n[ 4 ], n[ 5 ] -= a[ 5 ] * n[ 4 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], p[ 2 ] -= i[ 2 ] * n[ 4 ], p[ 3 ] -= i[ 3 ] * n[ 4 ], n[ 5 ] -= a[ 5 ] * n[ 4 ], n = h[ 5 ], ( p = t[ 5 ] )[ 0 ] -= i[ 0 ] * n[ 4 ], p[ 1 ] -= i[ 1 ] * n[ 4 ], p[ 2 ] -= i[ 2 ] * n[ 4 ], p[ 3 ] -= i[ 3 ] * n[ 4 ], p[ 4 ] = - s * n[ 4 ], n[ 5 ] -= a[ 5 ] * n[ 4 ], a = h[ 5 ], i = t[ 5 ], s = 1 / a[ 5 ], i[ 5 ] = s, i[ 0 ] *= s, i[ 1 ] *= s, i[ 2 ] *= s, i[ 3 ] *= s, i[ 4 ] *= s, n = h[ 0 ], ( p = t[ 0 ] )[ 0 ] -= i[ 0 ] * n[ 5 ], n = h[ 1 ], ( p = t[ 1 ] )[ 0 ] -= i[ 0 ] * n[ 5 ], p[ 1 ] -= i[ 1 ] * n[ 5 ], n = h[ 2 ], ( p = t[ 2 ] )[ 0 ] -= i[ 0 ] * n[ 5 ], p[ 1 ] -= i[ 1 ] * n[ 5 ], p[ 2 ] -= i[ 2 ] * n[ 5 ], n = h[ 3 ], ( p = t[ 3 ] )[ 0 ] -= i[ 0 ] * n[ 5 ], p[ 1 ] -= i[ 1 ] * n[ 5 ], p[ 2 ] -= i[ 2 ] * n[ 5 ], p[ 3 ] -= i[ 3 ] * n[ 5 ], n = h[ 4 ], ( p = t[ 4 ] )[ 0 ] -= i[ 0 ] * n[ 5 ], p[ 1 ] -= i[ 1 ] * n[ 5 ], p[ 2 ] -= i[ 2 ] * n[ 5 ], p[ 3 ] -= i[ 3 ] * n[ 5 ], p[ 4 ] -= i[ 4 ] * n[ 5 ], i = t[ 1 ], t[ 0 ][ 1 ] = i[ 0 ], i = t[ 2 ], t[ 0 ][ 2 ] = i[ 0 ], t[ 1 ][ 2 ] = i[ 1 ], i = t[ 3 ], t[ 0 ][ 3 ] = i[ 0 ], t[ 1 ][ 3 ] = i[ 1 ], t[ 2 ][ 3 ] = i[ 2 ], i = t[ 4 ], t[ 0 ][ 4 ] = i[ 0 ], t[ 1 ][ 4 ] = i[ 1 ], t[ 2 ][ 4 ] = i[ 2 ], t[ 3 ][ 4 ] = i[ 3 ], i = t[ 5 ], t[ 0 ][ 5 ] = i[ 0 ], t[ 1 ][ 5 ] = i[ 1 ], t[ 2 ][ 5 ] = i[ 2 ], t[ 3 ][ 5 ] = i[ 3 ], t[ 4 ][ 5 ] = i[ 4 ]; break; default:for ( e = 0; e < s; ) {

				for ( a = h[ o = e ++ ], i = t[ o ], r = 1 / a[ o ], i[ o ] = r, n = 0, p = o; n < p; ) {

					i[ l = n ++ ] *= r;

				}

				for ( n = o + 1, p = s; n < p; )a[ l = n ++ ] *= r; for ( var l = 0, c = o; l < c; ) {

					n = h[ f = l ++ ]; p = t[ f ]; for ( var y = 0, f = f + 1; y < f; ) {

						var u = y ++; p[ u ] -= i[ u ] * n[ o ];

					}

					for ( p = o + 1, y = s; p < y; )n[ f = p ++ ] -= a[ f ] * n[ o ];

				}

				for ( l = o + 1, c = s; l < c; ) {

					for ( n = h[ p = l ++ ], p = t[ p ], y = 0, f = o; y < f; )p[ u = y ++ ] -= i[ u ] * n[ o ]; for ( p[ o ] = - r * n[ o ], p = o + 1, y = s; p < y; )n[ f = p ++ ] -= a[ f ] * n[ o ];

				}

			}

				for ( h = 1; h < s; ) for ( i = t[ a = h ++ ], e = 0, o = a; e < o; )t[ r = e ++ ][ a ] = i[ r ];

		}

	}, ll: function ( t, i ) {

		var s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x = this.$a, d = this.cj, z = t.Ka, m = t.Qe, j = t.Re, M = m.$a, A = j.$a; s = m.P, h = m.R, a = m.S, e = m.T, o = m.U, r = m.V, n = m.W, p = m.X, m = m.Y, l = j.P, c = j.R, y = j.S, f = j.T, u = j.U, b = j.V, v = j.W, g = j.X; j = j.Y; for ( var w = 0; w < z; ) {

			var D, C, B, q = w ++, S = t.rows[ q ].Aa; q = i[ q ]; if ( S.Im(), 1 & S.xc ? ( q.qd = S.va * M, q.rd = S.wa * M, q.sd = S.xa * M, q.td = S.Ba * A, q.ud = S.Ca * A, q.vd = S.Da * A ) : ( q.qd = 0, q.rd = 0, q.sd = 0, q.td = 0, q.ud = 0, q.vd = 0 ), 2 & S.xc )D = s * S.aa + h * S.ba + a * S.ca, C = e * S.aa + o * S.ba + r * S.ca, B = n * S.aa + p * S.ba + m * S.ca, q.kd = D, q.ld = C, q.md = B, D = l * S.ea + c * S.fa + y * S.ga, C = f * S.ea + u * S.fa + b * S.ga, S = v * S.ea + g * S.fa + j * S.ga, q.nd = D, q.od = C, q.pd = S; else q.kd = 0, q.ld = 0, q.md = 0, q.nd = 0, q.od = 0, q.pd = 0;

		}

		for ( M = 0; M < z; ) for ( A = M ++, s = t.rows[ A ].Aa, h = A, a = z; h < a; )o = i[ e = h ++ ], r = s.va * o.qd + s.wa * o.rd + s.xa * o.sd + ( s.aa * o.kd + s.ba * o.ld + s.ca * o.md ) + ( s.Ba * o.td + s.Ca * o.ud + s.Da * o.vd ) + ( s.ea * o.nd + s.fa * o.od + s.ga * o.pd ), A == e ? ( x[ A ][ e ] = r + t.rows[ A ].Ma, d[ A ][ e ] = r, o.mass = r + t.rows[ A ].Ma, o.Ff = r, 0 != o.mass && ( o.mass = 1 / o.mass ), o.Ff && ( o.Ff = 1 / o.Ff ) ) : ( x[ A ][ e ] = r, x[ e ][ A ] = r, d[ A ][ e ] = r, d[ e ][ A ] = r ); for ( t = 0, i = this.ak; t < i; )x = t ++, this.Sj[ x ] = ! 1;

	} }, o.ua = Y, o.prototype = ri( Y.prototype, { xh: function ( t ) {

		this.Ji.$d( t, this.info ), this.C = this.info.Qe, this.D = this.info.Re, t = this.C.$a; var i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d = this.D.$a; i = this.C.P, s = this.C.R, h = this.C.S, a = this.C.T, e = this.C.U, o = this.C.V, r = this.C.W, n = this.C.X, p = this.C.Y, l = this.D.P, c = this.D.R, y = this.D.S, f = this.D.T, u = this.D.U, b = this.D.V, v = this.D.W, g = this.D.X, x = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w = z ++, D = this.info.rows[ w ], C = ( w = this.ac[ w ], D.Ng ); w.Zh = C.va * t, w.$h = C.wa * t, w.ai = C.xa * t, w.bi = C.Ba * d, w.ci = C.Ca * d, w.di = C.Da * d, j = i * C.aa + s * C.ba + h * C.ca, M = a * C.aa + e * C.ba + o * C.ca, A = r * C.aa + n * C.ba + p * C.ca, w.Xf = j, w.Yf = M, w.Zf = A, j = l * C.ea + c * C.fa + y * C.ga, M = f * C.ea + u * C.fa + b * C.ga, A = v * C.ea + g * C.fa + x * C.ga, w.$f = j, w.ag = M, w.bg = A, w.he = t + d + ( w.Xf * C.aa + w.Yf * C.ba + w.Zf * C.ca ) + ( w.$f * C.ea + w.ag * C.fa + w.bg * C.ga ), 0 != w.he && ( w.he = 1 / w.he ), C = D.Lj, D = D.Kj, w.yl = C.va * t, w.zl = C.wa * t, w.Al = C.xa * t, w.Bl = C.Ba * d, w.Cl = C.Ca * d, w.Dl = C.Da * d, w.sl = D.va * t, w.tl = D.wa * t, w.ul = D.xa * t, w.vl = D.Ba * d, w.wl = D.Ca * d, w.xl = D.Da * d, j = i * C.aa + s * C.ba + h * C.ca, M = a * C.aa + e * C.ba + o * C.ca, A = r * C.aa + n * C.ba + p * C.ca, w.Ej = j, w.Fj = M, w.Gj = A, j = l * C.ea + c * C.fa + y * C.ga, M = f * C.ea + u * C.fa + b * C.ga, A = v * C.ea + g * C.fa + x * C.ga, w.Hj = j, w.Ij = M, w.Jj = A, j = i * D.aa + s * D.ba + h * D.ca, M = a * D.aa + e * D.ba + o * D.ca, A = r * D.aa + n * D.ba + p * D.ca, w.lk = j, w.mk = M, w.nk = A, j = l * D.ea + c * D.fa + y * D.ga, M = f * D.ea + u * D.fa + b * D.ga, A = v * D.ea + g * D.fa + x * D.ga, w.pk = j, w.qk = M, w.rk = A, C = t + d + ( w.Ej * C.aa + w.Fj * C.ba + w.Gj * C.ca ) + ( w.Hj * C.ea + w.Ij * C.fa + w.Jj * C.ga ), M = j = w.Ej * D.aa + w.Fj * D.ba + w.Gj * D.ca + ( w.Hj * D.ea + w.Ij * D.fa + w.Jj * D.ga ), ( A = C * ( D = t + d + ( w.lk * D.aa + w.mk * D.ba + w.nk * D.ca ) + ( w.pk * D.ea + w.qk * D.fa + w.rk * D.ga ) ) - j * M ) && ( A = 1 / A ), w.ym = D * A, w.zm = - j * A, w.Am = - M * A, w.Bm = C * A;

		}

	}, Gh: function ( t ) {

		var i, s, h, a, e, o, r, n, p, l, c, y; i = this.C.gb, s = this.C.hb, h = this.C.ib, a = this.D.gb, e = this.D.hb, o = this.D.ib, r = this.C.kb, n = this.C.lb, p = this.C.mb, l = this.D.kb, c = this.D.lb, y = this.D.mb; for ( var f = 0, u = this.info.Ka; f < u; ) {

			var b = f ++, v = ( d = this.info.rows[ b ] ).ta, g = ( b = this.ac[ b ], d.Lj ), x = d.Kj, d = v.bd; g = v.df * g.va + v.ef * g.wa + v.ff * g.xa, x = v.df * x.va + v.ef * x.wa + v.ff * x.xa; v.zc = g, v.yc = x, v.bd *= t.dtRatio, v.zc *= t.dtRatio, v.yc *= t.dtRatio, i += b.Zh * d, s += b.$h * d, h += b.ai * d, i += b.yl * g, s += b.zl * g, h += b.Al * g, i += b.sl * x, s += b.tl * x, h += b.ul * x, a += b.bi * - d, e += b.ci * - d, o += b.di * - d, a += b.Bl * - g, e += b.Cl * - g, o += b.Dl * - g, a += b.vl * - x, e += b.wl * - x, o += b.xl * - x, r += b.Xf * d, n += b.Yf * d, p += b.Zf * d, r += b.Ej * g, n += b.Fj * g, p += b.Gj * g, r += b.lk * x, n += b.mk * x, p += b.nk * x, l += b.$f * - d, c += b.ag * - d, y += b.bg * - d, l += b.Hj * - g, c += b.Ij * - g, y += b.Jj * - g, l += b.pk * - x, c += b.qk * - x, y += b.rk * - x;

		}

		this.C.gb = i, this.C.hb = s, this.C.ib = h, this.D.gb = a, this.D.hb = e, this.D.ib = o, this.C.kb = r, this.C.lb = n, this.C.mb = p, this.D.kb = l, this.D.lb = c, this.D.mb = y;

	}, Ch: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c; t = this.C.gb, i = this.C.hb, s = this.C.ib, h = this.D.gb, a = this.D.hb, e = this.D.ib, o = this.C.kb, r = this.C.lb, n = this.C.mb, p = this.D.kb, l = this.D.lb, c = this.D.mb; for ( var y = 0, f = this.info.Ka; y < f; ) {

			var u = y ++, b = this.info.rows[ u ], v = ( u = this.ac[ u ], b.ta ), g = ( g = ( g = ( g = ( g = 0 ) + ( t * ( d = b.Lj ).va + i * d.wa + s * d.xa ) ) - ( h * d.Ba + a * d.Ca + e * d.Da ) ) + ( o * d.aa + r * d.ba + n * d.ca ) ) - ( p * d.ea + l * d.fa + c * d.ga ), x = ( x = ( x = ( x = ( x = 0 ) + ( t * ( d = b.Kj ).va + i * d.wa + s * d.xa ) ) - ( h * d.Ba + a * d.Ca + e * d.Da ) ) + ( o * d.aa + r * d.ba + n * d.ca ) ) - ( p * d.ea + l * d.fa + c * d.ga ), d = - ( g * u.ym + x * u.zm ), z = - ( g * u.Am + x * u.Bm ); g = v.zc, x = v.yc; v.zc += d, v.yc += z, ( b = b.friction * v.bd ) ? ( d = v.zc * v.zc + v.yc * v.yc ) > b * b && ( b /= Math.sqrt( d ), v.zc *= b, v.yc *= b ) : ( v.zc = 0, v.yc = 0 ), d = v.zc - g, z = v.yc - x, t += u.yl * d, i += u.zl * d, s += u.Al * d, t += u.sl * z, i += u.tl * z, s += u.ul * z, h += u.Bl * - d, a += u.Cl * - d, e += u.Dl * - d, h += u.vl * - z, a += u.wl * - z, e += u.xl * - z, o += u.Ej * d, r += u.Fj * d, n += u.Gj * d, o += u.lk * z, r += u.mk * z, n += u.nk * z, p += u.Hj * - d, l += u.Ij * - d, c += u.Jj * - d, p += u.pk * - z, l += u.qk * - z, c += u.rk * - z;

		}

		for ( y = 0, f = this.info.Ka; y < f; )u = y ++, b = this.info.rows[ u ], u = this.ac[ u ], v = b.ta, g = 0, g += t * ( x = b.Ng ).va + i * x.wa + s * x.xa, g -= h * x.Ba + a * x.Ca + e * x.Da, g += o * x.aa + r * x.ba + n * x.ca, g -= p * x.ea + l * x.fa + c * x.ga, b = ( b.Fa - g ) * u.he, g = v.bd, v.bd += b, 0 > v.bd && ( v.bd = 0 ), b = v.bd - g, t += u.Zh * b, i += u.$h * b, s += u.ai * b, h += u.bi * - b, a += u.ci * - b, e += u.di * - b, o += u.Xf * b, r += u.Yf * b, n += u.Zf * b, p += u.$f * - b, l += u.ag * - b, c += u.bg * - b; this.C.gb = t, this.C.hb = i, this.C.ib = s, this.D.gb = h, this.D.hb = a, this.D.ib = e, this.C.kb = o, this.C.lb = r, this.C.mb = n, this.D.kb = p, this.D.lb = l, this.D.mb = c;

	}, Pg: function () {

		this.Ji.al(), this.Ji.gd( this.info ); var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x = this.C.$a, d = this.D.$a; t = this.C.P, i = this.C.R, s = this.C.S, h = this.C.T, a = this.C.U, e = this.C.V, o = this.C.W, r = this.C.X, n = this.C.Y, p = this.D.P, l = this.D.R, c = this.D.S, y = this.D.T, f = this.D.U, u = this.D.V, b = this.D.W, v = this.D.X, g = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w = z ++, D = this.ac[ w ]; w = this.info.rows[ w ].Ng; D.Zh = w.va * x, D.$h = w.wa * x, D.ai = w.xa * x, D.bi = w.Ba * d, D.ci = w.Ca * d, D.di = w.Da * d, j = t * w.aa + i * w.ba + s * w.ca, M = h * w.aa + a * w.ba + e * w.ca, A = o * w.aa + r * w.ba + n * w.ca, D.Xf = j, D.Yf = M, D.Zf = A, j = p * w.ea + l * w.fa + c * w.ga, M = y * w.ea + f * w.fa + u * w.ga, A = b * w.ea + v * w.fa + g * w.ga, D.$f = j, D.ag = M, D.bg = A, D.he = x + d + ( D.Xf * w.aa + D.Yf * w.ba + D.Zf * w.ca ) + ( D.$f * w.ea + D.ag * w.fa + D.bg * w.ga ), 0 != D.he && ( D.he = 1 / D.he );

		}

		for ( x = 0, d = this.info.Ka; x < d; )t = x ++, this.info.rows[ t ].ta.ub = 0;

	}, Bh: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c; t = this.C.Yc, i = this.C.Zc, s = this.C.$c, h = this.D.Yc, a = this.D.Zc, e = this.D.$c, o = this.C.Uc, r = this.C.Vc, n = this.C.Wc, p = this.D.Uc, l = this.D.Vc, c = this.D.Wc; for ( var y = 0, f = this.info.Ka; y < f; ) {

			var u = y ++, b = this.info.rows[ u ], v = ( u = this.ac[ u ], b.ta ), g = ( g = ( g = ( g = ( g = 0 ) + ( t * ( x = b.Ng ).va + i * x.wa + s * x.xa ) ) - ( h * x.Ba + a * x.Ca + e * x.Da ) ) + ( o * x.aa + r * x.ba + n * x.ca ) ) - ( p * x.ea + l * x.fa + c * x.ga ), x = ( b = ( b.Fa - g ) * u.he * gt.positionSplitImpulseBaumgarte, v.ub ); v.ub += b, 0 > v.ub && ( v.ub = 0 ), b = v.ub - x, t += u.Zh * b, i += u.$h * b, s += u.ai * b, h += u.bi * - b, a += u.ci * - b, e += u.di * - b, o += u.Xf * b, r += u.Yf * b, n += u.Zf * b, p += u.$f * - b, l += u.ag * - b, c += u.bg * - b;

		}

		this.C.Yc = t, this.C.Zc = i, this.C.$c = s, this.D.Yc = h, this.D.Zc = a, this.D.$c = e, this.C.Uc = o, this.C.Vc = r, this.C.Wc = n, this.D.Uc = p, this.D.Vc = l, this.D.Wc = c;

	}, Ah: function () {

		this.Ji.al(), this.Ji.gd( this.info ); var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x = this.C.$a, d = this.D.$a; t = this.C.P, i = this.C.R, s = this.C.S, h = this.C.T, a = this.C.U, e = this.C.V, o = this.C.W, r = this.C.X, n = this.C.Y, p = this.D.P, l = this.D.R, c = this.D.S, y = this.D.T, f = this.D.U, u = this.D.V, b = this.D.W, v = this.D.X, g = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w, D, C, B = z ++, q = this.ac[ B ], S = this.info.rows[ B ].Ng; q.Zh = S.va * x, q.$h = S.wa * x, q.ai = S.xa * x, q.bi = S.Ba * d, q.ci = S.Ca * d, q.di = S.Da * d, j = t * S.aa + i * S.ba + s * S.ca, M = h * S.aa + a * S.ba + e * S.ca, A = o * S.aa + r * S.ba + n * S.ca, q.Xf = j, q.Yf = M, q.Zf = A, w = p * S.ea + l * S.fa + c * S.ga, D = y * S.ea + f * S.fa + u * S.ga, C = b * S.ea + v * S.fa + g * S.ga, q.$f = w, q.ag = D, q.bg = C, q.he = x + d + ( q.Xf * S.aa + q.Yf * S.ba + q.Zf * S.ca ) + ( q.$f * S.ea + q.ag * S.fa + q.bg * S.ga ), 0 != q.he && ( q.he = 1 / q.he );

		}

		for ( var k, I, T, O, L, F, P, R, J, N, H, K, G = K = H = N = J = R = P = F = L = O = T = I = k = 0, V = this.info.Ka; G < V; ) {

			var E = G ++, U = this.info.rows[ E ], W = this.ac[ E ], Y = U.ta, X = U.Ng, $ = ( $ = ( $ = ( $ = ( $ = 0 ) + ( k * X.va + I * X.wa + T * X.xa ) ) - ( O * X.Ba + L * X.Ca + F * X.Da ) ) + ( P * X.aa + R * X.ba + J * X.ca ) ) - ( N * X.ea + H * X.fa + K * X.ga ), Z = ( U.Fa - $ ) * W.he * gt.positionNgsBaumgarte, Q = Y.ub; Y.ub += Z, 0 > Y.ub && ( Y.ub = 0 ), Z = Y.ub - Q, k += W.Zh * Z, I += W.$h * Z, T += W.ai * Z, O += W.bi * - Z, L += W.ci * - Z, F += W.di * - Z, P += W.Xf * Z, R += W.Yf * Z, J += W.Zf * Z, N += W.$f * - Z, H += W.ag * - Z, K += W.bg * - Z;

		}

		var _ = this.C; _.a.v += k, _.a.A += I, _.a.B += T; var tt = this.D; tt.a.v += O, tt.a.A += L, tt.a.B += F; var it, st, ht, at, et, ot, rt = this.C, nt = Math.sqrt( P * P + R * R + J * J ), pt = .5 * nt; if ( .5 > pt ) {

			var lt = pt * pt; it = .5 * ( 1 - .16666666666666666 * lt + lt * lt * .008333333333333333 ), st = 1 - .5 * lt + lt * lt * .041666666666666664;

		} else it = Math.sin( pt ) / nt, st = Math.cos( pt ); ht = P * it, at = R * it, et = J * it, ot = st; var ct, yt, ft, ut, bt, vt = rt.a.o, xt = rt.a.m, dt = rt.a.s, zt = vt + xt + dt; 0 < zt ? ( ut = .5 * ( bt = Math.sqrt( zt + 1 ) ), bt = .5 / bt, ct = ( rt.a.g - rt.a.j ) * bt, yt = ( rt.a.h - rt.a.l ) * bt, ft = ( rt.a.i - rt.a.f ) * bt ) : vt > xt ? vt > dt ? ( ct = .5 * ( bt = Math.sqrt( vt - xt - dt + 1 ) ), bt = .5 / bt, yt = ( rt.a.f + rt.a.i ) * bt, ft = ( rt.a.h + rt.a.l ) * bt, ut = ( rt.a.g - rt.a.j ) * bt ) : ( ft = .5 * ( bt = Math.sqrt( dt - vt - xt + 1 ) ), bt = .5 / bt, ct = ( rt.a.h + rt.a.l ) * bt, yt = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.i - rt.a.f ) * bt ) : xt > dt ? ( yt = .5 * ( bt = Math.sqrt( xt - dt - vt + 1 ) ), bt = .5 / bt, ct = ( rt.a.f + rt.a.i ) * bt, ft = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.h - rt.a.l ) * bt ) : ( ft = .5 * ( bt = Math.sqrt( dt - vt - xt + 1 ) ), bt = .5 / bt, ct = ( rt.a.h + rt.a.l ) * bt, yt = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.i - rt.a.f ) * bt ); var mt = ( ct = ot * ct + ht * ut + at * ft - et * yt ) * ct + ( yt = ot * yt - ht * ft + at * ut + et * ct ) * yt + ( ft = ot * ft + ht * yt - at * ct + et * ut ) * ft + ( ut = ot * ut - ht * ct - at * yt - et * ft ) * ut; 1e-32 < mt && ( mt = 1 / Math.sqrt( mt ) ); ct *= mt, yt *= mt, ft *= mt, ut *= mt; var jt, Mt, At, wt, Dt, Ct, Bt, qt, St, kt, It, Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt = 2 * ct, Ht = 2 * yt, Kt = 2 * ft, Gt = ct * Nt, Vt = yt * Ht, Et = ft * Kt, Ut = ct * Ht, Wt = yt * Kt, Yt = ct * Kt, Xt = ut * Nt, $t = ut * Ht, Zt = ut * Kt; rt.a.o = 1 - Vt - Et, rt.a.f = Ut - Zt, rt.a.h = Yt + $t, rt.a.i = Ut + Zt, rt.a.m = 1 - Gt - Et, rt.a.j = Wt - Xt, rt.a.l = Yt - $t, rt.a.g = Wt + Xt, rt.a.s = 1 - Gt - Vt, jt = rt.a.o * rt.Ra + rt.a.f * rt.Ua + rt.a.h * rt.Xa, Mt = rt.a.o * rt.Sa + rt.a.f * rt.Va + rt.a.h * rt.Ya, At = rt.a.o * rt.Ta + rt.a.f * rt.Wa + rt.a.h * rt.Za, wt = rt.a.i * rt.Ra + rt.a.m * rt.Ua + rt.a.j * rt.Xa, Dt = rt.a.i * rt.Sa + rt.a.m * rt.Va + rt.a.j * rt.Ya, Ct = rt.a.i * rt.Ta + rt.a.m * rt.Wa + rt.a.j * rt.Za, Bt = rt.a.l * rt.Ra + rt.a.g * rt.Ua + rt.a.s * rt.Xa, qt = rt.a.l * rt.Sa + rt.a.g * rt.Va + rt.a.s * rt.Ya, St = rt.a.l * rt.Ta + rt.a.g * rt.Wa + rt.a.s * rt.Za, rt.P = jt, rt.R = Mt, rt.S = At, rt.T = wt, rt.U = Dt, rt.V = Ct, rt.W = Bt, rt.X = qt, rt.Y = St, kt = rt.P * rt.a.o + rt.R * rt.a.f + rt.S * rt.a.h, It = rt.P * rt.a.i + rt.R * rt.a.m + rt.S * rt.a.j, Tt = rt.P * rt.a.l + rt.R * rt.a.g + rt.S * rt.a.s, Ot = rt.T * rt.a.o + rt.U * rt.a.f + rt.V * rt.a.h, Lt = rt.T * rt.a.i + rt.U * rt.a.m + rt.V * rt.a.j, Ft = rt.T * rt.a.l + rt.U * rt.a.g + rt.V * rt.a.s, Pt = rt.W * rt.a.o + rt.X * rt.a.f + rt.Y * rt.a.h, Rt = rt.W * rt.a.i + rt.X * rt.a.m + rt.Y * rt.a.j, Jt = rt.W * rt.a.l + rt.X * rt.a.g + rt.Y * rt.a.s, rt.P = kt, rt.R = It, rt.S = Tt, rt.T = Ot, rt.U = Lt, rt.V = Ft, rt.W = Pt, rt.X = Rt, rt.Y = Jt, rt.P *= rt.N.x, rt.R *= rt.N.x, rt.S *= rt.N.x, rt.T *= rt.N.y, rt.U *= rt.N.y, rt.V *= rt.N.y, rt.W *= rt.N.z, rt.X *= rt.N.z, rt.Y *= rt.N.z; var Qt, _t, ti, ii, si, hi, ai = this.D, ei = Math.sqrt( N * N + H * H + K * K ), oi = .5 * ei; if ( .5 > oi ) {

			var ri = oi * oi; Qt = .5 * ( 1 - .16666666666666666 * ri + ri * ri * .008333333333333333 ), _t = 1 - .5 * ri + ri * ri * .041666666666666664;

		} else Qt = Math.sin( oi ) / ei, _t = Math.cos( oi ); ti = N * Qt, ii = H * Qt, si = K * Qt, hi = _t; var ni, pi, li, ci, yi, fi = ai.a.o, ui = ai.a.m, bi = ai.a.s, vi = fi + ui + bi; 0 < vi ? ( ci = .5 * ( yi = Math.sqrt( vi + 1 ) ), yi = .5 / yi, ni = ( ai.a.g - ai.a.j ) * yi, pi = ( ai.a.h - ai.a.l ) * yi, li = ( ai.a.i - ai.a.f ) * yi ) : fi > ui ? fi > bi ? ( ni = .5 * ( yi = Math.sqrt( fi - ui - bi + 1 ) ), yi = .5 / yi, pi = ( ai.a.f + ai.a.i ) * yi, li = ( ai.a.h + ai.a.l ) * yi, ci = ( ai.a.g - ai.a.j ) * yi ) : ( li = .5 * ( yi = Math.sqrt( bi - fi - ui + 1 ) ), yi = .5 / yi, ni = ( ai.a.h + ai.a.l ) * yi, pi = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.i - ai.a.f ) * yi ) : ui > bi ? ( pi = .5 * ( yi = Math.sqrt( ui - bi - fi + 1 ) ), yi = .5 / yi, ni = ( ai.a.f + ai.a.i ) * yi, li = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.h - ai.a.l ) * yi ) : ( li = .5 * ( yi = Math.sqrt( bi - fi - ui + 1 ) ), yi = .5 / yi, ni = ( ai.a.h + ai.a.l ) * yi, pi = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.i - ai.a.f ) * yi ); var gi = ( ni = hi * ni + ti * ci + ii * li - si * pi ) * ni + ( pi = hi * pi - ti * li + ii * ci + si * ni ) * pi + ( li = hi * li + ti * pi - ii * ni + si * ci ) * li + ( ci = hi * ci - ti * ni - ii * pi - si * li ) * ci; 1e-32 < gi && ( gi = 1 / Math.sqrt( gi ) ); ni *= gi, pi *= gi, li *= gi, ci *= gi; var xi, di, zi, mi, ji, Mi, Ai, wi, Di, Ci, Bi, qi, Si, ki, Ii, Ti, Oi, Li, Fi = 2 * ni, Pi = 2 * pi, Ri = 2 * li, Ji = ni * Fi, Ni = pi * Pi, Hi = li * Ri, Ki = ni * Pi, Gi = pi * Ri, Vi = ni * Ri, Ei = ci * Fi, Ui = ci * Pi, Wi = ci * Ri; ai.a.o = 1 - Ni - Hi, ai.a.f = Ki - Wi, ai.a.h = Vi + Ui, ai.a.i = Ki + Wi, ai.a.m = 1 - Ji - Hi, ai.a.j = Gi - Ei, ai.a.l = Vi - Ui, ai.a.g = Gi + Ei, ai.a.s = 1 - Ji - Ni, xi = ai.a.o * ai.Ra + ai.a.f * ai.Ua + ai.a.h * ai.Xa, di = ai.a.o * ai.Sa + ai.a.f * ai.Va + ai.a.h * ai.Ya, zi = ai.a.o * ai.Ta + ai.a.f * ai.Wa + ai.a.h * ai.Za, mi = ai.a.i * ai.Ra + ai.a.m * ai.Ua + ai.a.j * ai.Xa, ji = ai.a.i * ai.Sa + ai.a.m * ai.Va + ai.a.j * ai.Ya, Mi = ai.a.i * ai.Ta + ai.a.m * ai.Wa + ai.a.j * ai.Za, Ai = ai.a.l * ai.Ra + ai.a.g * ai.Ua + ai.a.s * ai.Xa, wi = ai.a.l * ai.Sa + ai.a.g * ai.Va + ai.a.s * ai.Ya, Di = ai.a.l * ai.Ta + ai.a.g * ai.Wa + ai.a.s * ai.Za, ai.P = xi, ai.R = di, ai.S = zi, ai.T = mi, ai.U = ji, ai.V = Mi, ai.W = Ai, ai.X = wi, ai.Y = Di, Ci = ai.P * ai.a.o + ai.R * ai.a.f + ai.S * ai.a.h, Bi = ai.P * ai.a.i + ai.R * ai.a.m + ai.S * ai.a.j, qi = ai.P * ai.a.l + ai.R * ai.a.g + ai.S * ai.a.s, Si = ai.T * ai.a.o + ai.U * ai.a.f + ai.V * ai.a.h, ki = ai.T * ai.a.i + ai.U * ai.a.m + ai.V * ai.a.j, Ii = ai.T * ai.a.l + ai.U * ai.a.g + ai.V * ai.a.s, Ti = ai.W * ai.a.o + ai.X * ai.a.f + ai.Y * ai.a.h, Oi = ai.W * ai.a.i + ai.X * ai.a.m + ai.Y * ai.a.j, Li = ai.W * ai.a.l + ai.X * ai.a.g + ai.Y * ai.a.s, ai.P = Ci, ai.R = Bi, ai.S = qi, ai.T = Si, ai.U = ki, ai.V = Ii, ai.W = Ti, ai.X = Oi, ai.Y = Li, ai.P *= ai.N.x, ai.R *= ai.N.x, ai.S *= ai.N.x, ai.T *= ai.N.y, ai.U *= ai.N.y, ai.V *= ai.N.y, ai.W *= ai.N.z, ai.X *= ai.N.z, ai.Y *= ai.N.z;

	}, postSolve: function () {

		for ( var t = 0, i = this.info.Ka; t < i; ) {

			var s, h, a, e = t ++, o = ( e = ( r = this.info.rows[ e ] ).ta, r.Lj ), r = r.Kj; a = h = s = 0, s += o.va * e.zc, h += o.wa * e.zc, a += o.xa * e.zc, s += r.va * e.yc, h += r.wa * e.yc, a += r.xa * e.yc, e.df = s, e.ef = h, e.ff = a;

		}

		this.Ji.al();

	} } ), e.ua = Y, e.prototype = ri( Y.prototype, { xh: function ( t ) {

		this.$.hd(), this.$.$d( t, this.info ), this.C = this.info.Qe, this.D = this.info.Re, t = this.C.$a; var i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x, d = this.D.$a; i = this.C.P, s = this.C.R, h = this.C.S, a = this.C.T, e = this.C.U, o = this.C.V, r = this.C.W, n = this.C.X, p = this.C.Y, l = this.D.P, c = this.D.R, y = this.D.S, f = this.D.T, u = this.D.U, b = this.D.V, v = this.D.W, g = this.D.X, x = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w = z ++, D = this.info.rows[ w ], C = ( w = this.ac[ w ], D.Aa ); if ( C.Im(), 1 & C.xc ? ( w.qd = C.va * t, w.rd = C.wa * t, w.sd = C.xa * t, w.td = C.Ba * d, w.ud = C.Ca * d, w.vd = C.Da * d ) : ( w.qd = 0, w.rd = 0, w.sd = 0, w.td = 0, w.ud = 0, w.vd = 0 ), 2 & C.xc )j = i * C.aa + s * C.ba + h * C.ca, M = a * C.aa + e * C.ba + o * C.ca, A = r * C.aa + n * C.ba + p * C.ca, w.kd = j, w.ld = M, w.md = A, j = l * C.ea + c * C.fa + y * C.ga, M = f * C.ea + u * C.fa + b * C.ga, A = v * C.ea + g * C.fa + x * C.ga, w.nd = j, w.od = M, w.pd = A; else w.kd = 0, w.ld = 0, w.md = 0, w.nd = 0, w.od = 0, w.pd = 0; w.Ff = w.qd * C.va + w.rd * C.wa + w.sd * C.xa + ( w.td * C.Ba + w.ud * C.Ca + w.vd * C.Da ) + ( w.kd * C.aa + w.ld * C.ba + w.md * C.ca ) + ( w.nd * C.ea + w.od * C.fa + w.pd * C.ga ), w.mass = w.Ff + D.Ma, w.Ff && ( w.Ff = 1 / w.Ff ), 0 != w.mass && ( w.mass = 1 / w.mass );

		}

	}, Gh: function ( t ) {

		var i; if ( 0 >= ( i = ( i = this.$.Hc == W.BAUMGARTE ? gt.jointWarmStartingFactorForBaungarte : gt.jointWarmStartingFactor ) * t.dtRatio ) ) for ( i = 0, t = this.info.Ka; i < t; ) {

			var s = i ++; ( s = this.info.rows[ s ].ta ).ta = 0, s.ad = 0, s.ub = 0;

		} else {

			var h, a, e, o, r, n, p, l, c, y; t = this.C.gb, s = this.C.hb, h = this.C.ib, a = this.D.gb, e = this.D.hb, o = this.D.ib, r = this.C.kb, n = this.C.lb, p = this.C.mb, l = this.D.kb, c = this.D.lb, y = this.D.mb; for ( var f = 0, u = this.info.Ka; f < u; ) {

				var b = f ++, v = this.ac[ b ]; ( b = this.info.rows[ b ].ta ).ta *= i, b.ad *= i, b = b.ta + b.ad, t += v.qd * b, s += v.rd * b, h += v.sd * b, a += v.td * - b, e += v.ud * - b, o += v.vd * - b, r += v.kd * b, n += v.ld * b, p += v.md * b, l += v.nd * - b, c += v.od * - b, y += v.pd * - b;

			}

			this.C.gb = t, this.C.hb = s, this.C.ib = h, this.D.gb = a, this.D.hb = e, this.D.ib = o, this.C.kb = r, this.C.lb = n, this.C.mb = p, this.D.kb = l, this.D.lb = c, this.D.mb = y;

		}

	}, Ch: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c; t = this.C.gb, i = this.C.hb, s = this.C.ib, h = this.D.gb, a = this.D.hb, e = this.D.ib, o = this.C.kb, r = this.C.lb, n = this.C.mb, p = this.D.kb, l = this.D.lb, c = this.D.mb; for ( var y = 0, f = this.info.Ka; y < f; ) {

			var u = y ++, b = this.info.rows[ u ], v = ( u = this.ac[ u ], b.ta ), g = b.Aa; if ( 0 != b.fb ) {

				var x = ( x = ( x = ( x = ( x = 0 ) + ( t * g.va + i * g.wa + s * g.xa ) ) - ( h * g.Ba + a * g.Ca + e * g.Da ) ) + ( o * g.aa + r * g.ba + n * g.ca ) ) - ( p * g.ea + l * g.fa + c * g.ga ), d = ( x = ( - b.motorSpeed - x ) * u.Ff, v.ad ); v.ad += x, v.ad < - b.fb ? v.ad = - b.fb : v.ad > b.fb && ( v.ad = b.fb ), x = v.ad - d, 1 & g.xc && ( t += u.qd * x, i += u.rd * x, s += u.sd * x, h += u.td * - x, a += u.ud * - x, e += u.vd * - x ), 2 & g.xc && ( o += u.kd * x, r += u.ld * x, n += u.md * x, p += u.nd * - x, l += u.od * - x, c += u.pd * - x );

			}

		}

		for ( y = 0, f = this.info.Ka; y < f; )u = y ++, b = this.info.rows[ u ], u = this.ac[ u ], v = b.ta, x = 0, x += t * ( g = b.Aa ).va + i * g.wa + s * g.xa, x -= h * g.Ba + a * g.Ca + e * g.Da, x += o * g.aa + r * g.ba + n * g.ca, x -= p * g.ea + l * g.fa + c * g.ga, x = ( b.Fa - x - v.ta * b.Ma ) * u.mass, d = v.ta, v.ta += x, v.ta < b.Ia ? v.ta = b.Ia : v.ta > b.Ha && ( v.ta = b.Ha ), x = v.ta - d, 1 & g.xc && ( t += u.qd * x, i += u.rd * x, s += u.sd * x, h += u.td * - x, a += u.ud * - x, e += u.vd * - x ), 2 & g.xc && ( o += u.kd * x, r += u.ld * x, n += u.md * x, p += u.nd * - x, l += u.od * - x, c += u.pd * - x ); this.C.gb = t, this.C.hb = i, this.C.ib = s, this.D.gb = h, this.D.hb = a, this.D.ib = e, this.C.kb = o, this.C.lb = r, this.C.mb = n, this.D.kb = p, this.D.lb = l, this.D.mb = c;

	}, Li: function ( t ) {

		for ( var i, s, h, a, e, o, r = o = e = a = h = s = i = 0, n = this.info.Ka; r < n; ) {

			var p, l = r ++; l = ( p = this.info.rows[ l ] ).ta; 1 & ( p = p.Aa ).xc ? ( i += p.va * l.ta, s += p.wa * l.ta, h += p.xa * l.ta ) : 2 & p.xc && ( a += p.aa * l.ta, e += p.ba * l.ta, o += p.ca * l.ta );

		}

		this.$.Pi = i * t.invDt, this.$.Qi = s * t.invDt, this.$.Ri = h * t.invDt, this.$.Si = a * t.invDt, this.$.Ti = e * t.invDt, this.$.Ui = o * t.invDt;

	}, Pg: function () {

		this.$.hd(), this.$.gd( this.info ), this.C = this.info.Qe, this.D = this.info.Re; var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x = this.C.$a, d = this.D.$a; t = this.C.P, i = this.C.R, s = this.C.S, h = this.C.T, a = this.C.U, e = this.C.V, o = this.C.W, r = this.C.X, n = this.C.Y, p = this.D.P, l = this.D.R, c = this.D.S, y = this.D.T, f = this.D.U, u = this.D.V, b = this.D.W, v = this.D.X, g = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w = z ++, D = this.ac[ w ]; w = this.info.rows[ w ].Aa; D.qd = w.va * x, D.rd = w.wa * x, D.sd = w.xa * x, D.td = w.Ba * d, D.ud = w.Ca * d, D.vd = w.Da * d, j = t * w.aa + i * w.ba + s * w.ca, M = h * w.aa + a * w.ba + e * w.ca, A = o * w.aa + r * w.ba + n * w.ca, D.kd = j, D.ld = M, D.md = A, j = p * w.ea + l * w.fa + c * w.ga, M = y * w.ea + f * w.fa + u * w.ga, A = b * w.ea + v * w.fa + g * w.ga, D.nd = j, D.od = M, D.pd = A, D.mass = D.qd * w.va + D.rd * w.wa + D.sd * w.xa + ( D.td * w.Ba + D.ud * w.Ca + D.vd * w.Da ) + ( D.kd * w.aa + D.ld * w.ba + D.md * w.ca ) + ( D.nd * w.ea + D.od * w.fa + D.pd * w.ga ), D.mass && ( D.mass = 1 / D.mass );

		}

		for ( x = 0, d = this.info.Ka; x < d; )t = x ++, this.info.rows[ t ].ta.ub = 0;

	}, Bh: function () {

		var t, i, s, h, a, e, o, r, n, p, l, c; t = this.C.Yc, i = this.C.Zc, s = this.C.$c, h = this.D.Yc, a = this.D.Zc, e = this.D.$c, o = this.C.Uc, r = this.C.Vc, n = this.C.Wc, p = this.D.Uc, l = this.D.Vc, c = this.D.Wc; for ( var y = 0, f = this.info.Ka; y < f; ) {

			var u = y ++, b = this.info.rows[ u ], v = ( u = this.ac[ u ], b.ta ), g = ( g = ( g = ( g = ( g = 0 ) + ( t * ( x = b.Aa ).va + i * x.wa + s * x.xa ) ) - ( h * x.Ba + a * x.Ca + e * x.Da ) ) + ( o * x.aa + r * x.ba + n * x.ca ) ) - ( p * x.ea + l * x.fa + c * x.ga ), x = ( b.Fa * gt.positionSplitImpulseBaumgarte - g ) * u.mass; g = v.ub; v.ub += x, v.ub < b.Ia ? v.ub = b.Ia : v.ub > b.Ha && ( v.ub = b.Ha ), x = v.ub - g, t += u.qd * x, i += u.rd * x, s += u.sd * x, h += u.td * - x, a += u.ud * - x, e += u.vd * - x, o += u.kd * x, r += u.ld * x, n += u.md * x, p += u.nd * - x, l += u.od * - x, c += u.pd * - x;

		}

		this.C.Yc = t, this.C.Zc = i, this.C.$c = s, this.D.Yc = h, this.D.Zc = a, this.D.$c = e, this.C.Uc = o, this.C.Vc = r, this.C.Wc = n, this.D.Uc = p, this.D.Vc = l, this.D.Wc = c;

	}, Ah: function () {

		this.$.hd(), this.$.gd( this.info ), this.C = this.info.Qe, this.D = this.info.Re; var t, i, s, h, a, e, o, r, n, p, l, c, y, f, u, b, v, g, x = this.C.$a, d = this.D.$a; t = this.C.P, i = this.C.R, s = this.C.S, h = this.C.T, a = this.C.U, e = this.C.V, o = this.C.W, r = this.C.X, n = this.C.Y, p = this.D.P, l = this.D.R, c = this.D.S, y = this.D.T, f = this.D.U, u = this.D.V, b = this.D.W, v = this.D.X, g = this.D.Y; for ( var z = 0, m = this.info.Ka; z < m; ) {

			var j, M, A, w, D, C, B = z ++, q = this.ac[ B ], S = this.info.rows[ B ].Aa; q.qd = S.va * x, q.rd = S.wa * x, q.sd = S.xa * x, q.td = S.Ba * d, q.ud = S.Ca * d, q.vd = S.Da * d, j = t * S.aa + i * S.ba + s * S.ca, M = h * S.aa + a * S.ba + e * S.ca, A = o * S.aa + r * S.ba + n * S.ca, q.kd = j, q.ld = M, q.md = A, w = p * S.ea + l * S.fa + c * S.ga, D = y * S.ea + f * S.fa + u * S.ga, C = b * S.ea + v * S.fa + g * S.ga, q.nd = w, q.od = D, q.pd = C, q.mass = q.qd * S.va + q.rd * S.wa + q.sd * S.xa + ( q.td * S.Ba + q.ud * S.Ca + q.vd * S.Da ) + ( q.kd * S.aa + q.ld * S.ba + q.md * S.ca ) + ( q.nd * S.ea + q.od * S.fa + q.pd * S.ga ), q.mass && ( q.mass = 1 / q.mass );

		}

		for ( var k, I, T, O, L, F, P, R, J, N, H, K, G = K = H = N = J = R = P = F = L = O = T = I = k = 0, V = this.info.Ka; G < V; ) {

			var E = G ++, U = this.info.rows[ E ], W = this.ac[ E ], Y = U.ta, X = U.Aa, $ = ( $ = ( $ = ( $ = ( $ = 0 ) + ( k * X.va + I * X.wa + T * X.xa ) ) - ( O * X.Ba + L * X.Ca + F * X.Da ) ) + ( P * X.aa + R * X.ba + J * X.ca ) ) - ( N * X.ea + H * X.fa + K * X.ga ), Z = ( U.Fa * gt.positionNgsBaumgarte - $ ) * W.mass, Q = Y.ub; Y.ub += Z, Y.ub < U.Ia ? Y.ub = U.Ia : Y.ub > U.Ha && ( Y.ub = U.Ha ), Z = Y.ub - Q, k += W.qd * Z, I += W.rd * Z, T += W.sd * Z, O += W.td * - Z, L += W.ud * - Z, F += W.vd * - Z, P += W.kd * Z, R += W.ld * Z, J += W.md * Z, N += W.nd * - Z, H += W.od * - Z, K += W.pd * - Z;

		}

		var _ = this.C; _.a.v += k, _.a.A += I, _.a.B += T; var tt = this.D; tt.a.v += O, tt.a.A += L, tt.a.B += F; var it, st, ht, at, et, ot, rt = this.C, nt = Math.sqrt( P * P + R * R + J * J ), pt = .5 * nt; if ( .5 > pt ) {

			var lt = pt * pt; it = .5 * ( 1 - .16666666666666666 * lt + lt * lt * .008333333333333333 ), st = 1 - .5 * lt + lt * lt * .041666666666666664;

		} else it = Math.sin( pt ) / nt, st = Math.cos( pt ); ht = P * it, at = R * it, et = J * it, ot = st; var ct, yt, ft, ut, bt, vt = rt.a.o, xt = rt.a.m, dt = rt.a.s, zt = vt + xt + dt; 0 < zt ? ( ut = .5 * ( bt = Math.sqrt( zt + 1 ) ), bt = .5 / bt, ct = ( rt.a.g - rt.a.j ) * bt, yt = ( rt.a.h - rt.a.l ) * bt, ft = ( rt.a.i - rt.a.f ) * bt ) : vt > xt ? vt > dt ? ( ct = .5 * ( bt = Math.sqrt( vt - xt - dt + 1 ) ), bt = .5 / bt, yt = ( rt.a.f + rt.a.i ) * bt, ft = ( rt.a.h + rt.a.l ) * bt, ut = ( rt.a.g - rt.a.j ) * bt ) : ( ft = .5 * ( bt = Math.sqrt( dt - vt - xt + 1 ) ), bt = .5 / bt, ct = ( rt.a.h + rt.a.l ) * bt, yt = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.i - rt.a.f ) * bt ) : xt > dt ? ( yt = .5 * ( bt = Math.sqrt( xt - dt - vt + 1 ) ), bt = .5 / bt, ct = ( rt.a.f + rt.a.i ) * bt, ft = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.h - rt.a.l ) * bt ) : ( ft = .5 * ( bt = Math.sqrt( dt - vt - xt + 1 ) ), bt = .5 / bt, ct = ( rt.a.h + rt.a.l ) * bt, yt = ( rt.a.j + rt.a.g ) * bt, ut = ( rt.a.i - rt.a.f ) * bt ); var mt = ( ct = ot * ct + ht * ut + at * ft - et * yt ) * ct + ( yt = ot * yt - ht * ft + at * ut + et * ct ) * yt + ( ft = ot * ft + ht * yt - at * ct + et * ut ) * ft + ( ut = ot * ut - ht * ct - at * yt - et * ft ) * ut; 1e-32 < mt && ( mt = 1 / Math.sqrt( mt ) ); ct *= mt, yt *= mt, ft *= mt, ut *= mt; var jt, Mt, At, wt, Dt, Ct, Bt, qt, St, kt, It, Tt, Ot, Lt, Ft, Pt, Rt, Jt, Nt = 2 * ct, Ht = 2 * yt, Kt = 2 * ft, Gt = ct * Nt, Vt = yt * Ht, Et = ft * Kt, Ut = ct * Ht, Wt = yt * Kt, Yt = ct * Kt, Xt = ut * Nt, $t = ut * Ht, Zt = ut * Kt; rt.a.o = 1 - Vt - Et, rt.a.f = Ut - Zt, rt.a.h = Yt + $t, rt.a.i = Ut + Zt, rt.a.m = 1 - Gt - Et, rt.a.j = Wt - Xt, rt.a.l = Yt - $t, rt.a.g = Wt + Xt, rt.a.s = 1 - Gt - Vt, jt = rt.a.o * rt.Ra + rt.a.f * rt.Ua + rt.a.h * rt.Xa, Mt = rt.a.o * rt.Sa + rt.a.f * rt.Va + rt.a.h * rt.Ya, At = rt.a.o * rt.Ta + rt.a.f * rt.Wa + rt.a.h * rt.Za, wt = rt.a.i * rt.Ra + rt.a.m * rt.Ua + rt.a.j * rt.Xa, Dt = rt.a.i * rt.Sa + rt.a.m * rt.Va + rt.a.j * rt.Ya, Ct = rt.a.i * rt.Ta + rt.a.m * rt.Wa + rt.a.j * rt.Za, Bt = rt.a.l * rt.Ra + rt.a.g * rt.Ua + rt.a.s * rt.Xa, qt = rt.a.l * rt.Sa + rt.a.g * rt.Va + rt.a.s * rt.Ya, St = rt.a.l * rt.Ta + rt.a.g * rt.Wa + rt.a.s * rt.Za, rt.P = jt, rt.R = Mt, rt.S = At, rt.T = wt, rt.U = Dt, rt.V = Ct, rt.W = Bt, rt.X = qt, rt.Y = St, kt = rt.P * rt.a.o + rt.R * rt.a.f + rt.S * rt.a.h, It = rt.P * rt.a.i + rt.R * rt.a.m + rt.S * rt.a.j, Tt = rt.P * rt.a.l + rt.R * rt.a.g + rt.S * rt.a.s, Ot = rt.T * rt.a.o + rt.U * rt.a.f + rt.V * rt.a.h, Lt = rt.T * rt.a.i + rt.U * rt.a.m + rt.V * rt.a.j, Ft = rt.T * rt.a.l + rt.U * rt.a.g + rt.V * rt.a.s, Pt = rt.W * rt.a.o + rt.X * rt.a.f + rt.Y * rt.a.h, Rt = rt.W * rt.a.i + rt.X * rt.a.m + rt.Y * rt.a.j, Jt = rt.W * rt.a.l + rt.X * rt.a.g + rt.Y * rt.a.s, rt.P = kt, rt.R = It, rt.S = Tt, rt.T = Ot, rt.U = Lt, rt.V = Ft, rt.W = Pt, rt.X = Rt, rt.Y = Jt, rt.P *= rt.N.x, rt.R *= rt.N.x, rt.S *= rt.N.x, rt.T *= rt.N.y, rt.U *= rt.N.y, rt.V *= rt.N.y, rt.W *= rt.N.z, rt.X *= rt.N.z, rt.Y *= rt.N.z; var Qt, _t, ti, ii, si, hi, ai = this.D, ei = Math.sqrt( N * N + H * H + K * K ), oi = .5 * ei; if ( .5 > oi ) {

			var ri = oi * oi; Qt = .5 * ( 1 - .16666666666666666 * ri + ri * ri * .008333333333333333 ), _t = 1 - .5 * ri + ri * ri * .041666666666666664;

		} else Qt = Math.sin( oi ) / ei, _t = Math.cos( oi ); ti = N * Qt, ii = H * Qt, si = K * Qt, hi = _t; var ni, pi, li, ci, yi, fi = ai.a.o, ui = ai.a.m, bi = ai.a.s, vi = fi + ui + bi; 0 < vi ? ( ci = .5 * ( yi = Math.sqrt( vi + 1 ) ), yi = .5 / yi, ni = ( ai.a.g - ai.a.j ) * yi, pi = ( ai.a.h - ai.a.l ) * yi, li = ( ai.a.i - ai.a.f ) * yi ) : fi > ui ? fi > bi ? ( ni = .5 * ( yi = Math.sqrt( fi - ui - bi + 1 ) ), yi = .5 / yi, pi = ( ai.a.f + ai.a.i ) * yi, li = ( ai.a.h + ai.a.l ) * yi, ci = ( ai.a.g - ai.a.j ) * yi ) : ( li = .5 * ( yi = Math.sqrt( bi - fi - ui + 1 ) ), yi = .5 / yi, ni = ( ai.a.h + ai.a.l ) * yi, pi = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.i - ai.a.f ) * yi ) : ui > bi ? ( pi = .5 * ( yi = Math.sqrt( ui - bi - fi + 1 ) ), yi = .5 / yi, ni = ( ai.a.f + ai.a.i ) * yi, li = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.h - ai.a.l ) * yi ) : ( li = .5 * ( yi = Math.sqrt( bi - fi - ui + 1 ) ), yi = .5 / yi, ni = ( ai.a.h + ai.a.l ) * yi, pi = ( ai.a.j + ai.a.g ) * yi, ci = ( ai.a.i - ai.a.f ) * yi ); var gi = ( ni = hi * ni + ti * ci + ii * li - si * pi ) * ni + ( pi = hi * pi - ti * li + ii * ci + si * ni ) * pi + ( li = hi * li + ti * pi - ii * ni + si * ci ) * li + ( ci = hi * ci - ti * ni - ii * pi - si * li ) * ci; 1e-32 < gi && ( gi = 1 / Math.sqrt( gi ) ); ni *= gi, pi *= gi, li *= gi, ci *= gi; var xi, di, zi, mi, ji, Mi, Ai, wi, Di, Ci, Bi, qi, Si, ki, Ii, Ti, Oi, Li, Fi = 2 * ni, Pi = 2 * pi, Ri = 2 * li, Ji = ni * Fi, Ni = pi * Pi, Hi = li * Ri, Ki = ni * Pi, Gi = pi * Ri, Vi = ni * Ri, Ei = ci * Fi, Ui = ci * Pi, Wi = ci * Ri; ai.a.o = 1 - Ni - Hi, ai.a.f = Ki - Wi, ai.a.h = Vi + Ui, ai.a.i = Ki + Wi, ai.a.m = 1 - Ji - Hi, ai.a.j = Gi - Ei, ai.a.l = Vi - Ui, ai.a.g = Gi + Ei, ai.a.s = 1 - Ji - Ni, xi = ai.a.o * ai.Ra + ai.a.f * ai.Ua + ai.a.h * ai.Xa, di = ai.a.o * ai.Sa + ai.a.f * ai.Va + ai.a.h * ai.Ya, zi = ai.a.o * ai.Ta + ai.a.f * ai.Wa + ai.a.h * ai.Za, mi = ai.a.i * ai.Ra + ai.a.m * ai.Ua + ai.a.j * ai.Xa, ji = ai.a.i * ai.Sa + ai.a.m * ai.Va + ai.a.j * ai.Ya, Mi = ai.a.i * ai.Ta + ai.a.m * ai.Wa + ai.a.j * ai.Za, Ai = ai.a.l * ai.Ra + ai.a.g * ai.Ua + ai.a.s * ai.Xa, wi = ai.a.l * ai.Sa + ai.a.g * ai.Va + ai.a.s * ai.Ya, Di = ai.a.l * ai.Ta + ai.a.g * ai.Wa + ai.a.s * ai.Za, ai.P = xi, ai.R = di, ai.S = zi, ai.T = mi, ai.U = ji, ai.V = Mi, ai.W = Ai, ai.X = wi, ai.Y = Di, Ci = ai.P * ai.a.o + ai.R * ai.a.f + ai.S * ai.a.h, Bi = ai.P * ai.a.i + ai.R * ai.a.m + ai.S * ai.a.j, qi = ai.P * ai.a.l + ai.R * ai.a.g + ai.S * ai.a.s, Si = ai.T * ai.a.o + ai.U * ai.a.f + ai.V * ai.a.h, ki = ai.T * ai.a.i + ai.U * ai.a.m + ai.V * ai.a.j, Ii = ai.T * ai.a.l + ai.U * ai.a.g + ai.V * ai.a.s, Ti = ai.W * ai.a.o + ai.X * ai.a.f + ai.Y * ai.a.h, Oi = ai.W * ai.a.i + ai.X * ai.a.m + ai.Y * ai.a.j, Li = ai.W * ai.a.l + ai.X * ai.a.g + ai.Y * ai.a.s, ai.P = Ci, ai.R = Bi, ai.S = qi, ai.T = Si, ai.U = ki, ai.V = Ii, ai.W = Ti, ai.X = Oi, ai.Y = Li, ai.P *= ai.N.x, ai.R *= ai.N.x, ai.S *= ai.N.x, ai.T *= ai.N.y, ai.U *= ai.N.y, ai.V *= ai.N.y, ai.W *= ai.N.z, ai.X *= ai.N.z, ai.Y *= ai.N.z;

	}, postSolve: function () {

		this.$.hd(), this.$.Rl();

	} } ), h.prototype = { Wl: function ( t ) {

		switch ( this.Lb ) {

			case 1:this.Wc = this.Vc = this.Uc = this.$c = this.Zc = this.Yc = this.mb = this.lb = this.kb = this.ib = this.hb = this.gb = 0; break; case 0:case 2:var i, s, h, a, e; i = this.gb * t, s = this.hb * t, h = this.ib * t; var o = ( a = this.kb * t ) * a + ( e = this.lb * t ) * e + ( t = this.mb * t ) * t; if ( ( r = i * i + s * s + h * h ) || o ) {

				var r, n; r > gt.maxTranslationPerStep * gt.maxTranslationPerStep && ( r = gt.maxTranslationPerStep / Math.sqrt( r ), this.gb *= r, this.hb *= r, this.ib *= r, i *= r, s *= r, h *= r ), o > gt.maxRotationPerStep * gt.maxRotationPerStep && ( o = gt.maxRotationPerStep / Math.sqrt( o ), this.kb *= o, this.lb *= o, this.mb *= o, a *= o, e *= o, t *= o ), this.a.v += i, this.a.A += s, this.a.B += h, .5 > ( s = .5 * ( i = Math.sqrt( a * a + e * e + t * t ) ) ) ? ( i = .5 * ( 1 - .16666666666666666 * ( s *= s ) + s * s * .008333333333333333 ), s = 1 - .5 * s + s * s * .041666666666666664 ) : ( i = Math.sin( s ) / i, s = Math.cos( s ) ), a *= i, e *= i, t *= i, i = s, 0 < ( r = ( s = this.a.o ) + ( h = this.a.m ) + ( o = this.a.s ) ) ? ( s = .5 * ( n = Math.sqrt( r + 1 ) ), n = .5 / n, r = ( this.a.g - this.a.j ) * n, o = ( this.a.h - this.a.l ) * n, h = ( this.a.i - this.a.f ) * n ) : s > h ? s > o ? ( r = .5 * ( n = Math.sqrt( s - h - o + 1 ) ), n = .5 / n, o = ( this.a.f + this.a.i ) * n, h = ( this.a.h + this.a.l ) * n, s = ( this.a.g - this.a.j ) * n ) : ( h = .5 * ( n = Math.sqrt( o - s - h + 1 ) ), n = .5 / n, r = ( this.a.h + this.a.l ) * n, o = ( this.a.j + this.a.g ) * n, s = ( this.a.i - this.a.f ) * n ) : h > o ? ( o = .5 * ( n = Math.sqrt( h - o - s + 1 ) ), n = .5 / n, r = ( this.a.f + this.a.i ) * n, h = ( this.a.j + this.a.g ) * n, s = ( this.a.h - this.a.l ) * n ) : ( h = .5 * ( n = Math.sqrt( o - s - h + 1 ) ), n = .5 / n, r = ( this.a.h + this.a.l ) * n, o = ( this.a.j + this.a.g ) * n, s = ( this.a.i - this.a.f ) * n ), 1e-32 < ( t = ( r = i * r + a * s + e * h - t * o ) * r + ( o = i * o - a * h + e * s + t * r ) * o + ( h = i * h + a * o - e * r + t * s ) * h + ( s = i * s - a * r - e * o - t * h ) * s ) && ( t = 1 / Math.sqrt( t ) ), e = r * t, r = o * t, h *= t, i = s * t; var p = 2 * e; t = e * p, a = r * ( n = 2 * r ), h *= s = 2 * h, o = e * n, r *= s, e *= s, p *= i, n *= i, i *= s, this.a.o = 1 - a - h, this.a.f = o - i, this.a.h = e + n, this.a.i = o + i, this.a.m = 1 - t - h, this.a.j = r - p, this.a.l = e - n, this.a.g = r + p, this.a.s = 1 - t - a, e = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, t = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, a = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, i = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, s = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, h = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, o = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, r = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = e, this.R = t, this.S = a, this.T = i, this.U = s, this.V = h, this.W = o, this.X = r, this.Y = n, e = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, t = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, a = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, i = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, s = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, h = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, o = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, r = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = e, this.R = t, this.S = a, this.T = i, this.U = s, this.V = h, this.W = o, this.X = r, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z;

			}

		}

	}, dn: function () {

		var t = this.Uc * this.Uc + this.Vc * this.Vc + this.Wc * this.Wc; if ( this.Yc * this.Yc + this.Zc * this.Zc + this.$c * this.$c || t ) switch ( this.Lb ) {

			case 1:this.Wc = this.Vc = this.Uc = this.$c = this.Zc = this.Yc = 0; break; case 0:case 2:var i, s, h, a, e, o, r, n; i = this.Yc, s = this.Zc, h = this.$c, t = this.Uc, a = this.Vc, e = this.Wc, this.Wc = this.Vc = this.Uc = this.$c = this.Zc = this.Yc = 0, this.a.v += i, this.a.A += s, this.a.B += h, .5 > ( s = .5 * ( i = Math.sqrt( t * t + a * a + e * e ) ) ) ? ( i = .5 * ( 1 - .16666666666666666 * ( s *= s ) + s * s * .008333333333333333 ), s = 1 - .5 * s + s * s * .041666666666666664 ) : ( i = Math.sin( s ) / i, s = Math.cos( s ) ), t *= i, a *= i, e *= i, i = s, 0 < ( o = ( s = this.a.o ) + ( h = this.a.m ) + ( r = this.a.s ) ) ? ( s = .5 * ( n = Math.sqrt( o + 1 ) ), n = .5 / n, o = ( this.a.g - this.a.j ) * n, r = ( this.a.h - this.a.l ) * n, h = ( this.a.i - this.a.f ) * n ) : s > h ? s > r ? ( o = .5 * ( n = Math.sqrt( s - h - r + 1 ) ), n = .5 / n, r = ( this.a.f + this.a.i ) * n, h = ( this.a.h + this.a.l ) * n, s = ( this.a.g - this.a.j ) * n ) : ( h = .5 * ( n = Math.sqrt( r - s - h + 1 ) ), n = .5 / n, o = ( this.a.h + this.a.l ) * n, r = ( this.a.j + this.a.g ) * n, s = ( this.a.i - this.a.f ) * n ) : h > r ? ( r = .5 * ( n = Math.sqrt( h - r - s + 1 ) ), n = .5 / n, o = ( this.a.f + this.a.i ) * n, h = ( this.a.j + this.a.g ) * n, s = ( this.a.h - this.a.l ) * n ) : ( h = .5 * ( n = Math.sqrt( r - s - h + 1 ) ), n = .5 / n, o = ( this.a.h + this.a.l ) * n, r = ( this.a.j + this.a.g ) * n, s = ( this.a.i - this.a.f ) * n ), 1e-32 < ( a = ( o = i * o + t * s + a * h - e * r ) * o + ( r = i * r - t * h + a * s + e * o ) * r + ( h = i * h + t * r - a * o + e * s ) * h + ( s = i * s - t * o - a * r - e * h ) * s ) && ( a = 1 / Math.sqrt( a ) ), t = o * a, o = r * a, h *= a, i = s * a; var p = 2 * t; a = t * p, e = o * ( n = 2 * o ), h *= s = 2 * h, r = t * n, o *= s, t *= s, p *= i, n *= i, i *= s, this.a.o = 1 - e - h, this.a.f = r - i, this.a.h = t + n, this.a.i = r + i, this.a.m = 1 - a - h, this.a.j = o - p, this.a.l = t - n, this.a.g = o + p, this.a.s = 1 - a - e, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, a = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, e = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, i = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, s = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, h = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, r = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, o = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = a, this.S = e, this.T = i, this.U = s, this.V = h, this.W = r, this.X = o, this.Y = n, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, a = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, e = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, i = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, s = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, h = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, r = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, o = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = a, this.S = e, this.T = i, this.U = s, this.V = h, this.W = r, this.X = o, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z;

		}

	}, Oj: function () {

		for ( var t, i, s, h, a, e, o, r, n, p = n = r = o = e = a = h = s = i = t = 0, l = this.Dc; null != l; ) {

			var c = l.M; ( C = l.Kb ).Oe(); var y, f, u, b, v, g, x, d, z = l.Dk * C.yf; y = l.ha.o * C.mg + l.ha.f * C.pg + l.ha.h * C.sg, f = l.ha.o * C.ng + l.ha.f * C.qg + l.ha.h * C.tg, u = l.ha.o * C.og + l.ha.f * C.rg + l.ha.h * C.ug, b = l.ha.i * C.mg + l.ha.m * C.pg + l.ha.j * C.sg, v = l.ha.i * C.ng + l.ha.m * C.qg + l.ha.j * C.tg, g = l.ha.i * C.og + l.ha.m * C.rg + l.ha.j * C.ug, x = l.ha.l * C.mg + l.ha.g * C.pg + l.ha.s * C.sg, d = l.ha.l * C.ng + l.ha.g * C.qg + l.ha.s * C.tg; var m, j, M, A, w, D, C = l.ha.l * C.og + l.ha.g * C.rg + l.ha.s * C.ug; m = y * l.ha.o + f * l.ha.f + u * l.ha.h, j = y * l.ha.i + f * l.ha.m + u * l.ha.j, u = y * l.ha.l + f * l.ha.g + u * l.ha.s, M = b * l.ha.o + v * l.ha.f + g * l.ha.h, A = b * l.ha.i + v * l.ha.m + g * l.ha.j, g = b * l.ha.l + v * l.ha.g + g * l.ha.s, w = x * l.ha.o + d * l.ha.f + C * l.ha.h, D = x * l.ha.i + d * l.ha.m + C * l.ha.j, C = x * l.ha.l + d * l.ha.g + C * l.ha.s, y = m, f = j, b = M, v = A, x = w, d = D, y *= z, f *= z, u *= z, b *= z, v *= z, g *= z, x *= z, d *= z; var B, q; C = C * z; M = l.ha.v * l.ha.v, A = l.ha.A * l.ha.A, B = l.ha.B * l.ha.B, w = - l.ha.v * l.ha.A, D = - l.ha.A * l.ha.B, q = - l.ha.B * l.ha.v, p += z, t += y += ( l = A + B ) * z, i += f += ( m = w ) * z, s += u += ( j = q ) * z, h += b += w * z, a += v += ( B = M + B ) * z, e += g += D * z, o += x += q * z, r += d += D * z, n += C += ( M += A ) * z, l = c;

		}

		this.Pc = p, this.Ad = t, this.Bd = i, this.Cd = s, this.Dd = h, this.Ed = a, this.Fd = e, this.Gd = o, this.Hd = r, this.Id = n, t = this.Ad * ( this.Ed * this.Id - this.Fd * this.Hd ) - this.Bd * ( this.Dd * this.Id - this.Fd * this.Gd ) + this.Cd * ( this.Dd * this.Hd - this.Ed * this.Gd ), 0 == this.Lb ? ( this.$a = 1 / this.Pc, t = this.Ed * this.Id - this.Fd * this.Hd, i = this.Dd * this.Id - this.Fd * this.Gd, s = this.Dd * this.Hd - this.Ed * this.Gd, h = this.Bd * this.Id - this.Cd * this.Hd, a = this.Ad * this.Id - this.Cd * this.Gd, e = this.Ad * this.Hd - this.Bd * this.Gd, o = this.Bd * this.Fd - this.Cd * this.Ed, r = this.Ad * this.Fd - this.Cd * this.Dd, n = this.Ad * this.Ed - this.Bd * this.Dd, ( - 1e-32 > ( p = this.Ad * t - this.Bd * i + this.Cd * s ) || 1e-32 < p ) && ( p = 1 / p ), this.Ra = t * p, this.Sa = - h * p, this.Ta = o * p, this.Ua = - i * p, this.Va = a * p, this.Wa = - r * p, this.Xa = s * p, this.Ya = - e * p, this.Za = n * p, this.pi = this.Ra, this.ri = this.Sa, this.si = this.Ta, this.ti = this.Ua, this.ui = this.Va, this.vi = this.Wa, this.wi = this.Xa, this.xi = this.Ya, this.yi = this.Za, this.Ra = this.pi * this.N.x, this.Sa = this.ri * this.N.x, this.Ta = this.si * this.N.x, this.Ua = this.ti * this.N.y, this.Va = this.ui * this.N.y, this.Wa = this.vi * this.N.y, this.Xa = this.wi * this.N.z, this.Ya = this.xi * this.N.z, this.Za = this.yi * this.N.z ) : this.yi = this.xi = this.wi = this.vi = this.ui = this.ti = this.si = this.ri = this.pi = this.Za = this.Ya = this.Xa = this.Wa = this.Va = this.Ua = this.Ta = this.Sa = this.Ra = this.$a = 0, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, i = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, s = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, h = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, a = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, e = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, o = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, r = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, i = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, s = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, h = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, a = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, e = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, o = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, r = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, this.Gb = ! 1, this.yb = 0;

	}, qm: function () {

		var t = new dt(); return t.x = this.a.v, t.y = this.a.A, t.z = this.a.B, t;

	}, rm: function ( t ) {

		t.x = this.a.v, t.y = this.a.A, t.z = this.a.B;

	}, Xn: function ( t ) {

		this.a.v = t.x, this.a.A = t.y, this.a.B = t.z, t = this.pa; var i = this.a; for ( t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s, t = this.Dc; null != t; ) {

			i = t.M; var s, h, a, e, o, r, n, p, l, c = t.pa, y = t.ha, f = this.pa; s = f.o * y.o + f.f * y.i + f.h * y.l, h = f.o * y.f + f.f * y.m + f.h * y.g, a = f.o * y.h + f.f * y.j + f.h * y.s, e = f.i * y.o + f.m * y.i + f.j * y.l, o = f.i * y.f + f.m * y.m + f.j * y.g, r = f.i * y.h + f.m * y.j + f.j * y.s, n = f.l * y.o + f.g * y.i + f.s * y.l, p = f.l * y.f + f.g * y.m + f.s * y.g, l = f.l * y.h + f.g * y.j + f.s * y.s, c.o = s, c.f = h, c.h = a, c.i = e, c.m = o, c.j = r, c.l = n, c.g = p, c.s = l, s = f.o * y.v + f.f * y.A + f.h * y.B, h = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, c.v = s, c.A = h, c.B = y, c.v += f.v, c.A += f.A, c.B += f.B, c = t.a, y = t.ha, s = ( f = this.a ).o * y.o + f.f * y.i + f.h * y.l, h = f.o * y.f + f.f * y.m + f.h * y.g, a = f.o * y.h + f.f * y.j + f.h * y.s, e = f.i * y.o + f.m * y.i + f.j * y.l, o = f.i * y.f + f.m * y.m + f.j * y.g, r = f.i * y.h + f.m * y.j + f.j * y.s, n = f.l * y.o + f.g * y.i + f.s * y.l, p = f.l * y.f + f.g * y.m + f.s * y.g, l = f.l * y.h + f.g * y.j + f.s * y.s, c.o = s, c.f = h, c.h = a, c.i = e, c.m = o, c.j = r, c.l = n, c.g = p, c.s = l, s = f.o * y.v + f.f * y.A + f.h * y.B, h = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, c.v = s, c.A = h, c.B = y, c.v += f.v, c.A += f.A, c.B += f.B, t.Kb.Nb( t.u, t.pa ), c = t.u.ma, f = t.u.na, y = t.u.oa, s = t.u.ja, h = t.u.ka, a = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = c < t.u.ma ? c : t.u.ma, t.u.na = f < t.u.na ? f : t.u.na, t.u.oa = y < t.u.oa ? y : t.u.oa, t.u.ja = s > t.u.ja ? s : t.u.ja, t.u.ka = h > t.u.ka ? h : t.u.ka, t.u.la = a > t.u.la ? a : t.u.la, null != t.tb && ( c = t.a.v - t.pa.v, f = t.a.A - t.pa.A, y = t.a.B - t.pa.B, ( s = t.rc ).x = c, s.y = f, s.z = y, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = i;

		}

		this.Gb = ! 1, this.yb = 0;

	}, jo: function ( t ) {

		var i, s; for ( i = t.x, s = t.y, t = t.z, this.a.v += i, this.a.A += s, this.a.B += t, i = this.pa, s = this.a, i.v = s.v, i.A = s.A, i.B = s.B, i.o = s.o, i.f = s.f, i.h = s.h, i.i = s.i, i.m = s.m, i.j = s.j, i.l = s.l, i.g = s.g, i.s = s.s, i = this.Dc; null != i; ) {

			s = i.M, t = i.pa; var h, a, e, o, r, n, p, l, c, y = i.ha, f = this.pa; h = f.o * y.o + f.f * y.i + f.h * y.l, a = f.o * y.f + f.f * y.m + f.h * y.g, e = f.o * y.h + f.f * y.j + f.h * y.s, o = f.i * y.o + f.m * y.i + f.j * y.l, r = f.i * y.f + f.m * y.m + f.j * y.g, n = f.i * y.h + f.m * y.j + f.j * y.s, p = f.l * y.o + f.g * y.i + f.s * y.l, l = f.l * y.f + f.g * y.m + f.s * y.g, c = f.l * y.h + f.g * y.j + f.s * y.s, t.o = h, t.f = a, t.h = e, t.i = o, t.m = r, t.j = n, t.l = p, t.g = l, t.s = c, h = f.o * y.v + f.f * y.A + f.h * y.B, a = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, t.v = h, t.A = a, t.B = y, t.v += f.v, t.A += f.A, t.B += f.B, t = i.a, y = i.ha, h = ( f = this.a ).o * y.o + f.f * y.i + f.h * y.l, a = f.o * y.f + f.f * y.m + f.h * y.g, e = f.o * y.h + f.f * y.j + f.h * y.s, o = f.i * y.o + f.m * y.i + f.j * y.l, r = f.i * y.f + f.m * y.m + f.j * y.g, n = f.i * y.h + f.m * y.j + f.j * y.s, p = f.l * y.o + f.g * y.i + f.s * y.l, l = f.l * y.f + f.g * y.m + f.s * y.g, c = f.l * y.h + f.g * y.j + f.s * y.s, t.o = h, t.f = a, t.h = e, t.i = o, t.m = r, t.j = n, t.l = p, t.g = l, t.s = c, h = f.o * y.v + f.f * y.A + f.h * y.B, a = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, t.v = h, t.A = a, t.B = y, t.v += f.v, t.A += f.A, t.B += f.B, i.Kb.Nb( i.u, i.pa ), t = i.u.ma, f = i.u.na, y = i.u.oa, h = i.u.ja, a = i.u.ka, e = i.u.la, i.Kb.Nb( i.u, i.a ), i.u.ma = t < i.u.ma ? t : i.u.ma, i.u.na = f < i.u.na ? f : i.u.na, i.u.oa = y < i.u.oa ? y : i.u.oa, i.u.ja = h > i.u.ja ? h : i.u.ja, i.u.ka = a > i.u.ka ? a : i.u.ka, i.u.la = e > i.u.la ? e : i.u.la, null != i.tb && ( t = i.a.v - i.pa.v, f = i.a.A - i.pa.A, y = i.a.B - i.pa.B, ( h = i.rc ).x = t, h.y = f, h.z = y, i.Yb.oc.jc.wd( i.tb, i.u, i.rc ) ), i = s;

		}

		this.Gb = ! 1, this.yb = 0;

	}, vm: function () {

		var t = new ft(); return t.e00 = this.a.o, t.e01 = this.a.f, t.e02 = this.a.h, t.e10 = this.a.i, t.e11 = this.a.m, t.e12 = this.a.j, t.e20 = this.a.l, t.e21 = this.a.g, t.e22 = this.a.s, t;

	}, wm: function ( t ) {

		t.e00 = this.a.o, t.e01 = this.a.f, t.e02 = this.a.h, t.e10 = this.a.i, t.e11 = this.a.m, t.e12 = this.a.j, t.e20 = this.a.l, t.e21 = this.a.g, t.e22 = this.a.s;

	}, $n: function ( t ) {

		var i, s, h, a, e, o, r, n; for ( this.a.o = t.e00, this.a.f = t.e01, this.a.h = t.e02, this.a.i = t.e10, this.a.m = t.e11, this.a.j = t.e12, this.a.l = t.e20, this.a.g = t.e21, this.a.s = t.e22, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, i = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, s = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, h = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, a = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, e = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, o = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, r = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, i = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, s = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, h = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, a = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, e = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, o = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, r = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, t = this.pa, i = this.a, t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s, t = this.Dc; null != t; ) {

			var p, l, c, y, f; i = t.M, s = t.pa, a = t.ha, e = ( h = this.pa ).o * a.o + h.f * a.i + h.h * a.l, o = h.o * a.f + h.f * a.m + h.h * a.g, r = h.o * a.h + h.f * a.j + h.h * a.s, n = h.i * a.o + h.m * a.i + h.j * a.l, p = h.i * a.f + h.m * a.m + h.j * a.g, l = h.i * a.h + h.m * a.j + h.j * a.s, c = h.l * a.o + h.g * a.i + h.s * a.l, y = h.l * a.f + h.g * a.m + h.s * a.g, f = h.l * a.h + h.g * a.j + h.s * a.s, s.o = e, s.f = o, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, e = h.o * a.v + h.f * a.A + h.h * a.B, o = h.i * a.v + h.m * a.A + h.j * a.B, a = h.l * a.v + h.g * a.A + h.s * a.B, s.v = e, s.A = o, s.B = a, s.v += h.v, s.A += h.A, s.B += h.B, s = t.a, a = t.ha, e = ( h = this.a ).o * a.o + h.f * a.i + h.h * a.l, o = h.o * a.f + h.f * a.m + h.h * a.g, r = h.o * a.h + h.f * a.j + h.h * a.s, n = h.i * a.o + h.m * a.i + h.j * a.l, p = h.i * a.f + h.m * a.m + h.j * a.g, l = h.i * a.h + h.m * a.j + h.j * a.s, c = h.l * a.o + h.g * a.i + h.s * a.l, y = h.l * a.f + h.g * a.m + h.s * a.g, f = h.l * a.h + h.g * a.j + h.s * a.s, s.o = e, s.f = o, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, e = h.o * a.v + h.f * a.A + h.h * a.B, o = h.i * a.v + h.m * a.A + h.j * a.B, a = h.l * a.v + h.g * a.A + h.s * a.B, s.v = e, s.A = o, s.B = a, s.v += h.v, s.A += h.A, s.B += h.B, t.Kb.Nb( t.u, t.pa ), s = t.u.ma, h = t.u.na, a = t.u.oa, e = t.u.ja, o = t.u.ka, r = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = s < t.u.ma ? s : t.u.ma, t.u.na = h < t.u.na ? h : t.u.na, t.u.oa = a < t.u.oa ? a : t.u.oa, t.u.ja = e > t.u.ja ? e : t.u.ja, t.u.ka = o > t.u.ka ? o : t.u.ka, t.u.la = r > t.u.la ? r : t.u.la, null != t.tb && ( s = t.a.v - t.pa.v, h = t.a.A - t.pa.A, a = t.a.B - t.pa.B, ( e = t.rc ).x = s, e.y = h, e.z = a, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = i;

		}

		this.Gb = ! 1, this.yb = 0;

	}, fo: function ( t ) {

		var i, s, h; i = t.x, s = t.y, h = t.z, t = Math.sin( i ); var a, e, o, r = Math.sin( s ), n = Math.sin( h ); for ( i = Math.cos( i ), s = Math.cos( s ), h = Math.cos( h ), this.a.o = s * h, this.a.f = - s * n, this.a.h = r, this.a.i = i * n + h * t * r, this.a.m = i * h - t * r * n, this.a.j = - s * t, this.a.l = t * n - i * h * r, this.a.g = h * t + i * r * n, this.a.s = i * s, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, r = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, n = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, s = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, h = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, i = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, a = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, e = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, o = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = r, this.S = n, this.T = s, this.U = h, this.V = i, this.W = a, this.X = e, this.Y = o, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, r = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, n = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, s = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, h = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, i = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, a = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, e = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, o = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = r, this.S = n, this.T = s, this.U = h, this.V = i, this.W = a, this.X = e, this.Y = o, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, t = this.pa, r = this.a, t.v = r.v, t.A = r.A, t.B = r.B, t.o = r.o, t.f = r.f, t.h = r.h, t.i = r.i, t.m = r.m, t.j = r.j, t.l = r.l, t.g = r.g, t.s = r.s, t = this.Dc; null != t; ) {

			var p, l, c, y, f; r = t.M, n = t.pa, h = t.ha, i = ( s = this.pa ).o * h.o + s.f * h.i + s.h * h.l, a = s.o * h.f + s.f * h.m + s.h * h.g, e = s.o * h.h + s.f * h.j + s.h * h.s, o = s.i * h.o + s.m * h.i + s.j * h.l, p = s.i * h.f + s.m * h.m + s.j * h.g, l = s.i * h.h + s.m * h.j + s.j * h.s, c = s.l * h.o + s.g * h.i + s.s * h.l, y = s.l * h.f + s.g * h.m + s.s * h.g, f = s.l * h.h + s.g * h.j + s.s * h.s, n.o = i, n.f = a, n.h = e, n.i = o, n.m = p, n.j = l, n.l = c, n.g = y, n.s = f, i = s.o * h.v + s.f * h.A + s.h * h.B, a = s.i * h.v + s.m * h.A + s.j * h.B, h = s.l * h.v + s.g * h.A + s.s * h.B, n.v = i, n.A = a, n.B = h, n.v += s.v, n.A += s.A, n.B += s.B, n = t.a, h = t.ha, i = ( s = this.a ).o * h.o + s.f * h.i + s.h * h.l, a = s.o * h.f + s.f * h.m + s.h * h.g, e = s.o * h.h + s.f * h.j + s.h * h.s, o = s.i * h.o + s.m * h.i + s.j * h.l, p = s.i * h.f + s.m * h.m + s.j * h.g, l = s.i * h.h + s.m * h.j + s.j * h.s, c = s.l * h.o + s.g * h.i + s.s * h.l, y = s.l * h.f + s.g * h.m + s.s * h.g, f = s.l * h.h + s.g * h.j + s.s * h.s, n.o = i, n.f = a, n.h = e, n.i = o, n.m = p, n.j = l, n.l = c, n.g = y, n.s = f, i = s.o * h.v + s.f * h.A + s.h * h.B, a = s.i * h.v + s.m * h.A + s.j * h.B, h = s.l * h.v + s.g * h.A + s.s * h.B, n.v = i, n.A = a, n.B = h, n.v += s.v, n.A += s.A, n.B += s.B, t.Kb.Nb( t.u, t.pa ), n = t.u.ma, s = t.u.na, h = t.u.oa, i = t.u.ja, a = t.u.ka, e = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = n < t.u.ma ? n : t.u.ma, t.u.na = s < t.u.na ? s : t.u.na, t.u.oa = h < t.u.oa ? h : t.u.oa, t.u.ja = i > t.u.ja ? i : t.u.ja, t.u.ka = a > t.u.ka ? a : t.u.ka, t.u.la = e > t.u.la ? e : t.u.la, null != t.tb && ( n = t.a.v - t.pa.v, s = t.a.A - t.pa.A, h = t.a.B - t.pa.B, ( i = t.rc ).x = n, i.y = s, i.z = h, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = r;

		}

		this.Gb = ! 1, this.yb = 0;

	}, Em: function ( t ) {

		var i, s, h, a, e, o, r, n, p, l; for ( i = t.e00, s = t.e01, h = t.e02, a = t.e10, e = t.e11, o = t.e12, r = t.e20, n = t.e21, p = t.e22, t = i * this.a.o + s * this.a.i + h * this.a.l, l = i * this.a.f + s * this.a.m + h * this.a.g, i = i * this.a.h + s * this.a.j + h * this.a.s, s = a * this.a.o + e * this.a.i + o * this.a.l, h = a * this.a.f + e * this.a.m + o * this.a.g, a = a * this.a.h + e * this.a.j + o * this.a.s, e = r * this.a.o + n * this.a.i + p * this.a.l, o = r * this.a.f + n * this.a.m + p * this.a.g, r = r * this.a.h + n * this.a.j + p * this.a.s, this.a.o = t, this.a.f = l, this.a.h = i, this.a.i = s, this.a.m = h, this.a.j = a, this.a.l = e, this.a.g = o, this.a.s = r, r = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, n = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, t = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, l = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, p = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, a = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, e = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, o = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, i = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = r, this.R = n, this.S = t, this.T = l, this.U = p, this.V = a, this.W = e, this.X = o, this.Y = i, r = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, n = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, t = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, l = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, p = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, a = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, e = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, o = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, i = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = r, this.R = n, this.S = t, this.T = l, this.U = p, this.V = a, this.W = e, this.X = o, this.Y = i, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, r = this.pa, n = this.a, r.v = n.v, r.A = n.A, r.B = n.B, r.o = n.o, r.f = n.f, r.h = n.h, r.i = n.i, r.m = n.m, r.j = n.j, r.l = n.l, r.g = n.g, r.s = n.s, r = this.Dc; null != r; ) {

			var c, y, f; n = r.M, t = r.pa, p = r.ha, a = ( l = this.pa ).o * p.o + l.f * p.i + l.h * p.l, e = l.o * p.f + l.f * p.m + l.h * p.g, o = l.o * p.h + l.f * p.j + l.h * p.s, i = l.i * p.o + l.m * p.i + l.j * p.l, s = l.i * p.f + l.m * p.m + l.j * p.g, h = l.i * p.h + l.m * p.j + l.j * p.s, c = l.l * p.o + l.g * p.i + l.s * p.l, y = l.l * p.f + l.g * p.m + l.s * p.g, f = l.l * p.h + l.g * p.j + l.s * p.s, t.o = a, t.f = e, t.h = o, t.i = i, t.m = s, t.j = h, t.l = c, t.g = y, t.s = f, a = l.o * p.v + l.f * p.A + l.h * p.B, e = l.i * p.v + l.m * p.A + l.j * p.B, p = l.l * p.v + l.g * p.A + l.s * p.B, t.v = a, t.A = e, t.B = p, t.v += l.v, t.A += l.A, t.B += l.B, t = r.a, p = r.ha, a = ( l = this.a ).o * p.o + l.f * p.i + l.h * p.l, e = l.o * p.f + l.f * p.m + l.h * p.g, o = l.o * p.h + l.f * p.j + l.h * p.s, i = l.i * p.o + l.m * p.i + l.j * p.l, s = l.i * p.f + l.m * p.m + l.j * p.g, h = l.i * p.h + l.m * p.j + l.j * p.s, c = l.l * p.o + l.g * p.i + l.s * p.l, y = l.l * p.f + l.g * p.m + l.s * p.g, f = l.l * p.h + l.g * p.j + l.s * p.s, t.o = a, t.f = e, t.h = o, t.i = i, t.m = s, t.j = h, t.l = c, t.g = y, t.s = f, a = l.o * p.v + l.f * p.A + l.h * p.B, e = l.i * p.v + l.m * p.A + l.j * p.B, p = l.l * p.v + l.g * p.A + l.s * p.B, t.v = a, t.A = e, t.B = p, t.v += l.v, t.A += l.A, t.B += l.B, r.Kb.Nb( r.u, r.pa ), t = r.u.ma, l = r.u.na, p = r.u.oa, a = r.u.ja, e = r.u.ka, o = r.u.la, r.Kb.Nb( r.u, r.a ), r.u.ma = t < r.u.ma ? t : r.u.ma, r.u.na = l < r.u.na ? l : r.u.na, r.u.oa = p < r.u.oa ? p : r.u.oa, r.u.ja = a > r.u.ja ? a : r.u.ja, r.u.ka = e > r.u.ka ? e : r.u.ka, r.u.la = o > r.u.la ? o : r.u.la, null != r.tb && ( t = r.a.v - r.pa.v, l = r.a.A - r.pa.A, p = r.a.B - r.pa.B, ( a = r.rc ).x = t, a.y = l, a.z = p, r.Yb.oc.jc.wd( r.tb, r.u, r.rc ) ), r = n;

		}

		this.Gb = ! 1, this.yb = 0;

	}, Sn: function ( t ) {

		var i, s, h, a, e, o, r; i = t.x, s = t.y, t = t.z, o = Math.sin( i ); var n = Math.sin( s ), p = Math.sin( t ), l = Math.cos( i ); r = Math.cos( s ); var c = Math.cos( t ); for ( h = r * c, a = - r * p, t = l * p + c * o * n, i = l * c - o * n * p, e = - r * o, s = o * p - l * c * n, o = c * o + l * n * p, r *= l, p = h * this.a.o + a * this.a.i + n * this.a.l, l = h * this.a.f + a * this.a.m + n * this.a.g, n = h * this.a.h + a * this.a.j + n * this.a.s, h = t * this.a.o + i * this.a.i + e * this.a.l, a = t * this.a.f + i * this.a.m + e * this.a.g, t = t * this.a.h + i * this.a.j + e * this.a.s, i = s * this.a.o + o * this.a.i + r * this.a.l, e = s * this.a.f + o * this.a.m + r * this.a.g, s = s * this.a.h + o * this.a.j + r * this.a.s, this.a.o = p, this.a.f = l, this.a.h = n, this.a.i = h, this.a.m = a, this.a.j = t, this.a.l = i, this.a.g = e, this.a.s = s, s = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, t = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, i = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, e = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, o = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, n = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, p = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, l = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, r = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = s, this.R = t, this.S = i, this.T = e, this.U = o, this.V = n, this.W = p, this.X = l, this.Y = r, s = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, t = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, i = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, e = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, o = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, n = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, p = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, l = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, r = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = s, this.R = t, this.S = i, this.T = e, this.U = o, this.V = n, this.W = p, this.X = l, this.Y = r, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, s = this.pa, t = this.a, s.v = t.v, s.A = t.A, s.B = t.B, s.o = t.o, s.f = t.f, s.h = t.h, s.i = t.i, s.m = t.m, s.j = t.j, s.l = t.l, s.g = t.g, s.s = t.s, s = this.Dc; null != s; ) {

			t = s.M, i = s.pa, o = s.ha; var y, f; n = ( e = this.pa ).o * o.o + e.f * o.i + e.h * o.l, p = e.o * o.f + e.f * o.m + e.h * o.g, l = e.o * o.h + e.f * o.j + e.h * o.s; r = e.i * o.o + e.m * o.i + e.j * o.l, h = e.i * o.f + e.m * o.m + e.j * o.g, a = e.i * o.h + e.m * o.j + e.j * o.s, c = e.l * o.o + e.g * o.i + e.s * o.l, y = e.l * o.f + e.g * o.m + e.s * o.g, f = e.l * o.h + e.g * o.j + e.s * o.s, i.o = n, i.f = p, i.h = l, i.i = r, i.m = h, i.j = a, i.l = c, i.g = y, i.s = f, n = e.o * o.v + e.f * o.A + e.h * o.B, p = e.i * o.v + e.m * o.A + e.j * o.B, o = e.l * o.v + e.g * o.A + e.s * o.B, i.v = n, i.A = p, i.B = o, i.v += e.v, i.A += e.A, i.B += e.B, i = s.a, o = s.ha, n = ( e = this.a ).o * o.o + e.f * o.i + e.h * o.l, p = e.o * o.f + e.f * o.m + e.h * o.g, l = e.o * o.h + e.f * o.j + e.h * o.s, r = e.i * o.o + e.m * o.i + e.j * o.l, h = e.i * o.f + e.m * o.m + e.j * o.g, a = e.i * o.h + e.m * o.j + e.j * o.s, c = e.l * o.o + e.g * o.i + e.s * o.l, y = e.l * o.f + e.g * o.m + e.s * o.g, f = e.l * o.h + e.g * o.j + e.s * o.s, i.o = n, i.f = p, i.h = l, i.i = r, i.m = h, i.j = a, i.l = c, i.g = y, i.s = f, n = e.o * o.v + e.f * o.A + e.h * o.B, p = e.i * o.v + e.m * o.A + e.j * o.B, o = e.l * o.v + e.g * o.A + e.s * o.B, i.v = n, i.A = p, i.B = o, i.v += e.v, i.A += e.A, i.B += e.B, s.Kb.Nb( s.u, s.pa ), i = s.u.ma, e = s.u.na, o = s.u.oa, n = s.u.ja, p = s.u.ka, l = s.u.la, s.Kb.Nb( s.u, s.a ), s.u.ma = i < s.u.ma ? i : s.u.ma, s.u.na = e < s.u.na ? e : s.u.na, s.u.oa = o < s.u.oa ? o : s.u.oa, s.u.ja = n > s.u.ja ? n : s.u.ja, s.u.ka = p > s.u.ka ? p : s.u.ka, s.u.la = l > s.u.la ? l : s.u.la, null != s.tb && ( i = s.a.v - s.pa.v, e = s.a.A - s.pa.A, o = s.a.B - s.pa.B, ( n = s.rc ).x = i, n.y = e, n.z = o, s.Yb.oc.jc.wd( s.tb, s.u, s.rc ) ), s = t;

		}

		this.Gb = ! 1, this.yb = 0;

	}, jm: function () {

		var t, i, s, h, a, e = new pt(); return 0 < ( h = ( t = this.a.o ) + ( i = this.a.m ) + ( s = this.a.s ) ) ? ( h = .5 * ( a = Math.sqrt( h + 1 ) ), a = .5 / a, t = ( this.a.g - this.a.j ) * a, i = ( this.a.h - this.a.l ) * a, s = ( this.a.i - this.a.f ) * a ) : t > i ? t > s ? ( t = .5 * ( a = Math.sqrt( t - i - s + 1 ) ), a = .5 / a, i = ( this.a.f + this.a.i ) * a, s = ( this.a.h + this.a.l ) * a, h = ( this.a.g - this.a.j ) * a ) : ( s = .5 * ( a = Math.sqrt( s - t - i + 1 ) ), a = .5 / a, t = ( this.a.h + this.a.l ) * a, i = ( this.a.j + this.a.g ) * a, h = ( this.a.i - this.a.f ) * a ) : i > s ? ( i = .5 * ( a = Math.sqrt( i - s - t + 1 ) ), a = .5 / a, t = ( this.a.f + this.a.i ) * a, s = ( this.a.j + this.a.g ) * a, h = ( this.a.h - this.a.l ) * a ) : ( s = .5 * ( a = Math.sqrt( s - t - i + 1 ) ), a = .5 / a, t = ( this.a.h + this.a.l ) * a, i = ( this.a.j + this.a.g ) * a, h = ( this.a.i - this.a.f ) * a ), e.x = t, e.y = i, e.z = s, e.w = h, e;

	}, lm: function ( t ) {

		var i, s, h, a, e; 0 < ( a = ( i = this.a.o ) + ( s = this.a.m ) + ( h = this.a.s ) ) ? ( a = .5 * ( e = Math.sqrt( a + 1 ) ), e = .5 / e, i = ( this.a.g - this.a.j ) * e, s = ( this.a.h - this.a.l ) * e, h = ( this.a.i - this.a.f ) * e ) : i > s ? i > h ? ( i = .5 * ( e = Math.sqrt( i - s - h + 1 ) ), e = .5 / e, s = ( this.a.f + this.a.i ) * e, h = ( this.a.h + this.a.l ) * e, a = ( this.a.g - this.a.j ) * e ) : ( h = .5 * ( e = Math.sqrt( h - i - s + 1 ) ), e = .5 / e, i = ( this.a.h + this.a.l ) * e, s = ( this.a.j + this.a.g ) * e, a = ( this.a.i - this.a.f ) * e ) : s > h ? ( s = .5 * ( e = Math.sqrt( s - h - i + 1 ) ), e = .5 / e, i = ( this.a.f + this.a.i ) * e, h = ( this.a.j + this.a.g ) * e, a = ( this.a.h - this.a.l ) * e ) : ( h = .5 * ( e = Math.sqrt( h - i - s + 1 ) ), e = .5 / e, i = ( this.a.h + this.a.l ) * e, s = ( this.a.j + this.a.g ) * e, a = ( this.a.i - this.a.f ) * e ), t.x = i, t.y = s, t.z = h, t.w = a;

	}, Tn: function ( t ) {

		var i, s, h; i = t.x, s = t.y, h = t.z; var a = t.w, e = 2 * i; t = i * e; var o = s * ( f = 2 * s ); h *= n = 2 * h; var r = i * f; for ( s *= n, i *= n, e *= a, f *= a, a *= n, this.a.o = 1 - o - h, this.a.f = r - a, this.a.h = i + f, this.a.i = r + a, this.a.m = 1 - t - h, this.a.j = s - e, this.a.l = i - f, this.a.g = s + e, this.a.s = 1 - t - o, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, o = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, a = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, n = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, h = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, r = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, f = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, s = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, i = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = o, this.S = a, this.T = n, this.U = h, this.V = r, this.W = f, this.X = s, this.Y = i, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, o = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, a = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, n = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, h = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, r = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, f = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, s = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, i = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = o, this.S = a, this.T = n, this.U = h, this.V = r, this.W = f, this.X = s, this.Y = i, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, t = this.pa, o = this.a, t.v = o.v, t.A = o.A, t.B = o.B, t.o = o.o, t.f = o.f, t.h = o.h, t.i = o.i, t.m = o.m, t.j = o.j, t.l = o.l, t.g = o.g, t.s = o.s, t = this.Dc; null != t; ) {

			o = t.M, a = t.pa, h = t.ha; r = ( n = this.pa ).o * h.o + n.f * h.i + n.h * h.l; var n, p, l, c, y, f = n.o * h.f + n.f * h.m + n.h * h.g; s = n.o * h.h + n.f * h.j + n.h * h.s, i = n.i * h.o + n.m * h.i + n.j * h.l, e = n.i * h.f + n.m * h.m + n.j * h.g, p = n.i * h.h + n.m * h.j + n.j * h.s, l = n.l * h.o + n.g * h.i + n.s * h.l, c = n.l * h.f + n.g * h.m + n.s * h.g, y = n.l * h.h + n.g * h.j + n.s * h.s, a.o = r, a.f = f, a.h = s, a.i = i, a.m = e, a.j = p, a.l = l, a.g = c, a.s = y, r = n.o * h.v + n.f * h.A + n.h * h.B, f = n.i * h.v + n.m * h.A + n.j * h.B, h = n.l * h.v + n.g * h.A + n.s * h.B, a.v = r, a.A = f, a.B = h, a.v += n.v, a.A += n.A, a.B += n.B, a = t.a, h = t.ha, r = ( n = this.a ).o * h.o + n.f * h.i + n.h * h.l, f = n.o * h.f + n.f * h.m + n.h * h.g, s = n.o * h.h + n.f * h.j + n.h * h.s, i = n.i * h.o + n.m * h.i + n.j * h.l, e = n.i * h.f + n.m * h.m + n.j * h.g, p = n.i * h.h + n.m * h.j + n.j * h.s, l = n.l * h.o + n.g * h.i + n.s * h.l, c = n.l * h.f + n.g * h.m + n.s * h.g, y = n.l * h.h + n.g * h.j + n.s * h.s, a.o = r, a.f = f, a.h = s, a.i = i, a.m = e, a.j = p, a.l = l, a.g = c, a.s = y, r = n.o * h.v + n.f * h.A + n.h * h.B, f = n.i * h.v + n.m * h.A + n.j * h.B, h = n.l * h.v + n.g * h.A + n.s * h.B, a.v = r, a.A = f, a.B = h, a.v += n.v, a.A += n.A, a.B += n.B, t.Kb.Nb( t.u, t.pa ), a = t.u.ma, n = t.u.na, h = t.u.oa, r = t.u.ja, f = t.u.ka, s = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = a < t.u.ma ? a : t.u.ma, t.u.na = n < t.u.na ? n : t.u.na, t.u.oa = h < t.u.oa ? h : t.u.oa, t.u.ja = r > t.u.ja ? r : t.u.ja, t.u.ka = f > t.u.ka ? f : t.u.ka, t.u.la = s > t.u.la ? s : t.u.la, null != t.tb && ( a = t.a.v - t.pa.v, n = t.a.A - t.pa.A, h = t.a.B - t.pa.B, ( r = t.rc ).x = a, r.y = n, r.z = h, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = o;

		}

		this.Gb = ! 1, this.yb = 0;

	}, xm: function () {

		var t = this.a, i = new xt(); return i.v = t.v, i.A = t.A, i.B = t.B, i.o = t.o, i.f = t.f, i.h = t.h, i.i = t.i, i.m = t.m, i.j = t.j, i.l = t.l, i.g = t.g, i.s = t.s, i;

	}, Cm: function ( t ) {

		var i = this.a; t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s;

	}, ho: function ( t ) {

		var i, s, h, a, e, o, r, n; for ( this.a.v = t.v, this.a.A = t.A, this.a.B = t.B, this.a.o = t.o, this.a.f = t.f, this.a.h = t.h, this.a.i = t.i, this.a.m = t.m, this.a.j = t.j, this.a.l = t.l, this.a.g = t.g, this.a.s = t.s, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, i = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, s = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, h = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, a = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, e = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, o = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, r = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, i = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, s = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, h = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, a = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, e = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, o = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, r = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, t = this.pa, i = this.a, t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s, t = this.Dc; null != t; ) {

			var p, l, c, y, f; i = t.M, s = t.pa, a = t.ha, e = ( h = this.pa ).o * a.o + h.f * a.i + h.h * a.l, o = h.o * a.f + h.f * a.m + h.h * a.g, r = h.o * a.h + h.f * a.j + h.h * a.s, n = h.i * a.o + h.m * a.i + h.j * a.l, p = h.i * a.f + h.m * a.m + h.j * a.g, l = h.i * a.h + h.m * a.j + h.j * a.s, c = h.l * a.o + h.g * a.i + h.s * a.l, y = h.l * a.f + h.g * a.m + h.s * a.g, f = h.l * a.h + h.g * a.j + h.s * a.s, s.o = e, s.f = o, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, e = h.o * a.v + h.f * a.A + h.h * a.B, o = h.i * a.v + h.m * a.A + h.j * a.B, a = h.l * a.v + h.g * a.A + h.s * a.B, s.v = e, s.A = o, s.B = a, s.v += h.v, s.A += h.A, s.B += h.B, s = t.a, a = t.ha, e = ( h = this.a ).o * a.o + h.f * a.i + h.h * a.l, o = h.o * a.f + h.f * a.m + h.h * a.g, r = h.o * a.h + h.f * a.j + h.h * a.s, n = h.i * a.o + h.m * a.i + h.j * a.l, p = h.i * a.f + h.m * a.m + h.j * a.g, l = h.i * a.h + h.m * a.j + h.j * a.s, c = h.l * a.o + h.g * a.i + h.s * a.l, y = h.l * a.f + h.g * a.m + h.s * a.g, f = h.l * a.h + h.g * a.j + h.s * a.s, s.o = e, s.f = o, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, e = h.o * a.v + h.f * a.A + h.h * a.B, o = h.i * a.v + h.m * a.A + h.j * a.B, a = h.l * a.v + h.g * a.A + h.s * a.B, s.v = e, s.A = o, s.B = a, s.v += h.v, s.A += h.A, s.B += h.B, t.Kb.Nb( t.u, t.pa ), s = t.u.ma, h = t.u.na, a = t.u.oa, e = t.u.ja, o = t.u.ka, r = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = s < t.u.ma ? s : t.u.ma, t.u.na = h < t.u.na ? h : t.u.na, t.u.oa = a < t.u.oa ? a : t.u.oa, t.u.ja = e > t.u.ja ? e : t.u.ja, t.u.ka = o > t.u.ka ? o : t.u.ka, t.u.la = r > t.u.la ? r : t.u.la, null != t.tb && ( s = t.a.v - t.pa.v, h = t.a.A - t.pa.A, a = t.a.B - t.pa.B, ( e = t.rc ).x = s, e.y = h, e.z = a, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = i;

		}

		this.Gb = ! 1, this.yb = 0;

	}, Tg: function () {

		return this.Pc;

	}, se: function () {

		var t = new ft(); return t.e00 = this.Ad, t.e01 = this.Bd, t.e02 = this.Cd, t.e10 = this.Dd, t.e11 = this.Ed, t.e12 = this.Fd, t.e20 = this.Gd, t.e21 = this.Hd, t.e22 = this.Id, t;

	}, te: function ( t ) {

		t.e00 = this.Ad, t.e01 = this.Bd, t.e02 = this.Cd, t.e10 = this.Dd, t.e11 = this.Ed, t.e12 = this.Fd, t.e20 = this.Gd, t.e21 = this.Hd, t.e22 = this.Id;

	}, Ug: function () {

		var t = new a(); t.mass = this.Pc; var i = t.localInertia; return i.e00 = this.Ad, i.e01 = this.Bd, i.e02 = this.Cd, i.e10 = this.Dd, i.e11 = this.Ed, i.e12 = this.Fd, i.e20 = this.Gd, i.e21 = this.Hd, i.e22 = this.Id, t;

	}, Vg: function ( t ) {

		t.mass = this.Pc, ( t = t.localInertia ).e00 = this.Ad, t.e01 = this.Bd, t.e02 = this.Cd, t.e10 = this.Dd, t.e11 = this.Ed, t.e12 = this.Fd, t.e20 = this.Gd, t.e21 = this.Hd, t.e22 = this.Id;

	}, Qm: function ( t ) {

		if ( this.Pc = t.mass, t = t.localInertia, this.Ad = t.e00, this.Bd = t.e01, this.Cd = t.e02, this.Dd = t.e10, this.Ed = t.e11, this.Fd = t.e12, this.Gd = t.e20, this.Hd = t.e21, this.Id = t.e22, t = this.Ad * ( this.Ed * this.Id - this.Fd * this.Hd ) - this.Bd * ( this.Dd * this.Id - this.Fd * this.Gd ) + this.Cd * ( this.Dd * this.Hd - this.Ed * this.Gd ), 0 == this.Lb ) {

			this.$a = 1 / this.Pc, t = this.Ed * this.Id - this.Fd * this.Hd; var i = this.Dd * this.Id - this.Fd * this.Gd, s = this.Dd * this.Hd - this.Ed * this.Gd, h = this.Bd * this.Id - this.Cd * this.Hd, a = this.Ad * this.Id - this.Cd * this.Gd, e = this.Ad * this.Hd - this.Bd * this.Gd, o = this.Bd * this.Fd - this.Cd * this.Ed, r = this.Ad * this.Fd - this.Cd * this.Dd, n = this.Ad * this.Ed - this.Bd * this.Dd, p = this.Ad * t - this.Bd * i + this.Cd * s; ( - 1e-32 > p || 1e-32 < p ) && ( p = 1 / p ), this.Ra = t * p, this.Sa = - h * p, this.Ta = o * p, this.Ua = - i * p, this.Va = a * p, this.Wa = - r * p, this.Xa = s * p, this.Ya = - e * p, this.Za = n * p, this.pi = this.Ra, this.ri = this.Sa, this.si = this.Ta, this.ti = this.Ua, this.ui = this.Va, this.vi = this.Wa, this.wi = this.Xa, this.xi = this.Ya, this.yi = this.Za, this.Ra = this.pi * this.N.x, this.Sa = this.ri * this.N.x, this.Ta = this.si * this.N.x, this.Ua = this.ti * this.N.y, this.Va = this.ui * this.N.y, this.Wa = this.vi * this.N.y, this.Xa = this.wi * this.N.z, this.Ya = this.xi * this.N.z, this.Za = this.yi * this.N.z;

		} else this.yi = this.xi = this.wi = this.vi = this.ui = this.ti = this.si = this.ri = this.pi = this.Za = this.Ya = this.Xa = this.Wa = this.Va = this.Ua = this.Ta = this.Sa = this.Ra = this.$a = 0; t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, i = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, s = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, h = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, a = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, e = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, o = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, r = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, n = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, i = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, s = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, h = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, a = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, e = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, o = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, r = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, n = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = i, this.S = s, this.T = h, this.U = a, this.V = e, this.W = o, this.X = r, this.Y = n, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, this.Gb = ! 1, this.yb = 0;

	}, ji: function () {

		var t = this.N; return new dt( t.x, t.y, t.z );

	}, Rm: function ( t ) {

		var i, s, h, a, e, o, r, n = this.N; n.x = t.x, n.y = t.y, n.z = t.z, t = this.a.o * this.Ra + this.a.f * this.Ua + this.a.h * this.Xa, n = this.a.o * this.Sa + this.a.f * this.Va + this.a.h * this.Ya, i = this.a.o * this.Ta + this.a.f * this.Wa + this.a.h * this.Za, s = this.a.i * this.Ra + this.a.m * this.Ua + this.a.j * this.Xa, h = this.a.i * this.Sa + this.a.m * this.Va + this.a.j * this.Ya, a = this.a.i * this.Ta + this.a.m * this.Wa + this.a.j * this.Za, e = this.a.l * this.Ra + this.a.g * this.Ua + this.a.s * this.Xa, o = this.a.l * this.Sa + this.a.g * this.Va + this.a.s * this.Ya, r = this.a.l * this.Ta + this.a.g * this.Wa + this.a.s * this.Za, this.P = t, this.R = n, this.S = i, this.T = s, this.U = h, this.V = a, this.W = e, this.X = o, this.Y = r, t = this.P * this.a.o + this.R * this.a.f + this.S * this.a.h, n = this.P * this.a.i + this.R * this.a.m + this.S * this.a.j, i = this.P * this.a.l + this.R * this.a.g + this.S * this.a.s, s = this.T * this.a.o + this.U * this.a.f + this.V * this.a.h, h = this.T * this.a.i + this.U * this.a.m + this.V * this.a.j, a = this.T * this.a.l + this.U * this.a.g + this.V * this.a.s, e = this.W * this.a.o + this.X * this.a.f + this.Y * this.a.h, o = this.W * this.a.i + this.X * this.a.m + this.Y * this.a.j, r = this.W * this.a.l + this.X * this.a.g + this.Y * this.a.s, this.P = t, this.R = n, this.S = i, this.T = s, this.U = h, this.V = a, this.W = e, this.X = o, this.Y = r, this.P *= this.N.x, this.R *= this.N.x, this.S *= this.N.x, this.T *= this.N.y, this.U *= this.N.y, this.V *= this.N.y, this.W *= this.N.z, this.X *= this.N.z, this.Y *= this.N.z, this.Gb = ! 1, this.yb = 0;

	}, qe: function () {

		var t = new dt(); return t.x = this.gb, t.y = this.hb, t.z = this.ib, t;

	}, re: function ( t ) {

		t.x = this.gb, t.y = this.hb, t.z = this.ib;

	}, Pm: function ( t ) {

		1 == this.Lb ? this.ib = this.hb = this.gb = 0 : ( this.gb = t.x, this.hb = t.y, this.ib = t.z ), this.Gb = ! 1, this.yb = 0;

	}, Jc: function () {

		var t = new dt(); return t.x = this.kb, t.y = this.lb, t.z = this.mb, t;

	}, Kc: function ( t ) {

		t.x = this.gb, t.y = this.hb, t.z = this.ib;

	}, mo: function ( t ) {

		1 == this.Lb ? this.mb = this.lb = this.kb = 0 : ( this.kb = t.x, this.lb = t.y, this.mb = t.z ), this.Gb = ! 1, this.yb = 0;

	}, cb: function ( t ) {

		var i, s; 1 != this.Lb && ( i = t.x, s = t.y, t = t.z, this.gb += i, this.hb += s, this.ib += t ); this.Gb = ! 1, this.yb = 0;

	}, ua: function ( t ) {

		var i, s; 1 != this.Lb && ( i = t.x, s = t.y, t = t.z, this.kb += i, this.lb += s, this.mb += t ); this.Gb = ! 1, this.yb = 0;

	}, uc: function ( t, i ) {

		var s, h, a, e, o; s = t.x, h = t.y, t = t.z, this.gb += s * this.$a, this.hb += h * this.$a, this.ib += t * this.$a, a = i.x, e = i.y, o = i.z, a -= this.a.v, i = ( e -= this.a.A ) * t - ( o -= this.a.B ) * h, t = o * s - a * t, a = a * h - e * s, s = this.P * i + this.R * t + this.S * a, h = this.T * i + this.U * t + this.V * a, i = this.W * i + this.X * t + this.Y * a, this.kb += s, this.lb += h, this.mb += i, this.Gb = ! 1, this.yb = 0;

	}, vc: function ( t ) {

		var i, s; i = t.x, s = t.y, t = t.z, this.gb += i * this.$a, this.hb += s * this.$a, this.ib += t * this.$a, this.Gb = ! 1, this.yb = 0;

	}, Mb: function ( t ) {

		var i, s, h, a; i = t.x, s = t.y, h = t.z, t = this.P * i + this.R * s + this.S * h, a = this.T * i + this.U * s + this.V * h, i = this.W * i + this.X * s + this.Y * h, this.kb += t, this.lb += a, this.mb += i, this.Gb = ! 1, this.yb = 0;

	}, pc: function ( t, i ) {

		var s, h, a, e; s = t.x, h = t.y, t = t.z, this.Mh += s, this.Nh += h, this.Oh += t, a = i.x, e = i.y, i = i.z, a -= this.a.v, e -= this.a.A, i -= this.a.B, this.vf += e * t - i * h, this.wf += i * s - a * t, this.xf += a * h - e * s, this.Gb = ! 1, this.yb = 0;

	}, qc: function ( t ) {

		var i, s; i = t.x, s = t.y, t = t.z, this.Mh += i, this.Nh += s, this.Oh += t, this.Gb = ! 1, this.yb = 0;

	}, Ac: function ( t ) {

		var i, s; i = t.x, s = t.y, t = t.z, this.vf += i, this.wf += s, this.xf += t, this.Gb = ! 1, this.yb = 0;

	}, fd: function () {

		return this.eh;

	}, Nm: function ( t ) {

		this.eh = t, this.Gb = ! 1, this.yb = 0;

	}, ue: function ( t ) {

		var i, s, h, a; return i = t.x, s = t.y, t = t.z, i -= this.a.v, s -= this.a.A, t -= this.a.B, h = this.a.o * i + this.a.i * s + this.a.l * t, a = this.a.f * i + this.a.m * s + this.a.g * t, t = this.a.h * i + this.a.j * s + this.a.s * t, i = h, s = a, ( h = new dt() ).x = i, h.y = s, h.z = t, h;

	}, Ue: function ( t, i ) {

		var s, h, a, e; s = t.x, h = t.y, a = t.z, s -= this.a.v, h -= this.a.A, a -= this.a.B, t = this.a.o * s + this.a.i * h + this.a.l * a, e = this.a.f * s + this.a.m * h + this.a.g * a, s = this.a.h * s + this.a.j * h + this.a.s * a, i.x = t, i.y = e, i.z = s;

	}, Ve: function ( t ) {

		var i, s, h, a; return i = t.x, s = t.y, t = t.z, h = this.a.o * i + this.a.i * s + this.a.l * t, a = this.a.f * i + this.a.m * s + this.a.g * t, t = this.a.h * i + this.a.j * s + this.a.s * t, i = h, s = a, ( h = new dt() ).x = i, h.y = s, h.z = t, h;

	}, Mf: function ( t, i ) {

		var s, h, a, e; s = t.x, h = t.y, a = t.z, t = this.a.o * s + this.a.i * h + this.a.l * a, e = this.a.f * s + this.a.m * h + this.a.g * a, s = this.a.h * s + this.a.j * h + this.a.s * a, i.x = t, i.y = e, i.z = s;

	}, Pj: function ( t ) {

		var i, s, h, a; return i = t.x, s = t.y, t = t.z, h = this.a.o * i + this.a.f * s + this.a.h * t, a = this.a.i * i + this.a.m * s + this.a.j * t, t = this.a.l * i + this.a.g * s + this.a.s * t, i = h + this.a.v, s = a + this.a.A, t += this.a.B, ( h = new dt() ).x = i, h.y = s, h.z = t, h;

	}, Nl: function ( t, i ) {

		var s, h, a, e; s = t.x, h = t.y, a = t.z, t = this.a.o * s + this.a.f * h + this.a.h * a, e = this.a.i * s + this.a.m * h + this.a.j * a, a = this.a.l * s + this.a.g * h + this.a.s * a, s = t + this.a.v, h = e + this.a.A, a += this.a.B, i.x = s, i.y = h, i.z = a;

	}, am: function ( t ) {

		var i, s, h, a; return i = t.x, s = t.y, t = t.z, h = this.a.o * i + this.a.f * s + this.a.h * t, a = this.a.i * i + this.a.m * s + this.a.j * t, t = this.a.l * i + this.a.g * s + this.a.s * t, i = h, s = a, ( h = new dt() ).x = i, h.y = s, h.z = t, h;

	}, bm: function ( t, i ) {

		var s, h, a, e; s = t.x, h = t.y, a = t.z, t = this.a.o * s + this.a.f * h + this.a.h * a, e = this.a.i * s + this.a.m * h + this.a.j * a, s = this.a.l * s + this.a.g * h + this.a.s * a, i.x = t, i.y = e, i.z = s;

	}, im: function () {

		return this.zg;

	}, ki: function () {

		return this.Dc;

	}, Wg: function () {

		return this.Ae;

	}, Lc: function () {

		return this.Ob;

	}, Xg: function () {

		return this.kh;

	}, Yd: function () {

		return this.ze;

	}, Hb: function ( t ) {

		if ( null == this.Dc ? this.Dc = t : ( this.Fi.M = t, t.ia = this.Fi ), this.Fi = t, this.zg ++, t.Yb = this, null != this.oc ) {

			var i = this.oc; t.tb = i.jc.Vh( t, t.u ), t.Cc = i.Xl ++, i.zg ++;

		}

		for ( this.Oj(), t = this.Dc; null != t; ) {

			i = t.M; var s, h, a, e, o, r, n, p, l, c = t.pa, y = t.ha, f = this.pa; s = f.o * y.o + f.f * y.i + f.h * y.l, h = f.o * y.f + f.f * y.m + f.h * y.g, a = f.o * y.h + f.f * y.j + f.h * y.s, e = f.i * y.o + f.m * y.i + f.j * y.l, o = f.i * y.f + f.m * y.m + f.j * y.g, r = f.i * y.h + f.m * y.j + f.j * y.s, n = f.l * y.o + f.g * y.i + f.s * y.l, p = f.l * y.f + f.g * y.m + f.s * y.g, l = f.l * y.h + f.g * y.j + f.s * y.s, c.o = s, c.f = h, c.h = a, c.i = e, c.m = o, c.j = r, c.l = n, c.g = p, c.s = l, s = f.o * y.v + f.f * y.A + f.h * y.B, h = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, c.v = s, c.A = h, c.B = y, c.v += f.v, c.A += f.A, c.B += f.B, c = t.a, y = t.ha, s = ( f = this.a ).o * y.o + f.f * y.i + f.h * y.l, h = f.o * y.f + f.f * y.m + f.h * y.g, a = f.o * y.h + f.f * y.j + f.h * y.s, e = f.i * y.o + f.m * y.i + f.j * y.l, o = f.i * y.f + f.m * y.m + f.j * y.g, r = f.i * y.h + f.m * y.j + f.j * y.s, n = f.l * y.o + f.g * y.i + f.s * y.l, p = f.l * y.f + f.g * y.m + f.s * y.g, l = f.l * y.h + f.g * y.j + f.s * y.s, c.o = s, c.f = h, c.h = a, c.i = e, c.m = o, c.j = r, c.l = n, c.g = p, c.s = l, s = f.o * y.v + f.f * y.A + f.h * y.B, h = f.i * y.v + f.m * y.A + f.j * y.B, y = f.l * y.v + f.g * y.A + f.s * y.B, c.v = s, c.A = h, c.B = y, c.v += f.v, c.A += f.A, c.B += f.B, t.Kb.Nb( t.u, t.pa ), c = t.u.ma, f = t.u.na, y = t.u.oa, s = t.u.ja, h = t.u.ka, a = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = c < t.u.ma ? c : t.u.ma, t.u.na = f < t.u.na ? f : t.u.na, t.u.oa = y < t.u.oa ? y : t.u.oa, t.u.ja = s > t.u.ja ? s : t.u.ja, t.u.ka = h > t.u.ka ? h : t.u.ka, t.u.la = a > t.u.la ? a : t.u.la, null != t.tb && ( c = t.a.v - t.pa.v, f = t.a.A - t.pa.A, y = t.a.B - t.pa.B, ( s = t.rc ).x = c, s.y = f, s.z = y, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = i;

		}

	}, ko: function ( t ) {

		var i = t.ia, s = t.M; if ( null != i && ( i.M = s ), null != s && ( s.ia = i ), t == this.Dc && ( this.Dc = this.Dc.M ), t == this.Fi && ( this.Fi = this.Fi.ia ), t.M = null, t.ia = null, this.zg --, null != this.oc ) {

			( i = this.oc ).jc.Wh( t.tb ), t.tb = null, t.Cc = - 1; for ( var h = t.Yb.Ob; null != h; ) {

				s = h.M; if ( ( o = h.Zd ).Zb == t || o.$b == t ) {

					( h = h.Qc ).Gb = ! 1, h.yb = 0; h = i.Kh; var a = o.ia, e = o.M; null != a && ( a.M = e ), null != e && ( e.ia = a ), o == h.zd && ( h.zd = h.zd.M ), o == h.ye && ( h.ye = h.ye.ia ), o.M = null, o.ia = null, o.Td && ( ( a = o.Zb.yd ) == ( e = o.$b.yd ) && ( e = null ), null != a && a.endContact( o ), null != e && e.endContact( o ) ), a = o.rb.ia, e = o.rb.M, null != a && ( a.M = e ), null != e && ( e.ia = a ), o.rb == o.C.Ob && ( o.C.Ob = o.C.Ob.M ), o.rb == o.C.kc && ( o.C.kc = o.C.kc.ia ), o.rb.M = null, o.rb.ia = null, a = o.sb.ia, e = o.sb.M, null != a && ( a.M = e ), null != e && ( e.ia = a ), o.sb == o.D.Ob && ( o.D.Ob = o.D.Ob.M ), o.sb == o.D.kc && ( o.D.kc = o.D.kc.ia ), o.sb.M = null, o.sb.ia = null, o.C.Ae --, o.D.Ae --, o.rb.Qc = null, o.sb.Qc = null, o.rb.Zd = null, o.sb.Zd = null, o.Zb = null, o.$b = null, o.C = null, o.D = null, o.Td = ! 1, o.$i.Xe(), o.Ja.Xe(), o.Lh = null, ( a = o.Ye ).Zb = null, a.$b = null, a.C = null, a.D = null, a.pj = null, a.qj = null, o.M = h.lg, h.lg = o, h.Bi --;

				}

				h = s;

			}

			i.zg --;

		}

		for ( t.Yb = null, this.Oj(), t = this.Dc; null != t; ) {

			var o, r, n, p, l, c, y, f; i = t.M, s = t.pa, h = t.ha, a = ( o = this.pa ).o * h.o + o.f * h.i + o.h * h.l, e = o.o * h.f + o.f * h.m + o.h * h.g; r = o.o * h.h + o.f * h.j + o.h * h.s, n = o.i * h.o + o.m * h.i + o.j * h.l, p = o.i * h.f + o.m * h.m + o.j * h.g, l = o.i * h.h + o.m * h.j + o.j * h.s, c = o.l * h.o + o.g * h.i + o.s * h.l, y = o.l * h.f + o.g * h.m + o.s * h.g, f = o.l * h.h + o.g * h.j + o.s * h.s, s.o = a, s.f = e, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, a = o.o * h.v + o.f * h.A + o.h * h.B, e = o.i * h.v + o.m * h.A + o.j * h.B, h = o.l * h.v + o.g * h.A + o.s * h.B, s.v = a, s.A = e, s.B = h, s.v += o.v, s.A += o.A, s.B += o.B, s = t.a, h = t.ha, a = ( o = this.a ).o * h.o + o.f * h.i + o.h * h.l, e = o.o * h.f + o.f * h.m + o.h * h.g, r = o.o * h.h + o.f * h.j + o.h * h.s, n = o.i * h.o + o.m * h.i + o.j * h.l, p = o.i * h.f + o.m * h.m + o.j * h.g, l = o.i * h.h + o.m * h.j + o.j * h.s, c = o.l * h.o + o.g * h.i + o.s * h.l, y = o.l * h.f + o.g * h.m + o.s * h.g, f = o.l * h.h + o.g * h.j + o.s * h.s, s.o = a, s.f = e, s.h = r, s.i = n, s.m = p, s.j = l, s.l = c, s.g = y, s.s = f, a = o.o * h.v + o.f * h.A + o.h * h.B, e = o.i * h.v + o.m * h.A + o.j * h.B, h = o.l * h.v + o.g * h.A + o.s * h.B, s.v = a, s.A = e, s.B = h, s.v += o.v, s.A += o.A, s.B += o.B, t.Kb.Nb( t.u, t.pa ), s = t.u.ma, o = t.u.na, h = t.u.oa, a = t.u.ja, e = t.u.ka, r = t.u.la, t.Kb.Nb( t.u, t.a ), t.u.ma = s < t.u.ma ? s : t.u.ma, t.u.na = o < t.u.na ? o : t.u.na, t.u.oa = h < t.u.oa ? h : t.u.oa, t.u.ja = a > t.u.ja ? a : t.u.ja, t.u.ka = e > t.u.ka ? e : t.u.ka, t.u.la = r > t.u.la ? r : t.u.la, null != t.tb && ( s = t.a.v - t.pa.v, o = t.a.A - t.pa.A, h = t.a.B - t.pa.B, ( a = t.rc ).x = s, a.y = o, a.z = h, t.Yb.oc.jc.wd( t.tb, t.u, t.rc ) ), t = i;

		}

	}, Dm: function () {

		return this.Lb;

	}, Sm: function ( t ) {

		this.Lb = t, this.Oj();

	}, Um: function () {

		this.Gb = ! 1, this.yb = 0;

	}, Tm: function () {

		this.Gb = ! 0, this.yb = 0;

	}, cm: function () {

		return this.Gb;

	}, li: function () {

		return this.yb;

	}, Mm: function ( t ) {

		this.Bk = t, this.Gb = ! 1, this.yb = 0;

	}, pe: function () {

		return this.$j;

	}, Om: function ( t ) {

		this.$j = t;

	}, Ec: function () {

		return this.Qj;

	}, lo: function ( t ) {

		this.Qj = t;

	}, um: function () {

		return this.ia;

	}, gm: function () {

		return this.M;

	} }, i.prototype = { uc: function () {

		return this.Xj;

	}, ue: function ( t ) {

		this.Xj = t;

	}, Jc: function () {

		return this.hk;

	}, Ve: function ( t ) {

		this.hk = t;

	}, Ac: function () {

		var t = this.ha, i = new xt(); return i.v = t.v, i.A = t.A, i.B = t.B, i.o = t.o, i.f = t.f, i.h = t.h, i.i = t.i, i.m = t.m, i.j = t.j, i.l = t.l, i.g = t.g, i.s = t.s, i;

	}, Ec: function ( t ) {

		var i = this.ha; t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s;

	}, Yd: function () {

		var t = this.a, i = new xt(); return i.v = t.v, i.A = t.A, i.B = t.B, i.o = t.o, i.f = t.f, i.h = t.h, i.i = t.i, i.m = t.m, i.j = t.j, i.l = t.l, i.g = t.g, i.s = t.s, i;

	}, pe: function ( t ) {

		var i = this.a; t.v = i.v, t.A = i.A, t.B = i.B, t.o = i.o, t.f = i.f, t.h = i.h, t.i = i.i, t.m = i.m, t.j = i.j, t.l = i.l, t.g = i.g, t.s = i.s;

	}, Ue: function ( t ) {

		var i = this.ha; if ( i.v = t.v, i.A = t.A, i.B = t.B, i.o = t.o, i.f = t.f, i.h = t.h, i.i = t.i, i.m = t.m, i.j = t.j, i.l = t.l, i.g = t.g, i.s = t.s, null != this.Yb ) for ( ( t = this.Yb ).Oj(), i = t.Dc; null != i; ) {

			var s, h, a, e, o, r, n, p, l, c = i.M, y = i.pa, f = i.ha, u = t.pa; s = u.o * f.o + u.f * f.i + u.h * f.l, h = u.o * f.f + u.f * f.m + u.h * f.g, a = u.o * f.h + u.f * f.j + u.h * f.s, e = u.i * f.o + u.m * f.i + u.j * f.l, o = u.i * f.f + u.m * f.m + u.j * f.g, r = u.i * f.h + u.m * f.j + u.j * f.s, n = u.l * f.o + u.g * f.i + u.s * f.l, p = u.l * f.f + u.g * f.m + u.s * f.g, l = u.l * f.h + u.g * f.j + u.s * f.s, y.o = s, y.f = h, y.h = a, y.i = e, y.m = o, y.j = r, y.l = n, y.g = p, y.s = l, s = u.o * f.v + u.f * f.A + u.h * f.B, h = u.i * f.v + u.m * f.A + u.j * f.B, f = u.l * f.v + u.g * f.A + u.s * f.B, y.v = s, y.A = h, y.B = f, y.v += u.v, y.A += u.A, y.B += u.B, y = i.a, f = i.ha, s = ( u = t.a ).o * f.o + u.f * f.i + u.h * f.l, h = u.o * f.f + u.f * f.m + u.h * f.g, a = u.o * f.h + u.f * f.j + u.h * f.s, e = u.i * f.o + u.m * f.i + u.j * f.l, o = u.i * f.f + u.m * f.m + u.j * f.g, r = u.i * f.h + u.m * f.j + u.j * f.s, n = u.l * f.o + u.g * f.i + u.s * f.l, p = u.l * f.f + u.g * f.m + u.s * f.g, l = u.l * f.h + u.g * f.j + u.s * f.s, y.o = s, y.f = h, y.h = a, y.i = e, y.m = o, y.j = r, y.l = n, y.g = p, y.s = l, s = u.o * f.v + u.f * f.A + u.h * f.B, h = u.i * f.v + u.m * f.A + u.j * f.B, f = u.l * f.v + u.g * f.A + u.s * f.B, y.v = s, y.A = h, y.B = f, y.v += u.v, y.A += u.A, y.B += u.B, i.Kb.Nb( i.u, i.pa ), y = i.u.ma, u = i.u.na, f = i.u.oa, s = i.u.ja, h = i.u.ka, a = i.u.la, i.Kb.Nb( i.u, i.a ), i.u.ma = y < i.u.ma ? y : i.u.ma, i.u.na = u < i.u.na ? u : i.u.na, i.u.oa = f < i.u.oa ? f : i.u.oa, i.u.ja = s > i.u.ja ? s : i.u.ja, i.u.ka = h > i.u.ka ? h : i.u.ka, i.u.la = a > i.u.la ? a : i.u.la, null != i.tb && ( y = i.a.v - i.pa.v, u = i.a.A - i.pa.A, f = i.a.B - i.pa.B, ( s = i.rc ).x = y, s.y = u, s.z = f, i.Yb.oc.jc.wd( i.tb, i.u, i.rc ) ), i = c;

		}

	}, qc: function () {

		return this.Dk;

	}, te: function ( t ) {

		if ( this.Dk = t, null != this.Yb ) {

			( t = this.Yb ).Oj(); for ( var i = t.Dc; null != i; ) {

				var s, h, a, e, o, r, n, p, l, c = i.M, y = i.pa, f = i.ha, u = t.pa; s = u.o * f.o + u.f * f.i + u.h * f.l, h = u.o * f.f + u.f * f.m + u.h * f.g, a = u.o * f.h + u.f * f.j + u.h * f.s, e = u.i * f.o + u.m * f.i + u.j * f.l, o = u.i * f.f + u.m * f.m + u.j * f.g, r = u.i * f.h + u.m * f.j + u.j * f.s, n = u.l * f.o + u.g * f.i + u.s * f.l, p = u.l * f.f + u.g * f.m + u.s * f.g, l = u.l * f.h + u.g * f.j + u.s * f.s, y.o = s, y.f = h, y.h = a, y.i = e, y.m = o, y.j = r, y.l = n, y.g = p, y.s = l, s = u.o * f.v + u.f * f.A + u.h * f.B, h = u.i * f.v + u.m * f.A + u.j * f.B, f = u.l * f.v + u.g * f.A + u.s * f.B, y.v = s, y.A = h, y.B = f, y.v += u.v, y.A += u.A, y.B += u.B, y = i.a, f = i.ha, s = ( u = t.a ).o * f.o + u.f * f.i + u.h * f.l, h = u.o * f.f + u.f * f.m + u.h * f.g, a = u.o * f.h + u.f * f.j + u.h * f.s, e = u.i * f.o + u.m * f.i + u.j * f.l, o = u.i * f.f + u.m * f.m + u.j * f.g, r = u.i * f.h + u.m * f.j + u.j * f.s, n = u.l * f.o + u.g * f.i + u.s * f.l, p = u.l * f.f + u.g * f.m + u.s * f.g, l = u.l * f.h + u.g * f.j + u.s * f.s, y.o = s, y.f = h, y.h = a, y.i = e, y.m = o, y.j = r, y.l = n, y.g = p, y.s = l, s = u.o * f.v + u.f * f.A + u.h * f.B, h = u.i * f.v + u.m * f.A + u.j * f.B, f = u.l * f.v + u.g * f.A + u.s * f.B, y.v = s, y.A = h, y.B = f, y.v += u.v, y.A += u.A, y.B += u.B, i.Kb.Nb( i.u, i.pa ), y = i.u.ma, u = i.u.na, f = i.u.oa, s = i.u.ja, h = i.u.ka, a = i.u.la, i.Kb.Nb( i.u, i.a ), i.u.ma = y < i.u.ma ? y : i.u.ma, i.u.na = u < i.u.na ? u : i.u.na, i.u.oa = f < i.u.oa ? f : i.u.oa, i.u.ja = s > i.u.ja ? s : i.u.ja, i.u.ka = h > i.u.ka ? h : i.u.ka, i.u.la = a > i.u.la ? a : i.u.la, null != i.tb && ( y = i.a.v - i.pa.v, u = i.a.A - i.pa.A, f = i.a.B - i.pa.B, ( s = i.rc ).x = y, s.y = u, s.z = f, i.Yb.oc.jc.wd( i.tb, i.u, i.rc ) ), i = c;

			}

		}

	}, ua: function () {

		return this.u.clone();

	}, cb: function ( t ) {

		t.de( this.u );

	}, vc: function () {

		return this.Kb;

	}, Kc: function () {

		return this.Yb;

	}, Hb: function () {

		return this.Tj;

	}, qe: function ( t ) {

		this.Tj = t;

	}, Mb: function () {

		return this.Uj;

	}, re: function ( t ) {

		this.Uj = t;

	}, pc: function () {

		return this.yd;

	}, se: function ( t ) {

		this.yd = t;

	}, fd: function () {

		return this.ia;

	}, Lc: function () {

		return this.M;

	} }, ti.Ve = 1, ti.Mf = 2, ti.BRUTE_FORCE = 1, ti.BVH = 2, Jt.vm = 0, Jt.Ue = 1, Jt.ji = 2, Jt.Ug = 3, Jt.Tg = 4, Jt.Vg = 5, Jt.Xg = 0, Jt.Wg = 5, Jt.SPHERE = 0, Jt.BOX = 1, Jt.CYLINDER = 2, Jt.CONE = 3, Jt.CAPSULE = 4, Jt.CONVEX_HULL = 5, It.re = 1, jt.Mb = 0, dt.numCreations = 0, gt.defaultFriction = .2, gt.defaultRestitution = .2, gt.defaultDensity = 1, gt.defaultCollisionGroup = 1, gt.defaultCollisionMask = 1, gt.maxTranslationPerStep = 20, gt.maxRotationPerStep = 3.14159265358979, gt.bvhProxyPadding = .1, gt.bvhIncrementalCollisionThreshold = .45, gt.defaultGJKMargin = .05, gt.enableGJKCaching = ! 0, gt.maxEPAVertices = 128, gt.maxEPAPolyhedronFaces = 128, gt.contactEnableBounceThreshold = .5, gt.velocityBaumgarte = .2, gt.positionSplitImpulseBaumgarte = .4, gt.positionNgsBaumgarte = 1, gt.contactUseAlternativePositionCorrectionAlgorithmDepthThreshold = .05, gt.defaultContactPositionCorrectionAlgorithm = 0, gt.alternativeContactPositionCorrectionAlgorithm = 1, gt.contactPersistenceThreshold = .05, gt.maxManifoldPoints = 4, gt.defaultJointConstraintSolverType = 0, gt.defaultJointPositionCorrectionAlgorithm = 0, gt.jointWarmStartingFactorForBaungarte = .8, gt.jointWarmStartingFactor = .95, gt.minSpringDamperDampingRatio = 1e-6, gt.minRagdollMaxSwingAngle = 1e-6, gt.maxJacobianRows = 6, gt.directMlcpSolverEps = 1e-9, gt.islandInitialRigidBodyArraySize = 128, gt.islandInitialConstraintArraySize = 128, gt.sleepingVelocityThreshold = .2, gt.sleepingAngularVelocityThreshold = .5, gt.sleepingTimeThreshold = 1, gt.disableSleeping = ! 1, gt.linearSlop = .005, gt.angularSlop = .017453292519943278, vt.cb = new vt(), bt.Dm = 0, bt.gm = 1, bt.cm = 2, bt.bm = 257, bt.am = 258, bt.Nl = 259, bt.SUCCEEDED = 0, bt.GJK_FAILED_TO_MAKE_TETRAHEDRON = 1, bt.GJK_DID_NOT_CONVERGE = 2, bt.EPA_FAILED_TO_INIT = 257, bt.EPA_FAILED_TO_ADD_VERTEX = 258, bt.EPA_DID_NOT_CONVERGE = 259, ft.numCreations = 0, yt.numCreations = 0, ct.POSITIVE_INFINITY = 1 / 0, ct.NEGATIVE_INFINITY = - 1 / 0, ct.PI = 3.14159265358979, ct.TWO_PI = 6.28318530717958, ct.HALF_PI = 1.570796326794895, ct.TO_RADIANS = .017453292519943278, ct.TO_DEGREES = 57.29577951308238, pt.numCreations = 0, X.broadPhaseCollisionTime = 0, X.narrowPhaseCollisionTime = 0, X.dynamicsTime = 0, X.totalTime = 0, W.ue = 0, W.xm = 1, W.lm = 2, W.BAUMGARTE = 0, W.SPLIT_IMPULSE = 1, W.NGS = 2, H.pe = 1, H.Yd = 2, q.wm = 0, q.um = 1, q.ki = 2, q.qm = 3, q.Em = 4, q.rm = 5, q.SPHERICAL = 0, q.REVOLUTE = 1, q.CYLINDRICAL = 2, q.PRISMATIC = 3, q.UNIVERSAL = 4, q.RAGDOLL = 5, b.im = 0, b.li = 1, b.ITERATIVE = 0, b.DIRECT = 1, s.Pj = 0, s.Cm = 1, s.jm = 2, s.DYNAMIC = 0, s.STATIC = 1, s.KINEMATIC = 2, t.OIMO = {}, t.OIMO.BroadPhase = oi, oi.prototype.createProxy = oi.prototype.Vh, oi.prototype.destroyProxy = oi.prototype.Wh, oi.prototype.moveProxy = oi.prototype.wd, oi.prototype.isOverlapping = oi.prototype.Mb, oi.prototype.collectPairs = oi.prototype.Ii, oi.prototype.getProxyPairList = oi.prototype.ua, oi.prototype.isIncremental = oi.prototype.Hb, oi.prototype.getTestCount = oi.prototype.cb, oi.prototype.rayCast = oi.prototype.Vd, oi.prototype.convexCast = oi.prototype.Bf, oi.prototype.aabbTest = oi.prototype.qh, t.OIMO.Geometry = ei, ei.prototype.getType = ei.prototype.cb, ei.prototype.getVolume = ei.prototype.ua, ei.prototype.rayCast = ei.prototype.Vd, t.OIMO.ConvexGeometry = ai, ai.prototype.getGjkMargin = ai.prototype.un, ai.prototype.setGjkMargin = ai.prototype.Zn, ai.prototype.computeLocalSupportingVertex = ai.prototype.Pd, ai.prototype.rayCast = ai.prototype.Vd, t.OIMO.BroadPhaseProxyCallback = ii, ii.prototype.process = ii.prototype.process, t.OIMO.BroadPhaseType = ti, t.OIMO.Proxy = _t, _t.prototype.getId = _t.prototype.Hb, _t.prototype.getFatAabb = _t.prototype.ua, _t.prototype.getFatAabbTo = _t.prototype.cb, t.OIMO.ProxyPair = Qt, Qt.prototype.getProxy1 = Qt.prototype.ua, Qt.prototype.getProxy2 = Qt.prototype.cb, Qt.prototype.getNext = Qt.prototype.Hb, t.OIMO.BruteForceBroadPhase = Zt, Zt.prototype.createProxy = Zt.prototype.Vh, Zt.prototype.destroyProxy = Zt.prototype.Wh, Zt.prototype.moveProxy = Zt.prototype.wd, Zt.prototype.collectPairs = Zt.prototype.Ii, Zt.prototype.rayCast = Zt.prototype.Vd, Zt.prototype.convexCast = Zt.prototype.Bf, Zt.prototype.aabbTest = Zt.prototype.qh, t.OIMO.BvhBroadPhase = $t, $t.prototype.createProxy = $t.prototype.Vh, $t.prototype.destroyProxy = $t.prototype.Wh, $t.prototype.moveProxy = $t.prototype.wd, $t.prototype.collectPairs = $t.prototype.Ii, $t.prototype.rayCast = $t.prototype.Vd, $t.prototype.convexCast = $t.prototype.Bf, $t.prototype.aabbTest = $t.prototype.qh, $t.prototype.getTreeBalance = $t.prototype.Jn, t.OIMO.Aabb = Et, Et.prototype.init = Et.prototype.za, Et.prototype.getMin = Et.prototype.Jc, Et.prototype.getMinTo = Et.prototype.Kc, Et.prototype.setMin = Et.prototype.Yd, Et.prototype.getMax = Et.prototype.Ac, Et.prototype.getMaxTo = Et.prototype.Ec, Et.prototype.setMax = Et.prototype.fd, Et.prototype.getCenter = Et.prototype.Hb, Et.prototype.getCenterTo = Et.prototype.Mb, Et.prototype.getExtents = Et.prototype.pc, Et.prototype.getExtentsTo = Et.prototype.qc, Et.prototype.combine = Et.prototype.ua, Et.prototype.combined = Et.prototype.cb, Et.prototype.overlap = Et.prototype.Lc, Et.prototype.getIntersection = Et.prototype.uc, Et.prototype.getIntersectionTo = Et.prototype.vc, Et.prototype.copyFrom = Et.prototype.de, Et.prototype.clone = Et.prototype.clone, t.OIMO.BoxGeometry = Vt, Vt.prototype.getHalfExtents = Vt.prototype.vn, Vt.prototype.getHalfExtentsTo = Vt.prototype.wn, Vt.prototype.computeLocalSupportingVertex = Vt.prototype.Pd, t.OIMO.CapsuleGeometry = Gt, Gt.prototype.getRadius = Gt.prototype.Xh, Gt.prototype.getHalfHeight = Gt.prototype.Bj, Gt.prototype.computeLocalSupportingVertex = Gt.prototype.Pd, t.OIMO.ConeGeometry = Kt, Kt.prototype.getRadius = Kt.prototype.Xh, Kt.prototype.getHalfHeight = Kt.prototype.Bj, Kt.prototype.computeLocalSupportingVertex = Kt.prototype.Pd, t.OIMO.ConvexHullGeometry = Ht, Ht.prototype.getVertices = Ht.prototype.Nn, Ht.prototype.computeLocalSupportingVertex = Ht.prototype.Pd, t.OIMO.CylinderGeometry = Nt, Nt.prototype.getRadius = Nt.prototype.Xh, Nt.prototype.getHalfHeight = Nt.prototype.Bj, Nt.prototype.computeLocalSupportingVertex = Nt.prototype.Pd, t.OIMO.GeometryType = Jt, t.OIMO.RayCastHit = Rt, t.OIMO.SphereGeometry = Pt, Pt.prototype.getRadius = Pt.prototype.Xh, Pt.prototype.computeLocalSupportingVertex = Pt.prototype.Pd, t.OIMO.CollisionMatrix = Ft, Ft.prototype.getDetector = Ft.prototype.ua, t.OIMO.DetectorResult = Lt, Lt.prototype.getMaxDepth = Lt.prototype.mm, Lt.prototype.clear = Lt.prototype.clear, t.OIMO.DetectorResultPoint = Ot, t.OIMO.Detector = Tt, Tt.prototype.detect = Tt.prototype.hm, t.OIMO.BoxBoxDetector = It, t.OIMO.CapsuleCapsuleDetector = Bt, t.OIMO.GjkEpaDetector = Ct, t.OIMO.SphereBoxDetector = Dt, t.OIMO.SphereCapsuleDetector = wt, t.OIMO.SphereSphereDetector = At, t.OIMO.Vec3 = dt, dt.prototype.init = dt.prototype.za, dt.prototype.zero = dt.prototype.Z, dt.prototype.add = dt.prototype.Lc, dt.prototype.addScaled = dt.prototype.ua, dt.prototype.sub = dt.prototype.ue, dt.prototype.scale = dt.prototype.se, dt.prototype.scale3 = dt.prototype.Ve, dt.prototype.dot = dt.prototype.Yd, dt.prototype.cross = dt.prototype.Hb, dt.prototype.addEq = dt.prototype.fd, dt.prototype.addScaledEq = dt.prototype.cb, dt.prototype.subEq = dt.prototype.Ue, dt.prototype.scaleEq = dt.prototype.te, dt.prototype.scale3Eq = dt.prototype.Mf, dt.prototype.crossEq = dt.prototype.Mb, dt.prototype.mulMat3 = dt.prototype.pc, dt.prototype.mulMat4 = dt.prototype.uc, dt.prototype.mulTransform = dt.prototype.Ac, dt.prototype.mulMat3Eq = dt.prototype.qc, dt.prototype.mulMat4Eq = dt.prototype.vc, dt.prototype.mulTransformEq = dt.prototype.Ec, dt.prototype.length = dt.prototype.length, dt.prototype.lengthSq = dt.prototype.pe, dt.prototype.normalized = dt.prototype.re, dt.prototype.normalize = dt.prototype.qe, dt.prototype.negate = dt.prototype.Jc, dt.prototype.negateEq = dt.prototype.Kc, dt.prototype.copyFrom = dt.prototype.de, dt.prototype.clone = dt.prototype.clone, dt.prototype.toString = dt.prototype.toString, t.OIMO.Transform = xt, xt.prototype.identity = xt.prototype.Wf, xt.prototype.getPosition = xt.prototype.Hb, xt.prototype.getPositionTo = xt.prototype.Mb, xt.prototype.setPosition = xt.prototype.Ec, xt.prototype.translate = xt.prototype.Lc, xt.prototype.getRotation = xt.prototype.pc, xt.prototype.getRotationTo = xt.prototype.qc, xt.prototype.setRotation = xt.prototype.Jc, xt.prototype.setRotationXyz = xt.prototype.Kc, xt.prototype.rotate = xt.prototype.uc, xt.prototype.rotateXyz = xt.prototype.vc, xt.prototype.getOrientation = xt.prototype.ua, xt.prototype.getOrientationTo = xt.prototype.cb, xt.prototype.setOrientation = xt.prototype.Ac, xt.prototype.clone = xt.prototype.clone, xt.prototype.copyFrom = xt.prototype.de, t.OIMO.Setting = gt, t.OIMO.GjkEpa = vt, vt.prototype.computeClosestPoints = vt.prototype.ua, vt.prototype.computeDistance = vt.prototype.cb, vt.prototype.convexCast = vt.prototype.Bf, vt.prototype.rayCast = vt.prototype.Vd, vt.getInstance = vt.pc, t.OIMO.GjkEpaResultState = bt, t.OIMO.SimplexUtil = ut, ut.projectOrigin2 = ut.qc, ut.projectOrigin3 = ut.uc, ut.projectOrigin4 = ut.vc, t.OIMO.Mat3 = ft, ft.prototype.init = ft.prototype.za, ft.prototype.identity = ft.prototype.Wf, ft.prototype.add = ft.prototype.Ac, ft.prototype.sub = ft.prototype.Ug, ft.prototype.scale = ft.prototype.Mf, ft.prototype.mul = ft.prototype.re, ft.prototype.addEq = ft.prototype.Ec, ft.prototype.subEq = ft.prototype.Vg, ft.prototype.scaleEq = ft.prototype.Tg, ft.prototype.mulEq = ft.prototype.se, ft.prototype.prependScale = ft.prototype.Ue, ft.prototype.appendScale = ft.prototype.Lc, ft.prototype.prependRotation = ft.prototype.te, ft.prototype.appendRotation = ft.prototype.Jc, ft.prototype.prependScaleEq = ft.prototype.Ve, ft.prototype.appendScaleEq = ft.prototype.fd, ft.prototype.prependRotationEq = ft.prototype.ue, ft.prototype.appendRotationEq = ft.prototype.Kc, ft.prototype.transpose = ft.prototype.ji, ft.prototype.transposeEq = ft.prototype.ki, ft.prototype.determinant = ft.prototype.Yd, ft.prototype.trace = ft.prototype.Xg, ft.prototype.inverse = ft.prototype.pe, ft.prototype.inverseEq = ft.prototype.qe, ft.prototype.toArray = ft.prototype.Wg, ft.prototype.copyFrom = ft.prototype.de, ft.prototype.clone = ft.prototype.clone, ft.prototype.fromQuat = ft.prototype.Hb, ft.prototype.toQuat = ft.prototype.Pj, ft.prototype.fromEulerXyz = ft.prototype.cb, ft.prototype.toEulerXyz = ft.prototype.li, ft.prototype.getRow = ft.prototype.uc, ft.prototype.getCol = ft.prototype.pc, ft.prototype.getRowTo = ft.prototype.vc, ft.prototype.getColTo = ft.prototype.qc, ft.prototype.fromRows = ft.prototype.Mb, ft.prototype.fromCols = ft.prototype.ua, ft.prototype.toString = ft.prototype.toString, t.OIMO.Mat4 = yt, yt.prototype.init = yt.prototype.za, yt.prototype.identity = yt.prototype.Wf, yt.prototype.add = yt.prototype.pc, yt.prototype.sub = yt.prototype.Mf, yt.prototype.scale = yt.prototype.Ue, yt.prototype.mul = yt.prototype.Yd, yt.prototype.addEq = yt.prototype.qc, yt.prototype.subEq = yt.prototype.Tg, yt.prototype.scaleEq = yt.prototype.Ve, yt.prototype.mulEq = yt.prototype.pe, yt.prototype.prependScale = yt.prototype.te, yt.prototype.appendScale = yt.prototype.Ac, yt.prototype.prependRotation = yt.prototype.re, yt.prototype.appendRotation = yt.prototype.uc, yt.prototype.prependTranslation = yt.prototype.ki, yt.prototype.appendTranslation = yt.prototype.ua, yt.prototype.prependScaleEq = yt.prototype.ue, yt.prototype.appendScaleEq = yt.prototype.Ec, yt.prototype.prependRotationEq = yt.prototype.se, yt.prototype.appendRotationEq = yt.prototype.vc, yt.prototype.prependTranslationEq = yt.prototype.li, yt.prototype.appendTranslationEq = yt.prototype.cb, yt.prototype.transpose = yt.prototype.Wg, yt.prototype.transposeEq = yt.prototype.Xg, yt.prototype.determinant = yt.prototype.Jc, yt.prototype.trace = yt.prototype.Vg, yt.prototype.inverse = yt.prototype.Lc, yt.prototype.inverseEq = yt.prototype.fd, yt.prototype.lookAt = yt.prototype.Mb, yt.prototype.perspective = yt.prototype.qe, yt.prototype.ortho = yt.prototype.ji, yt.prototype.toArray = yt.prototype.Ug, yt.prototype.copyFrom = yt.prototype.de, yt.prototype.fromMat3 = yt.prototype.Kc, yt.prototype.fromTransform = yt.prototype.Hb, yt.prototype.clone = yt.prototype.clone, yt.prototype.toString = yt.prototype.toString, t.OIMO.MathUtil = ct, ct.abs = ct.abs, ct.sin = ct.sin, ct.cos = ct.cos, ct.tan = ct.tan, ct.asin = ct.asin, ct.acos = ct.acos, ct.atan = ct.atan, ct.safeAsin = ct.fd, ct.safeAcos = ct.Lc, ct.atan2 = ct.atan2, ct.sqrt = ct.sqrt, ct.clamp = ct.Hb, ct.rand = ct.Ac, ct.randIn = ct.Ec, ct.randVec3In = ct.Kc, ct.randVec3 = ct.Jc, t.OIMO.Pool = lt, lt.prototype.vec3 = lt.prototype.Ac, lt.prototype.mat3 = lt.prototype.qc, lt.prototype.mat4 = lt.prototype.uc, lt.prototype.quat = lt.prototype.vc, lt.prototype.dispose = lt.prototype.ua, lt.prototype.disposeVec3 = lt.prototype.pc, lt.prototype.disposeMat3 = lt.prototype.cb, lt.prototype.disposeMat4 = lt.prototype.Hb, lt.prototype.disposeQuat = lt.prototype.Mb, t.OIMO.Quat = pt, pt.prototype.identity = pt.prototype.Wf, pt.prototype.init = pt.prototype.za, pt.prototype.add = pt.prototype.ua, pt.prototype.sub = pt.prototype.Ec, pt.prototype.scale = pt.prototype.vc, pt.prototype.addEq = pt.prototype.cb, pt.prototype.subEq = pt.prototype.Jc, pt.prototype.scaleEq = pt.prototype.Ac, pt.prototype.length = pt.prototype.length, pt.prototype.lengthSq = pt.prototype.pc, pt.prototype.dot = pt.prototype.Hb, pt.prototype.normalized = pt.prototype.uc, pt.prototype.normalize = pt.prototype.qc, pt.prototype.setArc = pt.prototype.Kc, pt.prototype.slerp = pt.prototype.Lc, pt.prototype.copyFrom = pt.prototype.de, pt.prototype.clone = pt.prototype.clone, pt.prototype.fromMat3 = pt.prototype.Mb, pt.prototype.toMat3 = pt.prototype.fd, pt.prototype.toString = pt.prototype.toString, t.OIMO.Contact = nt, nt.prototype.getShape1 = nt.prototype.pc, nt.prototype.getShape2 = nt.prototype.qc, nt.prototype.isTouching = nt.prototype.sk, nt.prototype.getManifold = nt.prototype.cb, nt.prototype.getContactConstraint = nt.prototype.ua, nt.prototype.getPrev = nt.prototype.Mb, nt.prototype.getNext = nt.prototype.Hb, t.OIMO.ContactLink = rt, rt.prototype.getContact = rt.prototype.ua, rt.prototype.getOther = rt.prototype.Hb, rt.prototype.getPrev = rt.prototype.Mb, rt.prototype.getNext = rt.prototype.cb, t.OIMO.ContactManager = ot, ot.prototype.getNumContacts = ot.prototype.cb, ot.prototype.getContactList = ot.prototype.ua, t.OIMO.TimeStep = at, t.OIMO.World = ht, ht.prototype.step = ht.prototype.pe, ht.prototype.addRigidBody = ht.prototype.cb, ht.prototype.removeRigidBody = ht.prototype.qe, ht.prototype.addJoint = ht.prototype.ua, ht.prototype.removeJoint = ht.prototype.Kl, ht.prototype.rayCast = ht.prototype.Vd, ht.prototype.convexCast = ht.prototype.Bf, ht.prototype.aabbTest = ht.prototype.qh, ht.prototype.getRigidBodyList = ht.prototype.fd, ht.prototype.getJointList = ht.prototype.vc, ht.prototype.getBroadPhase = ht.prototype.Mb, ht.prototype.getContactManager = ht.prototype.pc, ht.prototype.getNumRigidBodies = ht.prototype.Kc, ht.prototype.getNumJoints = ht.prototype.Ec, ht.prototype.getNumShapes = ht.prototype.Yd, ht.prototype.getNumIslands = ht.prototype.Ac, ht.prototype.getNumVelocityIterations = ht.prototype.Lc, ht.prototype.setNumVelocityIterations = ht.prototype.ue, ht.prototype.getNumPositionIterations = ht.prototype.Jc, ht.prototype.setNumPositionIterations = ht.prototype.te, ht.prototype.getGravity = ht.prototype.uc, ht.prototype.setGravity = ht.prototype.se, t.OIMO.AabbTestCallback = _, t.OIMO.ContactCallback = Q, t.OIMO.RayCastCallback = Z, t.OIMO.RayCastClosest = $, $.prototype.clear = $.prototype.clear, $.prototype.process = $.prototype.process, t.OIMO.Performance = X, t.OIMO.ConstraintSolver = Y, Y.prototype.preSolveVelocity = Y.prototype.xh, Y.prototype.warmStart = Y.prototype.Gh, Y.prototype.solveVelocity = Y.prototype.Ch, Y.prototype.postSolveVelocity = Y.prototype.Li, Y.prototype.preSolvePosition = Y.prototype.Pg, Y.prototype.solvePositionSplitImpulse = Y.prototype.Bh, Y.prototype.solvePositionNgs = Y.prototype.Ah, Y.prototype.postSolve = Y.prototype.postSolve, t.OIMO.PositionCorrectionAlgorithm = W, t.OIMO.ContactConstraint = U, U.prototype.getShape1 = U.prototype.cb, U.prototype.getShape2 = U.prototype.Hb, U.prototype.getManifold = U.prototype.ua, U.prototype.isTouching = U.prototype.sk, t.OIMO.Manifold = V, V.prototype.getNormal = V.prototype.Hb, V.prototype.getNormalTo = V.prototype.Mb, V.prototype.getTangent = V.prototype.uc, V.prototype.getTangentTo = V.prototype.vc, V.prototype.getBinormal = V.prototype.ua, V.prototype.getBinormalTo = V.prototype.cb, V.prototype.getPoints = V.prototype.qc, V.prototype.getNumPoints = V.prototype.pc, t.OIMO.ManifoldPoint = G, G.prototype.getPosition1 = G.prototype.Mb, G.prototype.getPosition1To = G.prototype.pc, G.prototype.getPosition2 = G.prototype.qc, G.prototype.getPosition2To = G.prototype.uc, G.prototype.getDepth = G.prototype.cb, G.prototype.isWarmStarted = G.prototype.Ac, G.prototype.getNormalImpulse = G.prototype.Hb, G.prototype.getTangentImpulse = G.prototype.vc, G.prototype.getBinormalImpulse = G.prototype.ua, G.prototype.isEnabled = G.prototype.Ec, t.OIMO.Joint = F, F.prototype.getRigidBody1 = F.prototype.ue, F.prototype.getRigidBody2 = F.prototype.Ue, F.prototype.getType = F.prototype.Tg, F.prototype.getAnchor1 = F.prototype.cb, F.prototype.getAnchor2 = F.prototype.Mb, F.prototype.getAnchor1To = F.prototype.Hb, F.prototype.getAnchor2To = F.prototype.pc, F.prototype.getLocalAnchor1 = F.prototype.pe, F.prototype.getLocalAnchor2 = F.prototype.re, F.prototype.getLocalAnchor1To = F.prototype.qe, F.prototype.getLocalAnchor2To = F.prototype.se, F.prototype.getBasis1 = F.prototype.Ec, F.prototype.getBasis2 = F.prototype.Kc, F.prototype.getBasis1To = F.prototype.Jc, F.prototype.getBasis2To = F.prototype.Lc, F.prototype.getAllowCollision = F.prototype.ua, F.prototype.setAllowCollision = F.prototype.Ug, F.prototype.getBreakForce = F.prototype.fd, F.prototype.setBreakForce = F.prototype.Vg, F.prototype.getBreakTorque = F.prototype.Yd, F.prototype.setBreakTorque = F.prototype.Wg, F.prototype.getPositionCorrectionAlgorithm = F.prototype.te, F.prototype.setPositionCorrectionAlgorithm = F.prototype.Xg, F.prototype.getAppliedForce = F.prototype.qc, F.prototype.getAppliedForceTo = F.prototype.uc, F.prototype.getAppliedTorque = F.prototype.vc, F.prototype.getAppliedTorqueTo = F.prototype.Ac, F.prototype.getPrev = F.prototype.Mf, F.prototype.getNext = F.prototype.Ve, t.OIMO.CylindricalJoint = L, L.prototype.getAxis1 = L.prototype.Eg, L.prototype.getAxis2 = L.prototype.Gg, L.prototype.getAxis1To = L.prototype.Fg, L.prototype.getAxis2To = L.prototype.Hg, L.prototype.getLocalAxis1 = L.prototype.Ig, L.prototype.getLocalAxis2 = L.prototype.Kg, L.prototype.getLocalAxis1To = L.prototype.Jg, L.prototype.getLocalAxis2To = L.prototype.Lg, L.prototype.getTranslationalSpringDamper = L.prototype.In, L.prototype.getRotationalSpringDamper = L.prototype.An, L.prototype.getTranslationalLimitMotor = L.prototype.Hn, L.prototype.getRotationalLimitMotor = L.prototype.zn, L.prototype.getAngle = L.prototype.ol, L.prototype.getTranslation = L.prototype.rl, t.OIMO.JointConfig = O, t.OIMO.CylindricalJointConfig = T, T.prototype.init = T.prototype.za, t.OIMO.JointLink = S, S.prototype.getContact = S.prototype.ua, S.prototype.getOther = S.prototype.Hb, S.prototype.getPrev = S.prototype.Mb, S.prototype.getNext = S.prototype.cb, t.OIMO.JointType = q, t.OIMO.PrismaticJoint = B, B.prototype.getAxis1 = B.prototype.Eg, B.prototype.getAxis2 = B.prototype.Gg, B.prototype.getAxis1To = B.prototype.Fg, B.prototype.getAxis2To = B.prototype.Hg, B.prototype.getLocalAxis1 = B.prototype.Ig, B.prototype.getLocalAxis2 = B.prototype.Kg, B.prototype.getLocalAxis1To = B.prototype.Jg, B.prototype.getLocalAxis2To = B.prototype.Lg, B.prototype.getSpringDamper = B.prototype.Cj, B.prototype.getLimitMotor = B.prototype.ql, B.prototype.getTranslation = B.prototype.rl, t.OIMO.PrismaticJointConfig = C, C.prototype.init = C.prototype.za, t.OIMO.RagdollJoint = D, D.prototype.getAxis1 = D.prototype.Eg, D.prototype.getAxis2 = D.prototype.Gg, D.prototype.getAxis1To = D.prototype.Fg, D.prototype.getAxis2To = D.prototype.Hg, D.prototype.getLocalAxis1 = D.prototype.Ig, D.prototype.getLocalAxis2 = D.prototype.Kg, D.prototype.getLocalAxis1To = D.prototype.Jg, D.prototype.getLocalAxis2To = D.prototype.Lg, D.prototype.getTwistSpringDamper = D.prototype.Mn, D.prototype.getTwistLimitMotor = D.prototype.Ln, D.prototype.getSwingSpringDamper = D.prototype.Gn, D.prototype.getSwingAxis = D.prototype.En, D.prototype.getSwingAxisTo = D.prototype.Fn, D.prototype.getSwingAngle = D.prototype.Dn, D.prototype.getTwistAngle = D.prototype.Kn, t.OIMO.RagdollJointConfig = w, w.prototype.init = w.prototype.za, t.OIMO.RevoluteJoint = A, A.prototype.getAxis1 = A.prototype.Eg, A.prototype.getAxis2 = A.prototype.Gg, A.prototype.getAxis1To = A.prototype.Fg, A.prototype.getAxis2To = A.prototype.Hg, A.prototype.getLocalAxis1 = A.prototype.Ig, A.prototype.getLocalAxis2 = A.prototype.Kg, A.prototype.getLocalAxis1To = A.prototype.Jg, A.prototype.getLocalAxis2To = A.prototype.Lg, A.prototype.getSpringDamper = A.prototype.Cj, A.prototype.getLimitMotor = A.prototype.ql, A.prototype.getAngle = A.prototype.ol, t.OIMO.RevoluteJointConfig = M, M.prototype.init = M.prototype.za, t.OIMO.RotationalLimitMotor = j, j.prototype.setLimits = j.prototype.ua, j.prototype.setMotor = j.prototype.cb, j.prototype.clone = j.prototype.clone, t.OIMO.SphericalJoint = m, m.prototype.getSpringDamper = m.prototype.Cj, t.OIMO.SphericalJointConfig = z, z.prototype.init = z.prototype.za, t.OIMO.SpringDamper = d, d.prototype.setSpring = d.prototype.ua, d.prototype.setSymplecticEuler = d.prototype.cb, d.prototype.clone = d.prototype.clone, t.OIMO.TranslationalLimitMotor = x, x.prototype.setLimits = x.prototype.ua, x.prototype.setMotor = x.prototype.cb, x.prototype.clone = x.prototype.clone, t.OIMO.UniversalJoint = g, g.prototype.getAxis1 = g.prototype.Eg, g.prototype.getAxis2 = g.prototype.Gg, g.prototype.getAxis1To = g.prototype.Fg, g.prototype.getAxis2To = g.prototype.Hg, g.prototype.getLocalAxis1 = g.prototype.Ig, g.prototype.getLocalAxis2 = g.prototype.Kg, g.prototype.getLocalAxis1To = g.prototype.Jg, g.prototype.getLocalAxis2To = g.prototype.Lg, g.prototype.getSpringDamper1 = g.prototype.Bn, g.prototype.getSpringDamper2 = g.prototype.Cn, g.prototype.getLimitMotor1 = g.prototype.xn, g.prototype.getLimitMotor2 = g.prototype.yn, g.prototype.getAngle1 = g.prototype.sn, g.prototype.getAngle2 = g.prototype.tn, t.OIMO.UniversalJointConfig = v, v.prototype.init = v.prototype.za, t.OIMO.ConstraintSolverType = b, t.OIMO.DirectJointConstraintSolver = n, n.prototype.preSolveVelocity = n.prototype.xh, n.prototype.warmStart = n.prototype.Gh, n.prototype.solveVelocity = n.prototype.Ch, n.prototype.postSolveVelocity = n.prototype.Li, n.prototype.preSolvePosition = n.prototype.Pg, n.prototype.solvePositionSplitImpulse = n.prototype.Bh, n.prototype.solvePositionNgs = n.prototype.Ah, n.prototype.postSolve = n.prototype.postSolve, t.OIMO.PgsContactConstraintSolver = o, o.prototype.preSolveVelocity = o.prototype.xh, o.prototype.warmStart = o.prototype.Gh, o.prototype.solveVelocity = o.prototype.Ch, o.prototype.preSolvePosition = o.prototype.Pg, o.prototype.solvePositionSplitImpulse = o.prototype.Bh, o.prototype.solvePositionNgs = o.prototype.Ah, o.prototype.postSolve = o.prototype.postSolve, t.OIMO.PgsJointConstraintSolver = e, e.prototype.preSolveVelocity = e.prototype.xh, e.prototype.warmStart = e.prototype.Gh, e.prototype.solveVelocity = e.prototype.Ch, e.prototype.postSolveVelocity = e.prototype.Li, e.prototype.preSolvePosition = e.prototype.Pg, e.prototype.solvePositionSplitImpulse = e.prototype.Bh, e.prototype.solvePositionNgs = e.prototype.Ah, e.prototype.postSolve = e.prototype.postSolve, t.OIMO.MassData = a, t.OIMO.RigidBody = h; h.prototype.getPosition = h.prototype.qm, h.prototype.getPositionTo = h.prototype.rm, h.prototype.setPosition = h.prototype.Xn, h.prototype.translate = h.prototype.jo, h.prototype.getRotation = h.prototype.vm, h.prototype.getRotationTo = h.prototype.wm, h.prototype.setRotation = h.prototype.$n, h.prototype.setRotationXyz = h.prototype.fo, h.prototype.rotate = h.prototype.Em, h.prototype.rotateXyz = h.prototype.Sn, h.prototype.getOrientation = h.prototype.jm, h.prototype.getOrientationTo = h.prototype.lm, h.prototype.setOrientation = h.prototype.Tn, h.prototype.getTransform = h.prototype.xm, h.prototype.getTransformTo = h.prototype.Cm, h.prototype.setTransform = h.prototype.ho, h.prototype.getMass = h.prototype.Tg, h.prototype.getLocalInertia = h.prototype.se, h.prototype.getLocalInertiaTo = h.prototype.te, h.prototype.getMassData = h.prototype.Ug, h.prototype.getMassDataTo = h.prototype.Vg, h.prototype.setMassData = h.prototype.Qm, h.prototype.getRotationFactor = h.prototype.ji, h.prototype.setRotationFactor = h.prototype.Rm, h.prototype.getLinearVelocity = h.prototype.qe, h.prototype.getLinearVelocityTo = h.prototype.re, h.prototype.setLinearVelocity = h.prototype.Pm, h.prototype.getAngularVelocity = h.prototype.Jc, h.prototype.getAngularVelocityTo = h.prototype.Kc, h.prototype.setAngularVelocity = h.prototype.mo, h.prototype.addLinearVelocity = h.prototype.cb, h.prototype.addAngularVelocity = h.prototype.ua, h.prototype.applyImpulse = h.prototype.uc, h.prototype.applyLinearImpulse = h.prototype.vc, h.prototype.applyAngularImpulse = h.prototype.Mb, h.prototype.applyForce = h.prototype.pc, h.prototype.applyForceToCenter = h.prototype.qc, h.prototype.applyTorque = h.prototype.Ac, h.prototype.getGravityScale = h.prototype.fd, h.prototype.setGravityScale = h.prototype.Nm, h.prototype.getLocalPoint = h.prototype.ue, h.prototype.getLocalPointTo = h.prototype.Ue, h.prototype.getLocalVector = h.prototype.Ve, h.prototype.getLocalVectorTo = h.prototype.Mf, h.prototype.getWorldPoint = h.prototype.Pj, h.prototype.getWorldPointTo = h.prototype.Nl, h.prototype.getWorldVector = h.prototype.am, h.prototype.getWorldVectorTo = h.prototype.bm, h.prototype.getNumShapes = h.prototype.im, h.prototype.getShapeList = h.prototype.ki, h.prototype.getNumContectLinks = h.prototype.Wg, h.prototype.getContactLinkList = h.prototype.Lc, h.prototype.getNumJointLinks = h.prototype.Xg, h.prototype.getJointLinkList = h.prototype.Yd, h.prototype.addShape = h.prototype.Hb, h.prototype.removeShape = h.prototype.ko, h.prototype.getType = h.prototype.Dm, h.prototype.setType = h.prototype.Sm, h.prototype.wakeUp = h.prototype.Um, h.prototype.sleep = h.prototype.Tm, h.prototype.isSleeping = h.prototype.cm, h.prototype.getSleepTime = h.prototype.li, h.prototype.setAutoSleep = h.prototype.Mm, h.prototype.getLinearDamping = h.prototype.pe, h.prototype.setLinearDamping = h.prototype.Om, h.prototype.getAngularDamping = h.prototype.Ec, h.prototype.setAngularDamping = h.prototype.lo, h.prototype.getPrev = h.prototype.um, h.prototype.getNext = h.prototype.gm, t.OIMO.RigidBodyConfig = function () {

		this.position = new dt(), this.rotation = new ft(), this.linearVelocity = new dt(), this.angularVelocity = new dt(), this.type = 0, this.autoSleep = ! 0, this.angularDamping = this.linearDamping = 0;

	}, t.OIMO.RigidBodyType = s, t.OIMO.Shape = i, i.prototype.getFriction = i.prototype.uc, i.prototype.setFriction = i.prototype.ue, i.prototype.getRestitution = i.prototype.Jc, i.prototype.setRestitution = i.prototype.Ve, i.prototype.getLocalTransform = i.prototype.Ac, i.prototype.getLocalTransformTo = i.prototype.Ec, i.prototype.getTransform = i.prototype.Yd, i.prototype.getTransformTo = i.prototype.pe, i.prototype.setLocalTransform = i.prototype.Ue, i.prototype.getDensity = i.prototype.qc, i.prototype.setDensity = i.prototype.te, i.prototype.getAabb = i.prototype.ua, i.prototype.getAabbTo = i.prototype.cb, i.prototype.getGeometry = i.prototype.vc, i.prototype.getRigidBody = i.prototype.Kc, i.prototype.getCollisionGroup = i.prototype.Hb, i.prototype.setCollisionGroup = i.prototype.qe, i.prototype.getCollisionMask = i.prototype.Mb, i.prototype.setCollisionMask = i.prototype.re, i.prototype.getContactCallback = i.prototype.pc, i.prototype.setContactCallback = i.prototype.se, i.prototype.getPrev = i.prototype.fd, i.prototype.getNext = i.prototype.Lc, t.OIMO.ShapeConfig = function () {

		this.position = new dt(), this.rotation = new ft(), this.friction = gt.defaultFriction, this.restitution = gt.defaultRestitution, this.density = gt.defaultDensity, this.collisionGroup = gt.defaultCollisionGroup, this.collisionMask = gt.defaultCollisionMask, this.contactCallback = this.geometry = null;

	};

}( S );

var OIMO = S.OIMO;

class Animation {

	start( data ) {

		return data;

	}

}

class Renderable {

	start( data ) {

		this.ref = data;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this.ref );

	}

	onDisable() {

		this.entity.remove( this.ref );

	}

}

class OrthographicCamera$1 extends OrthographicCamera {

	start( data ) {

		this._region = new Vector4();

		if ( 'left' in data ) this.left = data.left;
		if ( 'right' in data ) this.right = data.right;
		if ( 'top' in data ) this.top = data.top;
		if ( 'bottom' in data ) this.bottom = data.bottom;
		if ( 'near' in data ) this.near = data.near;
		if ( 'far' in data ) this.far = data.far;
		this.viewport =
			'viewport' in data ? data.viewport : new Vector4( 0, 0, 1, 1 );
		this._onResize( this.entity.scene.app.canvas );
		this.updateProjectionMatrix();

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.scene._cameras.push( this );
		this.entity.add( this );

	}

	onDisable() {

		this.entity.scene._cameras.splice(
			this.entity.scene._cameras.indexOf( this ),
			1
		);
		this.entity.remove( this );

	}

	_onResize( canvas ) {

		const view = this.viewport;
		this._region.set(
			canvas.width * view.x,
			canvas.height * view.y,
			canvas.width * view.z,
			canvas.height * view.w
		);

	}

}

class PerspectiveCamera$1 extends PerspectiveCamera {

	start( data ) {

		this._region = new Vector4();
		this.autoAspect = true;

		if ( 'fov' in data ) this.fov = data.fov;
		if ( 'near' in data ) this.near = data.near;
		if ( 'far' in data ) this.far = data.far;
		this.viewport =
			'viewport' in data ? data.viewport : new Vector4( 0, 0, 1, 1 );
		if ( 'aspect' in data ) this.aspect = data.aspect;

		this._onResize( this.entity.scene.app.canvas );

		if ( ! this.autoAspect ) this.updateProjectionMatrix();

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.scene._cameras.push( this );
		this.entity.add( this );

	}

	onDisable() {

		this.entity.scene._cameras.splice(
			this.entity.scene._cameras.indexOf( this ),
			1
		);
		this.entity.remove( this );

	}

	_onResize( canvas ) {

		const view = this.viewport;
		if ( this.autoAspect ) {

			this._aspect = ( canvas.width * view.z ) / ( canvas.height * view.w );
			this.updateProjectionMatrix();

		}

		this._region.set(
			canvas.width * view.x,
			canvas.height * view.y,
			canvas.width * view.z,
			canvas.height * view.w
		);

	}

	get aspect() {

		return this._aspect;

	}

	set aspect( x ) {

		this.autoAspect = false;
		this._aspect = x;

	}

}

class AmbientLight$1 extends AmbientLight {

	start( data ) {

		if ( 'color' in data ) this.color.setHex( data.color );
		if ( 'intensity' in data ) this.intensity = data.intensity;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this );

	}

	onDisable() {

		this.entity.remove( this );

	}

}

class DirectionalLight$1 extends DirectionalLight {

	start( data ) {

		if ( 'color' in data ) this.color.setHex( data.color );
		if ( 'intensity' in data ) this.intensity = data.intensity;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this );

	}

	onDisable() {

		this.entity.remove( this );

	}

}

class HemisphereLight$1 extends HemisphereLight {

	start( data ) {

		if ( 'color' in data ) this.color.setHex( data.color );
		if ( 'groundColor' in data ) this.groundColor.setHex( data.groundColor );
		if ( 'intensity' in data ) this.intensity = data.intensity;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this );

	}

	onDisable() {

		this.entity.remove( this );

	}

}

class PointLight$1 extends PointLight {

	start( data ) {

		if ( 'color' in data ) this.color.setHex( data.color );
		if ( 'intensity' in data ) this.intensity = data.intensity;
		if ( 'distance' in data ) this.distance = data.distance;
		if ( 'decay' in data ) this.decay = data.decay;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this );

	}

	onDisable() {

		this.entity.remove( this );

	}

}

class SpotLight$1 extends SpotLight {

	start( data ) {

		if ( 'color' in data ) this.color.setHex( data.color );
		if ( 'intensity' in data ) this.intensity = data.intensity;
		if ( 'distance' in data ) this.distance = data.distance;
		if ( 'angle' in data ) this.angle = data.angle;
		if ( 'penumbra' in data ) this.penumbra = data.penumbra;
		if ( 'decay' in data ) this.decay = data.decay;

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );

	}

	onEnable() {

		this.entity.add( this );

	}

	onDisable() {

		this.entity.remove( this );

	}

}

const vector = new Vector3();
const vector2 = new Vector3();
const quat = new Quaternion();
const quat2 = new Quaternion();
const matrix = new Matrix4();

class Physics {

	constructor() {

		this._accumulator = 0;
		this._gravity = new Vector3( 0, - 9.80665, 0 );

		this._triggers = [];

		this._world;
		this.rigidbodies;

	}
	get gravity() {

		return this._gravity;

	}
	set gravity( gravity ) {

		this._world.setGravity( gravity );
		this._gravity = gravity;

	}
	raycast( begin, end, callback ) {

		// callback parameters: collider, fraction, normal, position
		this._world.rayCast( begin, end, {
			process( shape, hit ) {

				callback(
					shape.collider,
					hit.fraction,
					new Vector3().copy( hit.normal ),
					new Vector3().copy( hit.position )
				);

			},
		} );

	}
	_update( deltaTime, fixedTimestep ) {

		this._accumulator += deltaTime;

		if ( this._accumulator >= fixedTimestep ) {

			// trigger collision
			// const triggers = this._triggers;
			// for (let i = 0, len = triggers.length; i < len; i++) {
			// 	const trigger = triggers[i];
			// }

			// time step
			while ( this._accumulator >= fixedTimestep ) {

				this._world.step( fixedTimestep );
				for ( let i = 0, len = this.rigidbodies.length; i < len; i ++ ) {

					let rigidbody = this.rigidbodies[ i ];
					if ( ! rigidbody._ref.isSleeping() ) {

						const entity = rigidbody.entity;

						const ePos = entity.position;
						const pos = rigidbody._ref.getPosition();
						ePos._x = pos.x;
						ePos._y = pos.y;
						ePos._z = pos.z;

						const eQuat = entity.quaternion;
						const rot = rigidbody._ref.getOrientation();
						eQuat._x = rot.x;
						eQuat._y = rot.y;
						eQuat._z = rot.z;
						eQuat._w = rot.w;

						if ( entity.parent !== entity.scene ) {

							vector
								.copy( ePos )
								.applyMatrix4(
									matrix
										.copy( entity.parent.matrixWorld )
										.invert()
								);
							ePos._x = vector.x;
							ePos._y = vector.y;
							ePos._z = vector.z;

							quat.copy( eQuat ).premultiply(
								entity.parent.getWorldQuaternion( quat2 ).invert()
							);
							eQuat._x = quat.x;
							eQuat._y = quat.y;
							eQuat._z = quat.z;
							eQuat._w = quat.w;

						}

					}

				}

				this._accumulator -= fixedTimestep;

			}
			// console.log("finish");

		}

	}

}

const quat$1 = new Quaternion();
const vector$1 = new Vector3();
const vector2$1 = new Vector3();
const massData = new OIMO.MassData();
const config = new OIMO.RigidBodyConfig();

class Rigidbody {

	start( data ) {

		if ( '_physicsRef' in this.entity ) this._ref = this.entity._physicsRef;
		else createRigidbody( this, 0 );

		if ( 'angularVelocity' in data )
			this.setAngularVelocity( data.angularVelocity );

		if ( 'angularDamping' in data )
			this._ref.setAngularDamping( data.angularDamping );

		if ( 'linearVelocity' in data )
			this.setLinearVelocity( data.linearVelocity );

		if ( 'linearDamping' in data )
			this._ref.setLinearDamping( data.linearDamping );

		this.autoSleep = 'autoSleep' in data ? data.autoSleep : true;
		this._ref.mass = 'mass' in data ? data.mass : 1;
		this._isKinematic = 'isKinematic' in data ? data.isKinematic : false;
		this.setRotationFactor(
			'rotationFactor' in data
				? data.rotationFactor
				: new Vector3( 1, 1, 1 )
		);

		if ( 'useGravity' in data && ! data.useGravity ) {

			this.gravityScale = 0;

		}

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );
		this.entity.addEventListener( 'scenechange', this.onSceneChange );

	}

	onEnable() {

		this.mass = this._ref.mass;
		if ( this._isKinematic ) this._ref.setType( 2 );
		else {

			this._ref.setType( 0 );
			this.mass = this._ref.mass;

		}

		if ( this._ref.getNumShapes() === 0 ) {

			this.entity.scene._physicsWorld.addRigidBody( this._ref );

		}

	}

	onDisable() {

		if ( this._ref.getNumShapes() > 0 ) {

			this._ref.setType( 1 );

		} else {

			this.entity.scene._physicsWorld.removeRigidBody( this._ref );

		}

	}

	onSceneChange( event ) {

		// need to test
		if ( this._enabled ) {

			event.oldScene._physicsWorld.removeRigidBody( this._ref );
			event.newScene._physicsWorld.addRigidBody( this._ref );

		}

	}

	addAngularVelocity( v ) {

		this._ref.addAngularVelocity( v );

	}
	addLinearVelocity( v ) {

		this._ref.addAngularVelocity( v );

	}
	applyAngularImpulse( v ) {

		this._ref.applyAngularImpulse( v );

	}
	applyForce( v, w ) {

		this._ref.applyForce( v, w );

	}
	applyForceToCenter( v ) {

		this._ref.applyForceToCenter( v );

	}
	applyImpulse( v, w ) {

		this._ref.applyImpulse( v, w );

	}
	applyLinearImpulse( v ) {

		this._ref.applyLinearImpulse( v );

	}
	applyTorque( v ) {

		this._ref.applyTorque( v );

	}
	get angularDamping() {

		return this._ref.getAngularDamping();

	}
	getAngularVelocity() {

		const vector = new Vector3();
		this._ref.getAngularVelocityTo( vector );
		return vector;

	}
	get gravityScale() {

		return this._ref.getGravityScale();

	}
	get linearDamping() {

		return this._ref.getLinearDamping();

	}
	getLinearVelocity() {

		const vector = new Vector3();
		this._ref.getLinearVelocityTo( vector );
		return vector;

	}
	get localInertia() {

		const v = this._ref.getLocalInertia();
		return new Matrix3().set(
			v.e00,
			v.e01,
			v.e02,
			v.e10,
			v.e11,
			v.e12,
			v.e20,
			v.e21,
			v.e22
		);

	}
	get mass() {

		return this._ref.mass;

	}
	get sleepTime() {

		return this._ref.getSleepTime();

	}
	get isKinematic() {

		return this.isKinematic;

	}
	set isKinematic( v ) {

		this._isKinematic = v;
		if ( v ) this._ref.setType( 2 );
		else {

			this._ref.setType( 0 );
			this.mass = this._ref.mass;

		}

	}
	get isSleeping() {

		return this._ref.isSleeping();

	}
	set isSleeping( sleep ) {

		if ( sleep ) {

			this._ref.sleep();

		} else {

			this._ref.wakeUp();

		}

	}
	rotate( v ) {

		this._ref.rotateXyz( v );

	}
	set angularDamping( v ) {

		this._ref.setAngularDamping( v );

	}
	setAngularVelocity( v ) {

		this._ref.setAngularVelocity( v );

	}
	get autoSleep() {

		return this._autoSleep;

	}
	set autoSleep( v ) {

		this._autoSleep = v;
		this._ref.setAutoSleep( v );

	}
	set gravityScale( v ) {

		this._ref.setGravityScale( v );

	}
	set linearDamping( v ) {

		this._ref.setLinearDamping( v );

	}
	setLinearVelocity( v ) {

		this._ref.setLinearVelocity( v );

	}
	set mass( mass ) {

		this._ref.mass = mass;
		this._ref.getMassDataTo( massData );
		massData.mass = mass;
		this._ref.setMassData( massData );

	}
	getRotationFactor() {

		return this._rotationFactor;

	}
	setRotationFactor( vector ) {

		this._rotationFactor = vector;
		this._ref.setRotationFactor( vector );

	}

}

const posProps = {
	_x: { value: 0, writable: true },
	_y: { value: 0, writable: true },
	_z: { value: 0, writable: true },
	x: {
		get() {

			return this._x;

		},
		set( value ) {

			this._x = value;
			this._entity.getWorldPosition( vector$1 );
			this._entity._physicsRef.setPosition( vector$1 );

		},
	},
	y: {
		get() {

			return this._y;

		},
		set( value ) {

			this._y = value;
			this._entity.getWorldPosition( vector$1 );
			this._entity._physicsRef.setPosition( vector$1 );

		},
	},
	z: {
		get() {

			return this._z;

		},
		set( value ) {

			this._z = value;
			this._entity.getWorldPosition( vector$1 );
			this._entity._physicsRef.setPosition( vector$1 );

		},
	},
};

function onQuaternionChange() {

	this._rotation.setFromQuaternion( this, undefined, false );
	this._entity.getWorldQuaternion( quat$1 );
	this._entity._physicsRef.setOrientation( quat$1 );

}

function onRotationChange() {

	this._quaternion.setFromEuler( this, false );
	this._entity.getWorldQuaternion( quat$1 );
	this._entity._physicsRef.setOrientation( quat$1 );

}

function createRigidbody( self, type ) {

	const entity = self.entity;
	entity.updateWorldMatrix();
	entity.matrixWorld.decompose( vector$1, quat$1, vector2$1 );
	config.position = vector$1;
	config.rotation.fromQuat( quat$1 );
	config.type = type;
	entity._physicsRef = self._ref = new OIMO.RigidBody( config );
	self._ref.component = self;
	self._ref.entity = entity;

	const position = entity.position;
	position._entity = entity;
	posProps._x.value = position.x;
	posProps._y.value = position.y;
	posProps._z.value = position.z;
	Object.defineProperties( position, posProps );

	const quaternion = entity.quaternion;
	const rotation = entity.rotation;

	quaternion._rotation = rotation;
	rotation._quaternion = quaternion;
	rotation._entity = quaternion._entity = entity;
	quaternion._onChange( onQuaternionChange );
	rotation._onChange( onRotationChange );

}

var ConvexHull = function () {

	function a() {

		this.tolerance = - 1, this.faces = [], this.newFaces = [], this.assigned = new g(), this.unassigned = new g(), this.vertices = [];

	}

	function d() {

		this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = 0, this.edge = null;

	}

	function e( a, b ) {

		this.vertex = a, this.prev = null, this.next = null, this.twin = null, this.face = b;

	}

	function f( a ) {

		this.point = a, this.prev = null, this.next = null, this.face = null;

	}

	function g() {

		this.head = null, this.tail = null;

	}

	var h = new Vector3(); return Object.assign( a.prototype, { setFromPoints: function ( a ) {

		! 0 !== Array.isArray( a ) && console.error( 'THREE.ConvexHull: Points parameter is not an array.' ), 4 > a.length && console.error( 'THREE.ConvexHull: The algorithm needs at least four points.' ), this.makeEmpty(); for ( var b = 0, c = a.length; b < c; b ++ ) this.vertices.push( new f( a[ b ] ) ); return this.compute(), this;

	}, setFromObject: function ( a ) {

		var b = []; return a.updateMatrixWorld( ! 0 ), a.traverse( function ( a ) {

			var c, d, e, f = a.geometry; if ( void 0 !== f ) if ( f.isGeometry ) {

				var g = f.vertices; for ( c = 0, d = g.length; c < d; c ++ )e = g[ c ].clone(), e.applyMatrix4( a.matrixWorld ), b.push( e );

			} else if ( f.isBufferGeometry ) {

				var h = f.attributes.position; if ( void 0 !== h ) for ( c = 0, d = h.count; c < d; c ++ )e = new Vector3(), e.fromBufferAttribute( h, c ).applyMatrix4( a.matrixWorld ), b.push( e );

			}

		} ), this.setFromPoints( b );

	}, containsPoint: function ( a ) {

		for ( var b, c = this.faces, d = 0, e = c.length; d < e; d ++ ) if ( b = c[ d ], b.distanceToPoint( a ) > this.tolerance ) return ! 1; return ! 0;

	}, intersectRay: function ( a, b ) {

		for ( var c = this.faces, d = - Infinity, e = 1 / 0, f = 0, g = c.length; f < g; f ++ ) {

			var h = c[ f ], j = h.distanceToPoint( a.origin ), k = h.normal.dot( a.direction ); if ( 0 < j && 0 <= k ) return null; var l = 0 === k ? 0 : - j / k; if ( ! ( 0 >= l ) && ( 0 < k ? e = Math.min( l, e ) : d = Math.max( l, d ), d > e ) ) return null;

		}

		return d === - Infinity ? a.at( e, b ) : a.at( d, b ), b;

	}, intersectsRay: function ( a ) {

		return null !== this.intersectRay( a, h );

	}, makeEmpty: function () {

		return this.faces = [], this.vertices = [], this;

	}, addVertexToFace: function ( a, b ) {

		return a.face = b, null === b.outside ? this.assigned.append( a ) : this.assigned.insertBefore( b.outside, a ), b.outside = a, this;

	}, removeVertexFromFace: function ( a, b ) {

		return a === b.outside && ( null !== a.next && a.next.face === b ? b.outside = a.next : b.outside = null ), this.assigned.remove( a ), this;

	}, removeAllVerticesFromFace: function ( a ) {

		if ( null !== a.outside ) {

			for ( var b = a.outside, c = a.outside; null !== c.next && c.next.face === a; )c = c.next; return this.assigned.removeSubList( b, c ), b.prev = c.next = null, a.outside = null, b;

		}

	}, deleteFaceVertices: function ( a, b ) {

		var c = this.removeAllVerticesFromFace( a ); if ( void 0 !== c ) if ( void 0 === b ) this.unassigned.appendChain( c ); else {

			var d = c; do {

				var e = d.next, f = b.distanceToPoint( d.point ); f > this.tolerance ? this.addVertexToFace( d, b ) : this.unassigned.append( d ), d = e;

			} while ( null !== d );

		}

		return this;

	}, resolveUnassignedPoints: function ( a ) {

		if ( ! 1 === this.unassigned.isEmpty() ) {

			var b = this.unassigned.first(); do {

				for ( var c, d = b.next, e = this.tolerance, f = null, g = 0; g < a.length; g ++ ) if ( c = a[ g ], 0 === c.mark ) {

					var h = c.distanceToPoint( b.point ); if ( h > e && ( e = h, f = c ), e > 1e3 * this.tolerance ) break;

				}

				null !== f && this.addVertexToFace( b, f ), b = d;

			} while ( null !== b );

		}

		return this;

	}, computeExtremes: function () {

		var a, b, c, d = new Vector3(), e = new Vector3(), f = [], g = []; for ( a = 0; 3 > a; a ++ )f[ a ] = g[ a ] = this.vertices[ 0 ]; for ( d.copy( this.vertices[ 0 ].point ), e.copy( this.vertices[ 0 ].point ), ( a = 0, b = this.vertices.length ); a < b; a ++ ) {

			var h = this.vertices[ a ], k = h.point; for ( c = 0; 3 > c; c ++ )k.getComponent( c ) < d.getComponent( c ) && ( d.setComponent( c, k.getComponent( c ) ), f[ c ] = h ); for ( c = 0; 3 > c; c ++ )k.getComponent( c ) > e.getComponent( c ) && ( e.setComponent( c, k.getComponent( c ) ), g[ c ] = h );

		}

		return this.tolerance = 3 * Number.EPSILON * ( Math.max( Math.abs( d.x ), Math.abs( e.x ) ) + Math.max( Math.abs( d.y ), Math.abs( e.y ) ) + Math.max( Math.abs( d.z ), Math.abs( e.z ) ) ), { min: f, max: g };

	}, computeInitialHull: function () {

		var a, b, c; return function () {

			void 0 === a && ( a = new Line3(), b = new Plane(), c = new Vector3() ); var e, f, g, h, k, m, n, o, p, q = this.vertices, r = this.computeExtremes(), s = r.min, t = r.max, u = 0, v = 0; for ( m = 0; 3 > m; m ++ )p = t[ m ].point.getComponent( m ) - s[ m ].point.getComponent( m ), p > u && ( u = p, v = m ); for ( f = s[ v ], g = t[ v ], u = 0, a.set( f.point, g.point ), ( m = 0, n = this.vertices.length ); m < n; m ++ )e = q[ m ], e !== f && e !== g && ( a.closestPointToPoint( e.point, ! 0, c ), p = c.distanceToSquared( e.point ), p > u && ( u = p, h = e ) ); for ( u = - 1, b.setFromCoplanarPoints( f.point, g.point, h.point ), ( m = 0, n = this.vertices.length ); m < n; m ++ )e = q[ m ], e !== f && e !== g && e !== h && ( p = Math.abs( b.distanceToPoint( e.point ) ), p > u && ( u = p, k = e ) ); var w = []; if ( 0 > b.distanceToPoint( k.point ) ) for ( w.push( d.create( f, g, h ), d.create( k, g, f ), d.create( k, h, g ), d.create( k, f, h ) ), m = 0; 3 > m; m ++ )o = ( m + 1 ) % 3, w[ m + 1 ].getEdge( 2 ).setTwin( w[ 0 ].getEdge( o ) ), w[ m + 1 ].getEdge( 1 ).setTwin( w[ o + 1 ].getEdge( 0 ) ); else for ( w.push( d.create( f, h, g ), d.create( k, f, g ), d.create( k, g, h ), d.create( k, h, f ) ), m = 0; 3 > m; m ++ )o = ( m + 1 ) % 3, w[ m + 1 ].getEdge( 2 ).setTwin( w[ 0 ].getEdge( ( 3 - m ) % 3 ) ), w[ m + 1 ].getEdge( 0 ).setTwin( w[ o + 1 ].getEdge( 1 ) ); for ( m = 0; 4 > m; m ++ ) this.faces.push( w[ m ] ); for ( m = 0, n = q.length; m < n; m ++ ) if ( e = q[ m ], e !== f && e !== g && e !== h && e !== k ) {

				u = this.tolerance; var x = null; for ( o = 0; 4 > o; o ++ )p = this.faces[ o ].distanceToPoint( e.point ), p > u && ( u = p, x = this.faces[ o ] ); null !== x && this.addVertexToFace( e, x );

			}

			return this;

		};

	}(), reindexFaces: function () {

		for ( var a, b = [], c = 0; c < this.faces.length; c ++ )a = this.faces[ c ], 0 === a.mark && b.push( a ); return this.faces = b, this;

	}, nextVertexToAdd: function () {

		if ( ! 1 === this.assigned.isEmpty() ) {

			var a, b = 0, c = this.assigned.first().face, d = c.outside; do {

				var e = c.distanceToPoint( d.point ); e > b && ( b = e, a = d ), d = d.next;

			} while ( null !== d && d.face === c );

			return a;

		}

	}, computeHorizon: function ( a, b, c, d ) {

		this.deleteFaceVertices( c ), c.mark = 1; var e = null === b ? b = c.getEdge( 0 ) : b.next; do {

			var f = e.twin, g = f.face; 0 === g.mark && ( g.distanceToPoint( a ) > this.tolerance ? this.computeHorizon( a, f, g, d ) : d.push( e ) ), e = e.next;

		} while ( e !== b );

		return this;

	}, addAdjoiningFace: function ( a, b ) {

		var c = d.create( a, b.tail(), b.head() ); return this.faces.push( c ), c.getEdge( - 1 ).setTwin( b.twin ), c.getEdge( 0 );

	}, addNewFaces: function ( a, b ) {

		this.newFaces = []; for ( var c = null, d = null, e = 0; e < b.length; e ++ ) {

			var f = b[ e ], g = this.addAdjoiningFace( a, f ); null === c ? c = g : g.next.setTwin( d ), this.newFaces.push( g.face ), d = g;

		}

		return c.next.setTwin( d ), this;

	}, addVertexToHull: function ( a ) {

		var b = []; return this.unassigned.clear(), this.removeVertexFromFace( a, a.face ), this.computeHorizon( a.point, null, a.face, b ), this.addNewFaces( a, b ), this.resolveUnassignedPoints( this.newFaces ), this;

	}, cleanup: function () {

		return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;

	}, compute: function () {

		var a; for ( this.computeInitialHull(); void 0 !== ( a = this.nextVertexToAdd() ); ) this.addVertexToHull( a ); return this.reindexFaces(), this.cleanup(), this;

	} } ), Object.assign( d, { create: function ( f, a, b ) {

		var c = new d(), g = new e( f, c ), h = new e( a, c ), i = new e( b, c ); return g.next = i.prev = h, h.next = g.prev = i, i.next = h.prev = g, c.edge = g, c.compute();

	} } ), Object.assign( d.prototype, { getEdge: function ( a ) {

		for ( var b = this.edge; 0 < a; )b = b.next, a --; for ( ;0 > a; )b = b.prev, a ++; return b;

	}, compute: function () {

		var d; return function () {

			void 0 === d && ( d = new Triangle() ); var e = this.edge.tail(), a = this.edge.head(), b = this.edge.next.head(); return d.set( e.point, a.point, b.point ), d.getNormal( this.normal ), d.getMidpoint( this.midpoint ), this.area = d.getArea(), this.constant = this.normal.dot( this.midpoint ), this;

		};

	}(), distanceToPoint: function ( a ) {

		return this.normal.dot( a ) - this.constant;

	} } ), Object.assign( e.prototype, { head: function () {

		return this.vertex;

	}, tail: function () {

		return this.prev ? this.prev.vertex : null;

	}, length: function () {

		var a = this.head(), b = this.tail(); return null === b ? - 1 : b.point.distanceTo( a.point );

	}, lengthSquared: function () {

		var a = this.head(), b = this.tail(); return null === b ? - 1 : b.point.distanceToSquared( a.point );

	}, setTwin: function ( a ) {

		return this.twin = a, a.twin = this, this;

	} } ), Object.assign( g.prototype, { first: function () {

		return this.head;

	}, last: function () {

		return this.tail;

	}, clear: function () {

		return this.head = this.tail = null, this;

	}, insertBefore: function ( a, b ) {

		return b.prev = a.prev, b.next = a, null === b.prev ? this.head = b : b.prev.next = b, a.prev = b, this;

	}, insertAfter: function ( a, b ) {

		return b.prev = a, b.next = a.next, null === b.next ? this.tail = b : b.next.prev = b, a.next = b, this;

	}, append: function ( a ) {

		return null === this.head ? this.head = a : this.tail.next = a, a.prev = this.tail, a.next = null, this.tail = a, this;

	}, appendChain: function ( a ) {

		for ( null === this.head ? this.head = a : this.tail.next = a, a.prev = this.tail; null !== a.next; )a = a.next; return this.tail = a, this;

	}, remove: function ( a ) {

		return null === a.prev ? this.head = a.next : a.prev.next = a.next, null === a.next ? this.tail = a.prev : a.next.prev = a.prev, this;

	}, removeSubList: function ( c, a ) {

		return null === c.prev ? this.head = a.next : c.prev.next = a.next, null === a.next ? this.tail = c.prev : a.next.prev = c.prev, this;

	}, isEmpty: function () {

		return null === this.head;

	} } ), a;

}();

const vector$2 = new Vector3();
const convexHull = new ConvexHull();
const massData$1 = new OIMO.MassData();
const transform = new OIMO.Transform();
const shapeConfig = new OIMO.ShapeConfig();
shapeConfig.contactCallback = {
	beginContact: ( c ) => contactCallback( c, 'collisionenter' ),
	preSolve: ( c ) => contactCallback( c, 'collisionpresolve' ),
	postSolve: ( c ) => contactCallback( c, 'collisionpostsolve' ),
	endContact: ( c ) => contactCallback( c, 'collisionend' ),
};
const config$1 = new OIMO.RigidBodyConfig();
config$1.type = 1;

const props = {
	_x: { value: 0, writable: true },
	_y: { value: 0, writable: true },
	_z: { value: 0, writable: true },
	x: {
		get() {

			return this._x;

		},
		set( value ) {

			this._x = value;
			const colliders = this._colliders;
			for ( let i = 0, len = colliders.length; i < len; i ++ ) {

				colliders[ i ]._setShape();

			}

		},
	},
	y: {
		get() {

			return this._y;

		},
		set( value ) {

			this._y = value;
			const colliders = this._colliders;
			for ( let i = 0, len = colliders.length; i < len; i ++ ) {

				colliders[ i ]._setShape();

			}

		},
	},
	z: {
		get() {

			return this._z;

		},
		set( value ) {

			this._z = value;
			const colliders = this._colliders;
			for ( let i = 0, len = colliders.length; i < len; i ++ ) {

				colliders[ i ]._setShape();

			}

		},
	},
};

class Collider {

	start( data ) {

		this._isTrigger = 'isTrigger' in data ? data.isTrigger : false;
		this._collisionGroup =
			'collisionGroup' in data ? data.collisionGroup : 1;
		this._collisionMask = 'collisionMask' in data ? data.collisionMask : 1;
		this._center = 'center' in data ? data.center : new Vector3( 0, 0, 0 );
		this._rotation = 'rotation' in data ? data.center : new Euler( 0, 0, 0 );
		switch ( this.type ) {

			case 'box':
				// box
				this._halfExtents =
					'halfExtents' in data
						? data.halfExtents
						: new Vector( 1, 1, 1 );
			case 'sphere':
				this._radius = 'radius' in data ? data.radius : 0.5;
				break;
			case 'capsule':
			case 'cone':
			case 'cylinder':
				this._radius = 'radius' in data ? data.radius : 0.5;
				this._halfHeight = 'halfHeight' in data ? data.halfHeight : 1;

				break;
			case 'mesh':
				this._mesh = 'mesh' in data ? data.mesh : null;

		}

		if ( 'material' in data ) this._material = data.material;
		this._setShape();

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );
		this.entity.addEventListener( 'scenechange', this.onSceneChange );

	}

	onEnable() {

		if ( this._isTrigger ) {

			this.entity.scene.app.physics._triggers.push(
				this._shapeRef.getGeometry()
			);

		} else {

			if ( '_physicsRef' in this.entity ) {

				const ref = this.entity._physicsRef;
				this._ref = ref;
				if ( ! ref.component._enabled ) {

					this.entity.scene._physicsWorld.addRigidBody( this._ref );

				}

			} else {

				createRigidbody( this, 1 );
				this.entity.scene._physicsWorld.addRigidBody( this._ref );

			}

			this._ref.addShape( this._shapeRef );
			if ( this._ref.getType() === 0 ) {

				this._ref.getMassDataTo( massData$1 );
				massData$1.mass = this._ref.mass;
				this._ref.setMassData( massData$1 );

			}

		}

		const scale = this.entity.scale;
		if ( '_colliders' in scale ) {

			scale._colliders.push( this );

		} else {

			scale._colliders = [ this ];
			props._x.value = scale.x;
			props._y.value = scale.y;
			props._z.value = scale.z;
			Object.defineProperties( this.entity.scale, props );

		}

	}

	onDisable() {

		if ( this._isTrigger ) {

			const triggers = this.entity.scene.app.physics._triggers;
			triggers.splice( triggers.indexOf( this._shapeRef.getGeometry() ), 1 );

		} else {

			this._ref.removeShape( this._shapeRef );
			if ( this._ref.getType() === 0 ) {

				this._ref.getMassDataTo( massData$1 );
				massData$1.mass = this._ref.mass;
				this._ref.setMassData( massData$1 );

			}

			if ( this._ref.getNumShapes() === 0 && this._ref.getType() === 1 ) {

				this.entity.scene._physicsWorld.removeRigidBody( this._ref );

			}

			delete this._ref;
			const scale = this.entity.scale;
			if ( scale.colliders.length === 1 ) {

				Object.defineProperty( this.entity, 'scale', {
					value: new Vector3().copy( scale ),
				} );

			} else {

				scale.colliders.splice( scale.colliders.indexOf( this ), 1 );

			}

		}

	}

	onSceneChange( event ) {

		// need to test
		if ( this._enabled ) {

			if ( this._isTrigger ) {

				const oldTriggers = event.oldScene.app.physics._triggers;
				oldTriggers.splice(
					oldTriggers.indexOf( this._shapeRef.getGeometry() ),
					1
				);
				event.newScene.app.physics._triggers.push(
					this._shapeRef.getGeometry()
				);

			} else {

				this._ref.removeShape( this._shapeRef );
				if (
					this._ref.getNumShapes() === 0 &&
					this._ref.getType() === 1
				) {

					event.oldScene._physicsWorld.removeRigidBody( this._ref );
					event.newScene._physicsWorld.addRigidBody( this._ref );

				}

			}

		}

	}

	_setShape() {

		let geometry;
		const scale = this.entity.scale;
		const max = Math.max( scale.x, scale.y, scale.z );
		switch ( this.type ) {

			case 'box':
				geometry = new OIMO.BoxGeometry(
					vector$2.copy( this._halfExtents ).multiply( scale )
				);
				break;
			case 'sphere':
				geometry = new OIMO.SphereGeometry( this._radius * max );
				break;
			case 'capsule':
				geometry = new OIMO.CapsuleGeometry(
					this._radius * max,
					this._halfHeight * max
				);
				break;
			case 'cone':
				geometry = new OIMO.ConeGeometry(
					this._radius * max,
					this._halfHeight * max
				);
				break;
			case 'cylinder':
				geometry = new OIMO.CylinderGeometry(
					this._radius * max,
					this._halfHeight * max
				);
				break;
			case 'mesh':
				let vertices = [];
				if ( this._mesh !== null ) {

					vertices = convexHull.setFromObject( this._mesh ).vertices;
					for ( let i = 0, len = vertices.length; i < len; i ++ ) {

						vertices[ i ] = vertices[ i ].point.multiply( scale );

					}

				}

				geometry = new OIMO.ConvexHullGeometry( vertices );

		}

		shapeConfig.geometry = geometry;
		shapeConfig.collisionGroup = this._collisionGroup;
		shapeConfig.collisionMask = this._collisionMask;
		shapeConfig.position = this._center;
		shapeConfig.rotation.fromEulerXyz( this._rotation );

		if ( '_shapeRef' in this && this._enabled ) {

			if ( this._isTrigger ) {

				const triggers = this.entity.scene.app.physics._triggers;
				triggers.splice(
					triggers.indexOf( this._shapeRef.getGeometry() ),
					1
				);
				this._shapeRef = new OIMO.Shape( shapeConfig );
				triggers.push( this._shapeRef.getGeometry() );

			} else {

				this._ref.removeShape( this._shapeRef );
				this._shapeRef = new OIMO.Shape( shapeConfig );
				this._ref.addShape( this._shapeRef );

			}

		} else {

			this._shapeRef = new OIMO.Shape( shapeConfig );

		}

		this._shapeRef.entity = this.entity;
		this._shapeRef.collider = this;

		if ( '_material' in this ) this.material = this._material;

	}

	get isTrigger() {

		return this._isTrigger;

	}

	set isTrigger( isTrigger ) {

		this.onDisable();
		this._isTrigger = isTrigger;
		this.onEnable();

	}

	get center() {

		return this._center;

	}

	set center( center ) {

		this._center = center;
		this._shapeRef.getLocalTransformTo( transform );
		transform.setPosition( center );
		this._shapeRef.setLocalTransform( transform );

	}

	get rotation() {

		return this._rotation;

	}

	set rotation( rotation ) {

		this._rotation = rotation;
		this._shapeRef.getLocalTransformTo( transform );
		transform.setRotationXyz( rotation );
		this._shapeRef.setLocalTransform( transform );

	}

	get material() {

		return this._material;

	}

	set material( material ) {

		if ( material === null ) {

			this._shapeRef.setFriction( 0.2 );
			this._shapeRef.setRestitution( 0.2 );

		}

		if ( '_material' in this ) {

			const colliders = this._material._colliders;
			colliders.splice( colliders.indexOf( this._shapeRef ), 1 );

		}

		material._colliders.push( this._shapeRef );
		this._shapeRef.setFriction( material._friction );
		this._shapeRef.setRestitution( material._restitution );
		this._material = material;

	}

	get volume() {

		return this._shapeRef.getGeometry().getVolume();

	}

	get mesh() {

		return this._mesh;

	}

	set mesh( v ) {

		this._mesh = v;
		this._setShape();

	}

	get halfExtents() {

		return this._halfHeight;

	}

	get halfHeight() {

		return this._halfHeight;

	}

	get radius() {

		return this._radius;

	}

	set halfExtents( v ) {

		this._halfExtents = v;
		this._setShape();

	}

	set halfHeight( v ) {

		this._halfHeight = v;
		this._setShape();

	}

	set radius( v ) {

		this.setShape( {
			type: this.type,
			radius: v,
			collisionGroup: this.collisionGroup,
			collisionMask: this.collisionMask,
			material: this.material,
		} );

	}

	get bounds() {

		const aabb = this._shapeRef.getAabb();
		return {
			min: aabb.getMin(),
			max: aabb.getMax(),
		};

	}

	get collisionGroup() {

		return this._collisionGroup;

	}

	get collisionMask() {

		return this._collisionMask;

	}

	set collisionGroup( v ) {

		this._collisionGroup = v;
		this._shapeRef.setCollisionGroup( v );

	}

	set collisionMask( v ) {

		this._collisionMask = v;
		this._shapeRef.setCollisionMask( v );

	}

}

function contactCallback( contact, type ) {

	const constraint = contact.getContactConstraint();
	const entity1 = constraint.getShape1().entity;
	const entity2 = constraint.getShape2().entity;

	const has1 = entity1.hasEventListener( type, contactCallback );
	const has2 = entity2.hasEventListener( type, contactCallback );

	if ( has1 || has2 ) {

		const collider1 = constraint.getShape1().collider;
		const collider2 = constraint.getShape2().collider;

		const binormal = new Vector3();
		const normal = new Vector3();
		const tangent = new Vector3();
		const manifold = contact.getManifold();
		manifold.getBinormalTo( binormal );
		manifold.getNormalTo( normal );
		manifold.getTangentTo( tangent );

		const contacts = manifold.getPoints();
		for ( let i = 0, len = contacts.length; i < len; i ++ ) {

			const point = new Vector3();
			const contact = contacts[ i ];
			contact.getPosition1To( point );

			contact.binormalImpulse = contact.getBinormalImpulse();
			contact.depthImpulse = contact.getDepth();
			contact.normalImpulse = contact.getNormalImpulse();
			contact.tangentImpulse = contact.getTangentImpulse();
			contact.point = point;

		}

		const obj = {
			type,
			entity: entity2,
			thisCollider: collider1,
			otherCollider: collider2,
			binormal,
			normal,
			tangent,
			contacts,
		};
		if ( has1 && has2 ) {

			entity1.dispatchEvent( obj );
			obj.entity = entity1;
			obj.thisCollider = collider2;
			obj.thisCollider = collider1;
			entity2.dispatchEvent( obj );

		} else if ( has1 ) {

			entity1.dispatchEvent( obj );

		} else {

			obj.entity = entity1;
			obj.thisCollider = collider2;
			obj.thisCollider = collider1;
			entity2.dispatchEvent( obj );

		}

	}

}

class BoxCollider extends Collider {

	start( data ) {

		this.type = 'box';
		super.start( data );

	}

}

class CapsuleCollider extends Collider {

	start( data ) {

		this.type = 'capsule';
		super.start( data );

	}

}

class ConeCollider extends Collider {

	start( data ) {

		this.type = 'cone';
		super.start( data );

	}

}

class CylinderCollider extends Collider {

	start( data ) {

		this.type = 'cylinder';
		super.start( data );

	}

}

class MeshCollider extends Collider {

	start( data ) {

		this.type = 'mesh';
		super.start( data );

	}

}

class SphereCollider extends Collider {

	start( data ) {

		this.type = 'sphere';
		super.start( data );

	}

}

class AngularLimit {

	constructor( lowerLimit = 1, upperLimit = 0, targetSpeed, maxTorque = 0 ) {

		this.lowerLimit = lowerLimit;
		this.upperLimit = upperLimit;
		this.motorSpeed = targetSpeed;
		this.motorTorque = maxTorque;

	}
	get targetSpeed() {

		return this.motorSpeed;

	}
	set targetSpeed( targetSpeed ) {

		this.motorSpeed = targetSpeed;

	}
	get maxTorque() {

		return this.motorTorque;

	}
	set maxTorque( maxTorque ) {

		this.motorTorque = maxTorque;

	}

	set( lowerLimit = 1, upperLimit = 0, targetSpeed, maxTorque = 0 ) {

		this.lowerLimit = lowerLimit;
		this.upperLimit = upperLimit;
		this.motorSpeed = targetSpeed;
		this.motorTorque = maxTorque;

	}

	clone() {

		return this;

	}

}

class LinearLimit {

	constructor( lowerLimit = 0, upperLimit = 0, targetSpeed, maxForce = 0 ) {

		this.lowerLimit = lowerLimit;
		this.upperLimit = upperLimit;
		this.motorSpeed = targetSpeed;
		this.motorForce = maxForce;

	}
	get targetSpeed() {

		return this.motorSpeed;

	}
	set targetSpeed( targetSpeed ) {

		this.motorSpeed = targetSpeed;

	}
	get maxForce() {

		return this.motorForce;

	}
	set maxForce( maxForce ) {

		this.motorForce = maxForce;

	}

	set( lowerLimit = 0, upperLimit = 0, targetSpeed, maxForce = 0 ) {

		this.lowerLimit = lowerLimit;
		this.upperLimit = upperLimit;
		this.motorSpeed = targetSpeed;
		this.motorForce = maxForce;

	}

	clone() {

		return this;

	}

}

class SpringDamper {

	constructor( frequency = 0, damping = 0 ) {

		this.frequency = frequency;
		this.dampingRatio = damping;
		this.useSymplecticEuler = false;

	}

	get damping() {

		return this.dampingRatio;

	}

	set damping( damping ) {

		this.dampingRatio = damping;

	}

	set( frequency = 0, damping = 0 ) {

		this.frequency = frequency;
		this.dampingRatio = damping;

	}

	clone() {

		return this;

	}

}

const configs = {
	cylindrical: new OIMO.CylindricalJointConfig(),
	prismatic: new OIMO.PrismaticJointConfig(),
	ragdoll: new OIMO.RagdollJointConfig(),
	hinge: new OIMO.RevoluteJointConfig(),
	ball: new OIMO.SphericalJointConfig(),
	universal: new OIMO.UniversalJointConfig(),
};

const rigidbodyConfig = new OIMO.RigidBodyConfig();
rigidbodyConfig.type = 1;
const worldBody = new OIMO.RigidBody( rigidbodyConfig );

class Joint {

	start( data ) {

		const type = this.type;

		configs[ type ].rigidBody1 = this.entity._physicsRef;
		this._bodyRef2 =
			'linkedEntity' in data && data.linkedEntity !== null
				? data.linkedEntity._physicsRef
				: worldBody;
		this._allowCollision = data.allowCollision === true;
		this._breakForce =
			'breakForce' in data && data.breakForce !== 0 ? data.breakForce : 0;
		this._breakTorque =
			'breakTorque' in data && data.breakTorque !== 0
				? data.breakTorque
				: 0;
		this._anchor = 'anchor' in data ? data.anchor : new Vector3();
		this._linkedAnchor =
			'linkedAnchor' in data ? data.linkedAnchor : new Vector3();

		switch ( type ) {

			case 'universal':
			case 'cylindrical':
			case 'prismatic':
			case 'hinge':
				this._axis = 'axis' in data ? data.axis : new Vector3( 1, 0, 0 );
				this._linkedAxis =
					'axis' in data ? data.linkedAxis : new Vector3( 1, 0, 0 );

		}

		switch ( type ) {

			case 'universal':
			case 'prismatic':
			case 'hinge':
			case 'ball':
				Object.defineProperty( this, 'springDamper', {
					value:
						'springDamper' in data
							? data.springDamper
							: new SpringDamper(),
				} );

		}

		switch ( type ) {

			case 'universal':
				Object.defineProperties( this, {
					linkedSpringDamper: {
						value:
							'linkedSpringDamper' in data
								? data.linkedSpringDamper
								: new SpringDamper(),
					},
					angularLimit: {
						value:
							'angularLimit' in data
								? data.angularLimit
								: new AngularLimit(),
					},
					linkedAngularLimit: {
						value:
							'linkedAngularLimit' in data
								? data.linkedAngularLimit
								: new AngularLimit(),
					},
				} );
				break;
			case 'cylindrical':
				Object.defineProperties( this, {
					linearLimit: {
						value:
							'linearLimit' in data
								? data.linearLimit
								: new LinearLimit(),
					},
					linearSpringDamper: {
						value:
							'linearSpringDamper' in data
								? data.linearSpringDamper
								: new SpringDamper(),
					},
					angularLimit: {
						value:
							'angularLimit' in data
								? data.angularLimit
								: new AngularLimit(),
					},
					angularSpringDamper: {
						value:
							'angularSpringDamper' in data
								? data.angularSpringDamper
								: new SpringDamper(),
					},
				} );
				break;
			case 'prismatic':
				Object.defineProperty( this, 'linearLimit', {
					value:
						'linearLimit' in data
							? data.linearLimit
							: new LinearLimit(),
				} );
				break;
			case 'ragdoll':
				this._twistAxis =
					'twistAxis' in data ? data.twistAxis : new Vector3( 1, 0, 0 );
				this._linkedTwistAxis =
					'linkedTwistAxis' in data
						? data.linkedTwistAxis
						: new Vector3( 1, 0, 0 );
				this._swingAxis =
					'swingAxis' in data ? data.swingAxis : new Vector3( 0, 1, 0 );
				this._maxSwing = 'maxSwing' in data ? data.maxSwing : Math.PI;
				this._linkedMaxSwing =
					'linkedMaxSwing' in data ? data.linkedMaxSwing : Math.PI;
				Object.defineProperties( this, {
					twistSpringDamper: {
						value:
							'twistSpringDamper' in data
								? data.twistSpringDamper
								: new SpringDamper(),
					},
					swingSpringDamper: {
						value:
							'swingSpringDamper' in data
								? data.swingSpringDamper
								: new SpringDamper(),
					},
					twistLimit: {
						value:
							'twistLimit' in data
								? data.twistLimit
								: new AngularLimit(),
					},
				} );
				break;
			case 'hinge':
				Object.defineProperty( this, 'angularLimit', {
					value:
						'angularLimit' in data
							? data.angularLimit
							: new AngularLimit(),
				} );
				break;

		}

		this._setJoint();

		this.addEventListener( 'enable', this.onEnable );
		this.addEventListener( 'disable', this.onDisable );
		this.entity.addEventListener( 'scenechange', this.onSceneChange );

	}

	onEnable() {

		this.entity.scene._physicsWorld.addJoint( this._ref );

	}

	onDisable() {

		this.entity.scene._physicsWorld.removeJoint( this._ref );

	}

	onSceneChange( event ) {

		// need to test
		if ( this._enabled ) {

			event.oldScene._physicsWorld.removeJoint( this._ref );
			event.newScene._physicsWorld.addJoint( this._ref );

		}

	}

	_setJoint() {

		let enable = false;
		const type = this.type;
		const config = configs[ type ];
		config.allowCollision = this._allowCollision;
		config.breakForce = this._breakForce;
		config.breakTorque = this._breakTorque;
		config.localAnchor1 = this._anchor;
		config.localAnchor2 = this._linkedAnchor;
		config.rigidBody2 = this._bodyRef2;
		if ( this._ref !== undefined && this._enabled ) {

			this.entity.scene._physicsWorld.removeJoint( this._ref );
			enable = true;

		}

		switch ( type ) {

			case 'universal':
			case 'cylindrical':
			case 'prismatic':
			case 'hinge':
				config.localAxis1 = this._axis;
				config.localAxis2 = this._linkedAxis;
				break;

		}

		switch ( type ) {

			case 'prismatic':
			case 'hinge':
			case 'ball':
				config.springDamper = this.springDamper;

		}

		switch ( type ) {

			case 'universal':
				config.springDamper1 = this.springDamper;
				config.springDamper2 = this.linkedSpringDamper;
				config.limitMotor1 = this.angularLimit;
				config.limitMotor2 = this.linkedAngularLimit;
				this._ref = new OIMO.UniversalJoint( config );
				break;
			case 'cylindrical':
				config.translationalLimitMotor = this.linearLimit;
				config.translationalSpringDamper = this.linearSpringDamper;
				config.rotationalLimitMotor = this.angularLimit;
				config.rotationalSpringDamper = this.angularSpringDamper;
				this._ref = new OIMO.CylindricalJoint( config );
				break;
			case 'prismatic':
				config.limitMotor = this.linearLimit;
				this._ref = new OIMO.PrismaticJoint( config );
				break;
			case 'ragdoll':
				config.localTwistAxis1 = this._twistAxis;
				config.localTwistAxis2 = this._linkedTwistAxis;
				config.localSwingAxis1 = this._swingAxis;
				config.maxSwingAngle1 = this._maxSwing;
				config.maxSwingAngle2 = this._linkedMaxSwing;
				config.twistSpringDamper = this.twistSpringDamper;
				config.swingSpringDamper = this.swingSpringDamper;
				config.twistLimitMotor = this.twistLimit;
				this._ref = new OIMO.RagdollJoint( config );
				break;
			case 'hinge':
				config.limitMotor = this.angularLimit;
				this._ref = new OIMO.RevoluteJoint( config );
				break;
			case 'ball':
				this._ref = new OIMO.SphericalJoint( config );
				break;

		}

		this._ref.component = this;
		if ( enable ) this.entity.scene._physicsWorld.addJoint( this._ref );

	}

	// joint
	get allowCollision() {

		return this._allowCollision;

	}

	set allowCollision( allowCollision ) {

		this._allowCollision = allowCollision;
		this._ref.setAllowCollision( allowCollision );

	}

	// local anchor
	get anchor() {

		return this._anchor;

	}

	set anchor( anchor ) {

		this._anchor = anchor;
		this._setJoint();

	}

	get linkedAnchor() {

		return this._linkedAnchor;

	}

	set linkedAnchor( anchor ) {

		this._linkedAnchor = anchor;
		this._setJoint();

	}

	get appliedForce() {

		const vector = new Vector3();
		this._ref.getAppliedForceTo( vector );
		return vector;

	}

	get appliedTorque() {

		const vector = new Vector3();
		this._ref.getAppliedTorqueTo( vector );
		return vector;

	}

	get breakForce() {

		this._breakForce;

	}

	set breakForce( force ) {

		this._breakForce = force;
		this._ref.setBreakForce( force );

	}

	get breakTorque() {

		this._ref.getBreakTorque();

	}

	set breakTorque( torque ) {

		this._ref.setBreakTorque( torque );

	}

	get linkedEntity() {

		const body = this._bodyRef2;
		if ( body === worldBody ) return null;
		return body.entity;

	}

	set linkedEntity( entity ) {

		this._bodyRef2 = entity === null ? worldBody : entity._physicsRef;
		this._setJoint();

	}

	// prismatic joint

	// local axis
	get axis() {

		return this._axis;

	}

	set axis( axis ) {

		this._axis = axis;
		this._setJoint();

	}

	get linkedAxis() {

		return this._linkedAxis;

	}

	set linkedAxis( axis ) {

		this._linkedAxis = axis;
		this._setJoint();

	}

	// ragdoll joint

	get swingAxis() {

		return this._swingAxis;

	}

	set swingAxis( axis ) {

		this._swingAxis = axis;
		this._setJoint();

	}

	get twistAxis() {

		return this._twistAxis;

	}

	set twistAxis( axis ) {

		this._twistAxis = axis;
		this._setJoint();

	}

	get linkedTwistAxis() {

		return this._linkedTwistAxis;

	}

	set linkedTwistAxis( axis ) {

		this._linkedTwistAxis = axis;
		this._setJoint();

	}

	get maxSwing() {

		return this._maxSwing;

	}

	set maxSwing( angle ) {

		this._maxSwing = angle;
		this._setJoint();

	}

	get linkedMaxSwing() {

		return this._linkedMaxSwing;

	}

	set linkedMaxSwing( angle ) {

		this._linkedMaxSwing = angle;
		this._setJoint();

	}

	// revolute joint and universal
	get angle() {

		if ( this.type === 'universal' ) return this._ref.getAngle1();
		return this._ref.getAngle();

	}

	// SphericalJoint

	// UniversalJoint
	get linkedAngle() {

		return this._ref.getAngle2();

	}

	// cylindrical

}

class BallJoint extends Joint {

	start( data ) {

		this.type = 'ball';
		super.start( data );

	}

}

class CylindricalJoint extends Joint {

	start( data ) {

		this.type = 'cylindrical';
		super.start( data );

	}

}

class PrismaticJoint extends Joint {

	start( data ) {

		this.type = 'prismatic';
		super.start( data );

	}

}

class RagdollJoint extends Joint {

	start( data ) {

		this.type = 'ragdoll';
		super.start( data );

	}

}

class HingeJoint extends Joint {

	start( data ) {

		this.type = 'hinge';
		super.start( data );

	}

}

class UniversalJoint extends Joint {

	start( data ) {

		this.type = 'universal';
		super.start( data );

	}

}

const cProto = {
	destroy: {
		value: function () {

			if ( this.enabled ) {

				const type = this.componentType;
				const container = this.entity.scene._containers[ type ];
				container.splice( container.indexOf( this ), 1 );

			} else {

				this.dispatchEvent( { type: 'disable' } );

			}

			const components = this.entity._components;
			components.splice( components.indexOf( this ), 1 );

			this.dispatchEvent( { type: 'destroy' } );

		},
	},
	componentType: { value: null },
	_enabled: { value: true, writable: true },
	enabled: {
		get() {

			return this._enabled;

		},
		set( value ) {

			if ( value != this._enabled ) {

				if ( value && ! this.entity._enabled )
					return console.warn(
						"Component: Can't enable if the entity is disabled"
					);
				this._enabled = value;

				const container = this.entity.scene._containers[
					this.componentType
				];
				if ( value ) {

					container.push( this );
					this.dispatchEvent( { type: 'enable' } );

				} else {

					container.splice( container.indexOf( this ), 1 );
					this.dispatchEvent( { type: 'disable' } );

				}

			}

		},
	},
};

const _components = {};

function createComponent( type, obj, options = {} ) {

	if ( type in _components ) throw 'Component type already exists';

	cProto.componentType.value = type;
	Object.defineProperties( obj.prototype, cProto );
	Object.assign( obj.prototype, EventDispatcher.prototype );

	_components[ type ] = [ obj, options ];
	return obj;

}

createComponent( 'Animation', Animation );
createComponent( 'Renderable', Renderable );
createComponent( 'OrthographicCamera', OrthographicCamera$1 );
createComponent( 'PerspectiveCamera', PerspectiveCamera$1 );
createComponent( 'AmbientLight', AmbientLight$1 );
createComponent( 'DirectionalLight', DirectionalLight$1 );
createComponent( 'HemisphereLight', HemisphereLight$1 );
createComponent( 'PointLight', PointLight$1 );
createComponent( 'SpotLight', SpotLight$1 );
createComponent( 'Rigidbody', Rigidbody );

createComponent( 'BoxCollider', BoxCollider );
createComponent( 'CapsuleCollider', CapsuleCollider );
createComponent( 'ConeCollider', ConeCollider );
createComponent( 'CylinderCollider', CylinderCollider );
createComponent( 'MeshCollider', MeshCollider );
createComponent( 'SphereCollider', SphereCollider );

createComponent( 'BallJoint', BallJoint, { requiredComponent: 'Rigidbody' } );
createComponent( 'CylindricalJoint', CylindricalJoint, {
	requiredComponent: 'Rigidbody',
} );
createComponent( 'PrismaticJoint', PrismaticJoint, {
	requiredComponent: 'Rigidbody',
} );
createComponent( 'RagdollJoint', RagdollJoint, {
	requiredComponent: 'Rigidbody',
} );
createComponent( 'HingeJoint', HingeJoint, { requiredComponent: 'Rigidbody' } );
createComponent( 'UniversalJoint', UniversalJoint, {
	requiredComponent: 'Rigidbody',
} );

class Scene$1 extends Scene {

	constructor() {

		super();
		this._cameras = [];

		this._containers = {};
		this._enabled = true;
		for ( const type in _components ) {

			this._containers[ type ] = [];

		}

		this._physicsWorld = new OIMO.World( 2 );

	}

	// used internally
	add( entity ) {

		if ( 'scene' in entity && entity.scene !== this ) {

			const components = entity._components;
			for ( let i = 0, len = components.length; i < len; i ++ ) {

				const component = components[ i ];
				if ( component._enabled ) {

					const type = component.componentType;
					const container = entity.scene._containers[ type ];
					container.splice( container.indexOf( component ), 1 );
					if ( ! ( type in this._containers ) )
						this._containers[ type ] = [];
					this._containers[ type ].push( component );

				}

			}

			entity.dispatchEvent( {
				type: 'scenechange',
				oldScene: entity.scene,
				newScene: this,
			} );

		}

		entity.scene = this;
		super.add( entity );
		return entity;

	}

	find( name ) {

		return this.getObjectByName( name );

	}

	findByTag( tag ) {

		const matches = [];
		this.traverse( ( child ) => {

			if ( child instanceof Entity && child.tags.includes( tag ) ) {

				matches.push( child );

			}

		} );
		return matches;

	}

	findById( id ) {

		return this.getObjectById( id );

	}

}

class Render extends WebGLRenderer {

	constructor( app, parameters ) {

		super( parameters );
		this.canvas = app.canvas;

		this.setPixelRatio( window.devicePixelRatio );
		this._onResize();

		new ResizeObserver( () => this._onResize() ).observe( this.canvas );

	}
	_onResize() {

		const canvas = this.canvas;
		this.setSize( canvas.clientWidth, canvas.clientHeight, false );
		if ( 'cameras' in this ) {

			for ( let i = 0, len = this.cameras.length; i < len; i ++ ) {

				const camera = this.cameras[ i ];
				camera._onResize( canvas );

			}

		}

	}
	_update() {

		for ( let i = 0, len = this.cameras.length; i < len; i ++ ) {

			const camera = this.cameras[ i ];

			this.setViewport( camera._region );
			this.setScissor( camera._region );
			this.setScissorTest( true );

			this.render( this.scene, this.cameras[ i ] );

		}

	}

}

class Time {

	constructor() {

		this.fixedTimestep = 0.02;
		this.maxDeltaTime = 0.1;
		this.timeScale = 1;
		this.deltaTime = 0;
		this.lastTimestamp = false;

	}
	_update( timestamp ) {

		this.deltaTime =
			( timestamp - ( this.lastTimestamp || timestamp ) ) * this.timeScale;
		const maxDeltaTime = this.maxDeltaTime * this.timeScale;
		if ( this.deltaTime > maxDeltaTime ) this.deltaTime = maxDeltaTime;
		this.lastTimestamp = timestamp;
		return this.deltaTime;

	}

}

class Input {

	constructor() {

		this.mousePosition = new Vector2();
		this.mouseDelta = new Vector2();
		this.wheelDelta = new Vector2();
		this._mouse = [];
		this._mouseDown = [];
		this._mouseUp = [];
		this._key = {};
		this._keyDown = {};
		this._keyUp = {};

		window.addEventListener( 'blur', () => {

			this._reset();

		} );

		document.addEventListener( 'fullscreenchange', () => {

			console.log( 'here' );
			this._reset();

		} );

		document.addEventListener( 'mousemove', ( e ) => {

			this.mouseDelta.set( e.movementX, e.movementY );
			this.mousePosition.set( e.clientX, e.clientY );

		} );
		document.addEventListener( 'mousedown', ( e ) => {

			this._mouse[ e.button ] = true;
			this._mouseDown[ e.button ] = true;

		} );
		document.addEventListener( 'mouseup', ( e ) => {

			this._mouse[ e.button ] = false;
			this._mouseUp[ e.button ] = true;

		} );

		document.addEventListener( 'wheel', ( e ) => {

			this.wheelDelta.set( e.deltaX, e.deltaY );

		} );

		document.addEventListener( 'keydown', () => {

			this._key[ event.code ] = true;
			if ( ! event.repeat ) this._keyDown[ event.code ] = true;

		} );
		document.addEventListener( 'keyup', () => {

			this._key[ event.code ] = false;
			this._keyUp[ event.code ] = true;

		} );

	}
	_reset() {

		for ( const prop in this._keyDown ) {

			delete this._keyDown[ prop ];

		}

		for ( const prop in this._keyUp ) {

			delete this._keyUp[ prop ];

		}

		this._mouseDown.length = 0;
		this._mouseUp.length = 0;
		this.mouseDelta.set( 0, 0 );
		this.wheelDelta.set( 0, 0 );

	}
	getKey( v ) {

		return Boolean( this._key[ v ] );

	}
	getKeyDown( v ) {

		return v in this._keyDown;

	}
	getKeyUp( v ) {

		return v in this._keyUp;

	}
	getMouse( v ) {

		return Boolean( this._mouse[ v ] );

	}
	getMouseDown( v ) {

		return Boolean( this._mouseDown[ v ] );

	}
	getMouseUp( v ) {

		return Boolean( this._mouseUp[ v ] );

	}

}

class Application {

	constructor( canvas ) {

		this.canvas = document.getElementById( canvas );
		this.time = new Time();
		this.physics = new Physics();
		this.render = new Render( this, {
			canvas: this.canvas,
		} );
		this.input = new Input();

		this._scenes = {};

		this.createScene( 'Untitled Scene' );
		this.setScene( 'Untitled Scene' );
		Application._currentApp = this;

	}
	start() {

		window.requestAnimationFrame( ( t ) => this._updateLoop( t / 1000 ) );

	}
	createScene( name ) {

		const scene = new Scene$1();
		scene.app = this;
		this._scenes[ name ] = scene;
		return scene;

	}
	getScene( name ) {

		return this._scenes[ name ];

	}
	removeScene( name ) {

		delete this._scenes[ name ].app;
		delete this._scenes[ name ];

	}
	setScene( name ) {

		const scene = this._scenes[ name ];

		this.render.scene = this._scene = scene;
		this._containers = scene._containers;

		scene._physicsWorld.setGravity( this.physics._gravity );
		this.physics._world = scene._physicsWorld;
		this.physics.rigidbodies = scene._containers[ 'Rigidbody' ];

		this.render.cameras = scene._cameras;
		return scene;

	}
	renameScene( oldName, newName ) {

		const scene = this._scene[ oldName ];
		delete this._scene[ oldName ];
		this._scene[ newName ] = scene;

	}
	get scene() {

		return this._scene;

	}
	get scenes() {

		return Object.assign( {}, this._scenes );

	}
	_updateLoop( timestamp ) {

		const deltaTime = this.time._update( timestamp );

		this.physics._update(
			deltaTime,
			this.time.fixedTimestep * this.time.timeScale
		);

		// update loop
		for ( const type in this._containers ) {

			const container = this._containers[ type ];
			if ( container[ 0 ] && 'update' in container[ 0 ] ) {

				for ( let j = 0, lenj = container.length; j < lenj; j ++ ) {

					container[ j ].update( deltaTime );

				}

			}

		}

		this.render._update();
		this.input._reset();

		window.requestAnimationFrame( ( t ) => this._updateLoop( t / 1000 ) );

	}
	static getApplication( id ) {

		return id ? Application._apps[ id ] : Application._currentApp;

	}

}

Application.apps = {};

class Entity extends Group {

	constructor( name, scene ) {

		super();

		this.tags = [];
		this._components = [];
		this._enabled = true;

		if ( name !== undefined ) {

			if ( name instanceof Scene$1 ) {

				name.add( this );

			} else {

				this.name = name;

			}

		}

		if ( scene instanceof Scene$1 ) {

			scene.add( this );

		} else {

			Application._currentApp.scene.add( this );

		}

	}

	getComponent( type ) {

		const components = this._components;
		for ( let i = 0, len = components.length; i < len; i ++ ) {

			if ( components[ i ].componentType === type ) return components[ i ];

		}

	}

	getComponents( type ) {

		const list = [];
		const components = this._components;
		for ( let i = 0, len = components.length; i < len; i ++ ) {

			if ( components[ i ].componentType === type ) list.push( components[ i ] );

		}

		return list;

	}

	addComponent( type, data = {} ) {

		const options = _components[ type ][ 1 ];
		if (
			options.allowMultiple === false &&
			this.getComponent( type ) !== undefined
		) {

			return console.warn( 'allowMultiple Attribute is false' );

		}

		if ( 'requireComponents' in options ) {

			required = options.requireComponents;
			for ( let i = 0, len = required.length; i < len; i ++ )
				if ( this.getComponent( required[ i ] ) === undefined )
					this.addComponent( required[ i ] );

		}

		const component = new _components[ type ][ 0 ]();

		Object.defineProperty( component, 'entity', {
			value: this,
		} );

		if ( ! ( type in this.scene._containers ) )
			this.scene._containers[ type ] = [];

		this.scene._containers[ type ].push( component );
		if ( 'start' in component ) component.start( data );
		component.dispatchEvent( { type: 'enable' } );

		this._components.push( component );

		return component;

	}

	add( obj ) {

		if ( obj instanceof Entity && obj.scene !== this.scene ) {

			this.scene.add( obj );

		}

		return super.add( obj );

	}

	remove( obj ) {

		if ( obj instanceof Entity ) {

			this.scene.add( obj );

		} else {

			super.remove( obj );

		}

		return obj;

	}

	destroy() {

		this.enabled = false;
		const children = this.getChildren();
		for ( let i = 0, len = children.length; i < len; i ++ )
			children[ i ].destroy();
		this.scene.remove( this );

	}

	get enabled() {

		return this._enabled;

	}

	set enabled( value ) {

		if ( value != this._enabled ) {

			if ( value && ! this.parent._enabled )
				return console.warn(
					"Entity: Can't enable if an ancestor is disabled"
				);
			this._enabled = value;

			const components = this._components;
			for ( let i = 0, len = components.length; i < len; i ++ )
				components[ i ].enabled = value;

			const children = this.getChildren();
			for ( let i = 0, len = children.length; i < len; i ++ )
				children[ i ].enabled = value;

			this.dispatchEvent( { type: value ? 'enable' : 'disable' } );

		}

	}

	getChildren() {

		const filteredChildren = [];
		const children = this.children;
		for ( let i = 0, len = children.length; i < len; i ++ ) {

			if ( children[ i ] instanceof Entity )
				filteredChildren.push( children[ i ] );

		}

		return filteredChildren;

	}

	find( name ) {

		return this.getObjectByName( name );

	}

	findByTag( tag ) {

		const matches = [];
		this.traverse( ( child ) => {

			if ( child instanceof Entity && child.tags.includes( tag ) ) {

				matches.push( child );

			}

		} );
		return matches;

	}

	findById( id ) {

		return this.getObjectById( id );

	}

	get app() {

		return this.scene.app;

	}

}

class PhysicMaterial {

	constructor( friction, restitution ) {

		this._friction = friction;
		this._restitution = restitution;
		this._colliders = [];

	}

	get friction() {

		return this._friction;

	}

	get restitution() {

		return this._restitution;

	}

	set friction( v ) {

		this._friction = v;
		for ( let i = 0, len = this._colliders.length; i < len; i ++ ) {

			this._colliders[ i ].setFriction( v );

		}

	}

	set restitution( v ) {

		this._restitution = v;
		for ( let i = 0, len = this._colliders.length; i < len; i ++ ) {

			this._colliders[ i ].setRestitution( v );

		}

	}

}

export { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AngularLimit, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, Application, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, BoxGeometry as CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, Entity, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float16BufferAttribute, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearLimit, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils as Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, PhysicMaterial, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene$1 as Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpringDamper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGL1Renderer, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, _components, createComponent, sRGBEncoding };
